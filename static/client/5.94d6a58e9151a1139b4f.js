(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[5],{

/***/ 1557:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./stores/redux_store.jsx + 3 modules
var redux_store = __webpack_require__(14);

// EXTERNAL MODULE: ./actions/views/meeting.js
var meeting = __webpack_require__(182);

// CONCATENATED MODULE: ./utils/ao_tools/isInElectron.js
const isInElectron = window.process && window.process.versions && window.process.versions.electron;
/* harmony default export */ var ao_tools_isInElectron = (isInElectron);
// CONCATENATED MODULE: ./utils/showMeetingInvitation.js




const showMeetingInvitation = ({
  invitation
}) => {
  console.log('showMeetingInvitation called'); // 1.展示ui提示
  // diapatch修改state, 页面上显示提示框
  // todo

  Object(meeting["j" /* receive */])({
    invitation
  })(redux_store["a" /* default */].dispatch, redux_store["a" /* default */].getState); // 2.通知主进程将窗口设置到最上层
  // 判断是否为electron环境

  if (ao_tools_isInElectron) {
    window.require('electron').ipcRenderer.sendSync('set-mainwindow-top', '');
  }
};

/* harmony default export */ var utils_showMeetingInvitation = (showMeetingInvitation);
window.showMeetingInvitation = showMeetingInvitation;
// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./actions/views/root.js
var root = __webpack_require__(421);

// EXTERNAL MODULE: ./components/root/root.jsx
var root_root = __webpack_require__(2279);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--4!./components/root/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









function mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const showTermsOfService = Object(users["shouldShowTermsOfService"])(state);
  return {
    state,
    diagnosticsEnabled: config.DiagnosticsEnabled === "true",
    noAccounts: config.NoAccounts === "true",
    diagnosticId: config.DiagnosticId,
    showTermsOfService,
    currentUser: Object(users["getCurrentUser"])(state)
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      loadMeAndConfig: root["b" /* loadMeAndConfig */]
    }, dispatch)
  };
}

/* harmony default export */ var lib_ref_4_components_root = __webpack_exports__["default"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(root_root["a" /* default */]));
setTimeout(() => {
  utils_showMeetingInvitation({});
}, 99999 * 1000);

/***/ }),

/***/ 1564:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CustomRenderer; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89);
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(marked__WEBPACK_IMPORTED_MODULE_3__);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




const TARGET_BLANK_URL_PREFIX = '!';
class CustomRenderer extends marked__WEBPACK_IMPORTED_MODULE_3___default.a.Renderer {
  link(href, title, text) {
    if (href[0] === TARGET_BLANK_URL_PREFIX) {
      return `<a href="${href.substring(1, href.length)}" rel="noreferrer" target="_blank">${text}</a>`;
    }

    return `<a href="${href}">${text}</a>`;
  }

  paragraph(text) {
    return text;
  }

}
/*
* Translations component with the same API as react-intl's <FormattedMessage> component except the message string
* accepts markdown. It supports the following non-block-level markdown:
* - *italic*
* - **bold**
* - `inline code`
* - ~~strikethrough~~
* - [link](http://example.com/)
* - [link in new tab](!http://example.com/)
* - line\nbreaks
*
* Note: Line breaks (\n) in a defaultMessage parameter string must be surrounded by curly brackets {} in JSX. Example:
* <FormattedMarkdownMessage id='my.example' defaultMessage={'first line\nsecond line'} />
*/

class FormattedMarkdownMessage extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  static get propTypes() {
    return {
      intl: react_intl__WEBPACK_IMPORTED_MODULE_1__[/* intlShape */ "i"].isRequired,
      id: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired,
      defaultMessage: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired,
      values: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object
    };
  }

  render() {
    const origMsg = this.props.intl.formatMessage({
      id: this.props.id,
      defaultMessage: this.props.defaultMessage
    }, this.props.values);
    const markedUpMessage = marked__WEBPACK_IMPORTED_MODULE_3___default()(origMsg, {
      breaks: true,
      sanitize: true,
      renderer: new CustomRenderer()
    });
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      dangerouslySetInnerHTML: {
        __html: markedUpMessage
      }
    });
  }

}

/* harmony default export */ __webpack_exports__["b"] = (Object(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* injectIntl */ "h"])(FormattedMarkdownMessage));

/***/ }),

/***/ 1567:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return emitChannelClickEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return emitCloseRightHandSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return toggleShortcutsModal; });
/* unused harmony export showChannelPurposeUpdateModal */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return showChannelNameUpdateModal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return showGetPostLinkModal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return showGetPublicLinkModal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return showGetTeamInviteLinkModal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return showLeavePrivateChannelModal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return sendEphemeralPost; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return sendAddToChannelEphemeralPost; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return emitLocalUserTypingEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return emitUserLoggedOutEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return toggleSideBarRightMenuAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return emitBrowserFocus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return redirectUserToDefaultTeam; });
/* harmony import */ var redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);
/* harmony import */ var redux_batched_actions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);
/* harmony import */ var mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/* harmony import */ var mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/* harmony import */ var mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32);
/* harmony import */ var mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(15);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);
/* harmony import */ var mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var utils_browser_history__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(114);
/* harmony import */ var actions_post_actions_jsx__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(408);
/* harmony import */ var actions_status_actions_jsx__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(246);
/* harmony import */ var actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(304);
/* harmony import */ var actions_views_rhs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(116);
/* harmony import */ var actions_views_root__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(421);
/* harmony import */ var actions_views_lhs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1722);
/* harmony import */ var actions_websocket_actions_jsx__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(1723);
/* harmony import */ var dispatcher_app_dispatcher_jsx__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(1845);
/* harmony import */ var selectors_i18n__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(302);
/* harmony import */ var selectors_rhs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(60);
/* harmony import */ var stores_browser_store_jsx__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(1767);
/* harmony import */ var stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(14);
/* harmony import */ var stores_local_storage_store__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(218);
/* harmony import */ var client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(1823);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(0);
/* harmony import */ var utils_team_utils_jsx__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(1726);
/* harmony import */ var utils_utils_jsx__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(22);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


























const dispatch = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"].dispatch;
const getState = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"].getState;
function emitChannelClickEvent(channel) {
  async function userVisitedFakeChannel(chan, success, fail) {
    const state = getState();
    const currentUserId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_5__["getCurrentUserId"])(state);
    const otherUserId = utils_utils_jsx__WEBPACK_IMPORTED_MODULE_25__[/* getUserIdFromChannelName */ "G"](chan);
    const {
      data: receivedChannel
    } = await Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["createDirectChannel"])(currentUserId, otherUserId)(dispatch, getState);

    if (receivedChannel) {
      success(receivedChannel);
    } else {
      fail();
    }
  }

  function switchToChannel(chan) {
    const state = getState();
    const getMyChannelMemberPromise = dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["getMyChannelMember"])(chan.id));
    const oldChannelId = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_6__["getCurrentChannelId"])(state);
    const userId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_5__["getCurrentUserId"])(state);
    const teamId = chan.team_id || Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_4__["getCurrentTeamId"])(state);
    const isRHSOpened = Object(selectors_rhs__WEBPACK_IMPORTED_MODULE_18__[/* getIsRhsOpen */ "c"])(state);
    const isPinnedPostsShowing = Object(selectors_rhs__WEBPACK_IMPORTED_MODULE_18__[/* getRhsState */ "m"])(state) === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* RHSStates */ "x"].PIN;
    const member = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_6__["getMyChannelMember"])(state, chan.id);
    getMyChannelMemberPromise.then(() => {
      dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["getChannelStats"])(chan.id)); // Mark previous and next channel as read

      dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["markChannelAsRead"])(chan.id, oldChannelId));
      dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["markChannelAsViewed"])(chan.id, oldChannelId));
    });

    if (chan.delete_at === 0) {
      const penultimate = stores_local_storage_store__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"].getPreviousChannelName(userId, teamId);

      if (penultimate !== chan.name) {
        stores_local_storage_store__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"].setPenultimateChannelName(userId, teamId, penultimate);
        stores_local_storage_store__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"].setPreviousChannelName(userId, teamId, chan.name);
      }
    } // When switching to a different channel if the pinned posts is showing
    // Update the RHS state to reflect the pinned post of the selected channel


    if (isRHSOpened && isPinnedPostsShowing) {
      dispatch(Object(actions_views_rhs__WEBPACK_IMPORTED_MODULE_12__[/* updateRhsState */ "v"])(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* RHSStates */ "x"].PIN, chan.id));
    }

    Object(actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_11__[/* loadProfilesForSidebar */ "i"])();
    dispatch(Object(redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__["batchActions"])([{
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_7__["ChannelTypes"].SELECT_CHANNEL,
      data: chan.id
    }, {
      type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* ActionTypes */ "b"].SELECT_CHANNEL_WITH_MEMBER,
      data: chan.id,
      channel: chan,
      member: member || {}
    }]));
  }

  if (channel.fake) {
    userVisitedFakeChannel(channel, data => {
      switchToChannel(data);
    }, () => {
      utils_browser_history__WEBPACK_IMPORTED_MODULE_8__[/* browserHistory */ "a"].push('/' + this.state.currentTeam.name);
    });
  } else {
    switchToChannel(channel);
  }
}
function emitCloseRightHandSide() {
  dispatch(Object(actions_views_rhs__WEBPACK_IMPORTED_MODULE_12__[/* closeRightHandSide */ "b"])());
}
function toggleShortcutsModal() {
  dispatcher_app_dispatcher_jsx__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].handleViewAction({
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* ActionTypes */ "b"].TOGGLE_SHORTCUTS_MODAL,
    value: true
  });
}
function showChannelPurposeUpdateModal(channel) {
  dispatcher_app_dispatcher_jsx__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].handleViewAction({
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* ActionTypes */ "b"].TOGGLE_CHANNEL_PURPOSE_UPDATE_MODAL,
    value: true,
    channel
  });
}
function showChannelNameUpdateModal(channel) {
  dispatcher_app_dispatcher_jsx__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].handleViewAction({
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* ActionTypes */ "b"].TOGGLE_CHANNEL_NAME_UPDATE_MODAL,
    value: true,
    channel
  });
}
function showGetPostLinkModal(post) {
  dispatcher_app_dispatcher_jsx__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].handleViewAction({
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* ActionTypes */ "b"].TOGGLE_GET_POST_LINK_MODAL,
    value: true,
    post
  });
}
function showGetPublicLinkModal(fileId) {
  dispatcher_app_dispatcher_jsx__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].handleViewAction({
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* ActionTypes */ "b"].TOGGLE_GET_PUBLIC_LINK_MODAL,
    value: true,
    fileId
  });
}
function showGetTeamInviteLinkModal() {
  dispatcher_app_dispatcher_jsx__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].handleViewAction({
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* Constants */ "g"].ActionTypes.TOGGLE_GET_TEAM_INVITE_LINK_MODAL,
    value: true
  });
}
function showLeavePrivateChannelModal(channel) {
  dispatcher_app_dispatcher_jsx__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].handleViewAction({
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* ActionTypes */ "b"].TOGGLE_LEAVE_PRIVATE_CHANNEL_MODAL,
    value: channel
  });
}
function sendEphemeralPost(message, channelId, parentId) {
  const timestamp = utils_utils_jsx__WEBPACK_IMPORTED_MODULE_25__[/* getTimestamp */ "E"]();
  const post = {
    id: utils_utils_jsx__WEBPACK_IMPORTED_MODULE_25__[/* generateId */ "s"](),
    user_id: '0',
    channel_id: channelId || Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_6__["getCurrentChannelId"])(getState()),
    message,
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* PostTypes */ "v"].EPHEMERAL,
    create_at: timestamp,
    update_at: timestamp,
    root_id: parentId,
    parent_id: parentId,
    props: {}
  };
  dispatch(Object(actions_post_actions_jsx__WEBPACK_IMPORTED_MODULE_9__[/* handleNewPost */ "h"])(post));
}
function sendAddToChannelEphemeralPost(user, addedUsername, addedUserId, channelId, postRootId = '', timestamp) {
  const post = {
    id: utils_utils_jsx__WEBPACK_IMPORTED_MODULE_25__[/* generateId */ "s"](),
    user_id: user.id,
    channel_id: channelId || Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_6__["getCurrentChannelId"])(getState()),
    message: '',
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* PostTypes */ "v"].EPHEMERAL_ADD_TO_CHANNEL,
    create_at: timestamp,
    update_at: timestamp,
    root_id: postRootId,
    parent_id: postRootId,
    props: {
      username: user.username,
      addedUsername,
      addedUserId
    }
  };
  dispatch(Object(actions_post_actions_jsx__WEBPACK_IMPORTED_MODULE_9__[/* handleNewPost */ "h"])(post));
}
let lastTimeTypingSent = 0;
function emitLocalUserTypingEvent(channelId, parentPostId) {
  const userTyping = async (actionDispatch, actionGetState) => {
    const state = actionGetState();
    const config = Object(mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_3__["getConfig"])(state);
    const t = Date.now();
    const stats = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_6__["getCurrentChannelStats"])(state);
    const membersInChannel = stats ? stats.member_count : 0;

    if (t - lastTimeTypingSent > config.TimeBetweenUserTypingUpdatesMilliseconds && membersInChannel < config.MaxNotificationsPerChannel && config.EnableUserTypingMessages === 'true') {
      client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_22__[/* default */ "a"].userTyping(channelId, parentPostId);
      lastTimeTypingSent = t;
    }

    return {
      data: true
    };
  };

  return dispatch(userTyping);
}
function emitUserLoggedOutEvent(redirectTo = '/', shouldSignalLogout = true, userAction = true) {
  // If the logout was intentional, discard knowledge about having previously been logged in.
  // This bit is otherwise used to detect session expirations on the login page.
  if (userAction) {
    stores_local_storage_store__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"].setWasLoggedIn(false);
  }

  dispatch(Object(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2__["logout"])()).then(() => {
    if (shouldSignalLogout) {
      stores_browser_store_jsx__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"].signalLogout();
    }

    stores_browser_store_jsx__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"].clear();
    Object(actions_status_actions_jsx__WEBPACK_IMPORTED_MODULE_10__[/* stopPeriodicStatusUpdates */ "e"])();
    actions_websocket_actions_jsx__WEBPACK_IMPORTED_MODULE_15__[/* close */ "a"]();
    Object(actions_views_root__WEBPACK_IMPORTED_MODULE_13__[/* clearUserCookie */ "a"])();
    utils_browser_history__WEBPACK_IMPORTED_MODULE_8__[/* browserHistory */ "a"].push(redirectTo);
  }).catch(() => {
    utils_browser_history__WEBPACK_IMPORTED_MODULE_8__[/* browserHistory */ "a"].push(redirectTo);
  });
}
function toggleSideBarRightMenuAction() {
  return doDispatch => {
    doDispatch(Object(actions_views_rhs__WEBPACK_IMPORTED_MODULE_12__[/* closeRightHandSide */ "b"])());
    doDispatch(Object(actions_views_lhs__WEBPACK_IMPORTED_MODULE_14__[/* close */ "a"])());
    doDispatch(Object(actions_views_rhs__WEBPACK_IMPORTED_MODULE_12__[/* closeMenu */ "a"])());
  };
}
function emitBrowserFocus(focus) {
  dispatch({
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_23__[/* ActionTypes */ "b"].BROWSER_CHANGE_FOCUS,
    focus
  });
}
async function redirectUserToDefaultTeam() {
  let state = getState(); // Assume we need to load the user if they don't have any team memberships loaded

  const shouldLoadUser = utils_utils_jsx__WEBPACK_IMPORTED_MODULE_25__[/* isEmptyObject */ "P"](Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_4__["getTeamMemberships"])(state));

  if (shouldLoadUser) {
    await dispatch(Object(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2__["loadMe"])());
  }

  state = getState();
  const userId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_5__["getCurrentUserId"])(state);
  const locale = Object(selectors_i18n__WEBPACK_IMPORTED_MODULE_17__[/* getCurrentLocale */ "a"])(state);
  const teamId = stores_local_storage_store__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"].getPreviousTeamId(userId);
  let team = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_4__["getTeam"])(state, teamId);
  const myMember = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_4__["getMyTeamMember"])(state, teamId);

  if (!team || !myMember || !myMember.team_id) {
    team = null;
    let myTeams = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_4__["getMyTeams"])(state);

    if (myTeams.length > 0) {
      myTeams = Object(utils_team_utils_jsx__WEBPACK_IMPORTED_MODULE_24__[/* filterAndSortTeamsByDisplayName */ "a"])(myTeams, locale);

      if (myTeams && myTeams[0]) {
        team = myTeams[0];
      }
    }
  }

  if (userId && team) {
    let channelName = stores_local_storage_store__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"].getPreviousChannelName(userId, team.id);
    const channel = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_6__["getChannelByName"])(state, channelName);

    if (channel && channel.team_id === team.id) {
      dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["selectChannel"])(channel.id));
      channelName = channel.name;
    } else {
      const {
        data
      } = await dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["getChannelByNameAndTeamName"])(team.name, channelName));

      if (data) {
        dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["selectChannel"])(data.id));
      }
    }

    utils_browser_history__WEBPACK_IMPORTED_MODULE_8__[/* browserHistory */ "a"].push(`/${team.name}/channels/${channelName}`);
  } else {
    utils_browser_history__WEBPACK_IMPORTED_MODULE_8__[/* browserHistory */ "a"].push('/select_team');
  }
}

/***/ }),

/***/ 1569:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoadingScreen; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class LoadingScreen extends react__WEBPACK_IMPORTED_MODULE_1___default.a.Component {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    let message = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
      id: "loading_screen.loading",
      defaultMessage: "Loading"
    });

    if (this.props.message) {
      message = this.props.message;
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      className: "loading-screen",
      style: {
        position: this.props.position,
        ...this.props.style
      }
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      className: "loading__content"
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("h3", null, message), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      className: "round round-1"
    }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      className: "round round-2"
    }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      className: "round round-3"
    })));
  }

}

_defineProperty(LoadingScreen, "propTypes", {
  position: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOf(['absolute', 'fixed', 'relative', 'static', 'inherit']),
  style: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,
  message: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node
});

_defineProperty(LoadingScreen, "defaultProps", {
  position: 'relative',
  style: {}
});

/***/ }),

/***/ 1576:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfirmModal; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1972);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class ConfirmModal extends react__WEBPACK_IMPORTED_MODULE_1___default.a.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "handleKeypress", e => {
      if (e.key === 'Enter' && this.props.show) {
        this.handleConfirm();
      }
    });

    _defineProperty(this, "handleConfirm", () => {
      const checked = this.refs.checkbox ? this.refs.checkbox.checked : false;
      this.props.onConfirm(checked);
    });

    _defineProperty(this, "handleCancel", () => {
      const checked = this.refs.checkbox ? this.refs.checkbox.checked : false;
      this.props.onCancel(checked);
    });
  }

  componentDidMount() {
    if (this.props.show) {
      document.addEventListener('keydown', this.handleKeypress);
    }
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleKeypress);
  }

  shouldComponentUpdate(nextProps) {
    return nextProps.show !== this.props.show;
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.show && !nextProps.show) {
      document.removeEventListener('keydown', this.handleKeypress);
    } else if (!this.props.show && nextProps.show) {
      document.addEventListener('keydown', this.handleKeypress);
    }
  }

  render() {
    let checkbox;

    if (this.props.showCheckbox) {
      checkbox = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
        className: "checkbox text-right margin-bottom--none"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("label", null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("input", {
        ref: "checkbox",
        type: "checkbox"
      }), this.props.checkboxText));
    }

    let cancelText;

    if (this.props.cancelButtonText) {
      cancelText = this.props.cancelButtonText;
    } else {
      cancelText = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_3__[/* FormattedMessage */ "c"], {
        id: "confirm_modal.cancel",
        defaultMessage: "Cancel"
      });
    }

    let cancelButton;

    if (!this.props.hideCancel) {
      cancelButton = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", {
        type: "button",
        className: "btn btn-link btn-cancel",
        onClick: this.handleCancel
      }, cancelText);
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
      className: 'modal-confirm ' + this.props.modalClass,
      show: this.props.show,
      onHide: this.props.onCancel,
      onExited: this.props.onExited,
      id: "confirmModal",
      role: "dialog",
      "aria-labelledby": "confirmModalLabel"
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Header, {
      closeButton: false
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Title, {
      componentClass: "h1",
      id: "confirmModalLabel"
    }, this.props.title)), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Body, null, this.props.message, checkbox), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Footer, null, cancelButton, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", {
      autoFocus: true,
      type: "button",
      className: this.props.confirmButtonClass,
      onClick: this.handleConfirm,
      id: "confirmModalButton"
    }, this.props.confirmButtonText)));
  }

}

_defineProperty(ConfirmModal, "propTypes", {
  /*
   * Set to show modal
   */
  show: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool.isRequired,

  /*
   * Title to use for the modal
   */
  title: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /*
   * Message to display in the body of the modal
   */
  message: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /*
   * The CSS class to apply to the confirm button
   */
  confirmButtonClass: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /*
   * The CSS class to apply to the modal
   */
  modalClass: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /*
   * Text/jsx element on the confirm button
   */
  confirmButtonText: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /*
   * Text/jsx element on the cancel button
   */
  cancelButtonText: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /*
   * Set to show checkbox
   */
  showCheckbox: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /*
   * Text/jsx element to display with the checkbox
   */
  checkboxText: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /*
   * Function called when the confirm button or ENTER is pressed. Passes `true` if the checkbox is checked
   */
  onConfirm: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func.isRequired,

  /*
   * Function called when the cancel button is pressed or the modal is hidden. Passes `true` if the checkbox is checked
   */
  onCancel: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func.isRequired,

  /**
   * Function called when modal is dismissed
   */
  onExited: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /*
   * Set to hide the cancel button
   */
  hideCancel: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool
});

_defineProperty(ConfirmModal, "defaultProps", {
  title: '',
  message: '',
  confirmButtonClass: 'btn btn-primary',
  confirmButtonText: '',
  modalClass: ''
});

/***/ }),

/***/ 1577:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LocalizedInput; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class LocalizedInput extends react__WEBPACK_IMPORTED_MODULE_1___default.a.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "focus", () => {
      this.input.current.focus();
    });

    this.input = react__WEBPACK_IMPORTED_MODULE_1___default.a.createRef();
  }

  get value() {
    return this.input.current.value;
  }

  set value(value) {
    this.input.current.value = value;
  }

  shouldComponentUpdate(nextProps) {
    return nextProps.value !== this.props.value || nextProps.placeholder.id !== this.props.placeholder.id || nextProps.placeholder.defaultMessage !== this.props.placeholder.defaultMessage;
  }

  render() {
    const {
      formatMessage
    } = this.context.intl;
    const {
      placeholder,
      ...otherProps
    } = this.props;
    const placeholderString = formatMessage(placeholder);
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("input", _extends({
      ref: this.input
    }, otherProps, {
      placeholder: placeholderString
    }));
  }

}

_defineProperty(LocalizedInput, "propTypes", {
  placeholder: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({
    id: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,
    defaultMessage: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired
  }).isRequired,
  value: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
});

_defineProperty(LocalizedInput, "contextTypes", {
  intl: react_intl__WEBPACK_IMPORTED_MODULE_2__[/* intlShape */ "i"].isRequired
});

/***/ }),

/***/ 1578:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return openModal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return closeModal; });
/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

function openModal(modalData) {
  // console.log(modalData, '-----modals')
  return dispatch => {
    const action = {
      type: utils_constants__WEBPACK_IMPORTED_MODULE_0__[/* ActionTypes */ "b"].MODAL_OPEN,
      modalId: modalData.modalId,
      dialogProps: modalData.dialogProps,
      dialogType: modalData.dialogType,
      activeTab: modalData.activeTab
    };
    dispatch(action);
  };
}
function closeModal(modalId) {
  return dispatch => {
    const action = {
      type: utils_constants__WEBPACK_IMPORTED_MODULE_0__[/* ActionTypes */ "b"].MODAL_CLOSE,
      modalId
    };
    dispatch(action);
  };
}

/***/ }),

/***/ 1579:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SettingItemMax; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var components_save_button_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1612);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var utils_utils_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(22);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class SettingItemMax extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "onKeyDown", e => {
      if (this.props.shiftEnter && e.keyCode === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* default */ "N"].KeyCodes.ENTER && e.shiftKey) {
        return;
      }

      if (Object(utils_utils_jsx__WEBPACK_IMPORTED_MODULE_5__[/* isKeyPressed */ "V"])(e, utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* default */ "N"].KeyCodes.ENTER) && this.props.submit) {
        this.handleSubmit(e);
      }
    });

    _defineProperty(this, "handleSubmit", e => {
      e.preventDefault();

      if (this.props.setting) {
        this.props.submit(this.props.setting);
      } else {
        this.props.submit();
      }
    });

    _defineProperty(this, "handleUpdateSection", e => {
      this.props.updateSection(this.props.section);
      e.preventDefault();
    });
  }

  componentDidMount() {
    document.addEventListener('keydown', this.onKeyDown);
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.onKeyDown);
  }

  render() {
    let clientError = null;

    if (this.props.clientError) {
      clientError = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
        className: "form-group"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("label", {
        id: "clientError",
        className: "col-sm-12 has-error"
      }, this.props.clientError));
    }

    let serverError = null;

    if (this.props.serverError) {
      serverError = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
        className: "form-group"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("label", {
        id: "serverError",
        className: "col-sm-12 has-error"
      }, this.props.serverError));
    }

    let extraInfo = null;
    let hintClass = 'setting-list__hint';

    if (this.props.infoPosition === 'top') {
      hintClass = 'padding-bottom x2';
    }

    if (this.props.extraInfo) {
      extraInfo = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
        className: hintClass
      }, this.props.extraInfo);
    }

    let submit = '';

    if (this.props.submit) {
      submit = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_save_button_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], {
        defaultMessage: this.props.saveButtonText,
        saving: this.props.saving,
        disabled: this.props.saving,
        onClick: this.handleSubmit
      });
    }

    const inputs = this.props.inputs;
    let widthClass;

    if (this.props.width === 'full') {
      widthClass = 'col-sm-12';
    } else if (this.props.width === 'medium') {
      widthClass = 'col-sm-10 col-sm-offset-2';
    } else {
      widthClass = 'col-sm-9 col-sm-offset-3';
    }

    let title;

    if (this.props.title) {
      title = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
        id: "settingTitle",
        className: "col-sm-12 section-title"
      }, this.props.title);
    }

    let listContent = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
      className: "setting-list-item"
    }, inputs, extraInfo);

    if (this.props.infoPosition === 'top') {
      listContent = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", null, extraInfo, inputs);
    }

    let cancelButtonText;

    if (this.props.cancelButtonText) {
      cancelButtonText = this.props.cancelButtonText;
    } else {
      cancelButtonText = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
        id: "setting_item_max.cancel",
        defaultMessage: "Cancel"
      });
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("ul", {
      className: `section-max form-horizontal ${this.props.containerStyle}`
    }, title, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
      className: widthClass
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("ul", {
      className: "setting-list"
    }, listContent, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
      className: "setting-list-item"
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("hr", null), this.props.submitExtra, serverError, clientError, submit, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", {
      id: 'cancelSetting',
      className: "btn btn-sm cursor--pointer style--none",
      onClick: this.handleUpdateSection
    }, cancelButtonText)))));
  }

}

_defineProperty(SettingItemMax, "defaultProps", {
  infoPosition: 'bottom',
  saving: false,
  section: '',
  containerStyle: ''
});

_defineProperty(SettingItemMax, "propTypes", {
  /**
   * Array of inputs selection
   */
  inputs: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /**
   * Styles for main component
   */
  containerStyle: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * Client error
   */
  clientError: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]),

  /**
   * Server error
   */
  serverError: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * Settings extra information
   */
  extraInfo: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.element,

  /**
   * Info position
   */
  infoPosition: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * Settings or tab section
   */
  section: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * Function to update section
   */
  updateSection: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /**
   * setting to submit
   */
  setting: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * Function to submit setting
   */
  submit: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /**
   * Extra information on submit
   */
  submitExtra: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /**
   * Indicates whether setting is on saving
   */
  saving: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * Settings title
   */
  title: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /**
   * Settings width
   */
  width: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * Text of cancel button
   */
  cancelButtonText: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /**
   * Avoid submitting when using SHIFT + ENTER
   */
  shiftEnter: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * Text of save button
   */
  saveButtonText: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
});

/***/ }),

/***/ 1583:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SettingItemMin; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var utils_utils_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);
/* harmony import */ var components_icon_edit_icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2184);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class SettingItemMin extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "getEdit", node => {
      this.edit = node;
    });

    _defineProperty(this, "handleUpdateSection", e => {
      e.preventDefault();
      this.props.updateSection(this.props.section);
    });
  }

  componentDidMount() {
    if (this.props.focused && this.edit) {
      this.edit.focus();
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.focused && this.edit) {
      this.edit.focus();
    }
  }

  render() {
    let editButton = null;
    let describeSection = null;

    if (!this.props.disableOpen && Object(utils_utils_jsx__WEBPACK_IMPORTED_MODULE_3__[/* isMobile */ "Y"])()) {
      editButton = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
        className: "col-xs-12 col-sm-3 section-edit"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", {
        id: this.props.section + 'Edit',
        className: "color--link cursor--pointer style--none",
        onClick: this.handleUpdateSection,
        ref: this.getEdit,
        "aria-labelledby": this.props.section + 'Title ' + this.props.section + 'Edit'
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_icon_edit_icon__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], null), this.props.describe));
    } else if (!this.props.disableOpen) {
      editButton = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
        className: "col-xs-12 col-sm-3 section-edit"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", {
        id: this.props.section + 'Edit',
        className: "color--link cursor--pointer style--none text-left",
        onClick: this.handleUpdateSection,
        ref: this.getEdit,
        "aria-labelledby": this.props.section + 'Title ' + this.props.section + 'Edit'
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_icon_edit_icon__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], null), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
        id: "setting_item_min.edit",
        defaultMessage: "Edit"
      })));
      describeSection = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
        id: this.props.section + 'Desc',
        className: "col-xs-12 section-describe"
      }, this.props.describe);
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("ul", {
      className: "section-min",
      onClick: this.handleUpdateSection
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
      id: this.props.section + 'Title',
      className: "col-xs-12 col-sm-9 section-title"
    }, this.props.title), editButton, describeSection);
  }

}

_defineProperty(SettingItemMin, "defaultProps", {
  section: '',
  focused: false
});

_defineProperty(SettingItemMin, "propTypes", {
  /**
   * Settings title
   */
  title: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /**
   * Option to disable opening the setting
   */
  disableOpen: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * Indicates whether the focus should be on the "Edit" button
   */
  focused: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * Settings or tab section
   */
  section: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * Function to update section
   */
  updateSection: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /**
   * Settings description
   */
  describe: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node
});

/***/ }),

/***/ 1584:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FormError; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class FormError extends react__WEBPACK_IMPORTED_MODULE_1___default.a.Component {
  static get propTypes() {
    // accepts either a single error or an array of errors
    return {
      type: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
      error: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
      textClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
      iconClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
      margin: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
      errors: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node)
    };
  }

  static get defaultProps() {
    return {
      error: null,
      errors: []
    };
  }

  render() {
    if (!this.props.error && this.props.errors.length === 0) {
      return null;
    } // look for the first truthy error to display


    let message = this.props.error;

    if (!message) {
      for (const error of this.props.errors) {
        if (error) {
          message = error;
        }
      }
    }

    if (!message) {
      return null;
    }

    if (this.props.type === 'modal') {
      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
        className: "form-group"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("label", {
        className: "col-sm-12 has-error"
      }, message));
    }

    if (this.props.type === 'backstage') {
      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
        className: "pull-left has-error"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("label", {
        className: "control-label"
      }, message));
    }

    if (this.props.margin) {
      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
        className: "form-group has-error"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("label", {
        className: "control-label"
      }, message));
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      className: `col-sm-12 ${this.props.textClassName || 'has-error'}`
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("label", {
      className: "control-label"
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("i", {
      className: `fa ${this.props.iconClassName || 'fa-exclamation-circle'}`
    }), " ", message));
  }

}

/***/ }),

/***/ 1588:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BotBadge; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var _badge_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1765);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function BotBadge(props) {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_badge_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], {
    className: 'BotBadge ' + props.className,
    show: props.show
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
    id: "post_info.bot",
    defaultMessage: "BOT"
  }));
}
BotBadge.propTypes = {
  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  show: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool
};
BotBadge.defaultProps = {
  show: true,
  className: ''
};

/***/ }),

/***/ 1589:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/redux-batched-actions/lib/index.js
var lib = __webpack_require__(65);

// EXTERNAL MODULE: ./mattermost-redux/actions/channels.js
var channels = __webpack_require__(70);

// EXTERNAL MODULE: ./mattermost-redux/actions/posts.js
var actions_posts = __webpack_require__(59);

// EXTERNAL MODULE: ./mattermost-redux/actions/users.js
var users = __webpack_require__(35);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var constants = __webpack_require__(17);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var entities_channels = __webpack_require__(15);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var entities_users = __webpack_require__(10);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./mattermost-redux/utils/channel_utils.js
var channel_utils = __webpack_require__(178);

// EXTERNAL MODULE: ./mattermost-redux/utils/event_emitter.js
var event_emitter = __webpack_require__(414);
var event_emitter_default = /*#__PURE__*/__webpack_require__.n(event_emitter);

// EXTERNAL MODULE: ./actions/channel_actions.jsx
var channel_actions = __webpack_require__(1593);

// EXTERNAL MODULE: ./selectors/local_storage.js
var local_storage = __webpack_require__(1830);

// CONCATENATED MODULE: ./selectors/views/channel.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
const getLastPostsApiTimeForChannel = (state, channelId) => state.views.channel.lastGetPosts[channelId];
// CONCATENATED MODULE: ./selectors/views/websocket.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
const getSocketStatus = state => state.views.websocket;
// EXTERNAL MODULE: ./utils/browser_history.jsx
var browser_history = __webpack_require__(114);

// EXTERNAL MODULE: ./utils/constants.jsx
var utils_constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./stores/local_storage_store.jsx
var local_storage_store = __webpack_require__(218);

// CONCATENATED MODULE: ./actions/views/channel.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return checkAndSetMobileView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return goToLastViewedChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return switchToChannelById; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return switchToChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return joinChannelById; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return leaveChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return autocompleteUsersInChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return loadInitialPosts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return increasePostVisibility; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return syncPostsInChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return scrollPostListToBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return scrollPostList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return setChannelsLastPost; });
/* unused harmony export setChannelMsgReply */
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



















function checkAndSetMobileView() {
  return dispatch => {
    dispatch({
      type: utils_constants["b" /* ActionTypes */].UPDATE_MOBILE_VIEW,
      data: Object(utils["Y" /* isMobile */])()
    });
  };
}
function goToLastViewedChannel() {
  return async (dispatch, getState) => {
    const state = getState();
    const currentChannel = Object(entities_channels["getCurrentChannel"])(state);
    const channelsInTeam = Object(entities_channels["getChannelsNameMapInCurrentTeam"])(state);
    let channelToSwitchTo = Object(channel_utils["getChannelByName"])(channelsInTeam, Object(local_storage["a" /* getLastViewedChannelName */])(state));

    if (currentChannel.id === channelToSwitchTo.id) {
      channelToSwitchTo = Object(channel_utils["getChannelByName"])(channelsInTeam, Object(entities_channels["getRedirectChannelNameForTeam"])(state, Object(teams["getCurrentTeamId"])(state)));
    }

    return dispatch(switchToChannel(channelToSwitchTo));
  };
}
function switchToChannelById(channelId) {
  return async (dispatch, getState) => {
    const state = getState();
    const channel = Object(entities_channels["getChannel"])(state, channelId);
    return dispatch(switchToChannel(channel));
  };
}
function switchToChannel(channel) {
  return async (dispatch, getState) => {
    const state = getState();
    const teamUrl = Object(teams["getCurrentRelativeTeamUrl"])(state);

    if (channel.fake || channel.userId) {
      const username = channel.userId ? channel.name : channel.display_name;
      const user = Object(entities_users["getUserByUsername"])(state, username);

      if (!user) {
        return {
          error: true
        };
      }

      const direct = await dispatch(Object(channel_actions["e" /* openDirectChannelToUserId */])(user.id));

      if (direct.error) {
        return {
          error: true
        };
      }

      browser_history["a" /* browserHistory */].push(`${teamUrl}/messages/@${channel.name}`);
    } else if (channel.type === utils_constants["g" /* Constants */].GM_CHANNEL) {
      const gmChannel = Object(entities_channels["getChannel"])(state, channel.id);
      browser_history["a" /* browserHistory */].push(`${teamUrl}/channels/${gmChannel.name}`);
    } else {
      browser_history["a" /* browserHistory */].push(`${teamUrl}/channels/${channel.name}`);
    }

    return {
      data: true
    };
  };
}
function joinChannelById(channelId) {
  return async (dispatch, getState) => {
    const state = getState();
    const currentUserId = Object(entities_users["getCurrentUserId"])(state);
    const currentTeamId = Object(teams["getCurrentTeamId"])(state);
    return dispatch(Object(channels["joinChannel"])(currentUserId, currentTeamId, channelId));
  };
}
function leaveChannel(channelId) {
  return async (dispatch, getState) => {
    const state = getState();
    const myPreferences = Object(preferences["getMyPreferences"])(state);
    const currentUserId = Object(entities_users["getCurrentUserId"])(state);
    const currentTeamId = Object(teams["getCurrentTeamId"])(state);

    if (Object(channel_utils["isFavoriteChannel"])(myPreferences, channelId)) {
      dispatch(Object(channels["unfavoriteChannel"])(channelId));
    }

    const teamUrl = Object(teams["getCurrentRelativeTeamUrl"])(state);
    local_storage_store["a" /* default */].removePreviousChannelName(currentUserId, currentTeamId);
    browser_history["a" /* browserHistory */].push(teamUrl);
    const {
      error
    } = await dispatch(Object(channels["leaveChannel"])(channelId));

    if (error) {
      return {
        error
      };
    }

    return {
      data: true
    };
  };
}
function autocompleteUsersInChannel(prefix, channelId) {
  return async (dispatch, getState) => {
    const state = getState();
    const currentTeamId = Object(teams["getCurrentTeamId"])(state);
    return dispatch(Object(users["autocompleteUsers"])(prefix, currentTeamId, channelId));
  };
}
function loadInitialPosts(channelId, focusedPostId) {
  return async dispatch => {
    let posts;
    let hasMoreBefore = false;
    let hasMoreAfter = false;
    const time = Date.now();

    if (focusedPostId) {
      const result = await dispatch(actions_posts["getPostsAround"](channelId, focusedPostId, constants["Posts"].POST_CHUNK_SIZE / 2));
      posts = result.data;

      if (posts) {
        // If the post is at index i, there are i posts after it and len - i - 1 before it
        const numPostsAfter = posts.order.indexOf(focusedPostId);
        const numPostsBefore = posts.order.length - numPostsAfter - 1;
        hasMoreBefore = numPostsBefore >= constants["Posts"].POST_CHUNK_SIZE / 2;
        hasMoreAfter = numPostsAfter >= constants["Posts"].POST_CHUNK_SIZE / 2;
      }
    } else {
      const result = await dispatch(actions_posts["getPosts"](channelId, 0, constants["Posts"].POST_CHUNK_SIZE / 2));
      posts = result.data;

      if (posts) {
        hasMoreBefore = posts && posts.order.length >= constants["Posts"].POST_CHUNK_SIZE / 2;
      }
    }

    if (posts) {
      dispatch({
        type: utils_constants["b" /* ActionTypes */].RECEIVED_POSTS_FOR_CHANNEL_AT_TIME,
        channelId,
        time
      });
    }

    return {
      posts,
      hasMoreBefore,
      hasMoreAfter
    };
  };
}
function increasePostVisibility(channelId, beforePostId) {
  return async (dispatch, getState) => {
    const state = getState();

    if (state.views.channel.loadingPosts[channelId]) {
      return true;
    }

    const currentPostVisibility = state.views.channel.postVisibility[channelId];

    if (currentPostVisibility >= utils_constants["g" /* Constants */].MAX_POST_VISIBILITY) {
      return true;
    }

    dispatch({
      type: utils_constants["b" /* ActionTypes */].LOADING_POSTS,
      data: true,
      channelId
    });
    const result = await dispatch(actions_posts["getPostsBefore"](channelId, beforePostId, 0, constants["Posts"].POST_CHUNK_SIZE / 2));
    const posts = result.data;
    const actions = [{
      type: utils_constants["b" /* ActionTypes */].LOADING_POSTS,
      data: false,
      channelId
    }];

    if (posts) {
      actions.push({
        type: utils_constants["b" /* ActionTypes */].INCREASE_POST_VISIBILITY,
        data: channelId,
        amount: posts.order.length
      });
    }

    dispatch(Object(lib["batchActions"])(actions));
    return {
      moreToLoad: posts ? posts.order.length >= constants["Posts"].POST_CHUNK_SIZE / 2 : false,
      error: result.error
    };
  };
}
function syncPostsInChannel(channelId, since) {
  return async (dispatch, getState) => {
    const time = Date.now();
    const state = getState();
    const socketStatus = getSocketStatus(state);
    let sinceTimeToGetPosts = since;
    const lastPostsApiCallForChannel = getLastPostsApiTimeForChannel(state, channelId);

    if (lastPostsApiCallForChannel && lastPostsApiCallForChannel < socketStatus.lastDisconnectAt) {
      sinceTimeToGetPosts = lastPostsApiCallForChannel;
    }

    const {
      data,
      error
    } = await dispatch(actions_posts["getPostsSince"](channelId, sinceTimeToGetPosts));

    if (data) {
      dispatch({
        type: utils_constants["b" /* ActionTypes */].RECEIVED_POSTS_FOR_CHANNEL_AT_TIME,
        channelId,
        time
      });
    }

    return {
      data,
      error
    };
  };
}
function scrollPostListToBottom() {
  return () => {
    event_emitter_default.a.emit(utils_constants["j" /* EventTypes */].POST_LIST_SCROLL_CHANGE, true);
  };
}
function scrollPostList() {
  return () => {
    event_emitter_default.a.emit(utils_constants["j" /* EventTypes */].POST_LIST_SCROLL_CHANGE, false);
  };
}
function setChannelsLastPost(channelsLastPost) {
  return dispatch => {
    dispatch({
      type: utils_constants["b" /* ActionTypes */].GET_CHANNELS_LAST_POST,
      data: channelsLastPost
    });
  };
}
function setChannelMsgReply(msgReply = {}) {
  return dispatch => {
    dispatch({
      type: utils_constants["b" /* ActionTypes */].CHANNEL_MESSAGE_REPLY,
      data: msgReply
    });
  };
}

/***/ }),

/***/ 1591:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIncomingHook = createIncomingHook;
exports.getIncomingHook = getIncomingHook;
exports.getIncomingHooks = getIncomingHooks;
exports.removeIncomingHook = removeIncomingHook;
exports.updateIncomingHook = updateIncomingHook;
exports.createOutgoingHook = createOutgoingHook;
exports.getOutgoingHook = getOutgoingHook;
exports.getOutgoingHooks = getOutgoingHooks;
exports.removeOutgoingHook = removeOutgoingHook;
exports.updateOutgoingHook = updateOutgoingHook;
exports.regenOutgoingHookToken = regenOutgoingHookToken;
exports.getCommands = getCommands;
exports.getAutocompleteCommands = getAutocompleteCommands;
exports.getCustomTeamCommands = getCustomTeamCommands;
exports.addCommand = addCommand;
exports.editCommand = editCommand;
exports.executeCommand = executeCommand;
exports.regenCommandToken = regenCommandToken;
exports.deleteCommand = deleteCommand;
exports.addOAuthApp = addOAuthApp;
exports.editOAuthApp = editOAuthApp;
exports.getOAuthApps = getOAuthApps;
exports.getOAuthApp = getOAuthApp;
exports.getAuthorizedOAuthApps = getAuthorizedOAuthApps;
exports.deauthorizeOAuthApp = deauthorizeOAuthApp;
exports.deleteOAuthApp = deleteOAuthApp;
exports.regenOAuthAppSecret = regenOAuthAppSecret;
exports.submitInteractiveDialog = submitInteractiveDialog;

__webpack_require__(83);

__webpack_require__(84);

var _action_types = __webpack_require__(8);

var _constants = __webpack_require__(17);

var _reduxBatchedActions = __webpack_require__(132);

var _client = __webpack_require__(27);

var _users = __webpack_require__(10);

var _channels = __webpack_require__(15);

var _teams = __webpack_require__(32);

var _errors = __webpack_require__(105);

var _helpers = __webpack_require__(117);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function createIncomingHook(hook
/*: IncomingWebhook*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.createIncomingWebhook,
    onRequest: _action_types.IntegrationTypes.CREATE_INCOMING_HOOK_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_INCOMING_HOOK, _action_types.IntegrationTypes.CREATE_INCOMING_HOOK_SUCCESS],
    onFailure: _action_types.IntegrationTypes.CREATE_INCOMING_HOOK_FAILURE,
    params: [hook]
  });
}

function getIncomingHook(hookId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getIncomingWebhook,
    onRequest: _action_types.IntegrationTypes.GET_INCOMING_HOOKS_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_INCOMING_HOOK, _action_types.IntegrationTypes.GET_INCOMING_HOOKS_SUCCESS],
    onFailure: _action_types.IntegrationTypes.GET_INCOMING_HOOKS_FAILURE,
    params: [hookId]
  });
}

function getIncomingHooks() {
  var teamId
  /*: string*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var page
  /*: number*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var perPage
  /*: number*/
  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constants.General.PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getIncomingWebhooks,
    onRequest: _action_types.IntegrationTypes.GET_INCOMING_HOOKS_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_INCOMING_HOOKS, _action_types.IntegrationTypes.GET_INCOMING_HOOKS_SUCCESS],
    onFailure: _action_types.IntegrationTypes.GET_INCOMING_HOOKS_FAILURE,
    params: [teamId, page, perPage]
  });
}

function removeIncomingHook(hookId
/*: string*/
) {
  return (
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(dispatch
      /*: DispatchFunc*/
      , getState
      /*: GetStateFunc*/
      ) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                dispatch({
                  type: _action_types.IntegrationTypes.DELETE_INCOMING_HOOK_REQUEST,
                  data: {}
                }, getState);
                _context.prev = 1;
                _context.next = 4;
                return _client.Client4.removeIncomingWebhook(hookId);

              case 4:
                _context.next = 11;
                break;

              case 6:
                _context.prev = 6;
                _context.t0 = _context["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.DELETE_INCOMING_HOOK_FAILURE,
                  error: _context.t0
                }, (0, _errors.logError)(_context.t0)]), getState);
                return _context.abrupt("return", {
                  error: _context.t0
                });

              case 11:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.DELETED_INCOMING_HOOK,
                  data: {
                    id: hookId
                  }
                }, {
                  type: _action_types.IntegrationTypes.DELETE_INCOMING_HOOK_SUCCESS
                }]), getState);
                return _context.abrupt("return", {
                  data: true
                });

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 6]]);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}

function updateIncomingHook(hook
/*: IncomingWebhook*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.updateIncomingWebhook,
    onRequest: _action_types.IntegrationTypes.UPDATE_INCOMING_HOOK_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_INCOMING_HOOK, _action_types.IntegrationTypes.UPDATE_INCOMING_HOOK_SUCCESS],
    onFailure: _action_types.IntegrationTypes.UPDATE_INCOMING_HOOK_FAILURE,
    params: [hook]
  });
}

function createOutgoingHook(hook
/*: OutgoingWebhook*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.createOutgoingWebhook,
    onRequest: _action_types.IntegrationTypes.CREATE_OUTGOING_HOOK_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_OUTGOING_HOOK, _action_types.IntegrationTypes.CREATE_OUTGOING_HOOK_SUCCESS],
    onFailure: _action_types.IntegrationTypes.CREATE_OUTGOING_HOOK_FAILURE,
    params: [hook]
  });
}

function getOutgoingHook(hookId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getOutgoingWebhook,
    onRequest: _action_types.IntegrationTypes.GET_OUTGOING_HOOKS_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_OUTGOING_HOOK, _action_types.IntegrationTypes.GET_OUTGOING_HOOKS_SUCCESS],
    onFailure: _action_types.IntegrationTypes.GET_OUTGOING_HOOKS_FAILURE,
    params: [hookId]
  });
}

function getOutgoingHooks() {
  var channelId
  /*: string*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var teamId
  /*: string*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var page
  /*: number*/
  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var perPage
  /*: number*/
  = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.General.PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getOutgoingWebhooks,
    onRequest: _action_types.IntegrationTypes.GET_OUTGOING_HOOKS_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_OUTGOING_HOOKS, _action_types.IntegrationTypes.GET_OUTGOING_HOOKS_SUCCESS],
    onFailure: _action_types.IntegrationTypes.GET_OUTGOING_HOOKS_FAILURE,
    params: [channelId, teamId, page, perPage]
  });
}

function removeOutgoingHook(hookId
/*: string*/
) {
  return (
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(dispatch
      /*: DispatchFunc*/
      , getState
      /*: GetStateFunc*/
      ) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                dispatch({
                  type: _action_types.IntegrationTypes.DELETE_OUTGOING_HOOK_REQUEST,
                  data: {}
                }, getState);
                _context2.prev = 1;
                _context2.next = 4;
                return _client.Client4.removeOutgoingWebhook(hookId);

              case 4:
                _context2.next = 11;
                break;

              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context2.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.DELETE_OUTGOING_HOOK_FAILURE,
                  error: _context2.t0
                }, (0, _errors.logError)(_context2.t0)]), getState);
                return _context2.abrupt("return", {
                  error: _context2.t0
                });

              case 11:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.DELETED_OUTGOING_HOOK,
                  data: {
                    id: hookId
                  }
                }, {
                  type: _action_types.IntegrationTypes.DELETE_OUTGOING_HOOK_SUCCESS
                }]), getState);
                return _context2.abrupt("return", {
                  data: true
                });

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[1, 6]]);
      }));

      return function (_x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }()
  );
}

function updateOutgoingHook(hook
/*: OutgoingWebhook*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.updateOutgoingWebhook,
    onRequest: _action_types.IntegrationTypes.UPDATE_OUTGOING_HOOK_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_OUTGOING_HOOK, _action_types.IntegrationTypes.UPDATE_OUTGOING_HOOK_SUCCESS],
    onFailure: _action_types.IntegrationTypes.UPDATE_OUTGOING_HOOK_FAILURE,
    params: [hook]
  });
}

function regenOutgoingHookToken(hookId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.regenOutgoingHookToken,
    onRequest: _action_types.IntegrationTypes.UPDATE_OUTGOING_HOOK_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_OUTGOING_HOOK, _action_types.IntegrationTypes.UPDATE_OUTGOING_HOOK_SUCCESS],
    onFailure: _action_types.IntegrationTypes.UPDATE_OUTGOING_HOOK_FAILURE,
    params: [hookId]
  });
}

function getCommands(teamId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getCommandsList,
    onRequest: _action_types.IntegrationTypes.GET_COMMANDS_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_COMMANDS, _action_types.IntegrationTypes.GET_COMMANDS_SUCCESS],
    onFailure: _action_types.IntegrationTypes.GET_COMMANDS_FAILURE,
    params: [teamId]
  });
}

function getAutocompleteCommands(teamId
/*: string*/
) {
  var page
  /*: number*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var perPage
  /*: number*/
  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constants.General.PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getAutocompleteCommandsList,
    onRequest: _action_types.IntegrationTypes.GET_AUTOCOMPLETE_COMMANDS_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_COMMANDS, _action_types.IntegrationTypes.GET_AUTOCOMPLETE_COMMANDS_SUCCESS],
    onFailure: _action_types.IntegrationTypes.GET_AUTOCOMPLETE_COMMANDS_FAILURE,
    params: [teamId, page, perPage]
  });
}

function getCustomTeamCommands(teamId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getCustomTeamCommands,
    onRequest: _action_types.IntegrationTypes.GET_CUSTOM_TEAM_COMMANDS_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_CUSTOM_TEAM_COMMANDS, _action_types.IntegrationTypes.GET_CUSTOM_TEAM_COMMANDS_SUCCESS],
    onFailure: _action_types.IntegrationTypes.GET_CUSTOM_TEAM_COMMANDS_FAILURE,
    params: [teamId]
  });
}

function addCommand(command
/*: Command*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.addCommand,
    onRequest: _action_types.IntegrationTypes.ADD_COMMAND_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_COMMAND, _action_types.IntegrationTypes.ADD_COMMAND_SUCCESS],
    onFailure: _action_types.IntegrationTypes.ADD_COMMAND_FAILURE,
    params: [command]
  });
}

function editCommand(command
/*: Command*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.editCommand,
    onRequest: _action_types.IntegrationTypes.EDIT_COMMAND_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_COMMAND, _action_types.IntegrationTypes.EDIT_COMMAND_SUCCESS],
    onFailure: _action_types.IntegrationTypes.EDIT_COMMAND_FAILURE,
    params: [command]
  });
}

function executeCommand(command
/*: Command*/
, args
/*: Array<string>*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.executeCommand,
    onRequest: _action_types.IntegrationTypes.EXECUTE_COMMAND_REQUEST,
    onSuccess: _action_types.IntegrationTypes.EXECUTE_COMMAND_SUCCESS,
    onFailure: _action_types.IntegrationTypes.EXECUTE_COMMAND_FAILURE,
    params: [command, args]
  });
}

function regenCommandToken(id
/*: string*/
) {
  return (
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(dispatch
      /*: DispatchFunc*/
      , getState
      /*: GetStateFunc*/
      ) {
        var res;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                dispatch({
                  type: _action_types.IntegrationTypes.REGEN_COMMAND_TOKEN_REQUEST,
                  data: {}
                }, getState);
                _context3.prev = 1;
                _context3.next = 4;
                return _client.Client4.regenCommandToken(id);

              case 4:
                res = _context3.sent;
                _context3.next = 12;
                break;

              case 7:
                _context3.prev = 7;
                _context3.t0 = _context3["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context3.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.REGEN_COMMAND_TOKEN_FAILURE,
                  error: _context3.t0
                }, (0, _errors.logError)(_context3.t0)]), getState);
                return _context3.abrupt("return", {
                  error: _context3.t0
                });

              case 12:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.RECEIVED_COMMAND_TOKEN,
                  data: {
                    id: id,
                    token: res.token
                  }
                }, {
                  type: _action_types.IntegrationTypes.REGEN_COMMAND_TOKEN_SUCCESS
                }]), getState);
                return _context3.abrupt("return", {
                  data: true
                });

              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[1, 7]]);
      }));

      return function (_x5, _x6) {
        return _ref3.apply(this, arguments);
      };
    }()
  );
}

function deleteCommand(id
/*: string*/
) {
  return (
    /*#__PURE__*/
    function () {
      var _ref4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(dispatch
      /*: DispatchFunc*/
      , getState
      /*: GetStateFunc*/
      ) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                dispatch({
                  type: _action_types.IntegrationTypes.DELETE_COMMAND_REQUEST,
                  data: {}
                }, getState);
                _context4.prev = 1;
                _context4.next = 4;
                return _client.Client4.deleteCommand(id);

              case 4:
                _context4.next = 11;
                break;

              case 6:
                _context4.prev = 6;
                _context4.t0 = _context4["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context4.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.DELETE_COMMAND_FAILURE,
                  error: _context4.t0
                }, (0, _errors.logError)(_context4.t0)]), getState);
                return _context4.abrupt("return", {
                  error: _context4.t0
                });

              case 11:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.DELETED_COMMAND,
                  data: {
                    id: id
                  }
                }, {
                  type: _action_types.IntegrationTypes.DELETE_COMMAND_SUCCESS
                }]), getState);
                return _context4.abrupt("return", {
                  data: true
                });

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[1, 6]]);
      }));

      return function (_x7, _x8) {
        return _ref4.apply(this, arguments);
      };
    }()
  );
}

function addOAuthApp(app
/*: OAuthApp*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.createOAuthApp,
    onRequest: _action_types.IntegrationTypes.ADD_OAUTH_APP_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_OAUTH_APP, _action_types.IntegrationTypes.ADD_OAUTH_APP_SUCCESS],
    onFailure: _action_types.IntegrationTypes.ADD_OAUTH_APP_FAILURE,
    params: [app]
  });
}

function editOAuthApp(app
/*: OAuthApp*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.editOAuthApp,
    onRequest: _action_types.IntegrationTypes.UPDATE_OAUTH_APP_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_OAUTH_APP, _action_types.IntegrationTypes.UPDATE_OAUTH_APP_SUCCESS],
    onFailure: _action_types.IntegrationTypes.UPDATE_OAUTH_APP_FAILURE,
    params: [app]
  });
}

function getOAuthApps() {
  var page
  /*: number*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var perPage
  /*: number*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.General.PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getOAuthApps,
    onRequest: _action_types.IntegrationTypes.GET_OAUTH_APPS_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_OAUTH_APPS, _action_types.IntegrationTypes.GET_OAUTH_APPS_SUCCESS],
    onFailure: _action_types.IntegrationTypes.GET_OAUTH_APPS_FAILURE,
    params: [page, perPage]
  });
}

function getOAuthApp(appId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getOAuthApp,
    onRequest: _action_types.IntegrationTypes.GET_OAUTH_APP_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_OAUTH_APP, _action_types.IntegrationTypes.GET_OAUTH_APP_SUCCESS],
    onFailure: _action_types.IntegrationTypes.GET_OAUTH_APP_FAILURE,
    params: [appId]
  });
}

function getAuthorizedOAuthApps() {
  return (
    /*#__PURE__*/
    function () {
      var _ref5 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(dispatch
      /*: DispatchFunc*/
      , getState
      /*: GetStateFunc*/
      ) {
        var state, currentUserId, data;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                dispatch({
                  type: _action_types.IntegrationTypes.GET_AUTHORIZED_OAUTH_APPS_REQUEST,
                  data: {}
                });
                state = getState();
                currentUserId = (0, _users.getCurrentUserId)(state);
                _context5.prev = 3;
                _context5.next = 6;
                return _client.Client4.getAuthorizedOAuthApps(currentUserId);

              case 6:
                data = _context5.sent;
                _context5.next = 14;
                break;

              case 9:
                _context5.prev = 9;
                _context5.t0 = _context5["catch"](3);
                (0, _helpers.forceLogoutIfNecessary)(_context5.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.GET_AUTHORIZED_OAUTH_APPS_FAILURE,
                  error: _context5.t0
                }, (0, _errors.logError)(_context5.t0)]), getState);
                return _context5.abrupt("return", {
                  error: _context5.t0
                });

              case 14:
                dispatch({
                  type: _action_types.IntegrationTypes.GET_AUTHORIZED_OAUTH_APPS_SUCCESS,
                  data: {}
                });
                return _context5.abrupt("return", {
                  data: data
                });

              case 16:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[3, 9]]);
      }));

      return function (_x9, _x10) {
        return _ref5.apply(this, arguments);
      };
    }()
  );
}

function deauthorizeOAuthApp(clientId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.deauthorizeOAuthApp,
    onRequest: _action_types.IntegrationTypes.DEAUTHORIZE_OAUTH_APP_REQUEST,
    onSuccess: _action_types.IntegrationTypes.DEAUTHORIZE_OAUTH_APP_SUCCESS,
    onFailure: _action_types.IntegrationTypes.DEAUTHORIZE_OAUTH_APP_FAILURE,
    params: [clientId]
  });
}

function deleteOAuthApp(id
/*: string*/
) {
  return (
    /*#__PURE__*/
    function () {
      var _ref6 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(dispatch
      /*: DispatchFunc*/
      , getState
      /*: GetStateFunc*/
      ) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                dispatch({
                  type: _action_types.IntegrationTypes.DELETE_OAUTH_APP_REQUEST,
                  data: {}
                }, getState);
                _context6.prev = 1;
                _context6.next = 4;
                return _client.Client4.deleteOAuthApp(id);

              case 4:
                _context6.next = 11;
                break;

              case 6:
                _context6.prev = 6;
                _context6.t0 = _context6["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context6.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.DELETE_OAUTH_APP_FAILURE,
                  error: _context6.t0
                }, (0, _errors.logError)(_context6.t0)]), getState);
                return _context6.abrupt("return", {
                  error: _context6.t0
                });

              case 11:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.DELETED_OAUTH_APP,
                  data: {
                    id: id
                  }
                }, {
                  type: _action_types.IntegrationTypes.DELETE_OAUTH_APP_SUCCESS
                }]), getState);
                return _context6.abrupt("return", {
                  data: true
                });

              case 13:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, null, [[1, 6]]);
      }));

      return function (_x11, _x12) {
        return _ref6.apply(this, arguments);
      };
    }()
  );
}

function regenOAuthAppSecret(appId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.regenOAuthAppSecret,
    onRequest: _action_types.IntegrationTypes.UPDATE_OAUTH_APP_REQUEST,
    onSuccess: [_action_types.IntegrationTypes.RECEIVED_OAUTH_APP, _action_types.IntegrationTypes.UPDATE_OAUTH_APP_SUCCESS],
    onFailure: _action_types.IntegrationTypes.UPDATE_OAUTH_APP_FAILURE,
    params: [appId]
  });
}

function submitInteractiveDialog(submission
/*: DialogSubmission*/
) {
  return (
    /*#__PURE__*/
    function () {
      var _ref7 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(dispatch
      /*: DispatchFunc*/
      , getState
      /*: GetStateFunc*/
      ) {
        var state, data;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                dispatch({
                  type: _action_types.IntegrationTypes.SUBMIT_INTERACTIVE_DIALOG_REQUEST,
                  data: {}
                });
                state = getState();
                submission.channel_id = (0, _channels.getCurrentChannelId)(state);
                submission.team_id = (0, _teams.getCurrentTeamId)(state);
                _context7.prev = 4;
                _context7.next = 7;
                return _client.Client4.submitInteractiveDialog(submission);

              case 7:
                data = _context7.sent;
                _context7.next = 15;
                break;

              case 10:
                _context7.prev = 10;
                _context7.t0 = _context7["catch"](4);
                (0, _helpers.forceLogoutIfNecessary)(_context7.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.IntegrationTypes.SUBMIT_INTERACTIVE_DIALOG_FAILURE,
                  error: _context7.t0
                }, (0, _errors.logError)(_context7.t0)]), getState);
                return _context7.abrupt("return", {
                  error: _context7.t0
                });

              case 15:
                dispatch({
                  type: _action_types.IntegrationTypes.SUBMIT_INTERACTIVE_DIALOG_SUCCESS,
                  data: {}
                });
                return _context7.abrupt("return", {
                  data: data
                });

              case 17:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, null, [[4, 10]]);
      }));

      return function (_x13, _x14) {
        return _ref7.apply(this, arguments);
      };
    }()
  );
}

/***/ }),

/***/ 1593:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return openDirectChannelToUserId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return openGroupChannelToUserIds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return loadChannelsForCurrentUser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return searchMoreChannels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return autocompleteChannels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return autocompleteChannelsForSearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addUsersToChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return setChannelVisible; });
/* harmony import */ var redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);
/* harmony import */ var redux_batched_actions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var mattermost_redux_actions_preferences__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(128);
/* harmony import */ var mattermost_redux_actions_preferences__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_preferences__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var mattermost_redux_selectors_entities_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(207);
/* harmony import */ var mattermost_redux_selectors_entities_common__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_common__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(15);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(32);
/* harmony import */ var mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var actions_diagnostics_actions_jsx__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(300);
/* harmony import */ var actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(304);
/* harmony import */ var stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(14);
/* harmony import */ var utils_browser_history__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(114);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(0);
/* harmony import */ var utils_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(22);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.














const doDispatch = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"].dispatch;
const doGetState = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"].getState;
function openDirectChannelToUserId(userId) {
  return async (dispatch, getState) => {
    const state = getState();
    const currentUserId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_7__["getCurrentUserId"])(state);
    const channelName = Object(utils_utils__WEBPACK_IMPORTED_MODULE_13__[/* getDirectChannelName */ "u"])(currentUserId, userId);
    const channel = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_5__["getChannelByName"])(state, channelName);

    if (!channel) {
      return dispatch(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_2__["createDirectChannel"](currentUserId, userId));
    }

    Object(actions_diagnostics_actions_jsx__WEBPACK_IMPORTED_MODULE_8__[/* trackEvent */ "d"])("api", "api_channels_join_direct");
    const now = Date.now();
    const prefDirect = {
      category: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__[/* Preferences */ "w"].CATEGORY_DIRECT_CHANNEL_SHOW,
      name: userId,
      value: "true"
    };
    const prefOpenTime = {
      category: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__[/* Preferences */ "w"].CATEGORY_CHANNEL_OPEN_TIME,
      name: channel.id,
      value: now.toString()
    };
    const actions = [{
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["PreferenceTypes"].RECEIVED_PREFERENCES,
      data: [prefDirect]
    }, {
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["PreferenceTypes"].RECEIVED_PREFERENCES,
      data: [prefOpenTime]
    }];
    dispatch(Object(redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__["batchActions"])(actions));
    dispatch(Object(mattermost_redux_actions_preferences__WEBPACK_IMPORTED_MODULE_3__["savePreferences"])(currentUserId, [{
      user_id: currentUserId,
      ...prefDirect
    }, {
      user_id: currentUserId,
      ...prefOpenTime
    }]));
    return {
      data: channel
    };
  };
}
function openGroupChannelToUserIds(userIds) {
  return async (dispatch, getState) => {
    const result = await dispatch(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_2__["createGroupChannel"](userIds));

    if (result.error) {
      utils_browser_history__WEBPACK_IMPORTED_MODULE_11__[/* browserHistory */ "a"].push(Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_6__["getCurrentTeamUrl"])(getState()));
    }

    return result;
  };
}
function loadChannelsForCurrentUser() {
  return async (dispatch, getState) => {
    const state = getState();
    const unreads = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_5__["getUnreadChannelIds"])(state);
    await dispatch(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_2__["fetchMyChannelsAndMembers"](Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_6__["getCurrentTeamId"])(state)));

    for (const id of unreads) {
      const channel = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_5__["getChannel"])(state, id);

      if (channel && channel.type === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__[/* Constants */ "g"].DM_CHANNEL) {
        Object(actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_9__[/* loadNewDMIfNeeded */ "d"])(channel.id);
      } else if (channel && channel.type === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__[/* Constants */ "g"].GM_CHANNEL) {
        Object(actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_9__[/* loadNewGMIfNeeded */ "e"])(channel.id);
      }
    }

    Object(actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_9__[/* loadProfilesForSidebar */ "i"])();
  };
}
function searchMoreChannels(term) {
  return async (dispatch, getState) => {
    const state = getState();
    const teamId = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_6__["getCurrentTeamId"])(state);

    if (!teamId) {
      throw new Error("No team id");
    }

    const {
      data,
      error
    } = await dispatch(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_2__["searchChannels"](teamId, term));

    if (data) {
      const myMembers = Object(mattermost_redux_selectors_entities_common__WEBPACK_IMPORTED_MODULE_4__["getMyChannelMemberships"])(state);
      const channels = data.filter(c => !myMembers[c.id]);
      return {
        data: channels
      };
    }

    return {
      error
    };
  };
}
async function autocompleteChannels(term, success, error) {
  const state = doGetState();
  const teamId = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_6__["getCurrentTeamId"])(state);

  if (!teamId) {
    return;
  }

  const {
    data,
    error: err
  } = await mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_2__["autocompleteChannels"](teamId, term)(doDispatch, doGetState);

  if (data && success) {
    success(data);
  } else if (err && error) {
    error({
      id: err.server_error_id,
      ...err
    });
  }
}
async function autocompleteChannelsForSearch(term, success, error) {
  const state = doGetState();
  const teamId = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_6__["getCurrentTeamId"])(state);

  if (!teamId) {
    return;
  }

  const {
    data,
    error: err
  } = await mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_2__["autocompleteChannelsForSearch"](teamId, term)(doDispatch, doGetState);

  if (data && success) {
    success(data);
  } else if (err && error) {
    error({
      id: err.server_error_id,
      ...err
    });
  }
}
function addUsersToChannel(channelId, userIds) {
  return async dispatch => {
    try {
      const requests = userIds.map(uId => dispatch(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_2__["addChannelMember"](channelId, uId)));
      return await Promise.all(requests);
    } catch (error) {
      return {
        error
      };
    }
  };
} // export function addChannelOUMember(channelId:string, userId: string, postRootId: string = ''): ActionFunc {
//   return async (dispatch, getState) => {
//       let member;
//       try {
//           member = await Client4.addToChannel(userId, channelId, postRootId);
//       } catch (error) {
//           forceLogoutIfNecessary(error, dispatch, getState);
//           dispatch(logError(error));
//           return {error};
//       }
//       Client4.trackEvent('action', 'action_channels_add_member', {channel_id: channelId});
//       dispatch(batchActions([
//           {
//               type: UserTypes.RECEIVED_PROFILE_IN_CHANNEL,
//               data: {id: channelId, user_id: userId},
//           },
//           {
//               type: ChannelTypes.RECEIVED_CHANNEL_MEMBER,
//               data: member,
//           },
//           {
//               type: ChannelTypes.ADD_CHANNEL_MEMBER_SUCCESS,
//               id: channelId,
//           },
//       ], 'ADD_CHANNEL_MEMBER.BATCH'), getState);
//       return {data: member};
//   };
// }
// 设置频道是否显示

function setChannelVisible(channelIds, value) {
  return async (dispatch, getState) => {
    const state = getState();
    const currentUserId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_7__["getCurrentUserId"])(state);
    const arr = channelIds.map(channelId => {
      let name;
      let category;
      const channel = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_5__["getChannel"])(state, channelId);

      if (channel.type === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__[/* Constants */ "g"].PRIVATE_CHANNEL || channel.type === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__[/* Constants */ "g"].OPEN_CHANNEL) {
        name = channel.id;
        category = utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__[/* Constants */ "g"].Preferences.CATEGORY_PRIVATE_CHANNEL_SHOW;
      } else if (channel.type === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__[/* Constants */ "g"].DM_CHANNEL) {
        const teammate = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_7__["getUser"])(state, channel.teammate_id);
        let channelTeammateId = '';

        if (teammate) {
          channelTeammateId = teammate.id;
        }

        name = channelTeammateId;
        category = utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__[/* Constants */ "g"].Preferences.CATEGORY_DIRECT_CHANNEL_SHOW;
      } else {
        name = channel.channelId;
        category = utils_constants_jsx__WEBPACK_IMPORTED_MODULE_12__[/* Constants */ "g"].Preferences.CATEGORY_GROUP_CHANNEL_SHOW;
      }

      return {
        user_id: currentUserId,
        category,
        name,
        value
      };
    });
    return dispatch(Object(mattermost_redux_actions_preferences__WEBPACK_IMPORTED_MODULE_3__["savePreferences"])(currentUserId, arr));
  };
}

/***/ }),

/***/ 1597:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Provider; });
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
class Provider {
  constructor() {
    this.latestPrefix = '';
    this.latestComplete = true;
    this.disableDispatches = false;
    this.requestStarted = false;
  }

  handlePretextChanged(pretext) {// eslint-disable-line no-unused-vars
    // NO-OP for inherited classes to override
  }

  resetRequest() {
    this.requestStarted = false;
  }

  startNewRequest(prefix) {
    this.latestPrefix = prefix;
    this.latestComplete = false;
    this.requestStarted = true;
  }

  shouldCancelDispatch(prefix) {
    if (this.disableDispatches) {
      return true;
    }

    if (!this.requestStarted) {
      return true;
    }

    if (prefix === this.latestPrefix) {
      this.latestComplete = true;
    } else if (this.latestComplete) {
      return true;
    }

    return false;
  }

  allowDividers() {
    return true;
  }

  presentationType() {
    return 'text';
  }

}

/***/ }),

/***/ 1598:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Suggestion; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class Suggestion extends react__WEBPACK_IMPORTED_MODULE_1___default.a.Component {
  static get propTypes() {
    return {
      item: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string]).isRequired,
      term: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,
      matchedPretext: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,
      isSelection: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
      onClick: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func
    };
  }

  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick(e) {
    e.preventDefault();
    this.props.onClick(this.props.term, this.props.matchedPretext);
  }

}

_defineProperty(Suggestion, "baseProps", {
  role: 'button',
  tabIndex: -1
});

/***/ }),

/***/ 1600:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export MenuItemActionImpl */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _menu_item_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1730);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



const MenuItemActionImpl = ({
  onClick,
  ariaLabel,
  text,
  extraText,
  id
}) => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
  id: id,
  "aria-label": ariaLabel,
  className: 'style--none' + (extraText ? ' MenuItem__help' : ''),
  onClick: onClick
}, text, extraText && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
  className: "extra-text"
}, extraText));
MenuItemActionImpl.propTypes = {
  onClick: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,
  ariaLabel: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  text: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node]).isRequired,
  extraText: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string
};
const MenuItemAction = Object(_menu_item_jsx__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(MenuItemActionImpl);
MenuItemAction.displayName = 'MenuItemAction';
/* harmony default export */ __webpack_exports__["a"] = (MenuItemAction);

/***/ }),

/***/ 1601:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return canUploadFiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return canDownloadFiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return trimFilename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getFileTypeFromMime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getExifOrientation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getOrientationStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return canPreviewDoc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return canPreview; });
/* harmony import */ var exif2css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2425);
/* harmony import */ var exif2css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(exif2css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var utils_user_agent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);
/* harmony import */ var _syntax_highlighting__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(295);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function canUploadFiles(config) {
  const enableFileAttachments = config.EnableFileAttachments === 'true';
  const enableMobileFileUpload = config.EnableMobileFileUpload === 'true';

  if (!enableFileAttachments) {
    return false;
  }

  if (utils_user_agent__WEBPACK_IMPORTED_MODULE_2__[/* isMobileApp */ "n"]()) {
    return enableMobileFileUpload;
  }

  return true;
}
function canDownloadFiles(config) {
  if (utils_user_agent__WEBPACK_IMPORTED_MODULE_2__[/* isMobileApp */ "n"]()) {
    return config.EnableMobileFileDownload === 'true';
  }

  return true;
}
function trimFilename(filename) {
  let trimmedFilename = filename;

  if (filename.length > utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__[/* default */ "N"].MAX_FILENAME_LENGTH) {
    trimmedFilename = filename.substring(0, Math.min(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__[/* default */ "N"].MAX_FILENAME_LENGTH, filename.length)) + '...';
  }

  return trimmedFilename;
}
function getFileTypeFromMime(mimetype) {
  const mimeTypeSplitBySlash = mimetype.split('/');
  const mimeTypePrefix = mimeTypeSplitBySlash[0];
  const mimeTypeSuffix = mimeTypeSplitBySlash[1];

  if (mimeTypePrefix === 'video') {
    return 'video';
  } else if (mimeTypePrefix === 'audio') {
    return 'audio';
  } else if (mimeTypePrefix === 'image') {
    return 'image';
  }

  if (mimeTypeSuffix) {
    if (mimeTypeSuffix === 'pdf') {
      return 'pdf';
    } else if (mimeTypeSuffix.includes('vnd.ms-excel') || mimeTypeSuffix.includes('spreadsheetml') || mimeTypeSuffix.includes('vnd.sun.xml.calc') || mimeTypeSuffix.includes('opendocument.spreadsheet')) {
      return 'spreadsheet';
    } else if (mimeTypeSuffix.includes('vnd.ms-powerpoint') || mimeTypeSuffix.includes('presentationml') || mimeTypeSuffix.includes('vnd.sun.xml.impress') || mimeTypeSuffix.includes('opendocument.presentation')) {
      return 'presentation';
    } else if (mimeTypeSuffix === 'msword' || mimeTypeSuffix.includes('vnd.ms-word') || mimeTypeSuffix.includes('officedocument.wordprocessingml') || mimeTypeSuffix.includes('application/x-mswrite')) {
      return 'word';
    }
  }

  return 'other';
} // based on https://stackoverflow.com/questions/7584794/accessing-jpeg-exif-rotation-data-in-javascript-on-the-client-side/32490603#32490603

function getExifOrientation(data) {
  var view = new DataView(data);

  if (view.getUint16(0, false) !== 0xFFD8) {
    return -2;
  }

  var length = view.byteLength;
  var offset = 2;

  while (offset < length) {
    var marker = view.getUint16(offset, false);
    offset += 2;

    if (marker === 0xFFE1) {
      if (view.getUint32(offset += 2, false) !== 0x45786966) {
        return -1;
      }

      var little = view.getUint16(offset += 6, false) === 0x4949;
      offset += view.getUint32(offset + 4, little);
      var tags = view.getUint16(offset, little);
      offset += 2;

      for (var i = 0; i < tags; i++) {
        if (view.getUint16(offset + i * 12, little) === 0x0112) {
          return view.getUint16(offset + i * 12 + 8, little);
        }
      }
    } else if ((marker & 0xFF00) === 0xFF00) {
      offset += view.getUint16(offset, false);
    } else {
      break;
    }
  }

  return -1;
}
function getOrientationStyles(orientation) {
  const {
    transform,
    'transform-origin': transformOrigin
  } = exif2css__WEBPACK_IMPORTED_MODULE_0___default()(orientation);
  return {
    transform,
    transformOrigin
  };
} // 判断能预览的文档

function canPreviewDoc(extension) {
  const fileType = _utils__WEBPACK_IMPORTED_MODULE_3__[/* getFileType */ "z"](extension);

  if (fileType === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__[/* FileTypes */ "k"].PRESENTATION || fileType === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__[/* FileTypes */ "k"].SPREADSHEET || fileType === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__[/* FileTypes */ "k"].WORD || fileType === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__[/* FileTypes */ "k"].PDF || fileType === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__[/* FileTypes */ "k"].TXT) {
    return true;
  }

  return false;
} // 判断能预览的格式

function canPreview(extension) {
  const fileType = _utils__WEBPACK_IMPORTED_MODULE_3__[/* getFileType */ "z"](extension);

  if (canPreviewDoc(extension) || fileType === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__[/* FileTypes */ "k"].IMAGE || fileType === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__[/* FileTypes */ "k"].SVG || Boolean(_syntax_highlighting__WEBPACK_IMPORTED_MODULE_4__[/* getLanguageFromFileExtension */ "b"](extension))) {
    return true;
  }

  return false;
}

/***/ }),

/***/ 1606:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/popmotion/dist/popmotion.es.js + 7 modules
var popmotion_es = __webpack_require__(3436);

// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/CSSTransition.js + 2 modules
var CSSTransition = __webpack_require__(3493);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// CONCATENATED MODULE: ./components/widgets/menu/menu_wrapper_animation.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const ANIMATION_DURATION = 80;
class menu_wrapper_animation_MenuWrapperAnimation extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "onEntering", node => {
      const nodeStyler = Object(popmotion_es["a" /* styler */])(node);
      Object(popmotion_es["b" /* tween */])({
        from: {
          opacity: 0
        },
        to: {
          opacity: 1
        },
        duration: ANIMATION_DURATION
      }).start(nodeStyler.set);
    });

    _defineProperty(this, "onExiting", node => {
      const nodeStyler = Object(popmotion_es["a" /* styler */])(node);
      Object(popmotion_es["b" /* tween */])({
        from: {
          opacity: 1
        },
        to: {
          opacity: 0
        },
        duration: ANIMATION_DURATION
      }).start(nodeStyler.set);
    });
  }

  render() {
    return react_default.a.createElement(CSSTransition["a" /* default */], {
      in: this.props.show,
      classNames: "MenuWrapperAnimation",
      enter: true,
      exit: true,
      mountOnEnter: true,
      unmountOnExit: true // onEntering={!isMobile() && this.onEntering}
      // onExiting={!isMobile() && this.onExiting}
      ,
      timeout: {
        enter: ANIMATION_DURATION,
        exit: ANIMATION_DURATION
      }
    }, this.props.children);
  }

}

_defineProperty(menu_wrapper_animation_MenuWrapperAnimation, "propTypes", {
  children: prop_types_default.a.node,
  show: prop_types_default.a.bool.isRequired
});
// CONCATENATED MODULE: ./components/widgets/menu/menu_wrapper.jsx
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return menu_wrapper_MenuWrapper; });
function menu_wrapper_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class menu_wrapper_MenuWrapper extends react_default.a.PureComponent {
  constructor(props) {
    if (!Array.isArray(props.children) || props.children.length !== 2) {
      throw new Error('MenuWrapper needs exactly 2 children');
    }

    super(props);

    menu_wrapper_defineProperty(this, "close", e => {
      if (this.node.current.contains(e.target)) {
        return;
      }

      if (this.state.open) {
        this.setState({
          open: false
        });

        if (this.props.onToggle) {
          this.props.onToggle(false);
        }
      }
    });

    menu_wrapper_defineProperty(this, "toggle", () => {
      const newState = !this.state.open;
      this.setState({
        open: newState
      });

      if (this.props.onToggle) {
        this.props.onToggle(newState);
      }
    });

    this.state = {
      open: false
    };
    this.node = react_default.a.createRef();
  }

  componentDidMount() {
    document.addEventListener('click', this.close, true);
  }

  componentWillUnmount() {
    document.removeEventListener('click', this.close, true);
  }

  render() {
    const {
      children
    } = this.props;
    const Animation = this.props.animationComponent;
    return react_default.a.createElement("div", {
      className: 'MenuWrapper ' + this.props.className,
      onClick: this.toggle,
      ref: this.node
    }, children[0], react_default.a.createElement(Animation, {
      show: this.state.open
    }, children[1]));
  }

}

menu_wrapper_defineProperty(menu_wrapper_MenuWrapper, "propTypes", {
  children: prop_types_default.a.node,
  className: prop_types_default.a.string,
  onToggle: prop_types_default.a.func,
  animationComponent: prop_types_default.a.any.isRequired
});

menu_wrapper_defineProperty(menu_wrapper_MenuWrapper, "defaultProps", {
  className: '',
  animationComponent: menu_wrapper_animation_MenuWrapperAnimation
});

/***/ }),

/***/ 1608:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoadingWrapper; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _loading_spinner_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1651);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class LoadingWrapper extends react__WEBPACK_IMPORTED_MODULE_1___default.a.Component {
  render() {
    const {
      text,
      loading,
      children
    } = this.props;

    if (!loading) {
      return children;
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_loading_spinner_jsx__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
      text: text
    });
  }

}

_defineProperty(LoadingWrapper, "propTypes", {
  loading: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool.isRequired,
  text: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node
});

_defineProperty(LoadingWrapper, "defaultProps", {
  loading: true,
  text: null,
  children: null
});

/***/ }),

/***/ 1609:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLogs = getLogs;
exports.getAudits = getAudits;
exports.getConfig = getConfig;
exports.updateConfig = updateConfig;
exports.reloadConfig = reloadConfig;
exports.getEnvironmentConfig = getEnvironmentConfig;
exports.testEmail = testEmail;
exports.testS3Connection = testS3Connection;
exports.invalidateCaches = invalidateCaches;
exports.recycleDatabase = recycleDatabase;
exports.createComplianceReport = createComplianceReport;
exports.getComplianceReport = getComplianceReport;
exports.getComplianceReports = getComplianceReports;
exports.uploadBrandImage = uploadBrandImage;
exports.deleteBrandImage = deleteBrandImage;
exports.getClusterStatus = getClusterStatus;
exports.testLdap = testLdap;
exports.syncLdap = syncLdap;
exports.getLdapGroups = getLdapGroups;
exports.linkLdapGroup = linkLdapGroup;
exports.unlinkLdapGroup = unlinkLdapGroup;
exports.getSamlCertificateStatus = getSamlCertificateStatus;
exports.uploadPublicSamlCertificate = uploadPublicSamlCertificate;
exports.uploadPrivateSamlCertificate = uploadPrivateSamlCertificate;
exports.uploadIdpSamlCertificate = uploadIdpSamlCertificate;
exports.removePublicSamlCertificate = removePublicSamlCertificate;
exports.removePrivateSamlCertificate = removePrivateSamlCertificate;
exports.removeIdpSamlCertificate = removeIdpSamlCertificate;
exports.testElasticsearch = testElasticsearch;
exports.purgeElasticsearchIndexes = purgeElasticsearchIndexes;
exports.uploadLicense = uploadLicense;
exports.removeLicense = removeLicense;
exports.getAnalytics = getAnalytics;
exports.getStandardAnalytics = getStandardAnalytics;
exports.getAdvancedAnalytics = getAdvancedAnalytics;
exports.getPostsPerDayAnalytics = getPostsPerDayAnalytics;
exports.getBotPostsPerDayAnalytics = getBotPostsPerDayAnalytics;
exports.getUsersPerDayAnalytics = getUsersPerDayAnalytics;
exports.uploadPlugin = uploadPlugin;
exports.installPluginFromUrl = installPluginFromUrl;
exports.getPlugins = getPlugins;
exports.getPluginStatuses = getPluginStatuses;
exports.removePlugin = removePlugin;
exports.enablePlugin = enablePlugin;
exports.disablePlugin = disablePlugin;

__webpack_require__(83);

__webpack_require__(84);

var _action_types = __webpack_require__(8);

var _constants = __webpack_require__(17);

var _client = __webpack_require__(27);

var _errors = __webpack_require__(105);

var _helpers = __webpack_require__(117);

var _reduxBatchedActions = __webpack_require__(132);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function getLogs()
/*: ActionFunc*/
{
  var page
  /*: number*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var perPage
  /*: number*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.General.LOGS_PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getLogs,
    onRequest: _action_types.AdminTypes.GET_LOGS_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_LOGS, _action_types.AdminTypes.GET_LOGS_SUCCESS],
    onFailure: _action_types.AdminTypes.GET_LOGS_FAILURE,
    params: [page, perPage]
  });
}

function getAudits()
/*: ActionFunc*/
{
  var page
  /*: number*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var perPage
  /*: number*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.General.PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getAudits,
    onRequest: _action_types.AdminTypes.GET_AUDITS_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_AUDITS, _action_types.AdminTypes.GET_AUDITS_SUCCESS],
    onFailure: _action_types.AdminTypes.GET_AUDITS_FAILURE,
    params: [page, perPage]
  });
}

function getConfig()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getConfig,
    onRequest: _action_types.AdminTypes.GET_CONFIG_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_CONFIG, _action_types.AdminTypes.GET_CONFIG_SUCCESS],
    onFailure: _action_types.AdminTypes.GET_CONFIG_FAILURE
  });
}

function updateConfig(config
/*: Object*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.updateConfig,
    onRequest: _action_types.AdminTypes.UPDATE_CONFIG_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_CONFIG, _action_types.AdminTypes.UPDATE_CONFIG_SUCCESS],
    onFailure: _action_types.AdminTypes.UPDATE_CONFIG_FAILURE,
    params: [config]
  });
}

function reloadConfig()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.reloadConfig,
    onRequest: _action_types.AdminTypes.RELOAD_CONFIG_REQUEST,
    onSuccess: _action_types.AdminTypes.RELOAD_CONFIG_SUCCESS,
    onFailure: _action_types.AdminTypes.RELOAD_CONFIG_FAILURE
  });
}

function getEnvironmentConfig()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getEnvironmentConfig,
    onRequest: _action_types.AdminTypes.GET_ENVIRONMENT_CONFIG_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_ENVIRONMENT_CONFIG, _action_types.AdminTypes.GET_ENVIRONMENT_CONFIG_SUCCESS],
    onFailure: _action_types.AdminTypes.GET_ENVIRONMENT_CONFIG_FAILURE
  });
}

function testEmail(config
/*: Object*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.testEmail,
    onRequest: _action_types.AdminTypes.TEST_EMAIL_REQUEST,
    onSuccess: _action_types.AdminTypes.TEST_EMAIL_SUCCESS,
    onFailure: _action_types.AdminTypes.TEST_EMAIL_FAILURE,
    params: [config]
  });
}

function testS3Connection(config
/*: Object*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.testS3Connection,
    onRequest: _action_types.AdminTypes.TEST_S3_REQUEST,
    onSuccess: _action_types.AdminTypes.TEST_S3_SUCCESS,
    onFailure: _action_types.AdminTypes.TEST_S3_FAILURE,
    params: [config]
  });
}

function invalidateCaches()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.invalidateCaches,
    onRequest: _action_types.AdminTypes.INVALIDATE_CACHES_REQUEST,
    onSuccess: _action_types.AdminTypes.INVALIDATE_CACHES_SUCCESS,
    onFailure: _action_types.AdminTypes.INVALIDATE_CACHES_FAILURE
  });
}

function recycleDatabase()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.recycleDatabase,
    onRequest: _action_types.AdminTypes.RECYCLE_DATABASE_REQUEST,
    onSuccess: _action_types.AdminTypes.RECYCLE_DATABASE_SUCCESS,
    onFailure: _action_types.AdminTypes.RECYCLE_DATABASE_FAILURE
  });
}

function createComplianceReport(job
/*: Job*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.createComplianceReport,
    onRequest: _action_types.AdminTypes.CREATE_COMPLIANCE_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_COMPLIANCE_REPORT, _action_types.AdminTypes.CREATE_COMPLIANCE_SUCCESS],
    onFailure: _action_types.AdminTypes.CREATE_COMPLIANCE_FAILURE,
    params: [job]
  });
}

function getComplianceReport(reportId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getComplianceReport,
    onRequest: _action_types.AdminTypes.GET_COMPLIANCE_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_COMPLIANCE_REPORT, _action_types.AdminTypes.GET_COMPLIANCE_SUCCESS],
    onFailure: _action_types.AdminTypes.GET_COMPLIANCE_FAILURE,
    params: [reportId]
  });
}

function getComplianceReports()
/*: ActionFunc*/
{
  var page
  /*: number*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var perPage
  /*: number*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.General.PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getComplianceReports,
    onRequest: _action_types.AdminTypes.GET_COMPLIANCE_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_COMPLIANCE_REPORTS, _action_types.AdminTypes.GET_COMPLIANCE_SUCCESS],
    onFailure: _action_types.AdminTypes.GET_COMPLIANCE_FAILURE,
    params: [page, perPage]
  });
}

function uploadBrandImage(imageData
/*: File*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.uploadBrandImage,
    onRequest: _action_types.AdminTypes.UPLOAD_BRAND_IMAGE_REQUEST,
    onSuccess: _action_types.AdminTypes.UPLOAD_BRAND_IMAGE_SUCCESS,
    onFailure: _action_types.AdminTypes.UPLOAD_BRAND_IMAGE_FAILURE,
    params: [imageData]
  });
}

function deleteBrandImage()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.deleteBrandImage,
    onRequest: _action_types.AdminTypes.DELETE_BRAND_IMAGE_REQUEST,
    onSuccess: _action_types.AdminTypes.DELETE_BRAND_IMAGE_SUCCESS,
    onFailure: _action_types.AdminTypes.DELETE_BRAND_IMAGE_FAILURE
  });
}

function getClusterStatus()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getClusterStatus,
    onRequest: _action_types.AdminTypes.GET_CLUSTER_STATUS_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_CLUSTER_STATUS, _action_types.AdminTypes.GET_CLUSTER_STATUS_SUCCESS],
    onFailure: _action_types.AdminTypes.GET_CLUSTER_STATUS_FAILURE
  });
}

function testLdap()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.testLdap,
    onRequest: _action_types.AdminTypes.TEST_LDAP_REQUEST,
    onSuccess: _action_types.AdminTypes.TEST_LDAP_SUCCESS,
    onFailure: _action_types.AdminTypes.TEST_LDAP_FAILURE
  });
}

function syncLdap()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.syncLdap,
    onRequest: _action_types.AdminTypes.SYNC_LDAP_REQUEST,
    onSuccess: _action_types.AdminTypes.SYNC_LDAP_SUCCESS,
    onFailure: _action_types.AdminTypes.SYNC_LDAP_FAILURE
  });
}

function getLdapGroups()
/*: ActionFunc*/
{
  var page
  /*: number*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var perPage
  /*: number*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.General.PAGE_SIZE_MAXIMUM;
  var opts
  /*: GroupSearchOpts*/
  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    q: ''
  };
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getLdapGroups,
    onRequest: _action_types.AdminTypes.GET_LDAP_GROUPS_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_LDAP_GROUPS, _action_types.AdminTypes.GET_LDAP_GROUPS_SUCCESS],
    onFailure: _action_types.AdminTypes.GET_LDAP_GROUPS_FAILURE,
    params: [page, perPage, opts]
  });
}

function linkLdapGroup(key
/*: string*/
)
/*: ActionFunc*/
{
  return (
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(dispatch, getState) {
        var data;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                dispatch({
                  type: _action_types.AdminTypes.LINK_LDAP_GROUP_REQUEST,
                  data: key
                });
                _context.prev = 1;
                _context.next = 4;
                return _client.Client4.linkLdapGroup(key);

              case 4:
                data = _context.sent;
                _context.next = 12;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.LINK_LDAP_GROUP_FAILURE,
                  error: _context.t0,
                  data: key
                }, (0, _errors.logError)(_context.t0)]));
                return _context.abrupt("return", {
                  error: _context.t0
                });

              case 12:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.LINK_LDAP_GROUP_SUCCESS,
                  data: null
                }, {
                  type: _action_types.AdminTypes.LINKED_LDAP_GROUP,
                  data: {
                    primary_key: key,
                    name: data.display_name,
                    mattermost_group_id: data.id,
                    has_syncables: false
                  }
                }]));
                return _context.abrupt("return", {
                  data: true
                });

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 7]]);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}

function unlinkLdapGroup(key
/*: string*/
)
/*: ActionFunc*/
{
  return (
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(dispatch, getState) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                dispatch({
                  type: _action_types.AdminTypes.UNLINK_LDAP_GROUP_REQUEST,
                  data: key
                });
                _context2.prev = 1;
                _context2.next = 4;
                return _client.Client4.unlinkLdapGroup(key);

              case 4:
                _context2.next = 11;
                break;

              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context2.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.UNLINK_LDAP_GROUP_FAILURE,
                  error: _context2.t0,
                  data: key
                }, (0, _errors.logError)(_context2.t0)]));
                return _context2.abrupt("return", {
                  error: _context2.t0
                });

              case 11:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.UNLINK_LDAP_GROUP_SUCCESS,
                  data: null
                }, {
                  type: _action_types.AdminTypes.UNLINKED_LDAP_GROUP,
                  data: key
                }]));
                return _context2.abrupt("return", {
                  data: true
                });

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[1, 6]]);
      }));

      return function (_x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }()
  );
}

function getSamlCertificateStatus()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getSamlCertificateStatus,
    onRequest: _action_types.AdminTypes.SAML_CERT_STATUS_REQUEST,
    onSuccess: [_action_types.AdminTypes.RECEIVED_SAML_CERT_STATUS, _action_types.AdminTypes.SAML_CERT_STATUS_SUCCESS],
    onFailure: _action_types.AdminTypes.SAML_CERT_STATUS_FAILURE
  });
}

function uploadPublicSamlCertificate(fileData
/*: File*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.uploadPublicSamlCertificate,
    onRequest: _action_types.AdminTypes.UPLOAD_SAML_PUBLIC_REQUEST,
    onSuccess: _action_types.AdminTypes.UPLOAD_SAML_PUBLIC_SUCCESS,
    onFailure: _action_types.AdminTypes.UPLOAD_SAML_PUBLIC_FAILURE,
    params: [fileData]
  });
}

function uploadPrivateSamlCertificate(fileData
/*: File*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.uploadPrivateSamlCertificate,
    onRequest: _action_types.AdminTypes.UPLOAD_SAML_PRIVATE_REQUEST,
    onSuccess: _action_types.AdminTypes.UPLOAD_SAML_PRIVATE_SUCCESS,
    onFailure: _action_types.AdminTypes.UPLOAD_SAML_PRIVATE_FAILURE,
    params: [fileData]
  });
}

function uploadIdpSamlCertificate(fileData
/*: File*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.uploadIdpSamlCertificate,
    onRequest: _action_types.AdminTypes.UPLOAD_SAML_IDP_REQUEST,
    onSuccess: _action_types.AdminTypes.UPLOAD_SAML_IDP_SUCCESS,
    onFailure: _action_types.AdminTypes.UPLOAD_SAML_IDP_FAILURE,
    params: [fileData]
  });
}

function removePublicSamlCertificate()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.deletePublicSamlCertificate,
    onRequest: _action_types.AdminTypes.DELETE_SAML_PUBLIC_REQUEST,
    onSuccess: _action_types.AdminTypes.DELETE_SAML_PUBLIC_SUCCESS,
    onFailure: _action_types.AdminTypes.DELETE_SAML_PUBLIC_FAILURE
  });
}

function removePrivateSamlCertificate()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.deletePrivateSamlCertificate,
    onRequest: _action_types.AdminTypes.DELETE_SAML_PRIVATE_REQUEST,
    onSuccess: _action_types.AdminTypes.DELETE_SAML_PRIVATE_SUCCESS,
    onFailure: _action_types.AdminTypes.DELETE_SAML_PRIVATE_FAILURE
  });
}

function removeIdpSamlCertificate()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.deleteIdpSamlCertificate,
    onRequest: _action_types.AdminTypes.DELETE_SAML_IDP_REQUEST,
    onSuccess: _action_types.AdminTypes.DELETE_SAML_IDP_SUCCESS,
    onFailure: _action_types.AdminTypes.DELETE_SAML_IDP_FAILURE
  });
}

function testElasticsearch(config
/*: Object*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.testElasticsearch,
    onRequest: _action_types.AdminTypes.TEST_ELASTICSEARCH_REQUEST,
    onSuccess: _action_types.AdminTypes.TEST_ELASTICSEARCH_SUCCESS,
    onFailure: _action_types.AdminTypes.TEST_ELASTICSEARCH_FAILURE,
    params: [config]
  });
}

function purgeElasticsearchIndexes()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.purgeElasticsearchIndexes,
    onRequest: _action_types.AdminTypes.PURGE_ELASTICSEARCH_INDEXES_REQUEST,
    onSuccess: _action_types.AdminTypes.PURGE_ELASTICSEARCH_INDEXES_SUCCESS,
    onFailure: _action_types.AdminTypes.PURGE_ELASTICSEARCH_INDEXES_FAILURE
  });
}

function uploadLicense(fileData
/*: File*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.uploadLicense,
    onRequest: _action_types.AdminTypes.UPLOAD_LICENSE_REQUEST,
    onSuccess: _action_types.AdminTypes.UPLOAD_LICENSE_SUCCESS,
    onFailure: _action_types.AdminTypes.UPLOAD_LICENSE_FAILURE,
    params: [fileData]
  });
}

function removeLicense()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.removeLicense,
    onRequest: _action_types.AdminTypes.REMOVE_LICENSE_REQUEST,
    onSuccess: _action_types.AdminTypes.REMOVE_LICENSE_SUCCESS,
    onFailure: _action_types.AdminTypes.REMOVE_LICENSE_FAILURE
  });
}

function getAnalytics(name
/*: string*/
)
/*: ActionFunc*/
{
  var teamId
  /*: string*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return (
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(dispatch, getState) {
        var data, actions;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                dispatch({
                  type: _action_types.AdminTypes.GET_ANALYTICS_REQUEST,
                  data: null
                }, getState);
                _context3.prev = 1;
                _context3.next = 4;
                return _client.Client4.getAnalytics(name, teamId);

              case 4:
                data = _context3.sent;
                _context3.next = 12;
                break;

              case 7:
                _context3.prev = 7;
                _context3.t0 = _context3["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context3.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.GET_ANALYTICS_FAILURE,
                  error: _context3.t0
                }, (0, _errors.logError)(_context3.t0)]), getState);
                return _context3.abrupt("return", {
                  error: _context3.t0
                });

              case 12:
                actions = [{
                  type: _action_types.AdminTypes.GET_ANALYTICS_SUCCESS,
                  data: null
                }];

                if (teamId === '') {
                  actions.push({
                    type: _action_types.AdminTypes.RECEIVED_SYSTEM_ANALYTICS,
                    data: data,
                    name: name
                  });
                } else {
                  actions.push({
                    type: _action_types.AdminTypes.RECEIVED_TEAM_ANALYTICS,
                    data: data,
                    name: name,
                    teamId: teamId
                  });
                }

                dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
                return _context3.abrupt("return", {
                  data: data
                });

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[1, 7]]);
      }));

      return function (_x5, _x6) {
        return _ref3.apply(this, arguments);
      };
    }()
  );
}

function getStandardAnalytics()
/*: ActionFunc*/
{
  var teamId
  /*: string*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return getAnalytics('standard', teamId);
}

function getAdvancedAnalytics()
/*: ActionFunc*/
{
  var teamId
  /*: string*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return getAnalytics('extra_counts', teamId);
}

function getPostsPerDayAnalytics()
/*: ActionFunc*/
{
  var teamId
  /*: string*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return getAnalytics('post_counts_day', teamId);
}

function getBotPostsPerDayAnalytics()
/*: ActionFunc*/
{
  var teamId
  /*: string*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return getAnalytics('bot_post_counts_day', teamId);
}

function getUsersPerDayAnalytics()
/*: ActionFunc*/
{
  var teamId
  /*: string*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return getAnalytics('user_counts_with_posts_day', teamId);
}

function uploadPlugin(fileData
/*: File*/
)
/*: ActionFunc*/
{
  var force
  /*: boolean*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return (
    /*#__PURE__*/
    function () {
      var _ref4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(dispatch, getState) {
        var data;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                dispatch({
                  type: _action_types.AdminTypes.UPLOAD_PLUGIN_REQUEST,
                  data: null
                });
                _context4.prev = 1;
                _context4.next = 4;
                return _client.Client4.uploadPlugin(fileData, force);

              case 4:
                data = _context4.sent;
                _context4.next = 12;
                break;

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context4.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.UPLOAD_PLUGIN_FAILURE,
                  error: _context4.t0
                }, (0, _errors.logError)(_context4.t0)]));
                return _context4.abrupt("return", {
                  error: _context4.t0
                });

              case 12:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.UPLOAD_PLUGIN_SUCCESS,
                  data: null
                }]));
                return _context4.abrupt("return", {
                  data: data
                });

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[1, 7]]);
      }));

      return function (_x7, _x8) {
        return _ref4.apply(this, arguments);
      };
    }()
  );
}

function installPluginFromUrl(url
/*: string*/
)
/*: ActionFunc*/
{
  var force
  /*: boolean*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return (
    /*#__PURE__*/
    function () {
      var _ref5 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(dispatch, getState) {
        var data;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                dispatch({
                  type: _action_types.AdminTypes.INSTALL_PLUGIN_FROM_URL_REQUEST,
                  data: null
                });
                _context5.prev = 1;
                _context5.next = 4;
                return _client.Client4.installPluginFromUrl(url, force);

              case 4:
                data = _context5.sent;
                _context5.next = 12;
                break;

              case 7:
                _context5.prev = 7;
                _context5.t0 = _context5["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context5.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.INSTALL_PLUGIN_FROM_URL_FAILURE,
                  error: _context5.t0
                }, (0, _errors.logError)(_context5.t0)]));
                return _context5.abrupt("return", {
                  error: _context5.t0
                });

              case 12:
                dispatch({
                  type: _action_types.AdminTypes.INSTALL_PLUGIN_FROM_URL_SUCCESS,
                  data: null
                });
                return _context5.abrupt("return", {
                  data: data
                });

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[1, 7]]);
      }));

      return function (_x9, _x10) {
        return _ref5.apply(this, arguments);
      };
    }()
  );
}

function getPlugins()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getPlugins,
    onRequest: _action_types.AdminTypes.GET_PLUGIN_REQUEST,
    onSuccess: [_action_types.AdminTypes.GET_PLUGIN_SUCCESS, _action_types.AdminTypes.RECEIVED_PLUGINS],
    onFailure: _action_types.AdminTypes.GET_PLUGIN_FAILURE
  });
}

function getPluginStatuses()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getPluginStatuses,
    onRequest: _action_types.AdminTypes.GET_PLUGIN_STATUSES_REQUEST,
    onSuccess: [_action_types.AdminTypes.GET_PLUGIN_STATUSES_SUCCESS, _action_types.AdminTypes.RECEIVED_PLUGIN_STATUSES],
    onFailure: _action_types.AdminTypes.GET_PLUGIN_STATUSES_FAILURE
  });
}

function removePlugin(pluginId
/*: string*/
)
/*: ActionFunc*/
{
  return (
    /*#__PURE__*/
    function () {
      var _ref6 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(dispatch, getState) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                dispatch({
                  type: _action_types.AdminTypes.REMOVE_PLUGIN_REQUEST,
                  data: pluginId
                });
                _context6.prev = 1;
                _context6.next = 4;
                return _client.Client4.removePlugin(pluginId);

              case 4:
                _context6.next = 11;
                break;

              case 6:
                _context6.prev = 6;
                _context6.t0 = _context6["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context6.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.REMOVE_PLUGIN_FAILURE,
                  error: _context6.t0,
                  data: pluginId
                }, (0, _errors.logError)(_context6.t0)]));
                return _context6.abrupt("return", {
                  error: _context6.t0
                });

              case 11:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.REMOVE_PLUGIN_SUCCESS,
                  data: null
                }, {
                  type: _action_types.AdminTypes.REMOVED_PLUGIN,
                  data: pluginId
                }]));
                return _context6.abrupt("return", {
                  data: true
                });

              case 13:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, null, [[1, 6]]);
      }));

      return function (_x11, _x12) {
        return _ref6.apply(this, arguments);
      };
    }()
  );
}

function enablePlugin(pluginId
/*: string*/
)
/*: ActionFunc*/
{
  return (
    /*#__PURE__*/
    function () {
      var _ref7 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(dispatch, getState) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                dispatch({
                  type: _action_types.AdminTypes.ENABLE_PLUGIN_REQUEST,
                  data: pluginId
                });
                _context7.prev = 1;
                _context7.next = 4;
                return _client.Client4.enablePlugin(pluginId);

              case 4:
                _context7.next = 11;
                break;

              case 6:
                _context7.prev = 6;
                _context7.t0 = _context7["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context7.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.ENABLE_PLUGIN_FAILURE,
                  error: _context7.t0,
                  data: pluginId
                }, (0, _errors.logError)(_context7.t0)]));
                return _context7.abrupt("return", {
                  error: _context7.t0
                });

              case 11:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.ENABLE_PLUGIN_SUCCESS,
                  data: null
                }, {
                  type: _action_types.AdminTypes.ENABLED_PLUGIN,
                  data: pluginId
                }]));
                return _context7.abrupt("return", {
                  data: true
                });

              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, null, [[1, 6]]);
      }));

      return function (_x13, _x14) {
        return _ref7.apply(this, arguments);
      };
    }()
  );
}

function disablePlugin(pluginId
/*: string*/
)
/*: ActionFunc*/
{
  return (
    /*#__PURE__*/
    function () {
      var _ref8 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(dispatch, getState) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                dispatch({
                  type: _action_types.AdminTypes.DISABLE_PLUGIN_REQUEST,
                  data: pluginId
                });
                _context8.prev = 1;
                _context8.next = 4;
                return _client.Client4.disablePlugin(pluginId);

              case 4:
                _context8.next = 11;
                break;

              case 6:
                _context8.prev = 6;
                _context8.t0 = _context8["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context8.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.DISABLE_PLUGIN_FAILURE,
                  error: _context8.t0,
                  data: pluginId
                }, (0, _errors.logError)(_context8.t0)]));
                return _context8.abrupt("return", {
                  error: _context8.t0
                });

              case 11:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.AdminTypes.DISABLE_PLUGIN_SUCCESS,
                  data: null
                }, {
                  type: _action_types.AdminTypes.DISABLED_PLUGIN,
                  data: pluginId
                }]));
                return _context8.abrupt("return", {
                  data: true
                });

              case 13:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, null, [[1, 6]]);
      }));

      return function (_x15, _x16) {
        return _ref8.apply(this, arguments);
      };
    }()
  );
}

/***/ }),

/***/ 1611:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFormattedFileSize = getFormattedFileSize;
exports.getFileType = getFileType;
exports.lookupMimeType = lookupMimeType;
exports.getFileUrl = getFileUrl;
exports.getFileDownloadUrl = getFileDownloadUrl;
exports.getFileThumbnailUrl = getFileThumbnailUrl;
exports.getFilePreviewUrl = getFilePreviewUrl;
exports.sortFileInfos = sortFileInfos;

__webpack_require__(62);

__webpack_require__(75);

__webpack_require__(13);

__webpack_require__(18);

__webpack_require__(12);

__webpack_require__(184);

var _constants = __webpack_require__(17);

var _client = __webpack_require__(27);

var _mimeDb = _interopRequireDefault(__webpack_require__(2408));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
} // Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow


function getFormattedFileSize(file
/*: FileInfo*/
)
/*: string*/
{
  var bytes = file.size;
  var fileSizes = [['TB', 1024 * 1024 * 1024 * 1024], ['GB', 1024 * 1024 * 1024], ['MB', 1024 * 1024], ['KB', 1024]];
  var size = fileSizes.find(function (unitAndMinBytes) {
    var minBytes = unitAndMinBytes[1];
    return bytes > minBytes;
  });

  if (size) {
    return "".concat(Math.floor(bytes / size[1]), " ").concat(size[0]);
  }

  return "".concat(bytes, " B");
}

function getFileType(file
/*: FileInfo*/
)
/*: string*/
{
  if (!file || !file.extension) {
    return 'other';
  }

  var fileExt = file.extension.toLowerCase();
  var fileTypes = ['image', 'code', 'pdf', 'video', 'audio', 'spreadsheet', 'word', 'presentation', 'patch'];
  return fileTypes.find(function (fileType) {
    var constForFileTypeExtList = "".concat(fileType, "_types").toUpperCase();
    var fileTypeExts = _constants.Files[constForFileTypeExtList];
    return fileTypeExts.indexOf(fileExt) > -1;
  }) || 'other';
}

var extToMime;

function buildExtToMime() {
  extToMime = {};
  Object.keys(_mimeDb.default).forEach(function (key) {
    var mime = _mimeDb.default[key];

    if (mime.extensions) {
      mime.extensions.forEach(function (ext) {
        extToMime[ext] = key;
      });
    }
  });
}

function lookupMimeType(filename
/*: string*/
)
/*: string*/
{
  if (!extToMime) {
    buildExtToMime();
  }

  var ext = filename.split('.').pop().toLowerCase();
  return extToMime[ext] || 'application/octet-stream';
}

function getFileUrl(fileId
/*: string*/
)
/*: string*/
{
  return _client.Client4.getFileRoute(fileId);
}

function getFileDownloadUrl(fileId
/*: string*/
)
/*: string*/
{
  return "".concat(_client.Client4.getFileRoute(fileId), "?download=1");
}

function getFileThumbnailUrl(fileId
/*: string*/
)
/*: string*/
{
  return "".concat(_client.Client4.getFileRoute(fileId), "/thumbnail");
}

function getFilePreviewUrl(fileId
/*: string*/
)
/*: string*/
{
  return "".concat(_client.Client4.getFileRoute(fileId), "/preview");
}

function sortFileInfos()
/*: Array<FileInfo>*/
{
  var fileInfos
  /*: Array<FileInfo>*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var locale
  /*: string*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.General.DEFAULT_LOCALE;
  return fileInfos.sort(function (a, b) {
    if (a.create_at !== b.create_at) {
      return a.create_at - b.create_at;
    }

    return a.name.localeCompare(b.name, locale, {
      numeric: true
    });
  });
}

/***/ }),

/***/ 1612:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SaveButton; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var components_widgets_loading_loading_wrapper_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1608);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class SaveButton extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  render() {
    const {
      formatMessage
    } = this.context.intl;
    const {
      saving,
      disabled,
      savingMessage,
      defaultMessage,
      btnClass,
      extraClasses,
      ...props
    } = this.props;
    let className = 'save-button btn';

    if (!disabled || saving) {
      className += ' ' + btnClass;
    }

    if (extraClasses) {
      className += ' ' + extraClasses;
    }

    const savingMessageComponent = savingMessage || formatMessage({
      id: 'save_button.saving',
      defaultMessage: 'Saving'
    });
    const defaultMessageComponent = defaultMessage || formatMessage({
      id: 'save_button.save',
      defaultMessage: 'Save'
    });
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", _extends({
      type: "submit",
      id: "saveSetting",
      className: className,
      disabled: disabled
    }, props), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_widgets_loading_loading_wrapper_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], {
      loading: saving,
      text: savingMessageComponent
    }, defaultMessageComponent));
  }

}

_defineProperty(SaveButton, "propTypes", {
  saving: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool.isRequired,
  disabled: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  savingMessage: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
  defaultMessage: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
  btnClass: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  extraClasses: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
});

_defineProperty(SaveButton, "defaultProps", {
  disabled: false,
  btnClass: 'btn-primary',
  extraClasses: ''
});

_defineProperty(SaveButton, "contextTypes", {
  intl: react_intl__WEBPACK_IMPORTED_MODULE_2__[/* intlShape */ "i"]
});

/***/ }),

/***/ 1618:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return editPost; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return selectAttachmentMenuAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return setMessageMergeForward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return setChannelPostSelect; });
/* harmony import */ var mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mattermost_redux_actions_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(105);
/* harmony import */ var mattermost_redux_actions_errors__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_errors__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



function editPost(post) {
  return async (dispatch, getState) => {
    const result = await mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_0__["editPost"](post)(dispatch, getState); // Send to error bar if it's an edit post error about time limit.

    if (result.error && result.error.server_error_id === 'api.post.update_post.permissions_time_limit.app_error') {
      dispatch(Object(mattermost_redux_actions_errors__WEBPACK_IMPORTED_MODULE_1__["logError"])({
        type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_2__[/* AnnouncementBarTypes */ "e"].ANNOUNCEMENT,
        message: result.error.message
      }, true));
    }

    return result;
  };
}
function selectAttachmentMenuAction(postId, actionId, cookie, dataSource, text, value) {
  return async dispatch => {
    dispatch({
      type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_2__[/* ActionTypes */ "b"].SELECT_ATTACHMENT_MENU_ACTION,
      postId,
      data: {
        [actionId]: {
          text,
          value
        }
      }
    });
    dispatch(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_0__["doPostActionWithCookie"](postId, actionId, cookie, value));
  };
}
function setMessageMergeForward(post) {
  return async (dispatch, state) => {
    let data = {
      [post.id]: post
    };

    if (post.__TYPE__) {
      data = post;
    }

    dispatch({
      type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_2__[/* ActionTypes */ "b"].MESSAGE_MERGE_FORWARD,
      data
    });
  };
}
function setChannelPostSelect(data) {
  return dispatch => {
    dispatch({
      type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_2__[/* ActionTypes */ "b"].CHANNEL_POST_SELECT,
      data
    });
  };
}

/***/ }),

/***/ 1619:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Menu; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class Menu extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  constructor(props) {
    super(props);
    this.node = react__WEBPACK_IMPORTED_MODULE_1___default.a.createRef();
  } // Used from DotMenu component to know in which direction show the menu


  rect() {
    if (this.node && this.node.current) {
      return this.node.current.getBoundingClientRect();
    }

    return null;
  }

  render() {
    const {
      children,
      openUp,
      openLeft,
      id,
      ariaLabel,
      customStyles
    } = this.props;
    let styles = {};

    if (customStyles) {
      styles = customStyles;
    } else {
      if (openLeft && !Object(utils_utils__WEBPACK_IMPORTED_MODULE_2__[/* isMobile */ "Y"])()) {
        styles.left = 'inherit';
        styles.right = 0;
      }

      if (openUp && !Object(utils_utils__WEBPACK_IMPORTED_MODULE_2__[/* isMobile */ "Y"])()) {
        styles.bottom = '100%';
        styles.top = 'auto';
      }
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("ul", {
      id: id,
      ref: this.node,
      className: "Menu dropdown-menu",
      style: styles,
      role: "menu",
      "aria-label": ariaLabel
    }, children);
  }

}

_defineProperty(Menu, "propTypes", {
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
  openLeft: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  openUp: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  id: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  ariaLabel: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,
  customStyles: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object
});

/***/ }),

/***/ 1621:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WarningIcon; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class WarningIcon extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  render() {
    const className = 'fa fa-warning' + (this.props.additionalClassName ? ' ' + this.props.additionalClassName : '');
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
      id: "generic_icons.warning",
      defaultMessage: "Warning Icon"
    }, title => react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("i", {
      className: className,
      title: title
    }));
  }

}

_defineProperty(WarningIcon, "propTypes", {
  additionalClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
});

_defineProperty(WarningIcon, "defaultProps", {
  additionalClassName: null
});

/***/ }),

/***/ 1624:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/reselect/es/index.js
var reselect_es = __webpack_require__(150);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var constants = __webpack_require__(17);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var channels = __webpack_require__(15);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./utils/url.jsx + 1 modules
var url = __webpack_require__(298);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./utils/message_html_to_component.jsx + 3 modules
var message_html_to_component = __webpack_require__(1684);

// EXTERNAL MODULE: ./utils/text_formatting.jsx
var text_formatting = __webpack_require__(81);

// CONCATENATED MODULE: ./components/markdown/markdown.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class markdown_Markdown extends react_default.a.PureComponent {
  render() {
    if (!this.props.enableFormatting) {
      return react_default.a.createElement("span", null, this.props.message);
    }

    const options = Object.assign({
      autolinkedUrlSchemes: this.props.autolinkedUrlSchemes,
      siteURL: this.props.siteURL,
      mentionKeys: this.props.mentionKeys,
      atMentions: true,
      channelNamesMap: this.props.channelNamesMap,
      proxyImages: this.props.hasImageProxy && this.props.proxyImages,
      team: this.props.team,
      minimumHashtagLength: this.props.minimumHashtagLength
    }, this.props.options);
    const htmlFormattedText = text_formatting["e" /* formatText */](this.props.message, options);
    return Object(message_html_to_component["a" /* default */])(htmlFormattedText, this.props.isRHS, {
      imageProps: this.props.imageProps,
      imagesMetadata: this.props.imagesMetadata,
      hasPluginTooltips: this.props.hasPluginTooltips
    });
  }

}

_defineProperty(markdown_Markdown, "propTypes", {
  /*
   * An object mapping channel names to channels for the current team
   */
  channelNamesMap: prop_types_default.a.object.isRequired,

  /*
   * An array of URL schemes that should be turned into links. Anything that looks
   * like a link will be turned into a link if this is not provided.
   */
  autolinkedUrlSchemes: prop_types_default.a.array,

  /*
   * Whether or not to do Markdown rendering
   */
  enableFormatting: prop_types_default.a.bool.isRequired,

  /*
   * Whether or not this text is part of the RHS
   */
  isRHS: prop_types_default.a.bool,

  /*
   * An array of words that can be used to mention a user
   */
  mentionKeys: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,

  /*
   * The text to be rendered
   */
  message: prop_types_default.a.string.isRequired,

  /*
   * Any additional text formatting options to be used
   */
  options: prop_types_default.a.object,

  /*
   * The root Site URL for the page
   */
  siteURL: prop_types_default.a.string.isRequired,

  /*
   * The current team
   */
  team: prop_types_default.a.object.isRequired,

  /**
   * If an image proxy is enabled.
   */
  hasImageProxy: prop_types_default.a.bool.isRequired,

  /**
   * Minimum number of characters in a hashtag.
   */
  minimumHashtagLength: prop_types_default.a.number,

  /**
   * Whether or not to proxy image URLs
   */
  proxyImages: prop_types_default.a.bool,

  /**
   * Any extra props that should be passed into the image component
   */
  imageProps: prop_types_default.a.object,

  /**
   * prop for passed down to image component for dimensions
   */
  imagesMetadata: prop_types_default.a.object,

  /**
   * Whether or not to place the LinkTooltip component inside links
   */
  hasPluginTooltips: prop_types_default.a.bool
});

_defineProperty(markdown_Markdown, "defaultProps", {
  options: {},
  isRHS: false,
  proxyImages: true,
  imagesMetadata: {}
});
// CONCATENATED MODULE: ./components/markdown/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











function makeGetChannelNamesMap() {
  return Object(reselect_es["a" /* createSelector */])(channels["getChannelsNameMapInCurrentTeam"], (state, props) => props && props.channelNamesMap, (channelNamesMap, channelMentions) => {
    if (channelMentions) {
      return Object.assign({}, channelMentions, channelNamesMap);
    }

    return channelNamesMap;
  });
}

function makeMapStateToProps() {
  const getChannelNamesMap = makeGetChannelNamesMap();
  return function mapStateToProps(state, ownProps) {
    const config = Object(general["getConfig"])(state);
    return {
      autolinkedUrlSchemes: Object(general["getAutolinkedUrlSchemes"])(state),
      channelNamesMap: getChannelNamesMap(state, ownProps),
      enableFormatting: Object(preferences["getBool"])(state, constants["Preferences"].CATEGORY_ADVANCED_SETTINGS, 'formatting', true),
      mentionKeys: Object(users["getCurrentUserMentionKeys"])(state),
      siteURL: Object(url["e" /* getSiteURL */])(),
      team: Object(teams["getCurrentTeam"])(state),
      hasImageProxy: config.HasImageProxy === 'true',
      minimumHashtagLength: parseInt(config.MinimumHashtagLength, 10)
    };
  };
}

/* harmony default export */ var markdown = __webpack_exports__["a"] = (Object(es["connect"])(makeMapStateToProps)(markdown_Markdown));

/***/ }),

/***/ 1626:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return setModalSearchTerm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return setSystemUsersSearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return setSidebarSearchTerm; });
/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

function setModalSearchTerm(term) {
  return async dispatch => {
    dispatch({
      type: utils_constants__WEBPACK_IMPORTED_MODULE_0__[/* SearchTypes */ "y"].SET_MODAL_SEARCH,
      data: term
    });
    return {
      data: true
    };
  };
}
function setSystemUsersSearch(term, team, filter = '') {
  return async dispatch => {
    dispatch({
      type: utils_constants__WEBPACK_IMPORTED_MODULE_0__[/* SearchTypes */ "y"].SET_SYSTEM_USERS_SEARCH,
      data: {
        term,
        team,
        filter
      }
    });
    return {
      data: true
    };
  };
}
function setSidebarSearchTerm(term) {
  return async dispatch => {
    dispatch({
      type: utils_constants__WEBPACK_IMPORTED_MODULE_0__[/* SearchTypes */ "y"].SET_SIDEBAR_SEARCH,
      data: term
    });
    return {
      data: true
    };
  };
}

/***/ }),

/***/ 1639:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return removeUserFromTeamAndGetStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return addUserToTeamFromInvite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addUserToTeam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return addUsersToTeam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return switchTeam; });
/* harmony import */ var mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);
/* harmony import */ var mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(299);
/* harmony import */ var mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);
/* harmony import */ var mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var utils_browser_history__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(114);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function removeUserFromTeamAndGetStats(teamId, userId) {
  return async (dispatch, getState) => {
    const response = await dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_2__["removeUserFromTeam"](teamId, userId));
    dispatch(Object(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_4__["getUser"])(userId));
    dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_2__["getTeamStats"](teamId));
    dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["getChannelStats"])(Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_3__["getCurrentChannelId"])(getState())));
    return response;
  };
}
function addUserToTeamFromInvite(token, inviteId) {
  return async dispatch => {
    const {
      data: member,
      error
    } = await dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_2__["addUserToTeamFromInvite"](token, inviteId));

    if (member) {
      const {
        data
      } = await dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_2__["getTeam"](member.team_id));
      dispatch({
        type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_0__["TeamTypes"].RECEIVED_MY_TEAM_MEMBER,
        data: { ...member,
          delete_at: 0,
          msg_count: 0,
          mention_count: 0
        }
      });
      return {
        data
      };
    }

    return {
      error
    };
  };
}
function addUserToTeam(teamId, userId) {
  return async dispatch => {
    const {
      data: member,
      error
    } = await dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_2__["addUserToTeam"](teamId, userId));

    if (member) {
      const {
        data
      } = await dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_2__["getTeam"](member.team_id));
      dispatch({
        type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_0__["TeamTypes"].RECEIVED_MY_TEAM_MEMBER,
        data: { ...member,
          delete_at: 0,
          msg_count: 0,
          mention_count: 0
        }
      });
      return {
        data
      };
    }

    return {
      error
    };
  };
}
function addUsersToTeam(teamId, userIds) {
  return async (dispatch, getState) => {
    const {
      data,
      error
    } = await dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_2__["addUsersToTeam"](teamId, userIds));

    if (error) {
      return {
        error
      };
    }

    dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["getChannelStats"])(Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_3__["getCurrentChannelId"])(getState())));
    return {
      data
    };
  };
}
function switchTeam(url) {
  return (dispatch, getState) => {
    dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_1__["viewChannel"])(Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_3__["getCurrentChannelId"])(getState())));
    utils_browser_history__WEBPACK_IMPORTED_MODULE_5__[/* browserHistory */ "a"].push(url);
  };
}

/***/ }),

/***/ 1647:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// CONCATENATED MODULE: ./plugins/pluggable/pluggable.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class pluggable_Pluggable extends react_default.a.PureComponent {
  render() {
    const pluggableName = this.props.pluggableName;
    let child;

    if (this.props.children) {
      child = react_default.a.Children.only(this.props.children).type;
    } else if (!pluggableName) {
      return null;
    }

    const components = this.props.components;
    const childrenProps = child ? this.props.children.props : {};
    const componentName = pluggableName || child.getComponentName(); // Include any props passed to this component or to the child component

    let props = { ...this.props
    };
    Reflect.deleteProperty(props, 'children');
    Reflect.deleteProperty(props, 'components');
    Reflect.deleteProperty(props, 'pluggableName');
    props = { ...props,
      ...childrenProps
    }; // Override the default component with any registered plugin's component
    // Select a specific component by pluginId if available

    if (components.hasOwnProperty(componentName)) {
      let pluginComponents = components[componentName];

      if (this.props.pluggableId) {
        pluginComponents = pluginComponents.filter(element => element.id === this.props.pluggableId);
      }

      const content = pluginComponents.map(p => {
        const PluginComponent = p.component;
        return react_default.a.createElement(PluginComponent, _extends({}, props, {
          theme: this.props.theme,
          key: componentName + p.id
        }));
      });
      return react_default.a.createElement(react_default.a.Fragment, null, content);
    }

    if (child == null) {
      return null;
    }

    return react_default.a.cloneElement(this.props.children, { ...props
    });
  }

}

_defineProperty(pluggable_Pluggable, "propTypes", {
  /*
   * Should be a single overridable React component. One of this or pluggableName is required
   */
  children: prop_types_default.a.element,

  /*
   * Override the component to be plugged. One of this or children is required
   */
  pluggableName: prop_types_default.a.string,

  /*
   * Components for overriding provided by plugins
   */
  components: prop_types_default.a.object.isRequired,

  /*
   * Logged in user's theme
   */
  theme: prop_types_default.a.object.isRequired,

  /*
   * Id of the specific component to be plugged.
   */
  pluggableId: prop_types_default.a.string
});
// CONCATENATED MODULE: ./plugins/pluggable/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function mapStateToProps(state) {
  return {
    components: state.plugins.components,
    theme: Object(preferences["getTheme"])(state)
  };
}

/* harmony default export */ var pluggable = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(pluggable_Pluggable));

/***/ }),

/***/ 1651:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoadingSpinner; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class LoadingSpinner extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  render() {
    const {
      formatMessage
    } = this.context.intl;
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", {
      id: "loadingSpinner",
      className: 'LoadingSpinner' + (this.props.text ? ' with-text' : '')
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", {
      className: "fa fa-spinner fa-fw fa-pulse spinner",
      title: formatMessage({
        id: 'generic_icons.loading',
        defaultMessage: 'Loading Icon'
      })
    }), this.props.text);
  }

}

_defineProperty(LoadingSpinner, "propTypes", {
  text: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node
});

_defineProperty(LoadingSpinner, "defaultProps", {
  text: null
});

_defineProperty(LoadingSpinner, "contextTypes", {
  intl: react_intl__WEBPACK_IMPORTED_MODULE_2__[/* intlShape */ "i"].isRequired
});

/***/ }),

/***/ 1652:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SuggestionBox; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mattermost_redux_utils_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(414);
/* harmony import */ var mattermost_redux_utils_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_utils_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var components_quick_input_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1766);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var utils_user_agent_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(39);
/* harmony import */ var utils_utils_jsx__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(22);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const KeyCodes = utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* default */ "N"].KeyCodes;
class SuggestionBox extends react__WEBPACK_IMPORTED_MODULE_1___default.a.Component {
  constructor(props) {
    super(props); // Keep track of whether we're composing a CJK character so we can make suggestions for partial characters

    _defineProperty(this, "handleMentionKeyClick", (mentionKey, isRHS) => {
      if (this.props.isRHS !== isRHS) {
        return;
      }

      let insertText = '@' + mentionKey; // if the current text does not end with a whitespace, then insert a space

      if (this.props.value && /[^\s]$/.test(this.props.value)) {
        insertText = ' ' + insertText;
      }

      this.addTextAtCaret(insertText, '');
    });

    _defineProperty(this, "getTextbox", () => {
      if (!this.refs.input) {
        return null;
      }

      const input = this.refs.input.getInput();

      if (input.getDOMNode) {
        return input.getDOMNode();
      }

      return input;
    });

    _defineProperty(this, "recalculateSize", () => {
      // Pretty hacky way to force an AutosizeTextarea to recalculate its height if that's what
      // we're rendering as the input
      const input = this.refs.input.getInput();

      if (input.recalculateSize) {
        input.recalculateSize();
      }
    });

    _defineProperty(this, "handleEmitClearSuggestions", (delay = 0) => {
      setTimeout(() => {
        this.clear();
      }, delay);
    });

    _defineProperty(this, "preventSuggestionListClose", () => {
      this.preventSuggestionListCloseFlag = true;
    });

    _defineProperty(this, "handleFocusOut", e => {
      if (this.preventSuggestionListCloseFlag) {
        this.preventSuggestionListCloseFlag = false;
        return;
      } // Focus is switching TO e.relatedTarget, so only treat this as a blur event if we're not switching
      // between children (like from the textbox to the suggestion list)


      if (this.container.contains(e.relatedTarget)) {
        return;
      }

      if (utils_user_agent_jsx__WEBPACK_IMPORTED_MODULE_5__[/* isIos */ "g"]() && !e.relatedTarget) {
        // On Safari and iOS classic app, the autocomplete stays open
        // when you tap outside of the post textbox or search box.
        return;
      }

      this.handleEmitClearSuggestions();
      this.setState({
        focused: false
      });

      if (this.props.onBlur) {
        this.props.onBlur();
      }
    });

    _defineProperty(this, "handleFocusIn", e => {
      // Focus is switching FROM e.relatedTarget, so only treat this as a focus event if we're not switching
      // between children (like from the textbox to the suggestion list). PreventSuggestionListCloseFlag is
      // checked because if true, it means that the focusIn comes from a click in the suggestion box, an
      // option choice, so we don't want the focus event to be triggered
      if (this.container.contains(e.relatedTarget) || this.preventSuggestionListCloseFlag) {
        return;
      }

      this.setState({
        focused: true
      });

      if (this.props.openOnFocus || this.props.openWhenEmpty) {
        setTimeout(() => {
          const textbox = this.getTextbox();

          if (textbox) {
            const pretext = textbox.value.substring(0, textbox.selectionEnd);

            if (this.props.openWhenEmpty || pretext.length >= this.props.requiredCharacters) {
              this.handlePretextChanged(pretext);
            }
          }
        });
      }

      if (this.props.onFocus) {
        this.props.onFocus();
      }
    });

    _defineProperty(this, "handleChange", e => {
      const textbox = this.getTextbox();
      const pretext = textbox.value.substring(0, textbox.selectionEnd).toLowerCase();

      if (!this.composing && this.pretext !== pretext) {
        this.handlePretextChanged(pretext);
      }

      if (this.props.onChange) {
        this.props.onChange(e);
      }
    });

    _defineProperty(this, "handleCompositionStart", () => {
      this.composing = true;

      if (this.props.onComposition) {
        this.props.onComposition();
      }
    });

    _defineProperty(this, "handleCompositionUpdate", e => {
      if (!e.data) {
        return;
      } // The caret appears before the CJK character currently being composed, so re-add it to the pretext


      const textbox = this.getTextbox();
      const pretext = textbox.value.substring(0, textbox.selectionStart) + e.data;
      this.handlePretextChanged(pretext);

      if (this.props.onComposition) {
        this.props.onComposition();
      }
    });

    _defineProperty(this, "handleCompositionEnd", () => {
      this.composing = false;

      if (this.props.onComposition) {
        this.props.onComposition();
      }
    });

    _defineProperty(this, "addTextAtCaret", (term, matchedPretext) => {
      const textbox = this.getTextbox();
      const caret = textbox.selectionEnd;
      const text = this.props.value;
      const pretext = textbox.value.substring(0, textbox.selectionEnd);
      let prefix;
      let keepPretext = false;

      if (pretext.toLowerCase().endsWith(matchedPretext.toLowerCase())) {
        prefix = pretext.substring(0, pretext.length - matchedPretext.length);
      } else {
        // the pretext has changed since we got a term to complete so see if the term still fits the pretext
        const termWithoutMatched = term.substring(matchedPretext.length);
        const overlap = SuggestionBox.findOverlap(pretext, termWithoutMatched);
        keepPretext = overlap.length === 0;
        prefix = pretext.substring(0, pretext.length - overlap.length - matchedPretext.length);
      }

      const suffix = text.substring(caret);
      let newValue;

      if (keepPretext) {
        newValue = pretext;
      } else {
        newValue = prefix + term + ' ' + suffix;
      }

      textbox.value = newValue;

      if (this.props.onChange) {
        // fake an input event to send back to parent components
        const e = {
          target: textbox
        }; // don't call handleChange or we'll get into an event loop

        this.props.onChange(e);
      } // set the caret position after the next rendering


      window.requestAnimationFrame(() => {
        if (textbox.value === newValue) {
          utils_utils_jsx__WEBPACK_IMPORTED_MODULE_6__[/* setCaretPosition */ "ob"](textbox, prefix.length + term.length + 1);
        }
      });
    });

    _defineProperty(this, "replaceText", term => {
      const textbox = this.getTextbox();
      textbox.value = term;

      if (this.props.onChange) {
        // fake an input event to send back to parent components
        const e = {
          target: textbox
        }; // don't call handleChange or we'll get into an event loop

        this.props.onChange(e);
      }
    });

    _defineProperty(this, "handleCompleteWord", (term, matchedPretext) => {
      if (this.props.replaceAllInputOnSelect) {
        this.replaceText(term);
      } else {
        this.addTextAtCaret(term, matchedPretext);
      }

      if (this.props.onItemSelected) {
        const items = this.state.items;
        const terms = this.state.terms;

        for (let i = 0; i < terms.length; i++) {
          if (terms[i] === term) {
            this.props.onItemSelected(items[i]);
            break;
          }
        }
      }

      this.clear();
      this.refs.input.focus();

      for (const provider of this.props.providers) {
        if (provider.handleCompleteWord) {
          provider.handleCompleteWord(term, matchedPretext);
        }
      }
    });

    _defineProperty(this, "selectNext", () => {
      this.setSelectionByDelta(1);
    });

    _defineProperty(this, "selectPrevious", () => {
      this.setSelectionByDelta(-1);
    });

    _defineProperty(this, "setSelectionByDelta", delta => {
      let selectionIndex = this.state.terms.indexOf(this.state.selection);

      if (selectionIndex === -1) {
        this.setState({
          selection: ''
        });
        return;
      }

      selectionIndex += delta;

      if (selectionIndex < 0) {
        selectionIndex = 0;
      } else if (selectionIndex > this.state.terms.length - 1) {
        selectionIndex = this.state.terms.length - 1;
      }

      this.setState({
        selection: this.state.terms[selectionIndex]
      });
    });

    _defineProperty(this, "clear", () => {
      this.setState({
        cleared: true,
        matchedPretext: [],
        terms: [],
        items: [],
        components: []
      });
    });

    _defineProperty(this, "hasSuggestions", () => {
      return this.state.items.some(item => !item.loading);
    });

    _defineProperty(this, "handleKeyDown", e => {
      if ((this.props.openWhenEmpty || this.props.value) && this.hasSuggestions()) {
        if (utils_utils_jsx__WEBPACK_IMPORTED_MODULE_6__[/* isKeyPressed */ "V"](e, KeyCodes.UP)) {
          this.selectPrevious();
          e.preventDefault();
        } else if (utils_utils_jsx__WEBPACK_IMPORTED_MODULE_6__[/* isKeyPressed */ "V"](e, KeyCodes.DOWN)) {
          this.selectNext();
          e.preventDefault();
        } else if (utils_utils_jsx__WEBPACK_IMPORTED_MODULE_6__[/* isKeyPressed */ "V"](e, KeyCodes.ENTER) || this.props.completeOnTab && utils_utils_jsx__WEBPACK_IMPORTED_MODULE_6__[/* isKeyPressed */ "V"](e, KeyCodes.TAB)) {
          let matchedPretext = '';

          for (let i = 0; i < this.state.terms.length; i++) {
            if (this.state.terms[i] === this.state.selection) {
              matchedPretext = this.state.matchedPretext[i];
            }
          } // If these don't match, the user typed quickly and pressed enter before we could
          // update the pretext, so update the pretext before completing


          if (this.pretext.endsWith(matchedPretext)) {
            this.handleCompleteWord(this.state.selection, matchedPretext);
          } else {
            clearTimeout(this.timeoutId);
            this.nonDebouncedPretextChanged(this.pretext, true);
          }

          if (this.props.onKeyDown) {
            this.props.onKeyDown(e);
          }

          e.preventDefault();
        } else if (utils_utils_jsx__WEBPACK_IMPORTED_MODULE_6__[/* isKeyPressed */ "V"](e, KeyCodes.ESCAPE)) {
          this.clear();
          this.setState({
            presentationType: 'text'
          });
          e.preventDefault();
          e.stopPropagation();
        } else if (this.props.onKeyDown) {
          this.props.onKeyDown(e);
        }
      } else if (this.props.onKeyDown) {
        this.props.onKeyDown(e);
      }
    });

    _defineProperty(this, "handleReceivedSuggestions", suggestions => {
      const newComponents = [];
      const newPretext = [];

      for (let i = 0; i < suggestions.terms.length; i++) {
        newComponents.push(suggestions.component);
        newPretext.push(suggestions.matchedPretext);
      }

      const terms = suggestions.terms;
      const items = suggestions.items;
      let selection = ''; //this.state.selection ; 修改为每次都查询

      this.setState({
        selection
      }, () => {
        if (terms.length > 0) {
          // if the current selection is no longer in the map, select the first term in the list
          if (!this.state.selection || terms.indexOf(this.state.selection) === -1) {
            selection = terms[0];
          }
        } else if (this.state.selection) {
          selection = '';
        }

        this.setState({
          cleared: false,
          selection,
          terms,
          items,
          components: newComponents,
          matchedPretext: newPretext
        });
        return {
          selection,
          matchedPretext: suggestions.matchedPretext
        };
      });
    });

    _defineProperty(this, "handleReceivedSuggestionsAndComplete", suggestions => {
      const {
        selection,
        matchedPretext
      } = this.handleReceivedSuggestions(suggestions);

      if (selection) {
        this.handleCompleteWord(selection, matchedPretext);
      }
    });

    _defineProperty(this, "nonDebouncedPretextChanged", (pretext, complete = false) => {
      this.pretext = pretext;
      let handled = false;
      let callback = this.handleReceivedSuggestions;

      if (complete) {
        callback = this.handleReceivedSuggestionsAndComplete;
      }

      for (const provider of this.props.providers) {
        handled = provider.handlePretextChanged(pretext, callback) || handled;

        if (handled) {
          this.setState({
            presentationType: provider.presentationType(),
            allowDividers: provider.allowDividers()
          });
          break;
        }
      }

      if (!handled) {
        this.clear();
      }
    });

    _defineProperty(this, "debouncedPretextChanged", pretext => {
      clearTimeout(this.timeoutId);
      this.timeoutId = setTimeout(() => this.nonDebouncedPretextChanged(pretext), utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* default */ "N"].SEARCH_TIMEOUT_MILLISECONDS);
    });

    _defineProperty(this, "handlePretextChanged", pretext => {
      this.pretext = pretext;
      this.debouncedPretextChanged(pretext);
    });

    _defineProperty(this, "blur", () => {
      this.refs.input.blur();
    });

    _defineProperty(this, "setContainerRef", container => {
      // Attach/detach event listeners that aren't supported by React
      if (this.container) {
        this.container.removeEventListener('focusin', this.handleFocusIn);
        this.container.removeEventListener('focusout', this.handleFocusOut);
      }

      if (container) {
        container.addEventListener('focusin', this.handleFocusIn);
        container.addEventListener('focusout', this.handleFocusOut);
      } // Save ref


      this.container = container;
    });

    this.composing = false;
    this.pretext = ''; // Used for debouncing pretext changes

    this.timeoutId = ''; // Used for preventing suggestion list to close when scrollbar is clicked

    this.preventSuggestionListCloseFlag = false; // pretext: the text before the cursor
    // matchedPretext: a list of the text before the cursor that will be replaced if the corresponding autocomplete term is selected
    // terms: a list of strings which the previously typed text may be replaced by
    // items: a list of objects backing the terms which may be used in rendering
    // components: a list of react components that can be used to render their corresponding item
    // selection: the term currently selected by the keyboard

    this.state = {
      focused: false,
      cleared: true,
      matchedPretext: [],
      items: [],
      terms: [],
      components: [],
      selection: '',
      allowDividers: true,
      presentationType: 'text'
    };
  }

  componentDidMount() {
    if (this.props.listenForMentionKeyClick) {
      mattermost_redux_utils_event_emitter__WEBPACK_IMPORTED_MODULE_2___default.a.addListener('mention_key_click', this.handleMentionKeyClick);
    }
  }

  componentWillUnmount() {
    mattermost_redux_utils_event_emitter__WEBPACK_IMPORTED_MODULE_2___default.a.removeListener('mention_key_click', this.handleMentionKeyClick);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.contextId !== this.props.contextId) {
      const textbox = this.getTextbox();
      const pretext = textbox.value.substring(0, textbox.selectionEnd).toLowerCase();
      this.handlePretextChanged(pretext);
    }
  }

  render() {
    const {
      listComponent,
      dateComponent,
      listStyle,
      renderNoResults,
      ...props
    } = this.props;
    const renderDividers = this.props.renderDividers && this.state.allowDividers; // Don't pass props used by SuggestionBox

    Reflect.deleteProperty(props, 'providers');
    Reflect.deleteProperty(props, 'onChange'); // We use onInput instead of onChange on the actual input

    Reflect.deleteProperty(props, 'onComposition');
    Reflect.deleteProperty(props, 'onItemSelected');
    Reflect.deleteProperty(props, 'completeOnTab');
    Reflect.deleteProperty(props, 'isRHS');
    Reflect.deleteProperty(props, 'requiredCharacters');
    Reflect.deleteProperty(props, 'openOnFocus');
    Reflect.deleteProperty(props, 'openWhenEmpty');
    Reflect.deleteProperty(props, 'onFocus');
    Reflect.deleteProperty(props, 'onBlur');
    Reflect.deleteProperty(props, 'containerClass');
    Reflect.deleteProperty(props, 'replaceAllInputOnSelect');
    Reflect.deleteProperty(props, 'renderDividers');
    Reflect.deleteProperty(props, 'contextId');
    Reflect.deleteProperty(props, 'listenForMentionKeyClick'); // This needs to be upper case so React doesn't think it's an html tag

    const SuggestionListComponent = listComponent;
    const SuggestionDateComponent = dateComponent;
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      ref: this.setContainerRef,
      className: this.props.containerClass
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_quick_input_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _extends({
      ref: "input",
      autoComplete: "off"
    }, props, {
      onInput: this.handleChange,
      onCompositionStart: this.handleCompositionStart,
      onCompositionUpdate: this.handleCompositionUpdate,
      onCompositionEnd: this.handleCompositionEnd,
      onKeyDown: this.handleKeyDown
    })), (this.props.openWhenEmpty || this.props.value.length >= this.props.requiredCharacters) && this.state.presentationType === 'text' && react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(SuggestionListComponent, {
      ref: "list",
      open: this.state.focused,
      pretext: this.pretext,
      location: listStyle,
      renderDividers: renderDividers,
      renderNoResults: renderNoResults,
      onCompleteWord: this.handleCompleteWord,
      preventClose: this.preventSuggestionListClose,
      cleared: this.state.cleared,
      matchedPretext: this.state.matchedPretext,
      items: this.state.items,
      terms: this.state.terms,
      selection: this.state.selection,
      components: this.state.components
    }), (this.props.openWhenEmpty || this.props.value.length >= this.props.requiredCharacters) && this.state.presentationType === 'date' && react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(SuggestionDateComponent, {
      ref: "date",
      items: this.state.items,
      terms: this.state.terms,
      components: this.state.components,
      matchedPretext: this.state.matchedPretext,
      onCompleteWord: this.handleCompleteWord
    }));
  } // Finds the longest substring that's at both the end of b and the start of a. For example,
  // if a = "firepit" and b = "pitbull", findOverlap would return "pit".


  static findOverlap(a, b) {
    const aLower = a.toLowerCase();
    const bLower = b.toLowerCase();

    for (let i = bLower.length; i > 0; i--) {
      const substring = bLower.substring(0, i);

      if (aLower.endsWith(substring)) {
        return substring;
      }
    }

    return '';
  }

}

_defineProperty(SuggestionBox, "propTypes", {
  /**
   * The list component to render, usually SuggestionList
   */
  listComponent: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func.isRequired,

  /**
   * The date component to render
   */
  dateComponent: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /**
   * The value of in the input
   */
  value: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,

  /**
   * Array of suggestion providers
   */
  providers: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object),

  /**
   * Where the list will be displayed relative to the input box, defaults to 'top'
   */
  listStyle: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * CSS class for the div parent of the input box
   */
  containerClass: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * Set to true to draw dividers between types of list items, defaults to false
   */
  renderDividers: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * Set to true to render a message when there were no results found, defaults to false
   */
  renderNoResults: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * Set to allow TAB to select an item in the list, defaults to true
   */
  completeOnTab: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * Function called when input box gains focus
   */
  onFocus: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /**
   * Function called when input box loses focus
   */
  onBlur: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /**
   * Function called when input box value changes
   */
  onChange: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /**
   * Function called when a key is pressed and the input box is in focus
   */
  onKeyDown: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  onComposition: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /**
   * Function called when an item is selected
   */
  onItemSelected: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /**
   * Flags if the suggestion_box is for the RHS (Reply).
   */
  isRHS: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * The number of characters required to show the suggestion list, defaults to 1
   */
  requiredCharacters: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,

  /**
   * If true, the suggestion box is opened on focus, default to false
   */
  openOnFocus: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * If true, the suggestion box is disabled
   */
  disabled: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * If true, it displays allow to display a default list when empty
   */
  openWhenEmpty: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * If true, replace all input in the suggestion box with the selected option after a select, defaults to false
   */
  replaceAllInputOnSelect: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * An optional, opaque identifier that distinguishes the context in which the suggestion
   * box is rendered. This allows the reused component to otherwise respond to changes.
   */
  contextId: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * If true, listen for clicks on a mention and populate the input with said mention, defaults to false
   */
  listenForMentionKeyClick: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool
});

_defineProperty(SuggestionBox, "defaultProps", {
  listStyle: 'top',
  containerClass: '',
  renderDividers: false,
  renderNoResults: false,
  completeOnTab: true,
  isRHS: false,
  requiredCharacters: 1,
  openOnFocus: false,
  openWhenEmpty: false,
  replaceAllInputOnSelect: false,
  listenForMentionKeyClick: false
});

/***/ }),

/***/ 1653:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GlobeIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class GlobeIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", this.props, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.channel.public",
      defaultMessage: "Public Channel Icon"
    }, ariaLabel => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
      width: "13px",
      height: "13px",
      viewBox: "0 0 14 14",
      role: "icon",
      "aria-label": ariaLabel
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(-115.000000, -147.000000)",
      fillRule: "nonzero",
      fill: "inherit"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(95.000000, 0.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(20.000000, 113.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(0.000000, 34.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      d: "M10.409,0.893375 C9.40275,0.329875 8.24075,0.00875 7,0 C3.13075,0 0,3.140375 0,7 C0,10.521875 2.594375,13.42775 5.97625,13.93 C6.314875,13.974625 6.6535,14 7,14 C8.24075,14 9.40275,13.678875 10.409,13.1145 C12.551875,11.918375 14,9.6285 14,7 C13.99125,4.3715 12.551875,2.090375 10.409,0.893375 Z M11.554375,4.375 L9.431625,4.375 C9.302125,3.5 9.10875,2.736125 8.86725,2.085125 C10.003875,2.519125 10.9515,3.5 11.554375,4.375 Z M6.941375,1.73775 C6.960625,1.736875 6.979875,1.73425 7,1.73425 C7.020125,1.73425 7.039375,1.736875 7.058625,1.73775 C7.340375,2.172625 7.697375,3.5 7.92225,4.375 L6.07775,4.375 C6.302625,3.5 6.659625,2.172625 6.941375,1.73775 Z M1.81475,7.875 C1.7675,7.875 1.73425,7.29925 1.73425,7 C1.73425,6.70075 1.764875,6.125 1.813,6.125 L4.396875,6.125 C4.384625,6.125 4.375,6.7025 4.375,7 C4.375,7.2975 4.384625,7.875 4.396875,7.875 L1.81475,7.875 Z M4.354875,11.54475 C4.346125,11.54475 4.337375,11.54475 4.337375,11.536 C3.548125,11.07575 2.893625,10.5 2.436875,9.625 L4.568375,9.625 C4.697875,10.5 4.890375,11.262125 5.131875,11.91225 C4.8615,11.81075 4.599875,11.692625 4.354875,11.54475 Z M4.568375,4.375 L2.443875,4.375 C3.045875,3.5 3.994375,2.517375 5.131875,2.083375 C4.89125,2.734375 4.697875,3.5 4.568375,4.375 Z M7.0595,12.26225 C7.039375,12.26225 7.020125,12.26575 7,12.26575 C6.979875,12.26575 6.960625,12.26225 6.9405,12.26225 C6.65875,11.8265 6.302625,11.375 6.07775,9.625 L7.921375,9.625 C7.697375,11.375 7.34125,11.8265 7.0595,12.26225 Z M8.11125,7.875 L5.88875,7.875 C5.873875,7.875 5.8625,7.30625 5.8625,7 C5.8625,6.69375 5.873875,6.125 5.88875,6.125 L8.11125,6.125 C8.126125,6.125 8.1375,6.69375 8.1375,7 C8.1375,7.30625 8.126125,7.875 8.11125,7.875 Z M10.409,11.0075 C10.13075,11.242 9.828,11.45025 9.506875,11.631375 C9.30125,11.74075 9.086875,11.839625 8.8655,11.923625 C9.107,11.270875 9.30125,10.5 9.431625,9.625 L11.557875,9.625 C11.25425,10.5 10.8675,10.618125 10.409,11.0075 Z M9.603125,7.875 C9.615375,7.875 9.625,7.2975 9.625,7 C9.625,6.7025 9.615375,6.125 9.603125,6.125 L12.186125,6.125 C12.235125,6.125 12.26575,6.70075 12.26575,7 C12.26575,7.29925 12.233375,7.875 12.18525,7.875 L9.603125,7.875 Z"
    })))))))));
  }

}

/***/ }),

/***/ 1654:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LockIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class LockIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", this.props, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.channel.private",
      defaultMessage: "Private Channel Icon"
    }, title => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
      width: "12px",
      height: "13px",
      viewBox: "0 0 13 15",
      role: "icon",
      title: title
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(-116.000000, -175.000000)",
      fillRule: "nonzero",
      fill: "inherit"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(95.000000, 0.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(20.000000, 113.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(1.000000, 62.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      d: "M12.0714286,6.5 L11.1428571,6.5 L11.1428571,4.64285714 C11.1428571,2.07814286 9.06471429,0 6.5,0 C3.93528571,0 1.85714286,2.07814286 1.85714286,4.64285714 L1.85714286,6.5 L0.928571429,6.5 C0.415071429,6.5 0,7.00792857 0,7.52142857 L0,13.9285714 C0,14.4420714 0.415071429,14.8571429 0.928571429,14.8571429 L12.0714286,14.8571429 C12.5849286,14.8571429 13,14.4420714 13,13.9285714 L13,7.52142857 C13,7.00792857 12.5849286,6.5 12.0714286,6.5 Z M6.5,1.85714286 C8.03585714,1.85714286 9.28571429,3.107 9.28571429,4.64285714 L9.28571429,6.5 L8.35714286,6.5 L4.64285714,6.5 L3.71428571,6.5 L3.71428571,4.64285714 C3.71428571,3.107 4.96414286,1.85714286 6.5,1.85714286 Z"
    })))))))));
  }

}

/***/ }),

/***/ 1655:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveAppPropsRequest = saveAppPropsRequest;
exports.saveAppProps = saveAppProps;
exports.selectSearchText = selectSearchText;
exports.updateSearchText = updateSearchText;
exports.searchBarTextSave = searchBarTextSave;
exports.invalidateSearchText = invalidateSearchText;
exports.requestSearch = requestSearch;
exports.receiveSearch = receiveSearch;
exports.receiveSearchEnd = receiveSearchEnd;
exports.errorSearching = errorSearching;
exports.receiveCategorySearch = receiveCategorySearch;
exports.clearSearchResults = clearSearchResults;
exports.requestSearchById = requestSearchById;
exports.receiveSearchById = receiveSearchById;
exports.errorSearchById = errorSearchById;
exports.searchScrollPosition = searchScrollPosition;
exports.searchPriorLocation = searchPriorLocation;
exports.searchGfycat = searchGfycat;
exports.searchCategory = searchCategory;
exports.shouldSearch = shouldSearch;
exports.searchIfNeeded = searchIfNeeded;
exports.searchIfNeededInitial = searchIfNeededInitial;
exports.shouldSearchInitial = shouldSearchInitial;
exports.searchById = searchById;
exports.shouldSearchById = shouldSearchById;
exports.searchByIdIfNeeded = searchByIdIfNeeded;
exports.saveSearchScrollPosition = saveSearchScrollPosition;
exports.saveSearchPriorLocation = saveSearchPriorLocation;
exports.searchTextUpdate = searchTextUpdate;
exports.saveSearchBarText = saveSearchBarText;
exports.categoriesListRequest = categoriesListRequest;
exports.categoriesListReceived = categoriesListReceived;
exports.categoriesListFailure = categoriesListFailure;
exports.requestCategoriesList = requestCategoriesList;
exports.requestCategoriesListIfNeeded = requestCategoriesListIfNeeded;
exports.shouldRequestCategoriesList = shouldRequestCategoriesList;
exports.cacheRequest = cacheRequest;
exports.cacheGifs = cacheGifs;
exports.cacheGifsRequest = cacheGifsRequest;

__webpack_require__(24);

__webpack_require__(40);

__webpack_require__(36);

__webpack_require__(19);

__webpack_require__(20);

__webpack_require__(23);

__webpack_require__(12);

__webpack_require__(13);

__webpack_require__(18);

__webpack_require__(83);

__webpack_require__(420);

var _action_types = __webpack_require__(8);

var _client = __webpack_require__(27);

var _gfycat_sdk = _interopRequireDefault(__webpack_require__(2397));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} // APP PROPS


function saveAppPropsRequest(props) {
  return {
    type: _action_types.GifTypes.SAVE_APP_PROPS,
    props: props
  };
}

function saveAppProps(appProps) {
  return function (dispatch, getState) {
    var _getState$entities$ge = getState().entities.general.config,
        GfycatApiKey = _getState$entities$ge.GfycatApiKey,
        GfycatApiSecret = _getState$entities$ge.GfycatApiSecret;
    (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).authenticate();
    dispatch(saveAppPropsRequest(appProps));
  };
} // SEARCH


function selectSearchText(searchText) {
  return {
    type: _action_types.GifTypes.SELECT_SEARCH_TEXT,
    searchText: searchText
  };
}

function updateSearchText(searchText) {
  return {
    type: _action_types.GifTypes.UPDATE_SEARCH_TEXT,
    searchText: searchText
  };
}

function searchBarTextSave(searchBarText) {
  return {
    type: _action_types.GifTypes.SAVE_SEARCH_BAR_TEXT,
    searchBarText: searchBarText
  };
}

function invalidateSearchText(searchText) {
  return {
    type: _action_types.GifTypes.INVALIDATE_SEARCH_TEXT,
    searchText: searchText
  };
}

function requestSearch(searchText) {
  return {
    type: _action_types.GifTypes.REQUEST_SEARCH,
    searchText: searchText
  };
}

function receiveSearch(_ref) {
  var searchText = _ref.searchText,
      count = _ref.count,
      start = _ref.start,
      json = _ref.json;
  return _objectSpread({
    type: _action_types.GifTypes.RECEIVE_SEARCH,
    searchText: searchText
  }, json, {
    count: count,
    start: start,
    currentPage: start / count,
    receivedAt: Date.now()
  });
}

function receiveSearchEnd(searchText) {
  return {
    type: _action_types.GifTypes.RECEIVE_SEARCH_END,
    searchText: searchText
  };
}

function errorSearching(err, searchText) {
  return {
    type: _action_types.GifTypes.SEARCH_FAILURE,
    searchText: searchText,
    err: err
  };
}

function receiveCategorySearch(_ref2) {
  var tagName = _ref2.tagName,
      json = _ref2.json;
  return _objectSpread({
    type: _action_types.GifTypes.RECEIVE_CATEGORY_SEARCH,
    searchText: tagName
  }, json, {
    receiveAt: Date.now()
  });
}

function clearSearchResults() {
  return {
    type: _action_types.GifTypes.CLEAR_SEARCH_RESULTS
  };
}

function requestSearchById(gfyId) {
  return {
    type: _action_types.GifTypes.SEARCH_BY_ID_REQUEST,
    payload: {
      gfyId: gfyId
    }
  };
}

function receiveSearchById(gfyId, gfyItem) {
  return {
    type: _action_types.GifTypes.SEARCH_BY_ID_SUCCESS,
    payload: {
      gfyId: gfyId,
      gfyItem: gfyItem
    }
  };
}

function errorSearchById(err, gfyId) {
  return {
    type: _action_types.GifTypes.SEARCH_BY_ID_FAILURE,
    err: err,
    gfyId: gfyId
  };
}

function searchScrollPosition(scrollPosition) {
  return {
    type: _action_types.GifTypes.SAVE_SEARCH_SCROLL_POSITION,
    scrollPosition: scrollPosition
  };
}

function searchPriorLocation(priorLocation) {
  return {
    type: _action_types.GifTypes.SAVE_SEARCH_PRIOR_LOCATION,
    priorLocation: priorLocation
  };
}

function searchGfycat(_ref3) {
  var searchText = _ref3.searchText,
      _ref3$count = _ref3.count,
      count = _ref3$count === void 0 ? 30 : _ref3$count,
      _ref3$startIndex = _ref3.startIndex,
      startIndex = _ref3$startIndex === void 0 ? 0 : _ref3$startIndex;
  var start = startIndex;
  return function (dispatch, getState) {
    var _getState$entities$ge2 = getState().entities.general.config,
        GfycatApiKey = _getState$entities$ge2.GfycatApiKey,
        GfycatApiSecret = _getState$entities$ge2.GfycatApiSecret;
    var resultsByTerm = getState().entities.gifs.search.resultsByTerm;

    if (resultsByTerm[searchText]) {
      start = resultsByTerm[searchText].start + count;
    }

    dispatch(requestSearch(searchText, count, start));
    (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).authenticate();
    return (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).search({
      search_text: searchText,
      count: count,
      start: start
    }).then(function (json) {
      if (json.errorMessage) {
        // There was no results before
        if (resultsByTerm[searchText].items) {
          dispatch(receiveSearchEnd(searchText));
        } else {
          dispatch(errorSearching(json, searchText));
        }
      } else {
        dispatch(updateSearchText(searchText));
        dispatch(cacheGifsRequest(json.gfycats));
        dispatch(receiveSearch({
          searchText: searchText,
          count: count,
          start: start,
          json: json
        }));
        var context = getState().entities.gifs.categories.tagsDict[searchText] ? 'category' : 'search';

        _client.Client4.trackEvent('gfycat', 'views', {
          context: context,
          count: json.gfycats.length,
          keyword: searchText
        });
      }
    }).catch(function (err) {
      return dispatch(errorSearching(err, searchText));
    });
  };
}

function searchCategory(_ref4) {
  var _ref4$tagName = _ref4.tagName,
      tagName = _ref4$tagName === void 0 ? '' : _ref4$tagName,
      _ref4$gfyCount = _ref4.gfyCount,
      gfyCount = _ref4$gfyCount === void 0 ? 30 : _ref4$gfyCount,
      cursorPos = _ref4.cursorPos;
  var cursor = cursorPos;
  return function (dispatch, getState) {
    var _getState$entities$ge3 = getState().entities.general.config,
        GfycatApiKey = _getState$entities$ge3.GfycatApiKey,
        GfycatApiSecret = _getState$entities$ge3.GfycatApiSecret;
    var resultsByTerm = getState().entities.gifs.search.resultsByTerm;

    if (resultsByTerm[tagName]) {
      cursor = resultsByTerm[tagName].cursor;
    }

    dispatch(requestSearch(tagName));
    return (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).getTrendingCategories({
      tagName: tagName,
      gfyCount: gfyCount,
      cursor: cursor
    }).then(function (json) {
      if (json.errorMessage) {
        if (resultsByTerm[tagName].gfycats) {
          dispatch(receiveSearchEnd(tagName));
        } else {
          dispatch(errorSearching(json, tagName));
        }
      } else {
        dispatch(updateSearchText(tagName));
        dispatch(cacheGifsRequest(json.gfycats));
        dispatch(receiveCategorySearch({
          tagName: tagName,
          json: json
        }));

        _client.Client4.trackEvent('gfycat', 'views', {
          context: 'category',
          count: json.gfycats.length,
          keyword: tagName
        }); // preload categories list


        if (tagName === 'trending') {
          dispatch(requestCategoriesListIfNeeded());
        }
      }
    }).catch(function (err) {
      return dispatch(errorSearching(err, tagName));
    });
  };
}

function shouldSearch(state, searchText) {
  var resultsByTerm = state.search.resultsByTerm[searchText];

  if (!resultsByTerm) {
    return true;
  } else if (resultsByTerm.isFetching) {
    return false;
  } else if (resultsByTerm.moreRemaining) {
    return true;
  }

  return resultsByTerm.didInvalidate;
}

function searchIfNeeded(searchText) {
  return function (dispatch, getState) {
    if (shouldSearch(getState(), searchText)) {
      if (searchText.toLowerCase() === 'trending') {
        return dispatch(searchCategory({
          tagName: searchText
        }));
      }

      return dispatch(searchGfycat({
        searchText: searchText
      }));
    }

    return Promise.resolve();
  };
}

function searchIfNeededInitial(searchText) {
  return function (dispatch, getState) {
    dispatch(updateSearchText(searchText));

    if (shouldSearchInitial(getState(), searchText)) {
      if (searchText.toLowerCase() === 'trending') {
        return dispatch(searchCategory({
          tagName: searchText
        }));
      }

      return dispatch(searchGfycat({
        searchText: searchText
      }));
    }

    return Promise.resolve();
  };
}

function shouldSearchInitial(state, searchText) {
  var resultsByTerm = state.entities.gifs.search.resultsByTerm[searchText];

  if (!resultsByTerm) {
    return true;
  } else if (resultsByTerm.isFetching) {
    return false;
  }

  return false;
}

function searchById(gfyId) {
  return function (dispatch, getState) {
    var _getState$entities$ge4 = getState().entities.general.config,
        GfycatApiKey = _getState$entities$ge4.GfycatApiKey,
        GfycatApiSecret = _getState$entities$ge4.GfycatApiSecret;
    dispatch(requestSearchById(gfyId));
    return (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).searchById({
      id: gfyId
    }).then(function (response) {
      dispatch(receiveSearchById(gfyId, response.gfyItem));
      dispatch(cacheGifsRequest([response.gfyItem]));
    }).catch(function (err) {
      return dispatch(errorSearchById(err, gfyId));
    });
  };
}

function shouldSearchById(state, gfyId) {
  return !state.cache.gifs[gfyId];
}

function searchByIdIfNeeded(gfyId) {
  return function (dispatch, getState) {
    if (shouldSearchById(getState(), gfyId)) {
      return dispatch(searchById(gfyId));
    }

    return Promise.resolve(getState().cache.gifs[gfyId]);
  };
}

function saveSearchScrollPosition(scrollPosition) {
  return function (dispatch) {
    dispatch(searchScrollPosition(scrollPosition));
  };
}

function saveSearchPriorLocation(priorLocation) {
  return function (dispatch) {
    dispatch(searchPriorLocation(priorLocation));
  };
}

function searchTextUpdate(searchText) {
  return function (dispatch) {
    dispatch(updateSearchText(searchText));
  };
}

function saveSearchBarText(searchBarText) {
  return function (dispatch) {
    dispatch(searchBarTextSave(searchBarText));
  };
} // CATEGORIES


function categoriesListRequest() {
  return {
    type: _action_types.GifTypes.REQUEST_CATEGORIES_LIST
  };
}

function categoriesListReceived(json) {
  return _objectSpread({
    type: _action_types.GifTypes.CATEGORIES_LIST_RECEIVED
  }, json);
}

function categoriesListFailure(err) {
  return {
    type: _action_types.GifTypes.CATEGORIES_LIST_FAILURE,
    err: err
  };
}

function requestCategoriesList() {
  var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref5$count = _ref5.count,
      count = _ref5$count === void 0 ? 60 : _ref5$count;

  return function (dispatch, getState) {
    var _getState$entities$ge5 = getState().entities.general.config,
        GfycatApiKey = _getState$entities$ge5.GfycatApiKey,
        GfycatApiSecret = _getState$entities$ge5.GfycatApiSecret;
    var state = getState().entities.gifs.categories;

    if (!shouldRequestCategoriesList(state)) {
      return Promise.resolve();
    }

    dispatch(categoriesListRequest());
    var cursor = state.cursor;

    var options = _objectSpread({}, count && {
      count: count
    }, {}, cursor && {
      cursor: cursor
    });

    return (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).getCategories(options).then(function (json) {
      var newGfycats = json.tags.reduce(function (gfycats, tag) {
        if (tag.gfycats[0] && tag.gfycats[0].width) {
          return [].concat(_toConsumableArray(gfycats), _toConsumableArray(tag.gfycats));
        }

        return gfycats;
      }, []);
      dispatch(cacheGifsRequest(newGfycats));
      dispatch(categoriesListReceived(json));
    }).catch(function (err) {
      dispatch(categoriesListFailure(err));
    });
  };
}

function requestCategoriesListIfNeeded() {
  var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      count = _ref6.count;

  return function (dispatch, getState) {
    var state = getState().entities.gifs.categories;

    if (state.tagsList && state.tagsList.length) {
      return Promise.resolve();
    }

    return dispatch(requestCategoriesList({
      count: count
    }));
  };
}

function shouldRequestCategoriesList(state) {
  var hasMore = state.hasMore,
      isFetching = state.isFetching,
      tagsList = state.tagsList;

  if (!tagsList || !tagsList.length) {
    return true;
  } else if (isFetching) {
    return false;
  } else if (hasMore) {
    return true;
  }

  return false;
} // CACHE


function cacheRequest() {
  return {
    type: _action_types.GifTypes.CACHE_REQUEST,
    payload: {
      updating: true
    }
  };
}

function cacheGifs(gifs) {
  return {
    type: _action_types.GifTypes.CACHE_GIFS,
    gifs: gifs
  };
}

function cacheGifsRequest(gifs) {
  return function (dispatch) {
    dispatch(cacheRequest());
    dispatch(cacheGifs(gifs));
  };
}

/***/ }),

/***/ 1656:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProfilePicture; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1995);
/* harmony import */ var components_profile_popover__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1962);
/* harmony import */ var components_status_icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1754);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class ProfilePicture extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "hideProfilePopover", () => {
      this.refs.overlay.hide();
    });
  }

  render() {
    if (this.props.userId) {
      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
        ref: "overlay",
        trigger: "click",
        placement: "right",
        rootClose: true,
        overlay: react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_profile_popover__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], {
          userId: this.props.userId,
          src: this.props.src,
          isBusy: this.props.isBusy,
          hide: this.hideProfilePopover,
          isRHS: this.props.isRHS,
          hasMention: this.props.hasMention
        })
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", {
        className: "status-wrapper"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("img", {
        className: "more-modal__image rounded",
        alt: `${this.props.username || 'user'} profile image`,
        width: this.props.width,
        height: this.props.width,
        src: this.props.src
      })));
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", {
      className: "status-wrapper"
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("img", {
      className: "more-modal__image rounded",
      alt: "",
      width: this.props.width,
      height: this.props.width,
      src: this.props.src
    }));
  }

}

_defineProperty(ProfilePicture, "defaultProps", {
  width: '36',
  height: '36',
  isRHS: false,
  hasMention: false
});

_defineProperty(ProfilePicture, "propTypes", {
  src: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,
  status: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  width: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  height: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  userId: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  username: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  isBusy: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  isRHS: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  hasMention: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool
});

/***/ }),

/***/ 1664:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/roles.js
var roles = __webpack_require__(90);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var constants = __webpack_require__(17);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/selectors/errors.js
var selectors_errors = __webpack_require__(2394);

// EXTERNAL MODULE: ./mattermost-redux/actions/errors.js
var actions_errors = __webpack_require__(105);

// EXTERNAL MODULE: ./mattermost-redux/actions/admin.js
var admin = __webpack_require__(1609);

// EXTERNAL MODULE: ./actions/views/notice.js
var notice = __webpack_require__(1859);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./utils/constants.jsx
var utils_constants = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./stores/redux_store.jsx + 3 modules
var redux_store = __webpack_require__(14);

// CONCATENATED MODULE: ./utils/license_utils.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


const LICENSE_EXPIRY_NOTIFICATION = 1000 * 60 * 60 * 24 * 60; // 60 days

const LICENSE_GRACE_PERIOD = 1000 * 60 * 60 * 24 * 15; // 15 days

function isLicenseExpiring() {
  const license = Object(general["getLicense"])(redux_store["a" /* default */].getState());

  if (license.IsLicensed !== 'true') {
    return false;
  }

  const timeDiff = parseInt(license.ExpiresAt, 10) - Date.now();
  return timeDiff <= LICENSE_EXPIRY_NOTIFICATION;
}
function isLicenseExpired() {
  const license = Object(general["getLicense"])(redux_store["a" /* default */].getState());

  if (license.IsLicensed !== 'true') {
    return false;
  }

  const timeDiff = parseInt(license.ExpiresAt, 10) - Date.now();
  return timeDiff < 0;
}
function isLicensePastGracePeriod() {
  const license = Object(general["getLicense"])(redux_store["a" /* default */].getState());

  if (license.IsLicensed !== 'true') {
    return false;
  }

  const timeDiff = Date.now() - parseInt(license.ExpiresAt, 10);
  return timeDiff > LICENSE_GRACE_PERIOD;
}
// EXTERNAL MODULE: ./utils/i18n.jsx
var i18n = __webpack_require__(53);

// EXTERNAL MODULE: ./components/formatted_markdown_message.jsx
var formatted_markdown_message = __webpack_require__(1564);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tooltip.js
var Tooltip = __webpack_require__(1998);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// CONCATENATED MODULE: ./components/announcement_bar/announcement_bar.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class announcement_bar_AnnouncementBar extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "handleClose", e => {
      e.preventDefault();

      if (this.props.handleClose) {
        this.props.handleClose();
      }
    });
  }

  componentDidMount() {
    document.body.classList.add('announcement-bar--fixed');
  }

  componentWillUnmount() {
    document.body.classList.remove('announcement-bar--fixed');
  }

  render() {
    if (!this.props.message) {
      return null;
    }

    let barClass = 'announcement-bar';
    const barStyle = {};
    const linkStyle = {};

    if (this.props.color && this.props.textColor) {
      barStyle.backgroundColor = this.props.color;
      barStyle.color = this.props.textColor;
      linkStyle.color = this.props.textColor;
    } else if (this.props.type === utils_constants["e" /* AnnouncementBarTypes */].DEVELOPER) {
      barClass = 'announcement-bar announcement-bar-developer';
    } else if (this.props.type === utils_constants["e" /* AnnouncementBarTypes */].CRITICAL) {
      barClass = 'announcement-bar announcement-bar-critical';
    } else if (this.props.type === utils_constants["e" /* AnnouncementBarTypes */].SUCCESS) {
      barClass = 'announcement-bar announcement-bar-success';
    }

    let closeButton;

    if (this.props.showCloseButton) {
      closeButton = react_default.a.createElement("a", {
        href: "#",
        className: "announcement-bar__close",
        style: linkStyle,
        onClick: this.handleClose
      }, '×');
    }

    let message = this.props.message;

    if (typeof message == 'string') {
      message = react_default.a.createElement(formatted_markdown_message["b" /* default */], {
        id: this.props.message
      });
    }

    const announcementTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "announcement-bar__tooltip"
    }, message);
    return react_default.a.createElement("div", {
      className: barClass,
      style: barStyle
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: utils_constants["g" /* Constants */].OVERLAY_TIME_DELAY,
      placement: "bottom",
      overlay: announcementTooltip
    }, react_default.a.createElement("span", null, message)), closeButton);
  }

}

_defineProperty(announcement_bar_AnnouncementBar, "propTypes", {
  showCloseButton: prop_types_default.a.bool,
  color: prop_types_default.a.string,
  textColor: prop_types_default.a.string,
  type: prop_types_default.a.string,
  message: prop_types_default.a.node.isRequired,
  handleClose: prop_types_default.a.func
});

_defineProperty(announcement_bar_AnnouncementBar, "defaultProps", {
  showCloseButton: false,
  color: '',
  textColor: '',
  type: utils_constants["e" /* AnnouncementBarTypes */].CRITICAL,
  handleClose: null
});
// EXTERNAL MODULE: ./utils/text_formatting.jsx
var text_formatting = __webpack_require__(81);

// CONCATENATED MODULE: ./components/announcement_bar/text_dismissable_bar.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function text_dismissable_bar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




const localStoragePrefix = '__announcement__';
class text_dismissable_bar_TextDismissableBar extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    text_dismissable_bar_defineProperty(this, "handleDismiss", () => {
      if (!this.props.allowDismissal) {
        return;
      }

      localStorage.setItem(localStoragePrefix + this.props.text, true);
      this.setState({
        dismissed: true
      });

      if (this.props.onDismissal) {
        this.props.onDismissal();
      }
    });

    this.state = {
      dismissed: true
    };
  }

  static getDerivedStateFromProps(props) {
    const dismissed = localStorage.getItem(localStoragePrefix + props.text);
    return {
      dismissed
    };
  }

  render() {
    if (this.state.dismissed) {
      return null;
    }

    const {
      allowDismissal,
      text,
      ...extraProps
    } = this.props;
    return react_default.a.createElement(announcement_bar_AnnouncementBar, _extends({}, extraProps, {
      showCloseButton: allowDismissal,
      handleClose: this.handleDismiss,
      message: react_default.a.createElement("span", {
        dangerouslySetInnerHTML: {
          __html: text_formatting["e" /* formatText */](text, {
            singleline: true,
            mentionHighlight: false
          })
        }
      })
    }));
  }

}

text_dismissable_bar_defineProperty(text_dismissable_bar_TextDismissableBar, "propTypes", {
  allowDismissal: prop_types_default.a.bool.isRequired,
  text: prop_types_default.a.string.isRequired,
  onDismissal: prop_types_default.a.func // Any props that AnnouncementBar supports

});
// CONCATENATED MODULE: ./components/announcement_bar/configuration_bar/configuration_bar.jsx
function configuration_bar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









const RENEWAL_LINK = 'https://licensing.mattermost.com/renew';
class configuration_bar_ConfigurationAnnouncementBar extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    configuration_bar_defineProperty(this, "dismissExpiringLicense", () => {
      this.props.actions.dismissNotice(utils_constants["d" /* AnnouncementBarMessages */].LICENSE_EXPIRING);
    });
  }

  render() {
    // System administrators
    if (this.props.canViewSystemErrors) {
      const renewalLink = RENEWAL_LINK + '?id=' + this.props.license.id + '&user_count=' + this.props.totalUsers;

      if (isLicensePastGracePeriod()) {
        return react_default.a.createElement(announcement_bar_AnnouncementBar, {
          type: utils_constants["e" /* AnnouncementBarTypes */].CRITICAL,
          message: react_default.a.createElement(formatted_markdown_message["b" /* default */], {
            id: utils_constants["d" /* AnnouncementBarMessages */].LICENSE_EXPIRED,
            defaultMessage: "Enterprise license is expired and some features may be disabled. [Please renew](!{link}).",
            values: {
              link: renewalLink
            }
          })
        });
      }

      if (isLicenseExpired()) {
        return react_default.a.createElement(announcement_bar_AnnouncementBar, {
          type: utils_constants["e" /* AnnouncementBarTypes */].CRITICAL,
          message: react_default.a.createElement(formatted_markdown_message["b" /* default */], {
            id: utils_constants["d" /* AnnouncementBarMessages */].LICENSE_EXPIRED,
            defaultMessage: "Enterprise license is expired and some features may be disabled. [Please renew](!{link}).",
            values: {
              link: renewalLink
            }
          })
        });
      }

      if (isLicenseExpiring() && !this.props.dismissedExpiringLicense) {
        return react_default.a.createElement(announcement_bar_AnnouncementBar, {
          showCloseButton: true,
          handleClose: this.dismissExpiringLicense,
          type: utils_constants["e" /* AnnouncementBarTypes */].ANNOUNCEMENT,
          message: react_default.a.createElement(formatted_markdown_message["b" /* default */], {
            id: utils_constants["d" /* AnnouncementBarMessages */].LICENSE_EXPIRING,
            defaultMessage: "Enterprise license expires on {date, date, long}. [Please renew](!{link}).",
            values: {
              date: new Date(parseInt(this.props.license.ExpiresAt, 10)),
              link: renewalLink
            }
          })
        });
      }
    } else {
      // Regular users
      if (isLicensePastGracePeriod()) {
        //eslint-disable-line no-lonely-if
        return react_default.a.createElement(announcement_bar_AnnouncementBar, {
          type: utils_constants["e" /* AnnouncementBarTypes */].CRITICAL,
          message: react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: utils_constants["d" /* AnnouncementBarMessages */].LICENSE_PAST_GRACE,
            defaultMessage: "Enterprise license is expired and some features may be disabled. Please contact your System Administrator for details."
          })
        });
      }
    }

    const {
      formatMessage
    } = this.context.intl;

    if (this.props.config.SendEmailNotifications !== 'true' && this.props.config.EnablePreviewModeBanner === 'true') {
      const emailMessage = formatMessage({
        id: utils_constants["d" /* AnnouncementBarMessages */].PREVIEW_MODE,
        defaultMessage: 'Preview Mode: Email notifications have not been configured'
      });
      return react_default.a.createElement(text_dismissable_bar_TextDismissableBar, {
        allowDismissal: true,
        text: emailMessage,
        type: utils_constants["e" /* AnnouncementBarTypes */].ANNOUNCEMENT
      });
    }

    if (this.props.canViewSystemErrors && this.props.config.SiteURL === '') {
      let id;
      let defaultMessage;

      if (this.props.config.EnableSignUpWithGitLab === 'true') {
        id = Object(i18n["b" /* t */])('announcement_bar.error.site_url_gitlab.full');
        defaultMessage = 'Please configure your [Site URL](https://docs.mattermost.com/administration/config-settings.html#site-url) in the [System Console](/admin_console/environment/web_server) or in gitlab.rb if you\'re using GitLab Mattermost.';
      } else {
        id = Object(i18n["b" /* t */])('announcement_bar.error.site_url.full');
        defaultMessage = 'Please configure your [Site URL](https://docs.mattermost.com/administration/config-settings.html#site-url) in the [System Console](/admin_console/environment/web_server).';
      }

      const siteURLMessage = formatMessage({
        id,
        defaultMessage
      });
      return react_default.a.createElement(text_dismissable_bar_TextDismissableBar, {
        allowDismissal: true,
        text: siteURLMessage,
        type: utils_constants["e" /* AnnouncementBarTypes */].ANNOUNCEMENT
      });
    }

    return null;
  }

}

configuration_bar_defineProperty(configuration_bar_ConfigurationAnnouncementBar, "propTypes", {
  config: prop_types_default.a.object,
  license: prop_types_default.a.object,
  user: prop_types_default.a.object,
  canViewSystemErrors: prop_types_default.a.bool.isRequired,
  totalUsers: prop_types_default.a.number,
  dismissedExpiringLicense: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    dismissNotice: prop_types_default.a.func.isRequired
  }).isRequired
});

configuration_bar_defineProperty(configuration_bar_ConfigurationAnnouncementBar, "contextTypes", {
  intl: index_es["i" /* intlShape */]
});
// CONCATENATED MODULE: ./components/announcement_bar/configuration_bar/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function mapStateToProps(state) {
  return {
    dismissedExpiringLicense: Boolean(state.views.notice.hasBeenDismissed[utils_constants["d" /* AnnouncementBarMessages */].LICENSE_EXPIRING])
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      dismissNotice: notice["a" /* dismissNotice */]
    }, dispatch)
  };
}

/* harmony default export */ var configuration_bar = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(configuration_bar_ConfigurationAnnouncementBar));
// CONCATENATED MODULE: ./utils/server_version.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/**
 * Compare server versions, ignoring the configuration hash and licensed status.
 *
 * For example, the following two server versions are considered equal:
 *     4.7.1.dev.3034fbc5fd566195d1b53e03890e35ff.true
 *     4.7.1.dev.d131dd02c5e6eec4693d9a0698aff95c.false
 *
 * but the following two are not
 *     4.7.0.dev.3034fbc5fd566195d1b53e03890e35ff.true
 *     4.7.1.dev.d131dd02c5e6eec4693d9a0698aff95c.true
 */
function equalServerVersions(a, b) {
  if (a === b) {
    return true;
  }

  const ignoredComponents = 2;
  const aIgnoringComponents = (a || '').split('.').slice(0, -ignoredComponents).join('.');
  const bIgnoringComponents = (b || '').split('.').slice(0, -ignoredComponents).join('.');

  if (aIgnoringComponents === bIgnoringComponents) {
    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./components/announcement_bar/version_bar/version_bar.jsx
function version_bar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class version_bar_VersionBar extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    version_bar_defineProperty(this, "reloadPage", () => {
      window.location.reload();
    });

    this.state = {
      serverVersionOnAppLoad: props.serverVersion
    };
  }

  static getDerivedStateFromProps(props, state) {
    if (!state.serverVersionOnAppLoad && props.serverVersion) {
      return {
        serverVersionOnAppLoad: props.serverVersion
      };
    }

    return null;
  }

  render() {
    const {
      serverVersionOnAppLoad
    } = this.state;
    const {
      serverVersion
    } = this.props;

    if (!serverVersionOnAppLoad) {
      return null;
    }

    if (!equalServerVersions(serverVersionOnAppLoad, serverVersion)) {
      return react_default.a.createElement(announcement_bar_AnnouncementBar, {
        type: utils_constants["e" /* AnnouncementBarTypes */].ANNOUNCEMENT,
        message: react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "version_bar.new",
          defaultMessage: "A new version of Mattermost is available."
        }), ' ', react_default.a.createElement("a", {
          onClick: this.reloadPage
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "version_bar.refresh",
          defaultMessage: "Refresh the app now"
        })), '.')
      });
    }

    return null;
  }

}

version_bar_defineProperty(version_bar_VersionBar, "propTypes", {
  serverVersion: prop_types_default.a.string
});
// CONCATENATED MODULE: ./components/announcement_bar/version_bar/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



function version_bar_mapStateToProps(state) {
  return {
    serverVersion: state.entities.general.serverVersion
  };
}

/* harmony default export */ var version_bar = (Object(es["connect"])(version_bar_mapStateToProps)(version_bar_VersionBar));
// CONCATENATED MODULE: ./components/announcement_bar/announcement_bar_controller.jsx
function announcement_bar_controller_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class announcement_bar_controller_AnnouncementBarController extends react_default.a.PureComponent {
  render() {
    let adminConfiguredAnnouncementBar = null;

    if (this.props.config.EnableBanner === 'true' && this.props.config.BannerText.trim()) {
      adminConfiguredAnnouncementBar = react_default.a.createElement(text_dismissable_bar_TextDismissableBar, {
        color: this.props.config.BannerColor,
        textColor: this.props.config.BannerTextColor,
        allowDismissal: this.props.config.AllowBannerDismissal === 'true',
        text: this.props.config.BannerText
      });
    }

    let errorBar = null;

    if (this.props.latestError) {
      errorBar = react_default.a.createElement(announcement_bar_AnnouncementBar, {
        type: this.props.latestError.error.type,
        message: this.props.latestError.error.message,
        showCloseButton: true,
        handleClose: this.props.actions.dismissError
      });
    }

    return react_default.a.createElement(react_default.a.Fragment, null, adminConfiguredAnnouncementBar, errorBar, react_default.a.createElement(version_bar, null), react_default.a.createElement(configuration_bar, {
      config: this.props.config,
      license: this.props.license,
      canViewSystemErrors: this.props.canViewSystemErrors,
      totalUsers: this.props.totalUsers,
      user: this.props.user
    }));
  }

}

announcement_bar_controller_defineProperty(announcement_bar_controller_AnnouncementBarController, "propTypes", {
  license: prop_types_default.a.object,
  config: prop_types_default.a.object,
  user: prop_types_default.a.shape({
    email: prop_types_default.a.string.isRequired,
    email_verified: prop_types_default.a.bool
  }),
  canViewSystemErrors: prop_types_default.a.bool.isRequired,
  latestError: prop_types_default.a.object,
  totalUsers: prop_types_default.a.number,
  actions: prop_types_default.a.shape({
    dismissError: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/announcement_bar/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












function announcement_bar_mapStateToProps(state) {
  const canViewSystemErrors = Object(roles["haveISystemPermission"])(state, {
    permission: constants["Permissions"].MANAGE_SYSTEM
  });
  const license = Object(general["getLicense"])(state);
  const config = Object(general["getConfig"])(state);
  const user = Object(users["getCurrentUser"])(state);
  const errors = Object(selectors_errors["getDisplayableErrors"])(state);
  const totalUsers = state.entities.admin.analytics.TOTAL_USERS;
  let latestError = null;

  if (errors && errors.length >= 1) {
    latestError = errors[0];
  }

  return {
    license,
    config,
    user,
    canViewSystemErrors,
    latestError,
    totalUsers
  };
}

function announcement_bar_mapDispatchToProps(dispatch) {
  const dismissFirstError = actions_errors["dismissError"].bind(null, 0);
  return {
    actions: Object(redux["bindActionCreators"])({
      getStandardAnalytics: admin["getStandardAnalytics"],
      dismissError: dismissFirstError,
      dismissNotice: notice["a" /* dismissNotice */]
    }, dispatch)
  };
}

/* harmony default export */ var announcement_bar = __webpack_exports__["a"] = (Object(es["connect"])(announcement_bar_mapStateToProps, announcement_bar_mapDispatchToProps)(announcement_bar_controller_AnnouncementBarController));

/***/ }),

/***/ 1666:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SpinnerButton; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var components_widgets_loading_loading_wrapper_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1608);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class SpinnerButton extends react__WEBPACK_IMPORTED_MODULE_1__["PureComponent"] {
  render() {
    const {
      spinning,
      spinningText,
      children,
      ...props
    } = this.props; // eslint-disable-line no-use-before-define

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", _extends({
      className: "btn btn-primary",
      disabled: spinning
    }, props), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_widgets_loading_loading_wrapper_jsx__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
      loading: spinning,
      text: spinningText
    }, children));
  }

}

_defineProperty(SpinnerButton, "defaultProps", {
  spinning: false
});

_defineProperty(SpinnerButton, "propTypes", {
  /**
   * Children to show when not spinning
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,

  /**
   * Set to true to spin
   */
  spinning: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool.isRequired,

  /**
   * Set the text used while spinning
   */
  spinningText: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node.isRequired,

  /**
   * Callback function when button is clicked
   */
  onClick: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func
});

/***/ }),

/***/ 1667:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SuggestionList; });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(175);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52);
/* harmony import */ var components_formatted_markdown_message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1564);
/* harmony import */ var components_widgets_loading_loading_spinner_jsx__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1651);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class SuggestionList extends react__WEBPACK_IMPORTED_MODULE_2___default.a.PureComponent {
  constructor(props) {
    super(props);
    this.getContent = this.getContent.bind(this);
    this.scrollToItem = this.scrollToItem.bind(this);
  }

  componentDidUpdate(prevProps) {
    if (this.props.selection !== prevProps.selection && this.props.selection) {
      this.scrollToItem(this.props.selection);
    }
  }

  getContent() {
    return jquery__WEBPACK_IMPORTED_MODULE_0___default()(react_dom__WEBPACK_IMPORTED_MODULE_3___default.a.findDOMNode(this.refs.content));
  }

  scrollToItem(term) {
    const content = this.getContent();

    if (!content || content.length === 0) {
      return;
    }

    const visibleContentHeight = content[0].clientHeight;
    const actualContentHeight = content[0].scrollHeight;

    if (visibleContentHeight < actualContentHeight) {
      const contentTop = content.scrollTop();
      const contentTopPadding = parseInt(content.css('padding-top'), 10);
      const contentBottomPadding = parseInt(content.css('padding-top'), 10);
      const item = jquery__WEBPACK_IMPORTED_MODULE_0___default()(react_dom__WEBPACK_IMPORTED_MODULE_3___default.a.findDOMNode(this.refs[term]));

      if (item.length === 0) {
        return;
      }

      const itemTop = item[0].offsetTop - parseInt(item.css('margin-top'), 10);
      const itemBottomMargin = parseInt(item.css('margin-bottom'), 10) + parseInt(item.css('padding-bottom'), 10);
      const itemBottom = item[0].offsetTop + item.height() + itemBottomMargin;

      if (itemTop - contentTopPadding < contentTop) {
        // the item is off the top of the visible space
        content.scrollTop(itemTop - contentTopPadding);
      } else if (itemBottom + contentTopPadding + contentBottomPadding > contentTop + visibleContentHeight) {
        // the item has gone off the bottom of the visible space
        content.scrollTop(itemBottom - visibleContentHeight + contentTopPadding + contentBottomPadding);
      }
    }
  }

  renderDivider(type) {
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("div", {
      key: type + '-divider',
      className: "suggestion-list__divider"
    }, react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("span", null, react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_4__[/* FormattedMessage */ "c"], {
      id: 'suggestion.' + type
    })));
  }

  renderNoResults() {
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("div", {
      key: "list-no-results",
      className: "suggestion-list__no-results"
    }, react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_formatted_markdown_message__WEBPACK_IMPORTED_MODULE_5__[/* default */ "b"], {
      id: "suggestion_list.no_matches",
      defaultMessage: "No items match __{value}__",
      values: {
        value: this.props.pretext || '""'
      }
    }));
  }

  render() {
    if (!this.props.open || this.props.cleared) {
      return null;
    }

    const items = [];

    if (this.props.items.length === 0) {
      if (!this.props.renderNoResults) {
        return null;
      }

      items.push(this.renderNoResults());
    }

    let lastType;

    for (let i = 0; i < this.props.items.length; i++) {
      const item = this.props.items[i];
      const term = this.props.terms[i];
      const isSelection = term === this.props.selection; // ReactComponent names need to be upper case when used in JSX

      const Component = this.props.components[i];

      if (this.props.renderDividers && item.type !== lastType) {
        items.push(this.renderDivider(item.type));
        lastType = item.type;
      }

      if (item.loading) {
        items.push(react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_widgets_loading_loading_spinner_jsx__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"], {
          key: item.type
        }));
        continue;
      }

      items.push(react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(Component, {
        key: term,
        ref: term,
        item: this.props.items[i],
        term: term,
        matchedPretext: this.props.matchedPretext[i],
        isSelection: isSelection,
        onClick: this.props.onCompleteWord
      }));
    }

    const mainClass = 'suggestion-list suggestion-list--' + this.props.location;
    const contentClass = 'suggestion-list__content suggestion-list__content--' + this.props.location;
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("div", {
      className: mainClass
    }, react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("div", {
      id: "suggestionList",
      ref: "content",
      className: contentClass,
      onMouseDown: this.props.preventClose
    }, items));
  }

}

_defineProperty(SuggestionList, "propTypes", {
  open: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool.isRequired,
  location: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  renderDividers: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  renderNoResults: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  onCompleteWord: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,
  preventClose: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
  pretext: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  cleared: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool.isRequired,
  matchedPretext: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.array.isRequired,
  items: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.array.isRequired,
  terms: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.array.isRequired,
  selection: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  components: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.array.isRequired
});

_defineProperty(SuggestionList, "defaultProps", {
  renderDividers: false,
  renderNoResults: false
});

/***/ }),

/***/ 1671:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DelayedAction; });
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
class DelayedAction {
  constructor(action) {
    this.action = action;
    this.timer = -1; // bind fire since it doesn't get passed the correct this value with setTimeout

    this.fire = this.fire.bind(this);
  }

  fire() {
    this.action();
    this.timer = -1;
  }

  fireAfter(timeout) {
    if (this.timer >= 0) {
      window.clearTimeout(this.timer);
    }

    this.timer = window.setTimeout(this.fire, timeout);
  }

  cancel() {
    window.clearTimeout(this.timer);
  }

}

/***/ }),

/***/ 1672:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SearchIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class SearchIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", this.props, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.search",
      defaultMessage: "Search Icon"
    }, ariaLabel => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
      width: "14px",
      height: "14px",
      viewBox: "0 0 19 18",
      role: "icon",
      "aria-label": ariaLabel
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      stroke: "inherit",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(-719.000000, -20.000000)",
      strokeWidth: "1.5"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(0.000000, 1.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(63.000000, 10.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(657.000000, 10.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("circle", {
      cx: "7",
      cy: "7",
      r: "7"
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      d: "M12.5,11.5 L16.5,15.5",
      strokeLinecap: "round"
    })))))))));
  }

}

/***/ }),

/***/ 1677:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2556);
/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_scss__WEBPACK_IMPORTED_MODULE_1__);


/* harmony default export */ __webpack_exports__["a"] = (({
  labelWidth,
  label,
  value,
  marginBottom
}) => {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    className: "ao-fieldinfo",
    style: {
      paddingLeft: `${labelWidth + 20}px`,
      marginBottom
    }
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", {
    style: {
      width: `${labelWidth}px`
    }
  }, label), value);
});

/***/ }),

/***/ 1681:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linkGroupSyncable = linkGroupSyncable;
exports.unlinkGroupSyncable = unlinkGroupSyncable;
exports.getGroupSyncables = getGroupSyncables;
exports.getGroupMembers = getGroupMembers;
exports.getGroup = getGroup;
exports.getGroupsNotAssociatedToTeam = getGroupsNotAssociatedToTeam;
exports.getGroupsNotAssociatedToChannel = getGroupsNotAssociatedToChannel;
exports.getAllGroupsAssociatedToTeam = getAllGroupsAssociatedToTeam;
exports.getAllGroupsAssociatedToChannel = getAllGroupsAssociatedToChannel;
exports.getGroupsAssociatedToTeam = getGroupsAssociatedToTeam;
exports.getGroupsAssociatedToChannel = getGroupsAssociatedToChannel;

__webpack_require__(83);

__webpack_require__(84);

var _action_types = __webpack_require__(8);

var _constants = __webpack_require__(17);

var _client = __webpack_require__(27);

var _errors = __webpack_require__(105);

var _helpers = __webpack_require__(117);

var _reduxBatchedActions = __webpack_require__(132);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function linkGroupSyncable(groupID
/*: string*/
, syncableID
/*: string*/
, syncableType
/*: SyncableType*/
, patch
/*: SyncablePatch*/
)
/*: ActionFunc*/
{
  return (
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(dispatch, getState) {
        var data, dispatches, type;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                dispatch({
                  type: _action_types.GroupTypes.LINK_GROUP_SYNCABLE_REQUEST,
                  data: {
                    groupID: groupID,
                    syncableID: syncableID
                  }
                });
                _context.prev = 1;
                _context.next = 4;
                return _client.Client4.linkGroupSyncable(groupID, syncableID, syncableType, patch);

              case 4:
                data = _context.sent;
                _context.next = 12;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.GroupTypes.LINK_GROUP_SYNCABLE_FAILURE,
                  error: _context.t0,
                  data: {
                    groupID: groupID,
                    syncableID: syncableID
                  }
                }, (0, _errors.logError)(_context.t0)]));
                return _context.abrupt("return", {
                  error: _context.t0
                });

              case 12:
                dispatches = [];
                _context.t1 = syncableType;
                _context.next = _context.t1 === _constants.Groups.SYNCABLE_TYPE_TEAM ? 16 : _context.t1 === _constants.Groups.SYNCABLE_TYPE_CHANNEL ? 19 : 21;
                break;

              case 16:
                dispatches.push({
                  type: _action_types.GroupTypes.RECEIVED_GROUPS_ASSOCIATED_TO_TEAM,
                  data: {
                    teamID: syncableID,
                    groups: [{
                      id: groupID
                    }]
                  }
                });
                type = _action_types.GroupTypes.LINKED_GROUP_TEAM;
                return _context.abrupt("break", 22);

              case 19:
                type = _action_types.GroupTypes.LINKED_GROUP_CHANNEL;
                return _context.abrupt("break", 22);

              case 21:
                console.warn("unhandled syncable type ".concat(syncableType));

              case 22:
                dispatches.push({
                  type: _action_types.GroupTypes.LINK_GROUP_SYNCABLE_SUCCESS,
                  data: null
                }, {
                  type: type,
                  data: data
                });
                dispatch((0, _reduxBatchedActions.batchActions)(dispatches));
                return _context.abrupt("return", {
                  data: true
                });

              case 25:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 7]]);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}

function unlinkGroupSyncable(groupID
/*: string*/
, syncableID
/*: string*/
, syncableType
/*: SyncableType*/
)
/*: ActionFunc*/
{
  return (
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(dispatch, getState) {
        var dispatches, type, data;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                dispatch({
                  type: _action_types.GroupTypes.UNLINK_GROUP_SYNCABLE_REQUEST,
                  data: {
                    groupID: groupID,
                    syncableID: syncableID
                  }
                });
                _context2.prev = 1;
                _context2.next = 4;
                return _client.Client4.unlinkGroupSyncable(groupID, syncableID, syncableType);

              case 4:
                _context2.next = 11;
                break;

              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context2.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.GroupTypes.UNLINK_GROUP_SYNCABLE_FAILURE,
                  error: _context2.t0,
                  data: {
                    groupID: groupID,
                    syncableID: syncableID
                  }
                }, (0, _errors.logError)(_context2.t0)]));
                return _context2.abrupt("return", {
                  error: _context2.t0
                });

              case 11:
                dispatches = [];
                data = {
                  group_id: groupID,
                  syncable_id: syncableID
                };
                _context2.t1 = syncableType;
                _context2.next = _context2.t1 === _constants.Groups.SYNCABLE_TYPE_TEAM ? 16 : _context2.t1 === _constants.Groups.SYNCABLE_TYPE_CHANNEL ? 20 : 23;
                break;

              case 16:
                type = _action_types.GroupTypes.UNLINKED_GROUP_TEAM;
                data.syncable_id = syncableID;
                dispatches.push({
                  type: _action_types.GroupTypes.RECEIVED_GROUPS_NOT_ASSOCIATED_TO_TEAM,
                  data: {
                    teamID: syncableID,
                    groups: [{
                      id: groupID
                    }]
                  }
                });
                return _context2.abrupt("break", 24);

              case 20:
                type = _action_types.GroupTypes.UNLINKED_GROUP_CHANNEL;
                data.syncable_id = syncableID;
                return _context2.abrupt("break", 24);

              case 23:
                console.warn("unhandled syncable type ".concat(syncableType));

              case 24:
                dispatches.push({
                  type: _action_types.GroupTypes.UNLINK_GROUP_SYNCABLE_SUCCESS,
                  data: null
                }, {
                  type: type,
                  data: data
                });
                dispatch((0, _reduxBatchedActions.batchActions)(dispatches));
                return _context2.abrupt("return", {
                  data: true
                });

              case 27:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[1, 6]]);
      }));

      return function (_x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }()
  );
}

function getGroupSyncables(groupID
/*: string*/
, syncableType
/*: SyncableType*/
)
/*: ActionFunc*/
{
  return (
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(dispatch, getState) {
        var data, type;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                dispatch({
                  type: _action_types.GroupTypes.GET_GROUP_SYNCABLES_REQUEST,
                  data: {
                    groupID: groupID
                  }
                });
                _context3.prev = 1;
                _context3.next = 4;
                return _client.Client4.getGroupSyncables(groupID, syncableType);

              case 4:
                data = _context3.sent;
                _context3.next = 12;
                break;

              case 7:
                _context3.prev = 7;
                _context3.t0 = _context3["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context3.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.GroupTypes.GET_GROUP_SYNCABLES_FAILURE,
                  error: _context3.t0,
                  data: {
                    groupID: groupID
                  }
                }, (0, _errors.logError)(_context3.t0)]));
                return _context3.abrupt("return", {
                  error: _context3.t0
                });

              case 12:
                _context3.t1 = syncableType;
                _context3.next = _context3.t1 === _constants.Groups.SYNCABLE_TYPE_TEAM ? 15 : _context3.t1 === _constants.Groups.SYNCABLE_TYPE_CHANNEL ? 17 : 19;
                break;

              case 15:
                type = _action_types.GroupTypes.RECEIVED_GROUP_TEAMS;
                return _context3.abrupt("break", 20);

              case 17:
                type = _action_types.GroupTypes.RECEIVED_GROUP_CHANNELS;
                return _context3.abrupt("break", 20);

              case 19:
                console.warn("unhandled syncable type ".concat(syncableType));

              case 20:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.GroupTypes.GET_GROUP_SYNCABLES_SUCCESS,
                  data: null
                }, {
                  type: type,
                  data: data,
                  group_id: groupID
                }]));
                return _context3.abrupt("return", {
                  data: true
                });

              case 22:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[1, 7]]);
      }));

      return function (_x5, _x6) {
        return _ref3.apply(this, arguments);
      };
    }()
  );
}

function getGroupMembers(groupID
/*: string*/
)
/*: ActionFunc*/
{
  var page
  /*: number*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var perPage
  /*: number*/
  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constants.General.PAGE_SIZE_DEFAULT;
  return (
    /*#__PURE__*/
    function () {
      var _ref4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(dispatch, getState) {
        var data;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                dispatch({
                  type: _action_types.GroupTypes.GET_GROUP_MEMBERS_REQUEST,
                  data: {
                    groupID: groupID,
                    page: page,
                    perPage: perPage
                  }
                });
                _context4.prev = 1;
                _context4.next = 4;
                return _client.Client4.getGroupMembers(groupID, page, perPage);

              case 4:
                data = _context4.sent;
                _context4.next = 12;
                break;

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context4.t0, dispatch, getState);
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.GroupTypes.GET_GROUP_MEMBERS_FAILURE,
                  error: _context4.t0,
                  data: {
                    groupID: groupID,
                    page: page,
                    perPage: perPage
                  }
                }, (0, _errors.logError)(_context4.t0)]));
                return _context4.abrupt("return", {
                  error: _context4.t0
                });

              case 12:
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.GroupTypes.GET_GROUP_MEMBERS_SUCCESS,
                  data: null
                }, {
                  type: _action_types.GroupTypes.RECEIVED_GROUP_MEMBERS,
                  group_id: groupID,
                  data: data
                }]));
                return _context4.abrupt("return", {
                  data: true
                });

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[1, 7]]);
      }));

      return function (_x7, _x8) {
        return _ref4.apply(this, arguments);
      };
    }()
  );
}

function getGroup(id
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getGroup,
    onRequest: _action_types.GroupTypes.GET_GROUP_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_GROUP, _action_types.GroupTypes.GET_GROUP_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_GROUP_FAILURE,
    params: [id]
  });
}

function getGroupsNotAssociatedToTeam(teamID
/*: string*/
)
/*: ActionFunc*/
{
  var q
  /*: string*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var page
  /*: number*/
  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var perPage
  /*: number*/
  = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.General.PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getGroupsNotAssociatedToTeam,
    onRequest: _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_TEAM_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_GROUPS, _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_TEAM_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_TEAM_FAILURE,
    params: [teamID, q, page, perPage]
  });
}

function getGroupsNotAssociatedToChannel(channelID
/*: string*/
)
/*: ActionFunc*/
{
  var q
  /*: string*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var page
  /*: number*/
  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var perPage
  /*: number*/
  = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.General.PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getGroupsNotAssociatedToChannel,
    onRequest: _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_CHANNEL_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_GROUPS, _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_CHANNEL_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_CHANNEL_FAILURE,
    params: [channelID, q, page, perPage]
  });
}

function getAllGroupsAssociatedToTeam(teamID
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: function () {
      var _clientFunc = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(param1) {
        var result;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return _client.Client4.getAllGroupsAssociatedToTeam(param1);

              case 2:
                result = _context5.sent;
                result.teamID = param1;
                return _context5.abrupt("return", result);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function clientFunc(_x9) {
        return _clientFunc.apply(this, arguments);
      }

      return clientFunc;
    }(),
    onRequest: _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_TEAM_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_ALL_GROUPS_ASSOCIATED_TO_TEAM, _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_TEAM_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_TEAM_FAILURE,
    params: [teamID]
  });
}

function getAllGroupsAssociatedToChannel(channelID
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: function () {
      var _clientFunc2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(param1) {
        var result;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return _client.Client4.getAllGroupsAssociatedToChannel(param1);

              case 2:
                result = _context6.sent;
                result.channelID = param1;
                return _context6.abrupt("return", result);

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function clientFunc(_x10) {
        return _clientFunc2.apply(this, arguments);
      }

      return clientFunc;
    }(),
    onRequest: _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_CHANNEL_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_ALL_GROUPS_ASSOCIATED_TO_CHANNEL, _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_CHANNEL_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_CHANNEL_FAILURE,
    params: [channelID]
  });
}

function getGroupsAssociatedToTeam(teamID
/*: string*/
)
/*: ActionFunc*/
{
  var q
  /*: string*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var page
  /*: number*/
  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var perPage
  /*: number*/
  = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.General.PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: function () {
      var _clientFunc3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(param1, param2, param3, param4) {
        var result;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return _client.Client4.getGroupsAssociatedToTeam(param1, param2, param3, param4);

              case 2:
                result = _context7.sent;
                return _context7.abrupt("return", {
                  groups: result.groups,
                  totalGroupCount: result.total_group_count,
                  teamID: param1
                });

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function clientFunc(_x11, _x12, _x13, _x14) {
        return _clientFunc3.apply(this, arguments);
      }

      return clientFunc;
    }(),
    onRequest: _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_TEAM_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_GROUPS_ASSOCIATED_TO_TEAM, _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_TEAM_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_TEAM_FAILURE,
    params: [teamID, q, page, perPage]
  });
}

function getGroupsAssociatedToChannel(channelID
/*: string*/
)
/*: ActionFunc*/
{
  var q
  /*: string*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var page
  /*: number*/
  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var perPage
  /*: number*/
  = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.General.PAGE_SIZE_DEFAULT;
  return (0, _helpers.bindClientFunc)({
    clientFunc: function () {
      var _clientFunc4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(param1, param2, param3, param4) {
        var result;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return _client.Client4.getGroupsAssociatedToChannel(param1, param2, param3, param4);

              case 2:
                result = _context8.sent;
                return _context8.abrupt("return", {
                  groups: result.groups,
                  totalGroupCount: result.total_group_count,
                  channelID: param1
                });

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function clientFunc(_x15, _x16, _x17, _x18) {
        return _clientFunc4.apply(this, arguments);
      }

      return clientFunc;
    }(),
    onRequest: _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_CHANNEL_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_GROUPS_ASSOCIATED_TO_CHANNEL, _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_CHANNEL_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_CHANNEL_FAILURE,
    params: [channelID, q, page, perPage]
  });
}

/***/ }),

/***/ 1684:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/html-to-react/index.js
var html_to_react = __webpack_require__(2328);

// EXTERNAL MODULE: ./components/at_mention/index.jsx + 1 modules
var at_mention = __webpack_require__(2264);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// CONCATENATED MODULE: ./components/latex_block.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class latex_block_LatexBlock extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.state = {
      katex: null
    };
  }

  componentDidMount() {
    __webpack_require__.e(/* import() */ 35).then(__webpack_require__.t.bind(null, 3481, 7)).then(katex => {
      this.setState({
        katex
      });
    });
  }

  render() {
    if (this.state.katex == null) {
      return react_default.a.createElement("div", {
        className: "post-body--code tex"
      }, this.props.content);
    }

    try {
      const html = this.state.katex.renderToString(this.props.content, {
        throwOnError: false,
        displayMode: true
      });
      return react_default.a.createElement("div", {
        className: "post-body--code tex",
        dangerouslySetInnerHTML: {
          __html: html
        }
      });
    } catch (e) {
      return react_default.a.createElement("div", {
        className: "post-body--code tex"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "katex.error",
        defaultMessage: "Couldn't compile your Latex code. Please review the syntax and try again."
      }));
    }
  }

}

_defineProperty(latex_block_LatexBlock, "propTypes", {
  content: prop_types_default.a.string.isRequired
});
// EXTERNAL MODULE: ./components/size_aware_image.jsx
var size_aware_image = __webpack_require__(1728);

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/utils/emoji_utils.js
var emoji_utils = __webpack_require__(250);

// EXTERNAL MODULE: ./selectors/emojis.js + 1 modules
var emojis = __webpack_require__(119);

// CONCATENATED MODULE: ./components/post_emoji/post_emoji.jsx
function post_emoji_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class post_emoji_PostEmoji extends react_default.a.PureComponent {
  render() {
    const emojiText = ':' + this.props.name + ':';

    if (!this.props.imageUrl) {
      return emojiText;
    }

    return react_default.a.createElement("span", {
      alt: emojiText,
      className: "emoticon",
      title: emojiText,
      style: {
        backgroundImage: 'url(' + this.props.imageUrl + ')'
      }
    });
  }

}

post_emoji_defineProperty(post_emoji_PostEmoji, "propTypes", {
  /*
   * Emoji name.
   */
  name: prop_types_default.a.string.isRequired,

  /*
   * Emoji image URL.
   */
  imageUrl: prop_types_default.a.string.isRequired
});
// CONCATENATED MODULE: ./components/post_emoji/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function mapStateToProps(state, ownProps) {
  const emojiMap = Object(emojis["a" /* getEmojiMap */])(state);
  const emoji = emojiMap.get(ownProps.name);
  return {
    imageUrl: emoji ? Object(emoji_utils["getEmojiImageUrl"])(emoji) : ''
  };
}

/* harmony default export */ var post_emoji = (Object(es["connect"])(mapStateToProps)(post_emoji_PostEmoji));
// EXTERNAL MODULE: ./components/link_tooltip/link_tooltip.jsx
var link_tooltip = __webpack_require__(2373);

// CONCATENATED MODULE: ./utils/message_html_to_component.jsx
/* unused harmony export messageHtmlToComponent */
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







/*
 * Converts HTML to React components using html-to-react.
 * The following options can be specified:
 * - mentions - If specified, mentions are replaced with the AtMention component. Defaults to true.
 * - emoji - If specified, emoji text is replaced with the PostEmoji component. Defaults to true.
 * - images - If specified, markdown images are replaced with the image component. Defaults to true.
 * - imageProps - If specified, any extra props that should be passed into the image component.
 * - latex - If specified, latex is replaced with the LatexBlock component. Defaults to true.
 * - imagesMetadata - the dimensions of the image as retrieved from post.metadata.images.
 * - hasPluginTooltips - If specified, the LinkTooltip component is placed inside links. Defaults to false.
 */

function messageHtmlToComponent(html, isRHS, options = {}) {
  if (!html) {
    return null;
  }

  const parser = new html_to_react["Parser"]();
  const processNodeDefinitions = new html_to_react["ProcessNodeDefinitions"](react_default.a);

  function isValidNode() {
    return true;
  }

  const processingInstructions = [// Workaround to fix MM-14931
  {
    replaceChildren: false,
    shouldProcessNode: node => node.type === 'tag' && node.name === 'input' && node.attribs.type === 'checkbox',
    processNode: node => {
      const attribs = node.attribs || {};
      node.attribs.checked = Boolean(attribs.checked);
      return react_default.a.createElement('input', { ...node.attribs
      });
    }
  }];

  if (options.hasPluginTooltips) {
    const hrefAttrib = 'href';
    processingInstructions.push({
      replaceChildren: true,
      shouldProcessNode: node => node.type === 'tag' && node.name === 'a' && node.attribs[hrefAttrib],
      processNode: (node, children) => {
        return react_default.a.createElement(link_tooltip["a" /* default */], {
          href: node.attribs[hrefAttrib],
          title: children[0]
        });
      }
    });
  }

  if (!('mentions' in options) || options.mentions) {
    const mentionAttrib = 'data-mention';
    processingInstructions.push({
      replaceChildren: true,
      shouldProcessNode: node => node.attribs && node.attribs[mentionAttrib],
      processNode: (node, children) => {
        const mentionName = node.attribs[mentionAttrib];
        const callAtMention = react_default.a.createElement(at_mention["a" /* default */], {
          mentionName: mentionName,
          isRHS: isRHS,
          hasMention: true
        }, children);
        return callAtMention;
      }
    });
  }

  if (!('emoji' in options) || options.emoji) {
    const emojiAttrib = 'data-emoticon';
    processingInstructions.push({
      replaceChildren: true,
      shouldProcessNode: node => node.attribs && node.attribs[emojiAttrib],
      processNode: node => {
        const emojiName = node.attribs[emojiAttrib];
        return react_default.a.createElement(post_emoji, {
          name: emojiName
        });
      }
    });
  }

  if (!('images' in options) || options.images) {
    processingInstructions.push({
      shouldProcessNode: node => node.type === 'tag' && node.name === 'img',
      processNode: node => {
        const {
          class: className,
          ...attribs
        } = node.attribs;
        return react_default.a.createElement(size_aware_image["a" /* default */], _extends({
          className: className,
          dimensions: options.imagesMetadata && options.imagesMetadata[attribs.src]
        }, attribs, options.imageProps));
      }
    });
  }

  if (!('latex' in options) || options.latex) {
    processingInstructions.push({
      shouldProcessNode: node => node.attribs && node.attribs['data-latex'],
      processNode: node => {
        return react_default.a.createElement(latex_block_LatexBlock, {
          content: node.attribs['data-latex']
        });
      }
    });
  }

  processingInstructions.push({
    shouldProcessNode: () => true,
    processNode: processNodeDefinitions.processDefaultNode
  });
  return parser.parseWithInstructions(html, isValidNode, processingInstructions);
}
/* harmony default export */ var message_html_to_component = __webpack_exports__["a"] = (messageHtmlToComponent);

/***/ }),

/***/ 1685:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./node_modules/react-select/dist/react-select.esm.js + 1 modules
var react_select_esm = __webpack_require__(1967);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./components/save_button.jsx
var save_button = __webpack_require__(1612);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/loading_screen.jsx
var loading_screen = __webpack_require__(1569);

// CONCATENATED MODULE: ./components/multiselect/multiselect_list.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const KeyCodes = constants["N" /* default */].KeyCodes;
class multiselect_list_MultiSelectList extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.defaultOptionRenderer = this.defaultOptionRenderer.bind(this);
    this.handleArrowPress = this.handleArrowPress.bind(this);
    this.setSelected = this.setSelected.bind(this);
    this.toSelect = -1;
    this.state = {
      selected: -1
    };
  }

  componentDidMount() {
    document.addEventListener('keydown', this.handleArrowPress);
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleArrowPress);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    this.setState({
      selected: this.toSelect
    });
    const options = nextProps.options;

    if (options && options.length > 0 && this.toSelect >= 0) {
      this.props.onSelect(options[this.toSelect]);
    }
  }

  componentDidUpdate(_, prevState) {
    if (prevState.selected === this.state.selected) {
      return;
    }

    if (this.refs.list && this.refs.selected) {
      const elemTop = this.refs.selected.getBoundingClientRect().top;
      const elemBottom = this.refs.selected.getBoundingClientRect().bottom;
      const listTop = this.refs.list.getBoundingClientRect().top;
      const listBottom = this.refs.list.getBoundingClientRect().bottom;

      if (elemBottom > listBottom) {
        this.refs.selected.scrollIntoView(false);
      } else if (elemTop < listTop) {
        this.refs.selected.scrollIntoView(true);
      }
    }
  }

  setSelected(selected) {
    this.toSelect = selected;
  }

  handleArrowPress(e) {
    if (Object(utils["e" /* cmdOrCtrlPressed */])(e) && e.shiftKey) {
      return;
    }

    const options = this.props.options;

    if (options.length === 0) {
      return;
    }

    let selected;

    switch (e.key) {
      case KeyCodes.DOWN[0]:
        if (this.state.selected === -1) {
          selected = 0;
          break;
        }

        selected = Math.min(this.state.selected + 1, options.length - 1);
        break;

      case KeyCodes.UP[0]:
        if (this.state.selected === -1) {
          selected = 0;
          break;
        }

        selected = Math.max(this.state.selected - 1, 0);
        break;

      default:
        return;
    }

    e.preventDefault();
    this.setState({
      selected
    });
    this.setSelected(selected);
    this.props.onSelect(options[selected]);
  }

  defaultOptionRenderer(option, isSelected, onAdd) {
    var rowSelected = '';

    if (isSelected) {
      rowSelected = 'more-modal__row--selected';
    }

    return react_default.a.createElement("div", {
      ref: isSelected ? 'selected' : option.value,
      className: rowSelected,
      key: 'multiselectoption' + option.value,
      onClick: () => onAdd(option)
    }, option.label);
  }

  render() {
    const options = this.props.options;

    if (this.props.loading) {
      return react_default.a.createElement("div", null, react_default.a.createElement(loading_screen["a" /* default */], {
        position: "absolute",
        key: "loading"
      }));
    }

    if (options == null || options.length === 0) {
      return react_default.a.createElement("div", {
        key: "no-users-found",
        className: "no-channel-message"
      }, react_default.a.createElement("p", {
        className: "primary-message"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "multiselect.list.notFound",
        defaultMessage: "No items found"
      })));
    }

    let renderer;

    if (this.props.optionRenderer) {
      renderer = this.props.optionRenderer;
    } else {
      renderer = this.defaultOptionRenderer;
    }

    const optionControls = options.map((o, i) => renderer(o, this.state.selected === i, this.props.onAdd));
    return react_default.a.createElement("div", {
      className: "more-modal__list"
    }, react_default.a.createElement("div", {
      ref: "list"
    }, optionControls));
  }

}
multiselect_list_MultiSelectList.defaultProps = {
  options: [],
  perPage: 50,
  onAction: () => null
};
multiselect_list_MultiSelectList.propTypes = {
  options: prop_types_default.a.arrayOf(prop_types_default.a.object),
  optionRenderer: prop_types_default.a.func,
  page: prop_types_default.a.number,
  perPage: prop_types_default.a.number,
  onPageChange: prop_types_default.a.func,
  onAdd: prop_types_default.a.func,
  onSelect: prop_types_default.a.func,
  loading: prop_types_default.a.bool
};
// CONCATENATED MODULE: ./components/multiselect/multiselect.jsx
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return multiselect_MultiSelect; });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const multiselect_KeyCodes = constants["g" /* Constants */].KeyCodes;
class multiselect_MultiSelect extends react_default.a.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "nextPage", () => {
      if (this.props.handlePageChange) {
        this.props.handlePageChange(this.state.page + 1, this.state.page);
      }

      if (this.refs.list) {
        this.refs.list.setSelected(0);
      }

      this.setState({
        page: this.state.page + 1
      });
    });

    _defineProperty(this, "prevPage", () => {
      if (this.state.page === 0) {
        return;
      }

      if (this.props.handlePageChange) {
        this.props.handlePageChange(this.state.page - 1, this.state.page);
      }

      this.refs.list.setSelected(0);
      this.setState({
        page: this.state.page - 1
      });
    });

    _defineProperty(this, "resetPaging", () => {
      this.setState({
        page: 0
      });
    });

    _defineProperty(this, "onSelect", selected => {
      this.selected = selected;
    });

    _defineProperty(this, "onAdd", value => {
      if (this.props.maxValues && this.props.values.length >= this.props.maxValues) {
        return;
      }

      for (let i = 0; i < this.props.values.length; i++) {
        if (this.props.values[i].id === value.id) {
          return;
        }
      }

      this.props.handleAdd(value);
      this.selected = null;
      this.refs.reactSelect.select.handleInputChange({
        currentTarget: {
          value: ''
        }
      });
      this.onInput('');
      this.refs.reactSelect.focus();
      const submitImmediatelyOn = this.props.submitImmediatelyOn;

      if (submitImmediatelyOn && submitImmediatelyOn(value)) {
        this.props.handleSubmit([value]);
      }
    });

    _defineProperty(this, "onInput", (input, change = {}) => {
      if (change.action === 'input-blur' || change.action === 'menu-close') {
        return;
      }

      if (this.state.input === input) {
        return;
      }

      this.setState({
        input
      });

      if (input === '') {
        this.refs.list.setSelected(-1);
      } else {
        this.refs.list.setSelected(0);
      }

      this.selected = null;
      this.props.handleInput(input, this);
    });

    _defineProperty(this, "onInputKeyDown", e => {
      switch (e.key) {
        case multiselect_KeyCodes.ENTER[0]:
          e.preventDefault();
          break;
      }
    });

    _defineProperty(this, "handleEnterPress", e => {
      switch (e.key) {
        case multiselect_KeyCodes.ENTER[0]:
          if (this.selected == null) {
            this.props.handleSubmit();
            return;
          }

          this.onAdd(this.selected);
          break;
      }
    });

    _defineProperty(this, "handleOnClick", e => {
      e.preventDefault();
      this.props.handleSubmit();
    });

    _defineProperty(this, "onChange", (_, change) => {
      if (change.action !== 'remove-value' && change.action !== 'pop-value') {
        return;
      }

      const values = [...this.props.values];

      for (let i = 0; i < values.length; i++) {
        if (values[i].id === change.removedValue.id) {
          values.splice(i, 1);
          break;
        }
      }

      this.props.handleDelete(values);
    });

    this.selected = null;
    this.state = {
      page: 0,
      input: ''
    };
  }

  componentDidMount() {
    document.addEventListener('keydown', this.handleEnterPress);

    if (this.refs.reactSelect) {
      this.refs.reactSelect.focus();
    }
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleEnterPress);
  }

  render() {
    const options = Object.assign([], this.props.options);
    const {
      totalCount,
      users,
      values
    } = this.props;
    let numRemainingText;

    if (this.props.numRemainingText) {
      numRemainingText = this.props.numRemainingText;
    } else if (this.props.maxValues != null) {
      numRemainingText = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "multiselect.numRemaining",
        defaultMessage: "You can add {num, number} more. ",
        values: {
          num: this.props.maxValues - this.props.values.length
        }
      });
    }

    let buttonSubmitText;

    if (this.props.buttonSubmitText) {
      buttonSubmitText = this.props.buttonSubmitText;
    } else if (this.props.maxValues != null) {
      buttonSubmitText = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "multiselect.go",
        defaultMessage: "Go"
      });
    }

    let optionsToDisplay = [];
    let nextButton;
    let previousButton;
    let noteTextContainer;

    if (this.props.noteText) {
      noteTextContainer = react_default.a.createElement("div", {
        className: "multi-select__note"
      }, react_default.a.createElement("div", {
        className: "note__icon"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "generic_icons.info",
        defaultMessage: "Info Icon"
      }, title => react_default.a.createElement("span", {
        className: "fa fa-info",
        title: title
      }))), react_default.a.createElement("div", null, this.props.noteText));
    }

    const valueMap = {};

    for (let i = 0; i < values.length; i++) {
      valueMap[values[i].id] = true;
    }

    for (let i = options.length - 1; i >= 0; i--) {
      if (valueMap[options[i].id]) {
        options.splice(i, 1);
      }
    }

    if (options && options.length > this.props.perPage) {
      const pageStart = this.state.page * this.props.perPage;
      const pageEnd = pageStart + this.props.perPage;
      optionsToDisplay = options.slice(pageStart, pageEnd);

      if (!this.props.loading) {
        if (options.length > pageEnd) {
          nextButton = react_default.a.createElement("button", {
            className: "btn btn-link filter-control filter-control__next",
            onClick: this.nextPage
          }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "filtered_user_list.next",
            defaultMessage: "Next"
          }));
        }

        if (this.state.page > 0) {
          previousButton = react_default.a.createElement("button", {
            className: "btn btn-link filter-control filter-control__prev",
            onClick: this.prevPage
          }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "filtered_user_list.prev",
            defaultMessage: "Previous"
          }));
        }
      }
    } else {
      optionsToDisplay = options;
    }

    let memberCount;

    if (users && users.length && totalCount) {
      memberCount = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "multiselect.numMembers",
        defaultMessage: "{memberOptions, number} of {totalCount, number} members",
        values: {
          memberOptions: optionsToDisplay.length,
          totalCount: this.props.totalCount
        }
      });
    }

    return react_default.a.createElement("div", {
      className: "filtered-user-list"
    }, react_default.a.createElement("div", {
      className: "filter-row filter-row--full"
    }, react_default.a.createElement("div", {
      className: "multi-select__container"
    }, react_default.a.createElement(react_select_esm["a" /* default */], {
      id: "selectItems",
      ref: "reactSelect",
      isMulti: true,
      options: this.props.options,
      styles: styles,
      components: {
        Menu: nullComponent,
        IndicatorsContainer: nullComponent,
        MultiValueLabel: paddedComponent(this.props.valueRenderer)
      },
      isClearable: false,
      openMenuOnFocus: false,
      onInputChange: this.onInput,
      onKeyDown: this.onInputKeyDown,
      onChange: this.onChange,
      value: this.props.values,
      placeholder: this.props.placeholderText,
      inputValue: this.state.input,
      getOptionValue: option => option.id
    }), react_default.a.createElement(save_button["a" /* default */], {
      id: "saveItems",
      saving: this.props.saving,
      disabled: this.props.saving,
      onClick: this.handleOnClick,
      defaultMessage: buttonSubmitText,
      savingMessage: this.props.buttonSubmitLoadingText
    })), react_default.a.createElement("div", {
      className: "multi-select__help"
    }, numRemainingText, memberCount), react_default.a.createElement("div", {
      className: "multi-select__help"
    }, noteTextContainer)), react_default.a.createElement(multiselect_list_MultiSelectList, {
      ref: "list",
      options: optionsToDisplay,
      optionRenderer: this.props.optionRenderer,
      page: this.state.page,
      perPage: this.props.perPage,
      onPageChange: this.props.handlePageChange,
      onAdd: this.onAdd,
      onSelect: this.onSelect,
      loading: this.props.loading
    }), react_default.a.createElement("div", {
      className: "filter-controls"
    }, previousButton, nextButton));
  }

}

_defineProperty(multiselect_MultiSelect, "propTypes", {
  users: prop_types_default.a.arrayOf(prop_types_default.a.object),
  totalCount: prop_types_default.a.number,
  options: prop_types_default.a.arrayOf(prop_types_default.a.object),
  optionRenderer: prop_types_default.a.func,
  values: prop_types_default.a.arrayOf(prop_types_default.a.object),
  valueRenderer: prop_types_default.a.func,
  handleInput: prop_types_default.a.func,
  handleDelete: prop_types_default.a.func,
  perPage: prop_types_default.a.number,
  handlePageChange: prop_types_default.a.func,
  handleAdd: prop_types_default.a.func,
  handleSubmit: prop_types_default.a.func,
  noteText: prop_types_default.a.node,
  maxValues: prop_types_default.a.number,
  numRemainingText: prop_types_default.a.node,
  buttonSubmitText: prop_types_default.a.node,
  buttonSubmitLoadingText: prop_types_default.a.node,
  submitImmediatelyOn: prop_types_default.a.func,
  saving: prop_types_default.a.bool,
  loading: prop_types_default.a.bool,
  placeholderText: prop_types_default.a.string
});

const nullComponent = () => null;

const paddedComponent = WrappedComponent => {
  return props => {
    return react_default.a.createElement("div", {
      style: {
        paddingRight: '5px',
        paddingLeft: '5px',
        borderRight: '1px solid rgba(0, 126, 255, 0.24)'
      }
    }, react_default.a.createElement(WrappedComponent, props));
  };
};

const styles = {
  container: () => {
    return {
      display: 'table-cell',
      paddingRight: '15px',
      verticalAlign: 'top',
      width: '100%'
    };
  },
  control: base => {
    return { ...base,
      borderRadius: '1px',
      borderColor: 'hsl(0,0%,80%)',
      minHeight: '36px',
      '&:hover': {},
      boxShadow: '',
      backgroundColor: 'hsl(0,0%,100%)'
    };
  },
  multiValue: base => {
    return { ...base,
      whiteSpace: 'nowrap',
      border: '1px solid rgba(0, 126, 255, 0.24)',
      backgroundColor: 'rgba(0, 126, 255, 0.08)',
      color: '#007eff'
    };
  },
  multiValueRemove: base => {
    return { ...base,
      ':hover': {
        backgroundColor: 'rgba(0, 126, 255, 0.15)'
      }
    };
  }
};

/***/ }),

/***/ 1686:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/roles.js
var roles = __webpack_require__(90);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// CONCATENATED MODULE: ./components/permissions_gates/system_permission_gate/system_permission_gate.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class system_permission_gate_SystemPermissionGate extends react_default.a.Component {
  render() {
    if (this.props.hasPermission && !this.props.invert) {
      return this.props.children;
    }

    if (!this.props.hasPermission && this.props.invert) {
      return this.props.children;
    }

    return null;
  }

}

_defineProperty(system_permission_gate_SystemPermissionGate, "defaultProps", {
  invert: false
});

_defineProperty(system_permission_gate_SystemPermissionGate, "propTypes", {
  /**
   * Permissions enough to pass the gate (binary OR)
   */
  permissions: prop_types_default.a.arrayOf(prop_types_default.a.string).isRequired,

  /**
   * Has permission
   */
  hasPermission: prop_types_default.a.bool.isRequired,

  /**
   * Invert the permission (used for else)
   */
  invert: prop_types_default.a.bool.isRequired,

  /**
   * Content protected by the permissions gate
   */
  children: prop_types_default.a.node.isRequired
});
// CONCATENATED MODULE: ./components/permissions_gates/system_permission_gate/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function mapStateToProps(state, ownProps) {
  for (const permission of ownProps.permissions) {
    if (Object(roles["haveISystemPermission"])(state, {
      permission
    })) {
      return {
        hasPermission: true
      };
    }
  }

  return {
    hasPermission: false
  };
}

/* harmony default export */ var system_permission_gate = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(system_permission_gate_SystemPermissionGate));

/***/ }),

/***/ 1687:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/actions/teams.js
var teams = __webpack_require__(299);

// EXTERNAL MODULE: ./mattermost-redux/actions/users.js
var actions_users = __webpack_require__(35);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var entities_users = __webpack_require__(10);

// EXTERNAL MODULE: ./actions/channel_actions.jsx
var channel_actions = __webpack_require__(1593);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/antd/es/modal/index.js + 3 modules
var modal = __webpack_require__(1552);

// EXTERNAL MODULE: ./node_modules/antd/es/icon/index.js + 3 modules
var icon = __webpack_require__(93);

// EXTERNAL MODULE: ./node_modules/antd/es/input/index.js + 7 modules
var input = __webpack_require__(3484);

// EXTERNAL MODULE: ./node_modules/antd/es/spin/index.js
var spin = __webpack_require__(2466);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./mattermost-redux/client/index.js
var client = __webpack_require__(27);

// EXTERNAL MODULE: ./mattermost-redux/utils/user_utils.js
var user_utils = __webpack_require__(104);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/profile_picture.jsx
var profile_picture = __webpack_require__(1656);

// EXTERNAL MODULE: ./components/multiselect/multiselect.jsx + 1 modules
var multiselect = __webpack_require__(1685);

// EXTERNAL MODULE: ./components/icon/add_icon.jsx
var add_icon = __webpack_require__(1696);

// EXTERNAL MODULE: ./components/widgets/badges/bot_badge.jsx
var bot_badge = __webpack_require__(1588);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./api/uaApi.js
var uaApi = __webpack_require__(2464);

// EXTERNAL MODULE: ./node_modules/antd/es/tree/index.js + 4 modules
var tree = __webpack_require__(3488);

// EXTERNAL MODULE: ./node_modules/antd/es/checkbox/index.js + 2 modules
var es_checkbox = __webpack_require__(3492);

// EXTERNAL MODULE: ./components/quick_input.jsx
var quick_input = __webpack_require__(1766);

// EXTERNAL MODULE: ./components/svg/search_icon.jsx
var search_icon = __webpack_require__(1672);

// EXTERNAL MODULE: ./mattermost-redux/actions/helpers.js
var helpers = __webpack_require__(117);

// EXTERNAL MODULE: ./api/post.js
var post = __webpack_require__(67);

// EXTERNAL MODULE: ./components/channel_new_invite_modal/index.scss
var channel_new_invite_modal = __webpack_require__(2465);

// CONCATENATED MODULE: ./components/channel_new_invite_modal/channel_new_invite_modal.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



















const {
  TreeNode
} = tree["a" /* default */];
const USERS_PER_PAGE = 50;
const MAX_SELECTABLE_VALUES = 20;
class channel_new_invite_modal_ChannelInviteModal extends react_default.a.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "addValue", value => {
      const values = Object.assign([], this.state.values);

      if (values.indexOf(value) === -1) {
        values.push(value);
      }

      this.setState({
        values
      });
    });

    _defineProperty(this, "onHide", () => {
      this.setState({
        show: false
      });
      this.props.onHide();
    });

    _defineProperty(this, "handleInviteError", err => {
      if (err) {
        this.setState({
          saving: false,
          inviteError: err.message
        });
      }
    });

    _defineProperty(this, "handleDelete", values => {
      this.setState({
        values
      });
    });

    _defineProperty(this, "setUsersLoadingState", loadingState => {
      this.setState({
        loadingUsers: loadingState
      });
    });

    _defineProperty(this, "handlePageChange", (page, prevPage) => {
      if (page > prevPage) {
        this.setUsersLoadingState(true);
        this.props.actions.getProfilesNotInChannel(this.props.channel.team_id, this.props.channel.id, this.props.channel.group_constrained, page + 1, USERS_PER_PAGE).then(() => {
          this.setUsersLoadingState(false);
        });
      }
    });

    _defineProperty(this, "handleSubmit", e => {
      if (e) {
        e.preventDefault();
      } //如果有值说明是邀请过来的


      if (this.props.otherData) {
        if (this.state.checkedData.length === 0) {
          return;
        }

        let inviteData = {};
        inviteData.post = this.props.otherData;
        inviteData.user_names = [];
        this.state.checkedData.forEach(item => {
          inviteData.user_names.push(item.adAccount);
        });
        Object(post["p" /* sendPostList */])(inviteData).then(res => {
          this.setState({
            saving: false,
            inviteError: null
          });
          this.onHide();
        });
        return;
      }

      const userIds = this.foundMemberList();

      if (userIds.length === 0) {
        return;
      }

      console.log("-----", userIds);
      this.props.actions.addUsersToChannel(this.props.channel.id, userIds).then(result => {
        if (result.error) {
          this.handleInviteError(result.error);
        } else {
          this.setState({
            saving: false,
            inviteError: null
          });
          this.onHide();
        }
      });
    });

    _defineProperty(this, "renderOption", (option, isSelected) => {
      var rowSelected = "";

      if (isSelected) {
        rowSelected = "more-modal__row--selected";
      }

      return react_default.a.createElement("div", {
        key: option.id,
        ref: isSelected ? "selected" : option.id,
        className: "more-modal__row clickable " + rowSelected
      }, react_default.a.createElement(profile_picture["a" /* default */], {
        src: client["Client4"].getProfilePictureUrl(option.id, option.last_picture_update),
        width: "32",
        height: "32"
      }), react_default.a.createElement("div", {
        className: "more-modal__details"
      }, react_default.a.createElement("div", {
        className: "more-modal__name"
      }, Object(utils["m" /* displayEntireNameForUser */])(option), react_default.a.createElement(bot_badge["a" /* default */], {
        show: Boolean(option.is_bot),
        className: "badge-popoverlist"
      }))), react_default.a.createElement("div", {
        className: "more-modal__actions"
      }, react_default.a.createElement("div", {
        className: "more-modal__actions--round"
      }, react_default.a.createElement(add_icon["a" /* default */], null))));
    });

    _defineProperty(this, "onCheck", (checkedKeys, info) => {
      const checkedData = this.state.checkedData;
      const allCheckedKeys = this.state.allCheckedKeys;
      const data = info.node.props.dataRef;

      if (info.checked) {
        checkedData.push(data);
        allCheckedKeys.push(data.key);
      } else {
        const index1 = checkedData.findIndex(item => item.id === data.id);
        const index2 = allCheckedKeys.findIndex(item => item === data.key);
        checkedData.splice(index1, 1);
        allCheckedKeys.splice(index2, 1);
      }

      this.setState({
        treeCheckedKeys: checkedKeys,
        allCheckedKeys,
        checkedData
      });
    });

    _defineProperty(this, "onExpand", expandedKeys => {
      this.setState({
        expandedKeys,
        autoExpandParent: false
      });
    });

    _defineProperty(this, "onLoadData", treeNode => new Promise(resolve => {
      if (!treeNode.props.children) {
        resolve();
        return;
      }

      Object(uaApi["b" /* getUAListMember */])(this.state.token, treeNode.props.dataRef.id).then(res => {
        const children = res.map(item => {
          let data = {
            key: item.id.toString(),
            id: item.id,
            title: item.name,
            companyId: item.companyId,
            departmentId: item.departmentId,
            adAccount: item.adAccount,
            deptNameTree: this.filterDeptNameTree(item.deptNameTree)
          };
          let index = this.props.users.findIndex(item1 => item1.username === item.adAccount);
          const checked = this.state.allCheckedKeys.indexOf(data.key) > -1;

          if (index > -1 && checked) {
            data.disabled = true;
            this.state.treeCheckedKeys.push(data.key);
          } else if (index > -1 && !checked) {
            data.disabled = true;
            this.state.allCheckedKeys.push(data.key);
            this.state.treeCheckedKeys.push(data.key);
          } else if (checked) {
            this.state.treeCheckedKeys.push(data.key);
          }

          return data;
        });
        treeNode.props.dataRef.children = children.concat(treeNode.props.dataRef.children);
        this.setState({
          treeData: [...this.state.treeData],
          treeCheckedKeys: this.state.treeCheckedKeys,
          allCheckedKeys: this.state.allCheckedKeys,
          treeMembers: this.state.treeMembers.concat(children)
        });
        resolve();
      });
    }));

    _defineProperty(this, "renderTreeNodes", data => data.map(item => {
      if (item.children) {
        return react_default.a.createElement(TreeNode, {
          title: item.title,
          key: item.key,
          dataRef: item,
          disabled: item.disabled,
          className: 'checkbox-hide'
        }, this.renderTreeNodes(item.children));
      }

      return react_default.a.createElement(TreeNode, _extends({
        key: item.key
      }, item, {
        dataRef: item,
        className: "user-node"
      }));
    }));

    _defineProperty(this, "search", Object(helpers["debounce"])(value => {
      this.setState({
        loading: true,
        searchValue: value
      });

      if (!value) {
        this.setState({
          loading: false
        });
        return;
      }

      Object(uaApi["d" /* queryEmployeeByAd */])(this.state.token, value).then(res => {
        const searchData = res.map(item => {
          let data = {
            key: item.id.toString(),
            id: item.id,
            title: item.name,
            companyId: item.companyId,
            departmentId: item.departmentId,
            adAccount: item.adAccount,
            deptNameTree: this.filterDeptNameTree(item.deptNameTree)
          };
          let index = this.props.users.findIndex(item1 => item1.username === item.adAccount);

          if (index > -1) {
            data.disabled = true;
            this.state.allCheckedKeys.push(data.key);
          }

          return data;
        });
        this.setState({
          loading: false,
          searchData: searchData
        });
      });
    }, 300));

    this.searchTimeoutId = 0;
    this.state = {
      values: [],
      term: "",
      show: true,
      saving: false,
      loadingUsers: true,
      token: "",
      activeKey: "1",
      uaList: [],
      uaMemberObject: {},
      isDo: false,
      //是否已经加载过 adAccount
      autoExpandParent: true,
      expandedKeys: [],
      treeCheckedKeys: [],
      // 树的已选择项，需要此字段是因为如果列表数据已勾选，而在树中还未加载该数据，则会报错
      treeMembers: [],
      // 树结构已加载的人员列表
      allCheckedKeys: [],
      // 搜索列表以及树合并的已选择项
      checkedData: [],
      // 已选择的成员信息
      treeData: [],
      // 树结构
      searchData: [],
      // 搜索数据
      focused: false,
      loading: false
    };
  }

  // 列表转化为树结构
  toTreeData(data) {
    let resData = data;
    let tree = []; // const ou = CompanyOU[this.props.currentUser.ou] ? CompanyOU[this.props.currentUser.ou] : this.props.currentUser.ou
    // 筛选对应的公司
    // data.forEach(item => {
    //   if (item.id == ou ||  item.treeCode && item.treeCode.indexOf(ou) > -1) {
    //     resData.push(item)
    //   }
    // })

    for (let i = 0; i < resData.length; i++) {
      if (resData[i].parentId < 0) {
        let obj = {
          key: resData[i].id.toString(),
          id: resData[i].id,
          title: resData[i].name,
          children: []
        };
        tree.push(obj);
        resData.splice(i, 1);
        i--;
      }
    }

    run(tree);

    function run(chiArr) {
      if (resData.length !== 0) {
        for (let i = 0; i < chiArr.length; i++) {
          for (let j = 0; j < resData.length; j++) {
            if (chiArr[i].id === resData[j].parentId) {
              let obj = {
                key: resData[j].id.toString(),
                id: resData[j].id,
                title: resData[j].name,
                children: []
              };
              chiArr[i].children.push(obj);
              resData.splice(j, 1);
              j--;
            }
          }

          run(chiArr[i].children);
        }
      }
    }

    return tree;
  }

  componentDidMount() {
    this.setUsersLoadingState(true);
    Object(uaApi["c" /* getUAToken */])().then(res => {
      this.setState({
        token: res
      });
      Object(uaApi["a" /* getUABuList */])(this.state.token).then(res => {
        const tree = this.toTreeData(res); // this.setState({treeData: tree, expandedKeys: tree[0] ? [tree[0].key] : []})

        this.setState({
          treeData: tree
        });
      }).catch(err => {
        console.log('error:', err);
      });
    }).catch(err => {
      console.log('error:', err);
    });
  } //关闭弹出


  //查找所有邀请人员
  foundMemberList() {
    let userIds = [];
    this.state.checkedData.forEach(item => {
      userIds.push(JSON.stringify({
        userId: item.adAccount,
        companyId: item.companyId.toString()
      }));
    });
    return userIds;
  } //提交邀请


  filterDeptNameTree(value) {
    if (!value) {
      return value;
    }

    const arr = value.split('/');
    const length = arr.length;

    if (length <= 2) {
      return arr.join('-');
    }

    return arr[length - 2] + '-' + arr[length - 1];
  }

  // 从已选择的成员当中删除
  deleteUser(data) {
    let checkedData = this.state.checkedData;
    let allCheckedKeys = this.state.allCheckedKeys;
    let treeCheckedKeys = this.state.treeCheckedKeys;
    checkedData.splice(checkedData.findIndex(item => item.id === data.id), 1);
    allCheckedKeys.splice(allCheckedKeys.indexOf(data.key), 1);
    treeCheckedKeys.splice(treeCheckedKeys.indexOf(data.key), 1); // 如果当前节点的父节点是选中状态，当子节点有一个未选中时，父节点需要改为未选中

    if (data.departmentId) {
      const index1 = allCheckedKeys.indexOf(data.departmentId.toString());
      const index2 = treeCheckedKeys.indexOf(data.departmentId.toString());

      if (index1 > -1) {
        allCheckedKeys.splice(index4, 1);
      }

      if (index2 > -1) {
        treeCheckedKeys.splice(index4, 1);
      }
    }

    this.setState({
      checkedData,
      allCheckedKeys,
      treeCheckedKeys
    });
  }

  handleFocus() {
    this.setState({
      focused: true
    });
  }

  handleBlur() {
    this.setState({
      focused: false
    });
  }

  // 搜索列表复选框
  onChangeCheckbox(e, data) {
    let {
      checkedData,
      allCheckedKeys,
      treeCheckedKeys,
      treeMembers
    } = this.state;

    if (e.target.checked) {
      checkedData.push(data);
      allCheckedKeys.push(data.key);

      if (treeMembers.findIndex(item => item.id === data.id) > -1) {
        treeCheckedKeys.push(data.key);
      }
    } else {
      checkedData.splice(checkedData.findIndex(item => item.id === data.id), 1);
      allCheckedKeys.splice(allCheckedKeys.findIndex(item => item === data.key), 1);
      treeCheckedKeys.splice(treeCheckedKeys.findIndex(item => item === data.key), 1);
    }

    this.setState({
      checkedData,
      allCheckedKeys,
      treeCheckedKeys
    });
  }

  render() {
    let inviteError = null;

    if (this.state.inviteError) {
      inviteError = react_default.a.createElement("label", {
        className: "has-error control-label"
      }, this.state.inviteError);
    }

    const {
      formatMessage
    } = this.props.intl;
    const {
      searchData,
      searchValue,
      allCheckedKeys,
      treeCheckedKeys,
      focused,
      loading
    } = this.state;
    return react_default.a.createElement(modal["a" /* default */], {
      className: "more-modal new-invite-modal",
      mask: false,
      maskClosable: false,
      centered: true,
      closeIcon: react_default.a.createElement(icon["a" /* default */], {
        type: "close-circle",
        theme: "filled"
      }),
      visible: this.state.show,
      onCancel: this.onHide,
      onOk: this.handleSubmit,
      role: "dialog",
      title: this.props.otherData ? '会议邀请' : '添加成员',
      cancelText: '取消',
      okText: '确定',
      width: '660px'
    }, inviteError, react_default.a.createElement("div", {
      className: "inner"
    }, react_default.a.createElement("div", {
      className: "left"
    }, react_default.a.createElement("div", {
      className: 'input-box' + (focused ? ' focused' : '')
    }, react_default.a.createElement(input["a" /* default */], {
      className: "search-members",
      placeholder: '搜索联系人',
      onChange: e => {
        this.search(e.target.value);
      },
      onFocus: () => {
        this.handleFocus();
      },
      onBlur: () => {
        this.handleBlur();
      }
    }), react_default.a.createElement(search_icon["a" /* default */], {
      id: "searchIcon",
      className: "search__icon",
      "aria-hidden": "true"
    })), loading ? react_default.a.createElement("div", {
      className: "loading-cont"
    }, react_default.a.createElement(spin["a" /* default */], null)) : react_default.a.createElement("div", null, react_default.a.createElement("ul", {
      className: 'search-list' + (searchValue ? '' : ' hide')
    }, searchData.map((item, index) => {
      return react_default.a.createElement("li", {
        key: index
      }, react_default.a.createElement("img", {
        src: __webpack_require__(2040)
      }), react_default.a.createElement("div", {
        className: "title"
      }, item.title), react_default.a.createElement("div", {
        className: "department"
      }, item.deptNameTree), react_default.a.createElement(es_checkbox["a" /* default */], {
        checked: allCheckedKeys.indexOf(item.key) > -1,
        disabled: item.disabled,
        onChange: e => {
          this.onChangeCheckbox(e, item);
        }
      }));
    })), react_default.a.createElement("p", {
      className: 'search-no-data' + (searchValue && !searchData.length ? '' : ' hide')
    }, "\u6CA1\u6709\u5173\u4E8E\u201C", searchValue, "\u201D\u7684\u7ED3\u679C"), react_default.a.createElement(tree["a" /* default */], {
      className: "new-invite-tree" + (searchValue ? ' hide' : ''),
      checkable: true,
      autoExpandParent: this.state.autoExpandParent,
      expandedKeys: this.state.expandedKeys,
      onExpand: this.onExpand,
      onCheck: this.onCheck,
      checkedKeys: treeCheckedKeys,
      loadData: this.onLoadData
    }, this.renderTreeNodes(this.state.treeData)))), react_default.a.createElement("div", {
      className: "right"
    }, react_default.a.createElement("p", {
      className: "tips"
    }, "\u5DF2\u9009\u62E9\u4E86", this.state.checkedData.length, "\u4F4D\u8054\u7CFB\u4EBA"), react_default.a.createElement("div", {
      className: "list"
    }, this.state.checkedData.map((item, index) => {
      return react_default.a.createElement("div", {
        key: index
      }, react_default.a.createElement("img", {
        src: __webpack_require__(2040)
      }), react_default.a.createElement("div", {
        className: "name"
      }, item.title), react_default.a.createElement(icon["a" /* default */], {
        type: "close-circle",
        theme: "filled",
        onClick: () => {
          this.deleteUser(item);
        }
      }));
    })))));
  }

}

_defineProperty(channel_new_invite_modal_ChannelInviteModal, "propTypes", {
  otherData: prop_types_default.a.object,
  //外传参数
  users: prop_types_default.a.array,
  profilesNotInCurrentChannel: prop_types_default.a.array.isRequired,
  onHide: prop_types_default.a.func.isRequired,
  channel: prop_types_default.a.object.isRequired,
  currentUser: prop_types_default.a.object.isRequired,
  actions: prop_types_default.a.shape({
    addUsersToChannel: prop_types_default.a.func.isRequired,
    getProfilesNotInChannel: prop_types_default.a.func.isRequired,
    getTeamStats: prop_types_default.a.func.isRequired,
    searchProfiles: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_new_invite_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function mapStateToProps(state, ownProps) {
  const users = (() => {
    if (!ownProps.channel) {
      return [];
    }

    const doGetProfilesInChannel = Object(entities_users["makeGetProfilesInChannel"])();
    const users = doGetProfilesInChannel(state, ownProps.channel.id, true);
    return users;
  })();

  return {
    profilesNotInCurrentChannel: Object(entities_users["getProfilesNotInCurrentChannel"])(state),
    currentUser: Object(entities_users["getCurrentUser"])(state),
    users: users
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      addUsersToChannel: channel_actions["a" /* addUsersToChannel */],
      getProfilesNotInChannel: actions_users["getProfilesNotInChannel"],
      getTeamStats: teams["getTeamStats"],
      searchProfiles: actions_users["searchProfiles"]
    }, dispatch)
  };
}

/* harmony default export */ var components_channel_new_invite_modal = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(Object(index_es["h" /* injectIntl */])(channel_new_invite_modal_ChannelInviteModal)));

/***/ }),

/***/ 1691:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ArchiveIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class ArchiveIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", this.props, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.archive",
      defaultMessage: "Archive Icon"
    }, ariaLabel => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
      width: "14",
      height: "14",
      viewBox: "0 0 14 14",
      role: "icon",
      "aria-label": ariaLabel
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      d: "M8.5 6.5q0-0.203-0.148-0.352t-0.352-0.148h-2q-0.203 0-0.352 0.148t-0.148 0.352 0.148 0.352 0.352 0.148h2q0.203 0 0.352-0.148t0.148-0.352zM13 5v7.5q0 0.203-0.148 0.352t-0.352 0.148h-11q-0.203 0-0.352-0.148t-0.148-0.352v-7.5q0-0.203 0.148-0.352t0.352-0.148h11q0.203 0 0.352 0.148t0.148 0.352zM13.5 1.5v2q0 0.203-0.148 0.352t-0.352 0.148h-12q-0.203 0-0.352-0.148t-0.148-0.352v-2q0-0.203 0.148-0.352t0.352-0.148h12q0.203 0 0.352 0.148t0.148 0.352z"
    }))));
  }

}

/***/ }),

/***/ 1695:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SuccessIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class SuccessIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.success",
      defaultMessage: "Success Icon"
    }, title => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", {
      className: "fa fa-check",
      title: title
    }));
  }

}

/***/ }),

/***/ 1696:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class AddIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.add",
      defaultMessage: "Add Icon"
    }, title => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", {
      className: "fa fa-plus",
      title: title
    }));
  }

}

/***/ }),

/***/ 1698:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export is20002 */
/* unused harmony export getZFLUrl */
/* unused harmony export addMeeting */
/* unused harmony export joinMeeting */
/* unused harmony export beginMeeting */
/* unused harmony export endMeeting */
/* unused harmony export heartMeeting */
/* unused harmony export meetingInfo */
/* harmony import */ var q__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2037);
/* harmony import */ var q__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(q__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var utils_browser_history__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(114);


 //const pathUrl = "https://t-api.zuifuli.com/api/website";
//const pathUrl = "/api/v4/zfl";

const pathUrl = "/api/v4";
const is20002 = function (data) {
  if (data.code === "20002") {//localStorage.setItem("isInitZfl", 0);
    //browserHistory.push("/zfl");
    //console.log("会议请求失败,请重新登陆")
  } else if (data.code === "10000") {
    alert("会议参数错误");
  } else if (data.code === "70004") {
    alert("会议已经结束");
  }
}; // 请求最福利验证接口

const getZFLUrl = function (phone, url) {
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({
    url: `/zfl/login?redirect_url=${url}&phone_num=${phone}`,
    method: "GET"
  });
}; // 增加会议

const addMeeting = function () {
  //删除
  return new q__WEBPACK_IMPORTED_MODULE_0__["Promise"](resolve => {
    Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({
      url: `${pathUrl}/meeting/create`,
      method: 'POST',
      data: {
        aa: "123"
      }
    }).then(res => {
      const {
        data
      } = res; //console.log("addMeeting", data);

      is20002(data);
      resolve(data);
    });
  }); // return new Promise(resolve => {
  //   $.ajax({
  //     async: true,
  //     url: `${pathUrl}/meeting/create`,
  //     type: "POST",
  //     contentType: "application/json",
  //     xhrFields: {
  //       withCredentials: true
  //     },
  //     crossDomain: true,
  //     timeout: 10000,
  //     data: JSON.stringify({
  //       aa: "123"
  //     }),
  //     success(data) {
  //       console.log("addMeeting", data);
  //       is20002(data);
  //       resolve(data);
  //     },
  //     error(xhr) {
  //       console.log(xhr);
  //     }
  //   });
  // });
}; // 参加会议

const joinMeeting = function (meetingNo) {
  return new q__WEBPACK_IMPORTED_MODULE_0__["Promise"](resolve => {
    Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({
      url: `${pathUrl}/meeting/join`,
      method: 'POST',
      data: {
        meetingNo: meetingNo + "",
        password: ""
      }
    }).then(res => {
      const {
        data
      } = res; //console.log("joinMeeting", data);

      is20002(data);
      resolve(data);
    });
  }); // return new Promise(resolve => {
  //   $.ajax({
  //     async: true,
  //     url: `${pathUrl}/meeting/join`,
  //     type: "POST",
  //     contentType: "application/json",
  //     xhrFields: {
  //       withCredentials: true
  //     },
  //     crossDomain: true,
  //     timeout: 10000,
  //     data: JSON.stringify({
  //       meetingNo: meetingNo,
  //       password: ""
  //     }),
  //     success(data) {
  //       console.log("joinMeeting", data);
  //       is20002(data);
  //       resolve(data);
  //     },
  //     error(xhr, type) {
  //       console.log(xhr);
  //     }
  //   });
  // });
}; // 开始会议

const beginMeeting = function (meetingId) {
  return new q__WEBPACK_IMPORTED_MODULE_0__["Promise"](resolve => {
    Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({
      url: `${pathUrl}/meeting/begin`,
      method: 'POST',
      data: {
        meetingId: meetingId + ""
      }
    }).then(res => {
      const {
        data
      } = res; //console.log("beginMeeting", data);

      is20002(data);
      resolve(data);
    });
  }); // return new Promise(resolve => {
  //   $.ajax({
  //     async: true,
  //     contentType: "application/json",
  //     xhrFields: {
  //       withCredentials: true
  //     },
  //     crossDomain: true,
  //     timeout: 10000,
  //     url: `${pathUrl}/meeting/begin`,
  //     type: "POST",
  //     data: JSON.stringify({ meetingId: meetingId }),
  //     success(data) {
  //       console.log("beginMeeting");
  //       is20002(data);
  //       resolve(data);
  //     },
  //     error(xhr, type) {
  //       console.log(xhr);
  //     }
  //   });
  // });
}; // 结束会议

const endMeeting = function (meetingId) {
  return new q__WEBPACK_IMPORTED_MODULE_0__["Promise"](resolve => {
    Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({
      url: `${pathUrl}/meeting/close`,
      method: 'POST',
      data: {
        meeting_id: meetingId + ""
      }
    }).then(res => {
      const {
        data
      } = res; //console.log("endMeeting", data);

      is20002(data);
      resolve(data);
    });
  }); // return new Promise(resolve => {
  //   $.ajax({
  //     async: true,
  //     contentType: "application/json",
  //     xhrFields: {
  //       withCredentials: true
  //     },
  //     crossDomain: true,
  //     timeout: 10000,
  //     url: `${pathUrl}/meeting/end`,
  //     type: "POST",
  //     data: JSON.stringify({ meetingId: meetingId }),
  //     success(data) {
  //       console.log("endMeeting", data);
  //       is20002(data);
  //       resolve(data);
  //     },
  //     error(xhr, type) {
  //       console.log(xhr);
  //     }
  //   });
  // });
}; // 会议心跳

const heartMeeting = function (meetingId = null) {
  return new q__WEBPACK_IMPORTED_MODULE_0__["Promise"](resolve => {
    Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({
      url: `${pathUrl}/meeting/heartbeat`,
      method: 'POST',
      data: {
        meetingId: meetingId + ""
      }
    }).then(res => {
      const {
        data
      } = res; //console.log("heartMeeting", data);

      is20002(data);
      resolve(data);
    });
  }); // return new Promise(resolve => {
  //   $.ajax({
  //     async: true,
  //     contentType: "application/json",
  //     xhrFields: {
  //       withCredentials: true
  //     },
  //     crossDomain: true,
  //     timeout: 10000,
  //     url:`${pathUrl}/meeting/heartbeat`,
  //     type: "POST",
  //     contentType: "application/json",
  //     data: JSON.stringify({ meetingId: meetingId }),
  //     success(data) {
  //       console.log("heartMeeting", data);
  //       is20002(data);
  //       resolve(data);
  //     },
  //     error(xhr, type) {
  //       console.log(xhr);
  //     }
  //   });
  // });
}; // 会议详情

const meetingInfo = function (meetingId) {
  return new q__WEBPACK_IMPORTED_MODULE_0__["Promise"](resolve => {
    Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({
      url: `${pathUrl}/meeting/heartbeat?meetingId=${meetingId}`,
      method: 'GET',
      data: {
        meetingId: meetingId + ""
      }
    }).then(res => {
      const {
        data
      } = res; //console.log("meetingInfo", data);

      is20002(data);
      resolve(data);
    });
  }); // return new Promise(resolve => {
  //   $.ajax({
  //     async: true,
  //     contentType: "application/json",
  //     xhrFields: {
  //       withCredentials: true
  //     },
  //     crossDomain: true,
  //     timeout: 10000,
  //     url: `${pathUrl}/meeting/heartbeat?meetingId=${meetingId}`,
  //     type: "GET",
  //     success(data) {
  //       console.log("meetingInfo", data);
  //       is20002(data);
  //       resolve(data);
  //     },
  //     error(xhr, type) {
  //       console.log(xhr);
  //     }
  //   });
  // });
}; //zoom老接口
// // 增加会议
// export const addMeeting = function() {
//   return new Promise(resolve => {
//     $.ajax({
//       async: true,
//       url: `${pathUrl}/meeting`,
//       type: "POST",
//       contentType: "application/json",
//       xhrFields: {
//         withCredentials: true
//       },
//       crossDomain: true,
//       timeout: 10000,
//       data: JSON.stringify({
//         aa: "123"
//       }),
//       success(data) {
//         console.log("addMeeting", data);
//         is20002(data);
//         resolve(data);
//       },
//       error(xhr) {
//         console.log(xhr);
//       }
//     });
//   });
// };
// // 参加会议
// export const joinMeeting = function(meetingNo) {
//   return new Promise(resolve => {
//     $.ajax({
//       async: true,
//       url: `${pathUrl}/meeting/join`,
//       type: "POST",
//       contentType: "application/json",
//       xhrFields: {
//         withCredentials: true
//       },
//       crossDomain: true,
//       timeout: 10000,
//       data: JSON.stringify({
//         meetingNo: meetingNo,
//         password: ""
//       }),
//       success(data) {
//         console.log("joinMeeting", data);
//         is20002(data);
//         resolve(data);
//       },
//       error(xhr, type) {
//         console.log(xhr);
//       }
//     });
//   });
// };
// // 开始会议
// export const beginMeeting = function(meetingId) {
//   return new Promise(resolve => {
//     $.ajax({
//       async: true,
//       contentType: "application/json",
//       xhrFields: {
//         withCredentials: true
//       },
//       crossDomain: true,
//       timeout: 10000,
//       url: `${pathUrl}/meeting/${meetingId}/begin`,
//       type: "POST",
//       data: JSON.stringify({ a: "123" }),
//       success(data) {
//         console.log("beginMeeting");
//         is20002(data);
//         resolve(data);
//       },
//       error(xhr, type) {
//         console.log(xhr);
//       }
//     });
//   });
// };
// // 结束会议
// export const endMeeting = function(meetingId) {
//   return new Promise(resolve => {
//     $.ajax({
//       async: true,
//       contentType: "application/json",
//       xhrFields: {
//         withCredentials: true
//       },
//       crossDomain: true,
//       timeout: 10000,
//       url: `${pathUrl}/meeting/${meetingId}/end`,
//       type: "POST",
//       data: JSON.stringify({ a: "123" }),
//       success(data) {
//         console.log("endMeeting", data);
//         is20002(data);
//         resolve(data);
//       },
//       error(xhr, type) {
//         console.log(xhr);
//       }
//     });
//   });
// };
// // 会议心跳
// export const heartMeeting = function(meetingId = null) {
//   return new Promise(resolve => {
//     $.ajax({
//       async: true,
//       contentType: "application/json",
//       xhrFields: {
//         withCredentials: true
//       },
//       crossDomain: true,
//       timeout: 10000,
//       url:
//         meetingId === null
//           ? `${pathUrl}/meeting/null/heartbeat`
//           : `${pathUrl}/meeting/${meetingId}/heartbeat`,
//       type: "POST",
//       contentType: "application/json",
//       data: JSON.stringify({ a: "123" }),
//       success(data) {
//         console.log("heartMeeting", data);
//         is20002(data);
//         resolve(data);
//       },
//       error(xhr, type) {
//         console.log(xhr);
//       }
//     });
//   });
// };
// // 会议详情
// export const meetingInfo = function(meetingId) {
//   return new Promise(resolve => {
//     $.ajax({
//       async: true,
//       contentType: "application/json",
//       xhrFields: {
//         withCredentials: true
//       },
//       crossDomain: true,
//       timeout: 10000,
//       url: `${pathUrl}/meeting/${meetingId}/heartbeat`,
//       type: "GET",
//       success(data) {
//         console.log("meetingInfo", data);
//         is20002(data);
//         resolve(data);
//       },
//       error(xhr, type) {
//         console.log(xhr);
//       }
//     });
//   });
// };

/***/ }),

/***/ 1709:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MenuIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class MenuIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", this.props, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.menu",
      defaultMessage: "Menu Icon"
    }, title => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
      width: "16px",
      height: "10px",
      viewBox: "0 0 16 10",
      version: "1.1",
      role: "icon",
      title: title
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(-188.000000, -38.000000)",
      fillRule: "nonzero",
      fill: "inherit"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(188.000000, 38.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      d: "M15.5,0 C15.776,0 16,0.224 16,0.5 L16,1.5 C16,1.776 15.776,2 15.5,2 L0.5,2 C0.224,2 0,1.776 0,1.5 L0,0.5 C0,0.224 0.224,0 0.5,0 L15.5,0 Z M15.5,4 C15.776,4 16,4.224 16,4.5 L16,5.5 C16,5.776 15.776,6 15.5,6 L0.5,6 C0.224,6 0,5.776 0,5.5 L0,4.5 C0,4.224 0.224,4 0.5,4 L15.5,4 Z M15.5,8 C15.776,8 16,8.224 16,8.5 L16,9.5 C16,9.776 15.776,10 15.5,10 L0.5,10 C0.224,10 0,9.776 0,9.5 L0,8.5 C0,8.224 0.224,8 0.5,8 L15.5,8 Z"
    })))))))));
  }

}

/***/ }),

/***/ 1710:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isModalOpen; });
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
function isModalOpen(state, modalId) {
  return state.views.modals.modalState[modalId] && state.views.modals.modalState[modalId].open;
}

/***/ }),

/***/ 1711:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class BackIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.back",
      defaultMessage: "Back Icon"
    }, title => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", {
      className: "fa fa-angle-left",
      title: title
    }));
  }

}

/***/ }),

/***/ 1712:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ModalToggleButton; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class ModalToggleButton extends react__WEBPACK_IMPORTED_MODULE_1___default.a.Component {
  constructor(props) {
    super(props);
    this.show = this.show.bind(this);
    this.hide = this.hide.bind(this);
    this.state = {
      show: false
    };
  }

  show(e) {
    if (e) {
      e.preventDefault();
    }

    this.setState({
      show: true
    });
  }

  hide() {
    this.setState({
      show: false
    });
  }

  render() {
    const {
      children,
      dialogType,
      dialogProps,
      onClick,
      ...props
    } = this.props; // allow callers to provide an onClick which will be called before the modal is shown

    let clickHandler = this.show;

    if (onClick) {
      clickHandler = e => {
        onClick();
        this.show(e);
      };
    }

    let dialog;

    if (this.state.show) {
      // this assumes that all modals will have an onHide event and will show when mounted
      dialog = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(dialogType, Object.assign({}, dialogProps, {
        onHide: () => {
          this.hide();

          if (dialogProps.onHide) {
            dialogProps.onHide();
          }
        }
      }));
    } // nesting the dialog in the anchor tag looks like it shouldn't work, but it does due to how react-bootstrap
    // renders modals at the top level of the DOM instead of where you specify in the virtual DOM


    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", _extends({}, props, {
      className: 'style--none ' + props.className,
      onClick: clickHandler
    }), children), dialog);
  }

}
ModalToggleButton.propTypes = {
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node.isRequired,
  dialogType: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func.isRequired,
  dialogProps: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,
  onClick: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
};
ModalToggleButton.defaultProps = {
  dialogProps: {},
  className: ''
};

/***/ }),

/***/ 1718:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/files.js
var files = __webpack_require__(1861);

// EXTERNAL MODULE: ./selectors/i18n.js
var i18n = __webpack_require__(302);

// EXTERNAL MODULE: ./selectors/posts.js
var posts = __webpack_require__(415);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./mattermost-redux/utils/file_utils.js
var file_utils = __webpack_require__(1611);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./utils/file_utils.jsx
var utils_file_utils = __webpack_require__(1601);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// CONCATENATED MODULE: ./components/svg/download_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class download_icon_DownloadIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.download",
      defaultMessage: "Download Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "40px",
      height: "40px",
      viewBox: "0 0 42 42",
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", {
      stroke: "inherit",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, react_default.a.createElement("g", {
      transform: "translate(-986.000000, -1142.000000)"
    }, react_default.a.createElement("g", {
      transform: "translate(50.000000, 1034.000000)"
    }, react_default.a.createElement("g", {
      transform: "translate(539.000000, 54.000000)"
    }, react_default.a.createElement("g", {
      transform: "translate(398.000000, 55.000000)"
    }, react_default.a.createElement("g", {
      transform: "translate(11.000000, 11.000000)",
      fillRule: "nonzero",
      fill: "inherit"
    }, react_default.a.createElement("path", {
      d: "M8.7345,14.1405 C8.74725,14.1525 8.763,14.15775 8.7765,14.16825 C8.802,14.18775 8.82675,14.20875 8.85675,14.22075 C8.9025,14.24025 8.95125,14.25 9,14.25 C9.04875,14.25 9.0975,14.24025 9.14325,14.22075 C9.18975,14.20125 9.23175,14.17275 9.267,14.1375 L13.764,9.6405 C13.91025,9.49425 13.91025,9.2565 13.764,9.11025 C13.61775,8.964 13.38,8.964 13.23375,9.11025 L9.375,12.969 L9.375,0.375 C9.375,0.168 9.207,0 9,0 C8.793,0 8.625,0.168 8.625,0.375 L8.625,12.9705 L4.76475,9.11025 C4.6185,8.964 4.38075,8.964 4.2345,9.11025 C4.08825,9.2565 4.08825,9.49425 4.2345,9.6405 L8.7345,14.1405 Z M17.25,13.5 C17.043,13.5 16.875,13.668 16.875,13.875 L16.875,17.25 L1.125,17.25 L1.125,13.875 C1.125,13.668 0.957,13.5 0.75,13.5 C0.543,13.5 0.375,13.668 0.375,13.875 L0.375,17.625 C0.375,17.832 0.543,18 0.75,18 L17.25,18 C17.457,18 17.625,17.832 17.625,17.625 L17.625,13.875 C17.625,13.668 17.457,13.5 17.25,13.5 Z"
    }))))))))));
  }

}
// EXTERNAL MODULE: ./components/file_attachment/filename_overlay.jsx
var filename_overlay = __webpack_require__(1862);

// CONCATENATED MODULE: ./components/file_attachment/file_thumbnail.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class file_thumbnail_FileThumbnail extends react_default.a.PureComponent {
  render() {
    const {
      fileInfo
    } = this.props;
    const type = Object(utils["z" /* getFileType */])(fileInfo.extension);
    let thumbnail;

    if (type === constants["k" /* FileTypes */].IMAGE) {
      let className = 'post-image';

      if (fileInfo.width < constants["N" /* default */].THUMBNAIL_WIDTH && fileInfo.height < constants["N" /* default */].THUMBNAIL_HEIGHT) {
        className += ' small';
      } else {
        className += ' normal';
      }

      let thumbnailUrl = Object(file_utils["getFileThumbnailUrl"])(fileInfo.id);

      if (Object(utils["T" /* isGIFImage */])(fileInfo.extension) && !fileInfo.has_preview_image) {
        thumbnailUrl = Object(file_utils["getFileUrl"])(fileInfo.id);
      }

      return react_default.a.createElement("div", {
        className: className,
        style: {
          backgroundImage: `url(${thumbnailUrl})`,
          backgroundSize: 'cover'
        }
      });
    } else if (fileInfo.extension === constants["k" /* FileTypes */].SVG) {
      thumbnail = react_default.a.createElement("img", {
        alt: 'file thumbnail image',
        className: "post-image normal",
        src: Object(file_utils["getFileUrl"])(fileInfo.id)
      });
    } else {
      thumbnail = react_default.a.createElement("div", {
        className: 'file-icon ' + Object(utils["B" /* getIconClassName */])(type)
      });
    }

    return thumbnail;
  }

}

_defineProperty(file_thumbnail_FileThumbnail, "propTypes", {
  /*
   * File detailed information
   */
  fileInfo: prop_types_default.a.object.isRequired
});
// CONCATENATED MODULE: ./components/file_attachment/file_attachment.jsx
function file_attachment_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class file_attachment_FileAttachment extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    file_attachment_defineProperty(this, "loadFiles", () => {
      const fileInfo = this.props.fileInfo;
      const fileType = Object(utils["z" /* getFileType */])(fileInfo.extension);

      if (fileType === constants["k" /* FileTypes */].IMAGE) {
        const thumbnailUrl = Object(file_utils["getFileThumbnailUrl"])(fileInfo.id);
        Object(utils["fb" /* loadImage */])(thumbnailUrl, this.handleImageLoaded);
      } else if (fileInfo.extension === constants["k" /* FileTypes */].SVG) {
        Object(utils["fb" /* loadImage */])(Object(file_utils["getFileUrl"])(fileInfo.id), this.handleImageLoaded);
      }
    });

    file_attachment_defineProperty(this, "handleImageLoaded", () => {
      if (this.mounted) {
        this.setState({
          loaded: true
        });
      }
    });

    file_attachment_defineProperty(this, "onAttachmentClick", e => {
      e.preventDefault();

      if (this.props.handleImageClick) {
        this.props.handleImageClick(this.props.index);
      }
    });

    this.state = {
      loaded: Object(utils["z" /* getFileType */])(props.fileInfo.extension) !== constants["k" /* FileTypes */].IMAGE
    };
  }

  componentDidMount() {
    this.mounted = true;
    this.loadFiles();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.fileInfo.id !== this.props.fileInfo.id) {
      const extension = nextProps.fileInfo.extension;
      this.setState({
        loaded: Object(utils["z" /* getFileType */])(extension) !== constants["k" /* FileTypes */].IMAGE && extension !== constants["k" /* FileTypes */].SVG
      });
    }
  }

  componentDidUpdate(prevProps) {
    if (!this.state.loaded && this.props.fileInfo.id !== prevProps.fileInfo.id) {
      this.loadFiles();
    }
  }

  componentWillUnmount() {
    this.mounted = false;
  }

  render() {
    const {
      compactDisplay,
      fileInfo
    } = this.props;
    const trimmedFilename = Object(utils_file_utils["h" /* trimFilename */])(fileInfo.name);
    let fileThumbnail;
    let fileDetail;

    if (!compactDisplay) {
      fileThumbnail = react_default.a.createElement("a", {
        className: "post-image__thumbnail",
        href: "#",
        onClick: this.onAttachmentClick
      }, this.state.loaded ? react_default.a.createElement(file_thumbnail_FileThumbnail, {
        fileInfo: fileInfo
      }) : react_default.a.createElement("div", {
        className: "post-image__load"
      }));
      fileDetail = react_default.a.createElement("div", {
        className: "post-image__detail_wrapper",
        onClick: this.onAttachmentClick
      }, react_default.a.createElement("div", {
        className: "post-image__detail"
      }, react_default.a.createElement("span", {
        className: 'post-image__name'
      }, trimmedFilename), react_default.a.createElement("span", {
        className: "post-image__size"
      }, Object(utils["p" /* fileSizeToString */])(fileInfo.size))));
    }

    let filenameOverlay;

    if (this.props.canDownloadFiles) {
      filenameOverlay = react_default.a.createElement(filename_overlay["a" /* default */], {
        fileInfo: fileInfo,
        compactDisplay: compactDisplay,
        canDownload: this.props.canDownloadFiles,
        handleImageClick: this.onAttachmentClick,
        iconClass: 'post-image__download'
      }, react_default.a.createElement("i", null));
    }

    return react_default.a.createElement("div", {
      className: "post-image__column"
    }, fileThumbnail, react_default.a.createElement("div", {
      className: "post-image__details"
    }, fileDetail), filenameOverlay);
  }

}

file_attachment_defineProperty(file_attachment_FileAttachment, "propTypes", {
  /*
   * File detailed information
   */
  fileInfo: prop_types_default.a.object.isRequired,

  /*
   * The index of this attachment preview in the parent FileAttachmentList
   */
  index: prop_types_default.a.number.isRequired,

  /*
   * Handler for when the thumbnail is clicked passed the index above
   */
  handleImageClick: prop_types_default.a.func,

  /*
   * Display in compact format
   */
  compactDisplay: prop_types_default.a.bool,
  canDownloadFiles: prop_types_default.a.bool
});
// CONCATENATED MODULE: ./components/file_attachment/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function file_attachment_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  return {
    canDownloadFiles: Object(utils_file_utils["a" /* canDownloadFiles */])(config)
  };
}

/* harmony default export */ var file_attachment = (Object(es["connect"])(file_attachment_mapStateToProps)(file_attachment_FileAttachment));
// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./selectors/rhs.jsx
var rhs = __webpack_require__(60);

// EXTERNAL MODULE: ./components/size_aware_image.jsx
var size_aware_image = __webpack_require__(1728);

// EXTERNAL MODULE: ./components/view_image/index.js + 6 modules
var view_image = __webpack_require__(1755);

// CONCATENATED MODULE: ./components/single_image_view/single_image_view.jsx
function single_image_view_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const PREVIEW_IMAGE_MIN_DIMENSION = 50;
class single_image_view_SingleImageView extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    single_image_view_defineProperty(this, "imageLoaded", () => {
      if (this.mounted) {
        this.setState({
          loaded: true
        });
      }
    });

    single_image_view_defineProperty(this, "handleImageClick", e => {
      e.preventDefault();
      this.setState({
        showPreviewModal: true
      });
    });

    single_image_view_defineProperty(this, "showPreviewModal", () => {
      this.setState({
        showPreviewModal: false
      });
    });

    single_image_view_defineProperty(this, "toggleEmbedVisibility", () => {
      this.props.actions.toggleEmbedVisibility(this.props.postId);
    });

    this.state = {
      loaded: false,
      showPreviewModal: false,
      dimensions: {
        width: props.fileInfo.width,
        height: props.fileInfo.height
      }
    };
  }

  componentDidMount() {
    this.mounted = true;
  }

  static getDerivedStateFromProps(props, state) {
    if (props.fileInfo.width !== state.dimensions.width || props.fileInfo.height !== state.dimensions.height) {
      return {
        dimensions: {
          width: props.fileInfo.width,
          height: props.fileInfo.height
        }
      };
    }

    return null;
  }

  componentWillUnmount() {
    this.mounted = false;
  }

  render() {
    const {
      fileInfo
    } = this.props;
    const {
      loaded
    } = this.state;
    const {
      has_preview_image: hasPreviewImage,
      id
    } = fileInfo;
    const fileURL = Object(file_utils["getFileUrl"])(id);
    const previewURL = hasPreviewImage ? Object(file_utils["getFilePreviewUrl"])(id) : fileURL;
    const previewHeight = fileInfo.height;
    const previewWidth = fileInfo.width;
    let minPreviewClass = '';

    if (previewWidth < PREVIEW_IMAGE_MIN_DIMENSION || previewHeight < PREVIEW_IMAGE_MIN_DIMENSION) {
      minPreviewClass = 'min-preview ';

      if (previewHeight > previewWidth) {
        minPreviewClass += 'min-preview--portrait ';
      }
    }

    const toggle = react_default.a.createElement("a", {
      key: "toggle",
      className: "post__embed-visibility",
      "data-expanded": this.props.isEmbedVisible,
      "aria-label": "Toggle Embed Visibility",
      onClick: this.toggleEmbedVisibility
    });
    const fileHeader = react_default.a.createElement("div", {
      className: "image-name"
    }, toggle, react_default.a.createElement("div", {
      onClick: this.handleImageClick
    }, fileInfo.name));
    let viewImageModal;
    let fadeInClass = '';
    const fileType = Object(utils["z" /* getFileType */])(fileInfo.extension);
    let styleIfSvgWithDimentions = {};
    let imageContainerStyle = {};
    let svgClass = '';

    if (fileType === constants["k" /* FileTypes */].SVG) {
      svgClass = 'svg';

      if (this.state.dimensions.height) {
        styleIfSvgWithDimentions = {
          width: '100%'
        };
      } else {
        imageContainerStyle = {
          height: 150,
          width: 'auto'
        };
      }
    }

    if (loaded) {
      viewImageModal = react_default.a.createElement(view_image["a" /* default */], {
        show: this.state.showPreviewModal,
        onModalDismissed: this.showPreviewModal,
        fileInfos: [fileInfo],
        postId: this.props.postId
      });
      fadeInClass = 'image-fade-in';
    }

    return react_default.a.createElement("div", {
      className: `${'file-view--single'}`
    }, react_default.a.createElement("div", {
      className: "file__image"
    }, this.props.isEmbedVisible && react_default.a.createElement("div", {
      className: "image-container",
      style: imageContainerStyle
    }, react_default.a.createElement("div", {
      className: `image-loaded ${fadeInClass} ${svgClass}`,
      style: styleIfSvgWithDimentions
    }, react_default.a.createElement(size_aware_image["a" /* default */], {
      onClick: this.handleImageClick,
      className: minPreviewClass,
      src: previewURL,
      dimensions: this.state.dimensions,
      onImageLoaded: this.imageLoaded,
      showLoader: this.props.isEmbedVisible
    }))), viewImageModal));
  }

}

single_image_view_defineProperty(single_image_view_SingleImageView, "propTypes", {
  postId: prop_types_default.a.string.isRequired,
  fileInfo: prop_types_default.a.object.isRequired,
  isRhsOpen: prop_types_default.a.bool.isRequired,
  isEmbedVisible: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    toggleEmbedVisibility: prop_types_default.a.func.isRequired
  }).isRequired
});

single_image_view_defineProperty(single_image_view_SingleImageView, "defaultProps", {
  fileInfo: {}
});
// CONCATENATED MODULE: ./components/single_image_view/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function single_image_view_mapStateToProps(state) {
  const isRhsOpen = Object(rhs["c" /* getIsRhsOpen */])(state);
  return {
    isRhsOpen
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      toggleEmbedVisibility: post_actions["o" /* toggleEmbedVisibility */]
    }, dispatch)
  };
}

/* harmony default export */ var single_image_view = (Object(es["connect"])(single_image_view_mapStateToProps, mapDispatchToProps)(single_image_view_SingleImageView));
// EXTERNAL MODULE: ./node_modules/antd/es/modal/index.js + 3 modules
var modal = __webpack_require__(1552);

// EXTERNAL MODULE: ./node_modules/antd/es/icon/index.js + 3 modules
var icon = __webpack_require__(93);

// CONCATENATED MODULE: ./components/file_attachment_list/file_attachment_list.jsx
function file_attachment_list_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









const {
  confirm: file_attachment_list_confirm
} = modal["a" /* default */];

class file_attachment_list_FileAttachmentList extends react_default.a.Component {
  constructor(props) {
    super(props);

    file_attachment_list_defineProperty(this, "hidePreviewModal", () => {
      this.setState({
        showPreviewModal: false
      });
    });

    this.handleImageClick = this.handleImageClick.bind(this);
    this.state = {
      showPreviewModal: false,
      startImgIndex: 0
    };
  }

  handleImageClick(indexClicked, fileInfo) {
    if (Object(utils_file_utils["b" /* canPreview */])(fileInfo.extension)) {
      this.setState({
        showPreviewModal: true,
        startImgIndex: indexClicked
      });
      return;
    }

    file_attachment_list_confirm({
      title: '该格式暂不支持预览，您可以下载查看',
      cancelText: '取消',
      okText: '下载',
      icon: react_default.a.createElement(icon["a" /* default */], {
        type: "exclamation-circle"
      }),
      zIndex: 1010,

      onOk() {
        const fileUrl = fileInfo.link || Object(file_utils["getFileUrl"])(fileInfo.id);
        window.open(fileUrl + '?download=1', '_self');
      }

    });
  }

  render() {
    const {
      compactDisplay,
      fileInfos,
      fileCount,
      locale
    } = this.props;

    if (compactDisplay === false) {
      if (fileInfos && fileInfos.length === 1) {
        const fileType = Object(utils["z" /* getFileType */])(fileInfos[0].extension);

        if (fileType === constants["k" /* FileTypes */].IMAGE || fileType === constants["k" /* FileTypes */].SVG) {
          return react_default.a.createElement(single_image_view, {
            fileInfo: fileInfos[0],
            isEmbedVisible: this.props.isEmbedVisible,
            postId: this.props.post.id
          });
        }
      } else if (fileCount === 1 && this.props.isEmbedVisible) {
        return react_default.a.createElement("div", {
          className: "file__content",
          style: style.minHeightPlaceholder
        });
      }
    }

    const sortedFileInfos = Object(file_utils["sortFileInfos"])(fileInfos, locale);
    const postFiles = [];

    if (sortedFileInfos && sortedFileInfos.length > 0) {
      for (let i = 0; i < sortedFileInfos.length; i++) {
        const fileInfo = sortedFileInfos[i];
        postFiles.push(react_default.a.createElement(file_attachment, {
          key: fileInfo.id,
          fileInfo: sortedFileInfos[i],
          index: i,
          handleImageClick: index => {
            this.handleImageClick(index, fileInfo);
          },
          compactDisplay: compactDisplay
        }));
      }
    } else if (fileCount > 0) {
      for (let i = 0; i < fileCount; i++) {
        // Add a placeholder to avoid pop-in once we get the file infos for this post
        postFiles.push(react_default.a.createElement("div", {
          key: `fileCount-${i}`,
          className: "post-image__column post-image__column--placeholder"
        }));
      }
    }

    return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("div", {
      className: "post-image__columns clearfix"
    }, postFiles), react_default.a.createElement(view_image["a" /* default */], {
      show: this.state.showPreviewModal,
      onModalDismissed: this.hidePreviewModal,
      startIndex: this.state.startImgIndex,
      fileInfos: sortedFileInfos,
      postId: this.props.post.id
    }));
  }

}

file_attachment_list_defineProperty(file_attachment_list_FileAttachmentList, "propTypes", {
  /*
   * The post the files are attached to
   */
  post: prop_types_default.a.object.isRequired,

  /*
   * The number of files attached to the post
   */
  fileCount: prop_types_default.a.number.isRequired,

  /*
   * Sorted array of metadata for each file attached to the post
   */
  fileInfos: prop_types_default.a.arrayOf(prop_types_default.a.object),

  /*
   * Set to render compactly
   */
  compactDisplay: prop_types_default.a.bool,
  isEmbedVisible: prop_types_default.a.bool,
  locale: prop_types_default.a.string.isRequired
});

const style = {
  minHeightPlaceholder: {
    minHeight: '385px'
  }
};
// CONCATENATED MODULE: ./components/file_attachment_list/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function makeMapStateToProps() {
  const selectFilesForPost = Object(files["makeGetFilesForPost"])();
  return function mapStateToProps(state, ownProps) {
    const postId = ownProps.post ? ownProps.post.id : '';
    const fileInfos = ownProps.fileInfos ? ownProps.fileInfos : selectFilesForPost(state, postId);
    let fileCount = 0;

    if (ownProps.post.metadata && ownProps.post.metadata.files) {
      fileCount = (ownProps.post.metadata.files || []).length;
    } else if (ownProps.post.file_ids) {
      fileCount = ownProps.post.file_ids.length;
    } else if (ownProps.post.filenames) {
      fileCount = ownProps.post.filenames.length;
    }

    return {
      fileInfos,
      fileCount,
      isEmbedVisible: Object(posts["b" /* isEmbedVisible */])(state, ownProps.post.id),
      locale: Object(i18n["a" /* getCurrentLocale */])(state)
    };
  };
}

/* harmony default export */ var file_attachment_list = __webpack_exports__["a"] = (Object(es["connect"])(makeMapStateToProps)(file_attachment_list_FileAttachmentList));

/***/ }),

/***/ 1719:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/roles.js
var roles = __webpack_require__(90);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// CONCATENATED MODULE: ./components/permissions_gates/team_permission_gate/team_permission_gate.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class team_permission_gate_TeamPermissionGate extends react_default.a.Component {
  render() {
    if (this.props.hasPermission && !this.props.invert) {
      return this.props.children;
    }

    if (!this.props.hasPermission && this.props.invert) {
      return this.props.children;
    }

    return null;
  }

}

_defineProperty(team_permission_gate_TeamPermissionGate, "defaultProps", {
  invert: false
});

_defineProperty(team_permission_gate_TeamPermissionGate, "propTypes", {
  /**
   * Team to check the permission
   */
  teamId: prop_types_default.a.string,

  /**
   * Permissions enough to pass the gate (binary OR)
   */
  permissions: prop_types_default.a.arrayOf(prop_types_default.a.string).isRequired,

  /**
   * Has permission
   */
  hasPermission: prop_types_default.a.bool.isRequired,

  /**
   * Invert the permission (used for else)
   */
  invert: prop_types_default.a.bool.isRequired,

  /**
   * Content protected by the permissions gate
   */
  children: prop_types_default.a.node.isRequired
});
// CONCATENATED MODULE: ./components/permissions_gates/team_permission_gate/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function mapStateToProps(state, ownProps) {
  if (!ownProps.teamId) {
    return {
      hasPermission: false
    };
  }

  for (const permission of ownProps.permissions) {
    if (Object(roles["haveITeamPermission"])(state, {
      team: ownProps.teamId,
      permission
    })) {
      return {
        hasPermission: true
      };
    }
  }

  return {
    hasPermission: false
  };
}

/* harmony default export */ var team_permission_gate = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(team_permission_gate_TeamPermissionGate));

/***/ }),

/***/ 1720:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/profile_popover/index.js + 5 modules
var profile_popover = __webpack_require__(1962);

// EXTERNAL MODULE: ./components/widgets/badges/bot_badge.jsx
var bot_badge = __webpack_require__(1588);

// CONCATENATED MODULE: ./components/user_profile/user_profile.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class user_profile_UserProfile extends react["PureComponent"] {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "hideProfilePopover", () => {
      this.refs.overlay.hide();
    });
  }

  render() {
    const {
      disablePopover,
      displayName,
      isBusy,
      isRHS,
      hasMention,
      hideStatus,
      overwriteName,
      user,
      userId
    } = this.props;
    const name = overwriteName || displayName || 'bot';

    if (disablePopover) {
      return react_default.a.createElement("div", {
        className: "user-popover"
      }, name);
    }

    let placement = 'right';

    if (isRHS && !Object(utils["Y" /* isMobile */])()) {
      placement = 'left';
    }

    let profileImg = '';

    if (user) {
      profileImg = Object(utils["K" /* imageURLForUser */])(user);
    }

    return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      ref: "overlay",
      trigger: "click",
      placement: placement,
      rootClose: true,
      overlay: react_default.a.createElement(profile_popover["a" /* default */], {
        userId: userId,
        src: profileImg,
        isBusy: isBusy,
        hide: this.hideProfilePopover,
        hideStatus: hideStatus,
        isRHS: isRHS,
        hasMention: hasMention
      })
    }, react_default.a.createElement("div", {
      className: "user-popover"
    }, name)), react_default.a.createElement(bot_badge["a" /* default */], {
      show: Boolean(user && user.is_bot),
      className: "badge-popoverlist"
    }));
  }

}

_defineProperty(user_profile_UserProfile, "propTypes", {
  disablePopover: prop_types_default.a.bool,
  displayName: prop_types_default.a.string,
  hasMention: prop_types_default.a.bool,
  hideStatus: prop_types_default.a.bool,
  isBusy: prop_types_default.a.bool,
  isRHS: prop_types_default.a.bool,
  overwriteName: prop_types_default.a.node,
  user: prop_types_default.a.object,
  userId: prop_types_default.a.string
});

_defineProperty(user_profile_UserProfile, "defaultProps", {
  disablePopover: false,
  hasMention: false,
  hideStatus: false,
  isRHS: false,
  overwriteImage: '',
  overwriteName: ''
});
// CONCATENATED MODULE: ./components/user_profile/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function makeMapStateToProps() {
  const getDisplayName = Object(users["makeGetDisplayName"])();
  return (state, ownProps) => {
    const user = Object(users["getUser"])(state, ownProps.userId);
    return {
      displayName: user ? user.nickname ? user.nickname : 'bot' : '账号不存在',
      user
    };
  };
}

/* harmony default export */ var user_profile = __webpack_exports__["a"] = (Object(es["connect"])(makeMapStateToProps)(user_profile_UserProfile));

/***/ }),

/***/ 1721:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/roles.js
var roles = __webpack_require__(90);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// CONCATENATED MODULE: ./components/permissions_gates/channel_permission_gate/channel_permission_gate.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class channel_permission_gate_ChannelPermissionGate extends react_default.a.Component {
  render() {
    if (this.props.hasPermission && !this.props.invert) {
      return this.props.children;
    }

    if (!this.props.hasPermission && this.props.invert) {
      return this.props.children;
    }

    return null;
  }

}

_defineProperty(channel_permission_gate_ChannelPermissionGate, "defaultProps", {
  invert: false
});

_defineProperty(channel_permission_gate_ChannelPermissionGate, "propTypes", {
  /**
   * Channel to check the permission
   */
  channelId: prop_types_default.a.string,

  /**
   * Team to check the permission
   */
  teamId: prop_types_default.a.string,

  /**
   * Permissions enough to pass the gate (binary OR)
   */
  permissions: prop_types_default.a.arrayOf(prop_types_default.a.string).isRequired,

  /**
   * Has permission
   */
  hasPermission: prop_types_default.a.bool.isRequired,

  /**
   * Invert the permission (used for else)
   */
  invert: prop_types_default.a.bool.isRequired,

  /**
   * Content protected by the permissions gate
   */
  children: prop_types_default.a.node.isRequired
});
// CONCATENATED MODULE: ./components/permissions_gates/channel_permission_gate/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function mapStateToProps(state, ownProps) {
  if (!ownProps.channelId || ownProps.teamId === null || typeof ownProps.teamId === 'undefined') {
    return {
      hasPermission: false
    };
  }

  for (const permission of ownProps.permissions) {
    if (Object(roles["haveIChannelPermission"])(state, {
      channel: ownProps.channelId,
      team: ownProps.teamId,
      permission
    })) {
      return {
        hasPermission: true
      };
    }
  }

  return {
    hasPermission: false
  };
}

/* harmony default export */ var channel_permission_gate = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(channel_permission_gate_ChannelPermissionGate));

/***/ }),

/***/ 1722:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return toggle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return open; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return close; });
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

const toggle = () => dispatch => dispatch({
  type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__[/* ActionTypes */ "b"].TOGGLE_LHS
});
const open = () => dispatch => dispatch({
  type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__[/* ActionTypes */ "b"].OPEN_LHS
});
const close = () => dispatch => dispatch({
  type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__[/* ActionTypes */ "b"].CLOSE_LHS
});

/***/ }),

/***/ 1723:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return initialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return close; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return registerPluginReconnectHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return unregisterPluginReconnectHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return reconnect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return startPeriodicSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return stopPeriodicSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return registerPluginWebSocketEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return unregisterPluginWebSocketEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return unregisterAllPluginWebSocketEvents; });
/* unused harmony export handleNewPostEvent */
/* unused harmony export handleNewPostEvents */
/* unused harmony export handlePostEditEvent */
/* unused harmony export handleUserRemovedEvent */
/* harmony import */ var redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);
/* harmony import */ var redux_batched_actions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mattermost_redux_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var mattermost_redux_constants__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_constants__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);
/* harmony import */ var mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var mattermost_redux_actions_general__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(253);
/* harmony import */ var mattermost_redux_actions_general__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_general__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59);
/* harmony import */ var mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var mattermost_redux_actions_errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(105);
/* harmony import */ var mattermost_redux_actions_errors__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_errors__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(299);
/* harmony import */ var mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(35);
/* harmony import */ var mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var mattermost_redux_client__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(27);
/* harmony import */ var mattermost_redux_client__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_client__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(10);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(32);
/* harmony import */ var mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(26);
/* harmony import */ var mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(15);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var mattermost_redux_selectors_entities_posts__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(61);
/* harmony import */ var mattermost_redux_selectors_entities_posts__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_posts__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var selectors_rhs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(60);
/* harmony import */ var actions_views_modals__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(1578);
/* harmony import */ var actions_views_meeting__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(182);
/* harmony import */ var actions_views_system__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(2297);
/* harmony import */ var actions_views_rhs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(116);
/* harmony import */ var actions_views_channel__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(1589);
/* harmony import */ var utils_browser_history__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(114);
/* harmony import */ var actions_channel_actions_jsx__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(1593);
/* harmony import */ var actions_global_actions_jsx__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(1567);
/* harmony import */ var actions_post_actions_jsx__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(408);
/* harmony import */ var actions_status_actions_jsx__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(246);
/* harmony import */ var actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(304);
/* harmony import */ var stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(14);
/* harmony import */ var client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(1823);
/* harmony import */ var plugins__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(2271);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(0);
/* harmony import */ var utils_post_utils__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(407);
/* harmony import */ var utils_url_jsx__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(298);
/* harmony import */ var components_removed_from_channel_modal__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(3462);
/* harmony import */ var components_interactive_dialog__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(1964);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



































const dispatch = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch;
const getState = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].getState;
const MAX_WEBSOCKET_FAILS = 7;
const pluginEventHandlers = {};
function initialize() {
  if (!window.WebSocket) {
    console.log('Browser does not support websocket'); //eslint-disable-line no-console

    return;
  }

  const config = Object(mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_12__["getConfig"])(getState());
  let connUrl = '';

  if (config.WebsocketURL) {
    connUrl = config.WebsocketURL;
  } else {
    connUrl = new URL(Object(utils_url_jsx__WEBPACK_IMPORTED_MODULE_32__[/* getSiteURL */ "e"])()); // replace the protocol with a websocket one

    if (connUrl.protocol === 'https:') {
      connUrl.protocol = 'wss:';
    } else {
      connUrl.protocol = 'ws:';
    } // append a port number if one isn't already specified


    if (!/:\d+$/.test(connUrl.host)) {
      if (connUrl.protocol === 'wss:') {
        connUrl.host += ':' + config.WebsocketSecurePort;
      } else {
        connUrl.host += ':' + config.WebsocketPort;
      }
    }

    connUrl = connUrl.toString();
  } // Strip any trailing slash before appending the pathname below.


  if (connUrl.length > 0 && connUrl[connUrl.length - 1] === '/') {
    connUrl = connUrl.substring(0, connUrl.length - 1);
  }

  connUrl += mattermost_redux_client__WEBPACK_IMPORTED_MODULE_9__["Client4"].getUrlVersion() + '/websocket';
  client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_28__[/* default */ "a"].setEventCallback(handleEvent);
  client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_28__[/* default */ "a"].setFirstConnectCallback(handleFirstConnect);
  client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_28__[/* default */ "a"].setReconnectCallback(() => reconnect(false));
  client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_28__[/* default */ "a"].setMissedEventCallback(() => reconnect(false));
  client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_28__[/* default */ "a"].setCloseCallback(handleClose);
  client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_28__[/* default */ "a"].initialize(connUrl);
}
function close() {
  client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_28__[/* default */ "a"].close();
}

function reconnectWebSocket() {
  close();
  initialize();
}

const pluginReconnectHandlers = {};
function registerPluginReconnectHandler(pluginId, handler) {
  pluginReconnectHandlers[pluginId] = handler;
}
function unregisterPluginReconnectHandler(pluginId) {
  Reflect.deleteProperty(pluginReconnectHandlers, pluginId);
}
function reconnect(includeWebSocket = true) {
  if (includeWebSocket) {
    reconnectWebSocket();
  }

  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["GeneralTypes"].WEBSOCKET_SUCCESS
  });
  Object(plugins__WEBPACK_IMPORTED_MODULE_29__[/* loadPluginsIfNecessary */ "c"])();
  Object.values(pluginReconnectHandlers).forEach(handler => {
    if (handler && typeof handler === 'function') {
      handler();
    }
  });
  const currentTeamId = getState().entities.teams.currentTeamId;

  if (currentTeamId) {
    const state = getState();
    const currentChannelId = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__["getCurrentChannelId"])(state);
    const mostRecentId = Object(mattermost_redux_selectors_entities_posts__WEBPACK_IMPORTED_MODULE_14__["getMostRecentPostIdInChannel"])(state, currentChannelId);
    const mostRecentPost = Object(mattermost_redux_selectors_entities_posts__WEBPACK_IMPORTED_MODULE_14__["getPost"])(state, mostRecentId);
    dispatch(Object(actions_channel_actions_jsx__WEBPACK_IMPORTED_MODULE_22__[/* loadChannelsForCurrentUser */ "d"])());

    if (mostRecentPost) {
      dispatch(Object(actions_views_channel__WEBPACK_IMPORTED_MODULE_20__[/* syncPostsInChannel */ "m"])(currentChannelId, mostRecentPost.create_at));
    } else {
      // if network timed-out the first time when loading a channel
      // we can request for getPosts again when socket is connected
      dispatch(Object(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5__["getPosts"])(currentChannelId));
    }

    actions_status_actions_jsx__WEBPACK_IMPORTED_MODULE_25__[/* loadStatusesForChannelAndSidebar */ "a"]();
    dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_7__["getMyTeamUnreads"]());
  }

  dispatch(Object(actions_views_system__WEBPACK_IMPORTED_MODULE_18__[/* resetWsErrorCount */ "b"])());
  dispatch(Object(mattermost_redux_actions_errors__WEBPACK_IMPORTED_MODULE_6__["clearErrors"])());
}
let intervalId = '';
const SYNC_INTERVAL_MILLISECONDS = 1000 * 60 * 15; // 15 minutes

function startPeriodicSync() {
  clearInterval(intervalId);
  intervalId = setInterval(() => {
    if (Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getCurrentUser"])(getState()) != null) {
      reconnect(false);
    }
  }, SYNC_INTERVAL_MILLISECONDS);
}
function stopPeriodicSync() {
  clearInterval(intervalId);
}
function registerPluginWebSocketEvent(pluginId, event, action) {
  if (!pluginEventHandlers[pluginId]) {
    pluginEventHandlers[pluginId] = {};
  }

  pluginEventHandlers[pluginId][event] = action;
}
function unregisterPluginWebSocketEvent(pluginId, event) {
  const events = pluginEventHandlers[pluginId];

  if (!events) {
    return;
  }

  Reflect.deleteProperty(events, event);
}
function unregisterAllPluginWebSocketEvents(pluginId) {
  Reflect.deleteProperty(pluginEventHandlers, pluginId);
}

function handleFirstConnect() {
  dispatch(Object(redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__["batchActions"])([{
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["GeneralTypes"].WEBSOCKET_SUCCESS
  }, Object(mattermost_redux_actions_errors__WEBPACK_IMPORTED_MODULE_6__["clearErrors"])()]));
}

function handleClose(failCount) {
  if (failCount > MAX_WEBSOCKET_FAILS) {
    dispatch(Object(mattermost_redux_actions_errors__WEBPACK_IMPORTED_MODULE_6__["logError"])({
      type: 'critical',
      message: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* AnnouncementBarMessages */ "d"].WEBSOCKET_PORT_ERROR
    }, true));
  }

  dispatch(Object(redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__["batchActions"])([{
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["GeneralTypes"].WEBSOCKET_FAILURE
  }, Object(actions_views_system__WEBPACK_IMPORTED_MODULE_18__[/* incrementWsErrorCount */ "a"])()]));
}

function handleEvent(msg) {
  switch (msg.event) {
    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].POSTED:
    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].EPHEMERAL_MESSAGE:
      handleNewPostEventDebounced(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].POST_EDITED:
      handlePostEditEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].POST_DELETED:
      handlePostDeleteEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].LEAVE_TEAM:
      handleLeaveTeamEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].UPDATE_TEAM:
      handleUpdateTeamEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].DELETE_TEAM:
      handleDeleteTeamEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].ADDED_TO_TEAM:
      handleTeamAddedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].USER_ADDED:
      handleUserAddedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].USER_REMOVED:
      handleUserRemovedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].USER_UPDATED:
      handleUserUpdatedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].ROLE_ADDED:
      handleRoleAddedEvent(msg, dispatch, getState);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].ROLE_REMOVED:
      handleRoleRemovedEvent(msg, dispatch, getState);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].MEMBERROLE_UPDATED:
      handleUpdateMemberRoleEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].ROLE_UPDATED:
      handleRoleUpdatedEvent(msg, dispatch, getState);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].CHANNEL_CREATED:
      handleChannelCreatedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].CHANNEL_DELETED:
      handleChannelDeletedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].CHANNEL_CONVERTED:
      handleChannelConvertedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].CHANNEL_UPDATED:
      handleChannelUpdatedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].CHANNEL_MEMBER_UPDATED:
      handleChannelMemberUpdatedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].DIRECT_ADDED:
      handleDirectAddedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].PREFERENCE_CHANGED:
      handlePreferenceChangedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].PREFERENCES_CHANGED:
      handlePreferencesChangedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].PREFERENCES_DELETED:
      handlePreferencesDeletedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].TYPING:
      handleUserTypingEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].STATUS_CHANGED:
      handleStatusChangedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].HELLO:
      handleHelloEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].REACTION_ADDED:
      handleReactionAddedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].REACTION_REMOVED:
      handleReactionRemovedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].EMOJI_ADDED:
      handleAddEmoji(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].CHANNEL_VIEWED:
      handleChannelViewedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].PLUGIN_ENABLED:
      handlePluginEnabled(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].PLUGIN_DISABLED:
      handlePluginDisabled(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].USER_ROLE_UPDATED:
      handleUserRoleUpdated(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].CONFIG_CHANGED:
      handleConfigChanged(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].LICENSE_CHANGED:
      handleLicenseChanged(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].PLUGIN_STATUSES_CHANGED:
      handlePluginStatusesChangedEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].OPEN_DIALOG:
      handleOpenDialogEvent(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].OPEN_MEETING:
      handleOpenMeeting(msg);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].SET_MY_MEETING_IN:
      handleMyMeeting(true);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].SET_MY_MEETING_OUT:
      handleMyMeeting(false);
      break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].SET_MY_MEETING_AV:
      handleMeetingAv(msg.data);
      break;
    // case SocketEvents.MEETING_LIVE://ing
    //     handleMeetingAv(msg.data);
    //     break;

    case utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* SocketEvents */ "D"].MEETING_CLOSE:
      handleMeetingClose(msg.data);
      break;

    default:
  }

  Object.values(pluginEventHandlers).forEach(pluginEvents => {
    if (!pluginEvents) {
      return;
    }

    if (pluginEvents.hasOwnProperty(msg.event) && typeof pluginEvents[msg.event] === 'function') {
      pluginEvents[msg.event](msg);
    }
  });
} // handleChannelConvertedEvent handles updating of channel which is converted from public to private


function handleChannelConvertedEvent(msg) {
  const channelId = msg.data.channel_id;

  if (channelId) {
    const channel = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__["getChannel"])(getState(), channelId);

    if (channel) {
      dispatch({
        type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["ChannelTypes"].RECEIVED_CHANNEL,
        data: { ...channel,
          type: mattermost_redux_constants__WEBPACK_IMPORTED_MODULE_2__["General"].PRIVATE_CHANNEL
        }
      });
    }
  }
}

function handleChannelUpdatedEvent(msg) {
  const channel = JSON.parse(msg.data.channel);
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["ChannelTypes"].RECEIVED_CHANNEL,
    data: channel
  });
}

function handleChannelMemberUpdatedEvent(msg) {
  const channelMember = JSON.parse(msg.data.channelMember);
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["ChannelTypes"].RECEIVED_MY_CHANNEL_MEMBER,
    data: channelMember
  });
}

function debouncePostEvent(wait) {
  let timeout;
  let queue = [];
  let count = 0; // Called when timeout triggered

  const triggered = () => {
    timeout = null;

    if (queue.length > 0) {
      dispatch(handleNewPostEvents(queue));
    }

    queue = [];
    count = 0;
  };

  return function fx(msg) {
    if (timeout && count > 2) {
      // If the timeout is going this is the second or further event so queue them up.
      if (queue.push(msg) > 200) {
        // Don't run us out of memory, give up if the queue gets insane
        queue = [];
        console.log('channel broken because of too many incoming messages'); //eslint-disable-line no-console
      }

      clearTimeout(timeout);
      timeout = setTimeout(triggered, wait);
    } else {
      // Apply immediately for events up until count reaches limit
      count += 1;
      dispatch(handleNewPostEvent(msg));
      clearTimeout(timeout);
      timeout = setTimeout(triggered, wait);
    }
  };
}

const handleNewPostEventDebounced = debouncePostEvent(100);
function handleNewPostEvent(msg) {
  return (myDispatch, myGetState) => {
    const post = JSON.parse(msg.data.post);
    myDispatch(Object(actions_post_actions_jsx__WEBPACK_IMPORTED_MODULE_24__[/* handleNewPost */ "h"])(post, msg));
    Object(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5__["getProfilesAndStatusesForPosts"])([post], myDispatch, myGetState);

    if (post.user_id !== Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getCurrentUserId"])(myGetState()) && !Object(utils_post_utils__WEBPACK_IMPORTED_MODULE_31__[/* fromAutoResponder */ "d"])(post)) {
      myDispatch({
        type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["UserTypes"].RECEIVED_STATUSES,
        data: [{
          user_id: post.user_id,
          status: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* UserStatuses */ "L"].ONLINE
        }]
      });
    }
  };
}
function handleNewPostEvents(queue) {
  return (myDispatch, myGetState) => {
    const posts = queue.map(msg => JSON.parse(msg.data.post)); // Receive the posts as one continuous block since they were received within a short period

    const actions = posts.map(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5__["receivedNewPost"]);
    myDispatch(Object(redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__["batchActions"])(actions)); // And any other data needed for them

    Object(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5__["getProfilesAndStatusesForPosts"])(posts, myDispatch, myGetState);
  };
}
function handlePostEditEvent(msg) {
  // Store post
  const post = JSON.parse(msg.data.post);
  dispatch(Object(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5__["receivedPost"])(post));
  Object(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5__["getProfilesAndStatusesForPosts"])([post], dispatch, getState);
  const currentChannelId = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__["getCurrentChannelId"])(getState()); // Update channel state

  if (currentChannelId === msg.broadcast.channel_id) {
    if (window.isActive) {
      dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_3__["viewChannel"])(currentChannelId));
    }
  }
}

function handlePostDeleteEvent(msg) {
  const post = JSON.parse(msg.data.post);
  dispatch(Object(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5__["postDeleted"])(post));
}

async function handleTeamAddedEvent(msg) {
  await dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_7__["getTeam"](msg.data.team_id));
  await dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_7__["getMyTeamMembers"]());
  await dispatch(mattermost_redux_actions_teams__WEBPACK_IMPORTED_MODULE_7__["getMyTeamUnreads"]());
}

function handleLeaveTeamEvent(msg) {
  const state = getState();
  dispatch(Object(redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__["batchActions"])([{
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["UserTypes"].RECEIVED_PROFILE_NOT_IN_TEAM,
    data: {
      id: msg.data.team_id,
      user_id: msg.data.user_id
    }
  }, {
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["TeamTypes"].REMOVE_MEMBER_FROM_TEAM,
    data: {
      team_id: msg.data.team_id,
      user_id: msg.data.user_id
    }
  }]));

  if (Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getCurrentUserId"])(state) === msg.data.user_id) {
    dispatch({
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["TeamTypes"].LEAVE_TEAM,
      data: {
        id: msg.data.team_id
      }
    }); // if they are on the team being removed redirect them to default team

    if (Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11__["getCurrentTeamId"])(state) === msg.data.team_id) {
      if (!global.location.pathname.startsWith('/admin_console')) {
        actions_global_actions_jsx__WEBPACK_IMPORTED_MODULE_23__[/* redirectUserToDefaultTeam */ "f"]();
      }
    }
  }
}

function handleUpdateTeamEvent(msg) {
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["TeamTypes"].UPDATED_TEAM,
    data: JSON.parse(msg.data.team)
  });
}

function handleDeleteTeamEvent(msg) {
  const deletedTeam = JSON.parse(msg.data.team);
  const state = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].getState();
  const {
    teams
  } = state.entities.teams;

  if (deletedTeam && teams && teams[deletedTeam.id] && teams[deletedTeam.id].delete_at === 0) {
    const {
      currentUserId
    } = state.entities.users;
    const {
      currentTeamId,
      myMembers
    } = state.entities.teams;
    const teamMembers = Object.values(myMembers);
    const teamMember = teamMembers.find(m => m.user_id === currentUserId && m.team_id === currentTeamId);
    let newTeamId = '';

    if (deletedTeam && teamMember && deletedTeam.id === teamMember.team_id) {
      const myTeams = {};
      Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11__["getMyTeams"])(state).forEach(t => {
        myTeams[t.id] = t;
      });

      for (let i = 0; i < teamMembers.length; i++) {
        const memberTeamId = teamMembers[i].team_id;

        if (myTeams && myTeams[memberTeamId] && myTeams[memberTeamId].delete_at === 0 && deletedTeam.id !== memberTeamId) {
          newTeamId = memberTeamId;
          break;
        }
      }
    }

    dispatch(Object(redux_batched_actions__WEBPACK_IMPORTED_MODULE_0__["batchActions"])([{
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["TeamTypes"].RECEIVED_TEAM_DELETED,
      data: {
        id: deletedTeam.id
      }
    }, {
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["TeamTypes"].UPDATED_TEAM,
      data: deletedTeam
    }]));

    if (newTeamId) {
      dispatch({
        type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["TeamTypes"].SELECT_TEAM,
        data: newTeamId
      });
      const globalState = getState();
      const redirectChannel = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__["getRedirectChannelNameForTeam"])(globalState, newTeamId);
      utils_browser_history__WEBPACK_IMPORTED_MODULE_21__[/* browserHistory */ "a"].push(`${Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11__["getCurrentTeamUrl"])(globalState)}/channels/${redirectChannel}`);
    } else {
      utils_browser_history__WEBPACK_IMPORTED_MODULE_21__[/* browserHistory */ "a"].push('/');
    }
  }
}

function handleUpdateMemberRoleEvent(msg) {
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["TeamTypes"].RECEIVED_MY_TEAM_MEMBER,
    data: msg.data.member
  });
}

function handleDirectAddedEvent(msg) {
  dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_3__["getChannelAndMyMember"])(msg.broadcast.channel_id));
}

function handleUserAddedEvent(msg) {
  const currentChannelId = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__["getCurrentChannelId"])(getState());

  if (currentChannelId === msg.broadcast.channel_id) {
    dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_3__["getChannelStats"])(currentChannelId));
    dispatch({
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["UserTypes"].RECEIVED_PROFILE_IN_CHANNEL,
      data: {
        id: msg.broadcast.channel_id,
        user_id: msg.data.user_id
      }
    });
  }

  const currentTeamId = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11__["getCurrentTeamId"])(getState());
  const currentUserId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getCurrentUserId"])(getState());

  if (msg.data.team_id === "" && currentUserId === msg.data.user_id || currentTeamId === msg.data.team_id && currentUserId === msg.data.user_id) {
    dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_3__["getChannelAndMyMember"])(msg.broadcast.channel_id));
  }
}

function handleUserRemovedEvent(msg) {
  const state = getState();
  const currentChannel = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__["getCurrentChannel"])(state) || {};
  const currentUserId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getCurrentUserId"])(state);

  if (msg.broadcast.user_id === currentUserId) {
    dispatch(Object(actions_channel_actions_jsx__WEBPACK_IMPORTED_MODULE_22__[/* loadChannelsForCurrentUser */ "d"])());
    const rhsChannelId = Object(selectors_rhs__WEBPACK_IMPORTED_MODULE_15__[/* getSelectedChannelId */ "p"])(state);

    if (msg.data.channel_id === rhsChannelId) {
      dispatch(Object(actions_views_rhs__WEBPACK_IMPORTED_MODULE_19__[/* closeRightHandSide */ "b"])());
    }

    if (msg.data.channel_id === currentChannel.id) {
      if (msg.data.remover_id === msg.broadcast.user_id) {
        utils_browser_history__WEBPACK_IMPORTED_MODULE_21__[/* browserHistory */ "a"].push(Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11__["getCurrentRelativeTeamUrl"])(state));
      } else {
        const user = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getUser"])(state, msg.data.remover_id) || {};
        dispatch(Object(actions_views_modals__WEBPACK_IMPORTED_MODULE_16__[/* openModal */ "b"])({
          modalId: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* ModalIdentifiers */ "p"].REMOVED_FROM_CHANNEL,
          dialogType: components_removed_from_channel_modal__WEBPACK_IMPORTED_MODULE_33__[/* default */ "a"],
          dialogProps: {
            channelName: currentChannel.display_name,
            remover: user.username
          }
        }));
      }
    }

    dispatch({
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["ChannelTypes"].LEAVE_CHANNEL,
      data: {
        id: msg.data.channel_id,
        user_id: msg.broadcast.user_id
      }
    });
  } else if (msg.broadcast.channel_id === currentChannel.id) {
    dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_3__["getChannelStats"])(currentChannel.id));
    dispatch({
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["UserTypes"].RECEIVED_PROFILE_NOT_IN_CHANNEL,
      data: {
        id: msg.broadcast.channel_id,
        user_id: msg.data.user_id
      }
    });
  }
}

function handleUserUpdatedEvent(msg) {
  const currentUser = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getCurrentUser"])(getState());
  const user = msg.data.user;

  if (currentUser.id === user.id) {
    if (user.update_at > currentUser.update_at) {
      // Need to request me to make sure we don't override with sanitized fields from the
      // websocket event
      Object(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_8__["getMe"])()(dispatch, getState);
    }
  } else {
    dispatch({
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["UserTypes"].RECEIVED_PROFILE,
      data: user
    });
  }
}

function handleRoleAddedEvent(msg) {
  const role = JSON.parse(msg.data.role);
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["RoleTypes"].RECEIVED_ROLE,
    data: role
  });
}

function handleRoleRemovedEvent(msg) {
  const role = JSON.parse(msg.data.role);
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["RoleTypes"].ROLE_DELETED,
    data: role
  });
}

function handleRoleUpdatedEvent(msg) {
  const role = JSON.parse(msg.data.role);
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["RoleTypes"].RECEIVED_ROLE,
    data: role
  });
}

function handleChannelCreatedEvent(msg) {
  const channelId = msg.data.channel_id;
  const teamId = msg.data.team_id;
  const state = getState();

  if (Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11__["getCurrentTeamId"])(state) === teamId && !Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__["getChannel"])(state, channelId)) {
    dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_3__["getChannelAndMyMember"])(channelId));
  }
}

function handleChannelDeletedEvent(msg) {
  const state = getState();
  const config = Object(mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_12__["getConfig"])(state);
  const viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';

  if (Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__["getCurrentChannelId"])(state) === msg.data.channel_id && !viewArchivedChannels) {
    const teamUrl = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11__["getCurrentRelativeTeamUrl"])(state);
    const currentTeamId = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_11__["getCurrentTeamId"])(state);
    const redirectChannel = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__["getRedirectChannelNameForTeam"])(state, currentTeamId);
    utils_browser_history__WEBPACK_IMPORTED_MODULE_21__[/* browserHistory */ "a"].push(teamUrl + '/channels/' + redirectChannel);
  }

  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["ChannelTypes"].RECEIVED_CHANNEL_DELETED,
    data: {
      id: msg.data.channel_id,
      team_id: msg.broadcast.team_id,
      deleteAt: msg.data.delete_at,
      viewArchivedChannels
    }
  });
}

function handlePreferenceChangedEvent(msg) {
  const preference = JSON.parse(msg.data.preference);
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["PreferenceTypes"].RECEIVED_PREFERENCES,
    data: [preference]
  });

  if (addedNewDmUser(preference)) {
    Object(actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_26__[/* loadProfilesForSidebar */ "i"])();
  }
}

function handlePreferencesChangedEvent(msg) {
  const preferences = JSON.parse(msg.data.preferences);
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["PreferenceTypes"].RECEIVED_PREFERENCES,
    data: preferences
  });

  if (preferences.findIndex(addedNewDmUser) !== -1) {
    Object(actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_26__[/* loadProfilesForSidebar */ "i"])();
  }
}

function handlePreferencesDeletedEvent(msg) {
  const preferences = JSON.parse(msg.data.preferences);
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["PreferenceTypes"].DELETED_PREFERENCES,
    data: preferences
  });
}

function addedNewDmUser(preference) {
  return preference.category === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* Constants */ "g"].Preferences.CATEGORY_DIRECT_CHANNEL_SHOW && preference.value === 'true';
}

function handleUserTypingEvent(msg) {
  const state = getState();
  const config = Object(mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_12__["getConfig"])(state);
  const currentUserId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getCurrentUserId"])(state);
  const currentUser = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getCurrentUser"])(state);
  const userId = msg.data.user_id;
  const data = {
    id: msg.broadcast.channel_id + msg.data.parent_id,
    userId,
    now: Date.now()
  };
  dispatch({
    type: mattermost_redux_constants__WEBPACK_IMPORTED_MODULE_2__["WebsocketEvents"].TYPING,
    data
  }, getState);
  setTimeout(() => {
    dispatch({
      type: mattermost_redux_constants__WEBPACK_IMPORTED_MODULE_2__["WebsocketEvents"].STOP_TYPING,
      data
    });
  }, parseInt(config.TimeBetweenUserTypingUpdatesMilliseconds, 10));

  if (!currentUser && userId !== currentUserId) {
    Object(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_8__["getProfilesByIds"])([userId])(dispatch, getState);
  }

  const status = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getStatusForUserId"])(state, userId);

  if (status !== mattermost_redux_constants__WEBPACK_IMPORTED_MODULE_2__["General"].ONLINE) {
    Object(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_8__["getStatusesByIds"])([userId])(dispatch, getState);
  }
}

function handleStatusChangedEvent(msg) {
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["UserTypes"].RECEIVED_STATUSES,
    data: [{
      user_id: msg.data.user_id,
      status: msg.data.status
    }]
  });
}

function handleHelloEvent(msg) {
  Object(mattermost_redux_actions_general__WEBPACK_IMPORTED_MODULE_4__["setServerVersion"])(msg.data.server_version)(dispatch, getState);
}

function handleReactionAddedEvent(msg) {
  const reaction = JSON.parse(msg.data.reaction);
  dispatch(Object(mattermost_redux_actions_posts__WEBPACK_IMPORTED_MODULE_5__["getCustomEmojiForReaction"])(reaction.emoji_name));
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["PostTypes"].RECEIVED_REACTION,
    data: reaction
  });
}

function handleAddEmoji(msg) {
  const data = JSON.parse(msg.data.emoji);
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["EmojiTypes"].RECEIVED_CUSTOM_EMOJI,
    data
  });
}

function handleReactionRemovedEvent(msg) {
  const reaction = JSON.parse(msg.data.reaction);
  dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["PostTypes"].REACTION_DELETED,
    data: reaction
  });
}

function handleChannelViewedEvent(msg) {
  // Useful for when multiple devices have the app open to different channels
  if ((!window.isActive || Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_13__["getCurrentChannelId"])(getState()) !== msg.data.channel_id) && Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_10__["getCurrentUserId"])(getState()) === msg.broadcast.user_id) {
    dispatch(Object(mattermost_redux_actions_channels__WEBPACK_IMPORTED_MODULE_3__["markChannelAsRead"])(msg.data.channel_id, '', false));
  }
}

function handlePluginEnabled(msg) {
  const manifest = msg.data.manifest;
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch({
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* ActionTypes */ "b"].RECEIVED_WEBAPP_PLUGIN,
    data: manifest
  });
  Object(plugins__WEBPACK_IMPORTED_MODULE_29__[/* loadPlugin */ "b"])(manifest);
}

function handlePluginDisabled(msg) {
  const manifest = msg.data.manifest;
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch({
    type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* ActionTypes */ "b"].REMOVED_WEBAPP_PLUGIN,
    data: manifest
  });
  Object(plugins__WEBPACK_IMPORTED_MODULE_29__[/* removePlugin */ "d"])(manifest);
}

function handleUserRoleUpdated(msg) {
  const user = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].getState().entities.users.profiles[msg.data.user_id];

  if (user) {
    const roles = msg.data.roles;
    const demoted = user.roles.includes(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* Constants */ "g"].PERMISSIONS_SYSTEM_ADMIN) && !roles.includes(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* Constants */ "g"].PERMISSIONS_SYSTEM_ADMIN);
    stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch({
      type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["UserTypes"].RECEIVED_PROFILE,
      data: { ...user,
        roles
      }
    });

    if (demoted && global.location.pathname.startsWith('/admin_console')) {
      actions_global_actions_jsx__WEBPACK_IMPORTED_MODULE_23__[/* redirectUserToDefaultTeam */ "f"]();
    }
  }
}

function handleConfigChanged(msg) {
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["GeneralTypes"].CLIENT_CONFIG_RECEIVED,
    data: msg.data.config
  });
}

function handleLicenseChanged(msg) {
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["GeneralTypes"].CLIENT_LICENSE_RECEIVED,
    data: msg.data.license
  });
}

function handlePluginStatusesChangedEvent(msg) {
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["AdminTypes"].RECEIVED_PLUGIN_STATUSES,
    data: msg.data.plugin_statuses
  });
}

function handleOpenDialogEvent(msg) {
  const data = msg.data && msg.data.dialog || {};
  const dialog = JSON.parse(data);
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch({
    type: mattermost_redux_action_types__WEBPACK_IMPORTED_MODULE_1__["IntegrationTypes"].RECEIVED_DIALOG,
    data: dialog
  });
  const currentTriggerId = getState().entities.integrations.dialogTriggerId;

  if (dialog.trigger_id !== currentTriggerId) {
    return;
  }

  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch(Object(actions_views_modals__WEBPACK_IMPORTED_MODULE_16__[/* openModal */ "b"])({
    modalId: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_30__[/* ModalIdentifiers */ "p"].INTERACTIVE_DIALOG,
    dialogType: components_interactive_dialog__WEBPACK_IMPORTED_MODULE_34__[/* default */ "a"]
  }));
} //会有三次


function handleOpenMeeting(msg) {
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch(Object(actions_views_meeting__WEBPACK_IMPORTED_MODULE_17__[/* addInvitationList */ "a"])(msg));
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch(Object(actions_views_meeting__WEBPACK_IMPORTED_MODULE_17__[/* openNextInvitation */ "i"])());
} // 设置我现在的会议状态


function handleMyMeeting(isMeeting) {
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch(Object(actions_views_meeting__WEBPACK_IMPORTED_MODULE_17__[/* setMyMeeting */ "l"])(isMeeting));
} // 设置会议音效


function handleMeetingAv(msg) {
  //console.log("1111----",msg);
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch(Object(actions_views_meeting__WEBPACK_IMPORTED_MODULE_17__[/* setMeetingAV */ "k"])(msg));
} // 会议关闭


function handleMeetingClose(msg) {
  //console.log("2222----",msg);
  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_27__[/* default */ "a"].dispatch(Object(actions_views_meeting__WEBPACK_IMPORTED_MODULE_17__[/* meetingClose */ "h"])(msg));
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(37)))

/***/ }),

/***/ 1726:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return filterAndSortTeamsByDisplayName; });
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// Use when sorting multiple teams by their `display_name` field
function compareTeamsByDisplayName(locale, a, b) {
  if (a.display_name !== b.display_name) {
    return a.display_name.localeCompare(b.display_name, locale, {
      numeric: true
    });
  }

  return a.name.localeCompare(b.name, locale, {
    numeric: true
  });
} // Use to filter out teams that are deleted and without display_name, then sort by their `display_name` field


function filterAndSortTeamsByDisplayName(teams, locale) {
  if (!teams) {
    return [];
  }

  return teams.filter(team => {
    return team && !team.delete_at > 0 && team.display_name != null;
  }).sort((a, b) => {
    return compareTeamsByDisplayName(locale, a, b);
  });
}

/***/ }),

/***/ 1728:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SizeAwareImage; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var components_loading_image_preview__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2001);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


 // SizeAwareImage is a component used for rendering images where the dimensions of the image are important for
// ensuring that the page is laid out correctly.

class SizeAwareImage extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  constructor(_props) {
    super(_props);

    _defineProperty(this, "handleLoad", event => {
      if (this.mounted) {
        const image = event.target;

        if (this.props.onImageLoaded && image.naturalHeight) {
          this.props.onImageLoaded({
            height: image.naturalHeight,
            width: image.naturalWidth
          });
        }

        this.setState({
          loaded: true,
          error: false
        });
      }
    });

    _defineProperty(this, "handleError", () => {
      if (this.mounted) {
        if (this.props.onImageLoadFail) {
          this.props.onImageLoadFail();
        }

        this.setState({
          error: true
        });
      }
    });

    _defineProperty(this, "renderImageLoaderIfNeeded", () => {
      if (!this.state.loaded && this.props.showLoader && !this.state.error) {
        return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
          style: {
            position: 'absolute',
            top: '50%',
            transform: 'translate(-50%, -50%)',
            left: '50%'
          }
        }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_loading_image_preview__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
          containerClass: 'file__image-loading'
        }));
      }

      return null;
    });

    _defineProperty(this, "renderImageOrPlaceholder", () => {
      const {
        dimensions,
        src,
        ...props
      } = this.props;
      let placeHolder;
      let imageStyleChangesOnLoad = {};

      if (dimensions && dimensions.width && !this.state.loaded) {
        placeHolder = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
          className: `image-loading__container ${this.props.className}`
        }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: `0 0 ${dimensions.width} ${dimensions.height}`,
          style: {
            verticalAlign: 'middle',
            maxHeight: dimensions.height,
            maxWidth: dimensions.width
          }
        }));
      }

      Reflect.deleteProperty(props, 'showLoader');
      Reflect.deleteProperty(props, 'onImageLoaded');
      Reflect.deleteProperty(props, 'onImageLoadFail');

      if (!this.state.loaded && dimensions) {
        imageStyleChangesOnLoad = {
          position: 'absolute',
          top: 0,
          height: 1,
          width: 1,
          visibility: 'hidden',
          overflow: 'hidden'
        };
      }

      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment, null, placeHolder, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("img", _extends({
        alt: "image placeholder"
      }, props, {
        src: src,
        onLoad: this.handleLoad,
        onError: this.handleError,
        style: imageStyleChangesOnLoad
      })));
    });

    this.state = {
      loaded: false
    };
    this.heightTimeout = 0;
  }

  componentDidMount() {
    this.mounted = true;
  }

  componentWillUnmount() {
    this.mounted = false;
  }

  render() {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment, null, this.renderImageLoaderIfNeeded(), this.renderImageOrPlaceholder());
  }

}

_defineProperty(SizeAwareImage, "propTypes", {
  /*
   * The source URL of the image
   */
  src: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,

  /*
   * dimensions object to create empty space required to prevent scroll pop
   */
  dimensions: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,

  /*
   * Boolean value to pass for showing a loader when image is being loaded
   */
  showLoader: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /*
   * A callback that is called as soon as the image component has a height value
   */
  onImageLoaded: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /*
   * A callback that is called when image load fails
   */
  onImageLoadFail: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /*
   * css classes that can added to the img as well as parent div on svg for placeholder
   */
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
});

/***/ }),

/***/ 1730:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return menuItem; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


function menuItem(Component) {
  class MenuItem extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
    render() {
      const {
        id,
        show,
        icon,
        text,
        ...props
      } = this.props;

      if (!show) {
        return null;
      }

      let textProp = text;

      if (icon) {
        textProp = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
          className: "icon"
        }, icon), text);
      }

      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", {
        className: "MenuItem",
        role: "menuitem",
        id: id
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({
        text: textProp
      }, props)));
    }

  }

  _defineProperty(MenuItem, "propTypes", {
    show: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
    id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
    icon: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node,
    text: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string
  });

  _defineProperty(MenuItem, "defaultProps", {
    show: true
  });

  return MenuItem;
}

/***/ }),

/***/ 1732:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


const split = (content, keyword) => {
  return content.split(keyword).reduce((acc, cur, idx) => {
    if (idx === 0) {
      return [...acc, cur];
    }

    return [...acc, keyword, cur];
  }, []).filter(text => text.length);
};

const style = {
  color: '#00BC70'
};
/* harmony default export */ __webpack_exports__["a"] = (({
  content,
  keyword
}) => {
  if (typeof keyword !== 'string' || keyword.length === 0) {
    return content;
  }

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0__["Fragment"], null, split(content, keyword).map((text, idx) => {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
      key: idx
    }, text === keyword ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      style: style
    }, text) : text);
  }));
});

/***/ }),

/***/ 1734:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return loadIncomingHooksAndProfilesForTeam; });
/* unused harmony export loadProfilesForIncomingHooks */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return loadOutgoingHooksAndProfilesForTeam; });
/* unused harmony export loadProfilesForOutgoingHooks */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return loadCommandsAndProfilesForTeam; });
/* unused harmony export loadProfilesForCommands */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return loadOAuthAppsAndProfiles; });
/* unused harmony export loadProfilesForOAuthApps */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getYoutubeVideoInfo; });
/* harmony import */ var superagent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2060);
/* harmony import */ var superagent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(superagent__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mattermost_redux_actions_integrations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1591);
/* harmony import */ var mattermost_redux_actions_integrations__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_integrations__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/* harmony import */ var mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var actions_views_modals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1578);
/* harmony import */ var components_interactive_dialog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1964);
/* harmony import */ var stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(14);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








const DEFAULT_PAGE_SIZE = 100;
function loadIncomingHooksAndProfilesForTeam(teamId, page = 0, perPage = DEFAULT_PAGE_SIZE) {
  return async dispatch => {
    const {
      data
    } = await dispatch(mattermost_redux_actions_integrations__WEBPACK_IMPORTED_MODULE_1__["getIncomingHooks"](teamId, page, perPage));

    if (data) {
      dispatch(loadProfilesForIncomingHooks(data));
    }
  };
}
function loadProfilesForIncomingHooks(hooks) {
  return async (dispatch, getState) => {
    const state = getState();
    const profilesToLoad = {};

    for (let i = 0; i < hooks.length; i++) {
      const hook = hooks[i];

      if (!Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_3__["getUser"])(state, hook.user_id)) {
        profilesToLoad[hook.user_id] = true;
      }
    }

    const list = Object.keys(profilesToLoad);

    if (list.length === 0) {
      return;
    }

    dispatch(Object(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2__["getProfilesByIds"])(list));
  };
}
function loadOutgoingHooksAndProfilesForTeam(teamId, page = 0, perPage = DEFAULT_PAGE_SIZE) {
  return async dispatch => {
    const {
      data
    } = await dispatch(mattermost_redux_actions_integrations__WEBPACK_IMPORTED_MODULE_1__["getOutgoingHooks"]('', teamId, page, perPage));

    if (data) {
      dispatch(loadProfilesForOutgoingHooks(data));
    }
  };
}
function loadProfilesForOutgoingHooks(hooks) {
  return async (dispatch, getState) => {
    const state = getState();
    const profilesToLoad = {};

    for (let i = 0; i < hooks.length; i++) {
      const hook = hooks[i];

      if (!Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_3__["getUser"])(state, hook.creator_id)) {
        profilesToLoad[hook.creator_id] = true;
      }
    }

    const list = Object.keys(profilesToLoad);

    if (list.length === 0) {
      return;
    }

    dispatch(Object(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2__["getProfilesByIds"])(list));
  };
}
function loadCommandsAndProfilesForTeam(teamId) {
  return async dispatch => {
    const {
      data
    } = await dispatch(mattermost_redux_actions_integrations__WEBPACK_IMPORTED_MODULE_1__["getCustomTeamCommands"](teamId));

    if (data) {
      dispatch(loadProfilesForCommands(data));
    }
  };
}
function loadProfilesForCommands(commands) {
  return async (dispatch, getState) => {
    const state = getState();
    const profilesToLoad = {};

    for (let i = 0; i < commands.length; i++) {
      const command = commands[i];

      if (!Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_3__["getUser"])(state, command.creator_id)) {
        profilesToLoad[command.creator_id] = true;
      }
    }

    const list = Object.keys(profilesToLoad);

    if (list.length === 0) {
      return;
    }

    dispatch(Object(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2__["getProfilesByIds"])(list));
  };
}
function loadOAuthAppsAndProfiles(page = 0, perPage = DEFAULT_PAGE_SIZE) {
  return async dispatch => {
    const {
      data
    } = await dispatch(mattermost_redux_actions_integrations__WEBPACK_IMPORTED_MODULE_1__["getOAuthApps"](page, perPage));

    if (data) {
      dispatch(loadProfilesForOAuthApps(data));
    }
  };
}
function loadProfilesForOAuthApps(apps) {
  return async (dispatch, getState) => {
    const state = getState();
    const profilesToLoad = {};

    for (let i = 0; i < apps.length; i++) {
      const app = apps[i];

      if (!Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_3__["getUser"])(state, app.creator_id)) {
        profilesToLoad[app.creator_id] = true;
      }
    }

    const list = Object.keys(profilesToLoad);

    if (list.length === 0) {
      return;
    }

    dispatch(Object(mattermost_redux_actions_users__WEBPACK_IMPORTED_MODULE_2__["getProfilesByIds"])(list));
  };
}
function getYoutubeVideoInfo(googleKey, videoId, success, error) {
  superagent__WEBPACK_IMPORTED_MODULE_0___default.a.get('https://www.googleapis.com/youtube/v3/videos').query({
    part: 'snippet',
    id: videoId,
    key: googleKey
  }).end((err, res) => {
    if (err) {
      return error(err);
    }

    if (!res.body) {
      console.error('Missing response body for getYoutubeVideoInfo'); // eslint-disable-line no-console
    }

    return success(res.body);
  });
}
let previousTriggerId = '';
stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].subscribe(() => {
  const state = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].getState();
  const currentTriggerId = state.entities.integrations.dialogTriggerId;

  if (currentTriggerId === previousTriggerId) {
    return;
  }

  previousTriggerId = currentTriggerId;
  const dialog = state.entities.integrations.dialog || {};

  if (dialog.trigger_id !== currentTriggerId) {
    return;
  }

  stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].dispatch(Object(actions_views_modals__WEBPACK_IMPORTED_MODULE_5__[/* openModal */ "b"])({
    modalId: utils_constants__WEBPACK_IMPORTED_MODULE_4__[/* ModalIdentifiers */ "p"].INTERACTIVE_DIALOG,
    dialogType: components_interactive_dialog__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]
  }));
});

/***/ }),

/***/ 1745:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllGroups = getAllGroups;
exports.getGroup = getGroup;
exports.getGroupMemberCount = getGroupMemberCount;
exports.getGroupTeams = getGroupTeams;
exports.getGroupChannels = getGroupChannels;
exports.getGroupMembers = getGroupMembers;
exports.getGroupsAssociatedToChannel = exports.getGroupsNotAssociatedToChannel = exports.getGroupsAssociatedToTeam = exports.getGroupsNotAssociatedToTeam = void 0;

__webpack_require__(36);

__webpack_require__(19);

__webpack_require__(20);

__webpack_require__(419);

__webpack_require__(12);

__webpack_require__(13);

__webpack_require__(24);

__webpack_require__(55);

var _reselect = __webpack_require__(94);

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var emptyList = [];
var emptySyncables = {
  teams: [],
  channels: []
};

function getAllGroups(state) {
  return state.entities.groups.groups;
}

function getGroup(state, id) {
  return getAllGroups(state)[id];
}

function getGroupMemberCount(state, id) {
  var memberData = state.entities.groups.members;
  var groupMemberData = memberData[id];

  if (!groupMemberData) {
    return 0;
  }

  return memberData[id].totalMemberCount;
}

function getGroupSyncables(state, id) {
  return state.entities.groups.syncables[id] || emptySyncables;
}

function getGroupTeams(state, id) {
  return getGroupSyncables(state, id).teams;
}

function getGroupChannels(state, id) {
  return getGroupSyncables(state, id).channels;
}

function getGroupMembers(state, id) {
  var groupMemberData = state.entities.groups.members[id];

  if (!groupMemberData) {
    return emptyList;
  }

  return groupMemberData.members;
}

var teamGroupIDs = function teamGroupIDs(state, teamID) {
  var _state$entities$teams;

  return ((_state$entities$teams = state.entities.teams.groupsAssociatedToTeam[teamID]) === null || _state$entities$teams === void 0 ? void 0 : _state$entities$teams.ids) || [];
};

var channelGroupIDs = function channelGroupIDs(state, channelID) {
  var _state$entities$chann;

  return ((_state$entities$chann = state.entities.channels.groupsAssociatedToChannel[channelID]) === null || _state$entities$chann === void 0 ? void 0 : _state$entities$chann.ids) || [];
};

var getTeamGroupIDSet = (0, _reselect.createSelector)(teamGroupIDs, function (teamIDs) {
  return new Set(teamIDs);
});
var getChannelGroupIDSet = (0, _reselect.createSelector)(channelGroupIDs, function (channelIDs) {
  return new Set(channelIDs);
});
var getGroupsNotAssociatedToTeam = (0, _reselect.createSelector)(getAllGroups, function (state, teamID) {
  return getTeamGroupIDSet(state, teamID);
}, function (allGroups, teamGroupIDSet) {
  return Object.entries(allGroups).filter(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        groupID = _ref2[0];

    return !teamGroupIDSet.has(groupID);
  }).map(function (entry) {
    return entry[1];
  });
});
exports.getGroupsNotAssociatedToTeam = getGroupsNotAssociatedToTeam;
var getGroupsAssociatedToTeam = (0, _reselect.createSelector)(getAllGroups, function (state, teamID) {
  return getTeamGroupIDSet(state, teamID);
}, function (allGroups, teamGroupIDSet) {
  return Object.entries(allGroups).filter(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        groupID = _ref4[0];

    return teamGroupIDSet.has(groupID);
  }).map(function (entry) {
    return entry[1];
  });
});
exports.getGroupsAssociatedToTeam = getGroupsAssociatedToTeam;
var getGroupsNotAssociatedToChannel = (0, _reselect.createSelector)(getAllGroups, function (state, channelID) {
  return getChannelGroupIDSet(state, channelID);
}, function (allGroups, channelGroupIDSet) {
  return Object.entries(allGroups).filter(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        groupID = _ref6[0];

    return !channelGroupIDSet.has(groupID);
  }).map(function (entry) {
    return entry[1];
  });
});
exports.getGroupsNotAssociatedToChannel = getGroupsNotAssociatedToChannel;
var getGroupsAssociatedToChannel = (0, _reselect.createSelector)(getAllGroups, function (state, channelID) {
  return getChannelGroupIDSet(state, channelID);
}, function (allGroups, channelGroupIDSet) {
  return Object.entries(allGroups).filter(function (_ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
        groupID = _ref8[0];

    return channelGroupIDSet.has(groupID);
  }).map(function (entry) {
    return entry[1];
  });
});
exports.getGroupsAssociatedToChannel = getGroupsAssociatedToChannel;

/***/ }),

/***/ 1754:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// CONCATENATED MODULE: ./components/svg/status_away_avatar_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class status_away_avatar_icon_StatusAwayAvatarIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "mobile.set_status.away.icon",
      defaultMessage: "Away Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "13px",
      height: "13px",
      viewBox: "0 0 12 12",
      style: style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("path", {
      className: "away--icon",
      d: "M9.081,5.712C9.267,5.712 9.417,5.863 9.417,6.048L9.417,9.086L11.864,10.499C12.025,10.592 12.08,10.797 11.987,10.958L11.482,11.832C11.39,11.993 11.184,12.048 11.023,11.955L7.904,10.154C7.788,10.087 7.727,9.961 7.737,9.836C7.736,9.827 7.736,9.818 7.736,9.809L7.736,6.048C7.736,5.863 7.886,5.712 8.072,5.712L9.081,5.712ZM4.812,11.513L4.605,11.513C2.325,11.41 0.253,10.374 0.046,9.027C-0.058,8.923 0.046,8.509 0.046,8.405C0.15,7.576 0.357,6.437 0.771,5.815C0.978,5.401 2.015,5.297 2.015,5.297C2.015,5.297 2.015,7.369 4.605,7.369L5.019,7.369C4.915,7.784 4.812,8.198 4.812,8.612C4.812,9.648 5.226,10.581 5.848,11.41C5.537,11.513 5.123,11.513 4.812,11.513ZM4.605,0.117C6.034,0.117 7.195,1.277 7.195,2.707C7.195,4.136 6.034,5.297 4.605,5.297C3.175,5.297 2.015,4.136 2.015,2.707C2.015,1.277 3.175,0.117 4.605,0.117Z"
    }))));
  }

}
const style = {
  fillRule: 'evenodd',
  clipRule: 'evenodd',
  strokeLinejoin: 'round',
  strokeMiterlimit: 1.41421
};
// CONCATENATED MODULE: ./components/svg/status_away_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class status_away_icon_StatusAwayIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "mobile.set_status.away.icon",
      defaultMessage: "Away Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "100%",
      height: "100%",
      viewBox: "0 0 20 20",
      style: status_away_icon_style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("path", {
      className: "away--icon",
      d: "M10,0C15.519,0 20,4.481 20,10C20,15.519 15.519,20 10,20C4.481,20 0,15.519 0,10C0,4.481 4.481,0 10,0ZM10.27,3C10.949,3 11.5,3.586 11.5,4.307L11.5,9.379L15.002,12.881C15.492,13.37 15.499,14.158 15.019,14.638L14.638,15.019C14.158,15.499 13.37,15.492 12.881,15.002L8.887,11.008C8.739,10.861 8.636,10.686 8.576,10.501C8.528,10.402 8.5,10.299 8.5,10.193L8.5,4.307C8.5,3.586 9.051,3 9.73,3L10.27,3Z"
    }))));
  }

}
const status_away_icon_style = {
  fillRule: 'evenodd',
  clipRule: 'evenodd',
  strokeLinejoin: 'round',
  strokeMiterlimit: 1.41421
};
// CONCATENATED MODULE: ./components/svg/status_dnd_avatar_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class status_dnd_avatar_icon_StatusDndAvatarIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "mobile.set_status.dnd.icon",
      defaultMessage: "Do Not Disturb Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      id: "Layer_1",
      x: "0px",
      y: "0px",
      width: "13px",
      height: "13px",
      viewBox: "-299 391 12 12",
      style: status_dnd_avatar_icon_style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", null, react_default.a.createElement("ellipse", {
      className: "dnd--icon",
      cx: "-294.6",
      cy: "394",
      rx: "2.5",
      ry: "2.5"
    }), react_default.a.createElement("path", {
      className: "dnd--icon",
      d: "M-293.8,399.4c0-0.4,0.1-0.7,0.2-1c-0.3,0.1-0.6,0.2-1,0.2c-2.5,0-2.5-2-2.5-2s-1,0.1-1.2,0.5c-0.4,0.6-0.6,1.7-0.7,2.5 c0,0.1-0.1,0.5,0,0.6c0.2,1.3,2.2,2.3,4.4,2.4c0,0,0.1,0,0.1,0c0,0,0.1,0,0.1,0c0.7,0,1.4-0.1,2-0.3 C-293.3,401.5-293.8,400.5-293.8,399.4z"
    })), react_default.a.createElement("path", {
      className: "dnd--icon",
      d: "M-287,400c0,0.1-0.1,0.1-0.1,0.1l-4.9,0c-0.1,0-0.1-0.1-0.1-0.1v-1.6c0-0.1,0.1-0.1,0.1-0.1l4.9,0c0.1,0,0.1,0.1,0.1,0.1 V400z"
    }))));
  }

}
const status_dnd_avatar_icon_style = {
  enableBackground: 'new -299 391 12 12'
};
// CONCATENATED MODULE: ./components/svg/status_dnd_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class status_dnd_icon_StatusDndIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "mobile.set_status.dnd.icon",
      defaultMessage: "Do Not Disturb Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "100%",
      height: "100%",
      viewBox: "0 0 20 20",
      style: status_dnd_icon_style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("path", {
      className: "dnd--icon",
      d: "M10,0c5.519,0 10,4.481 10,10c0,5.519 -4.481,10 -10,10c-5.519,0 -10,-4.481 -10,-10c0,-5.519 4.481,-10 10,-10Zm5.25,8.5l-10.5,0c-0.414,0 -0.75,0.336 -0.75,0.75l0,1.5c0,0.414 0.336,0.75 0.75,0.75l10.5,0c0.414,0 0.75,-0.336 0.75,-0.75l0,-1.5c0,-0.414 -0.336,-0.75 -0.75,-0.75Z"
    }))));
  }

}
const status_dnd_icon_style = {
  fillRule: 'evenodd',
  clipRule: 'evenodd',
  strokeLinejoin: 'round',
  strokeMiterlimit: 1.41421
};
// CONCATENATED MODULE: ./components/svg/status_offline_avatar_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class status_offline_avatar_icon_StatusDndAvatarIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "mobile.set_status.offline.icon",
      defaultMessage: "Offline Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      id: "Layer_1",
      x: "0px",
      y: "0px",
      width: "13px",
      height: "13px",
      viewBox: "-299 391 12 12",
      style: status_offline_avatar_icon_style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", null, react_default.a.createElement("g", null, react_default.a.createElement("ellipse", {
      className: "offline--icon",
      cx: "-294.5",
      cy: "394",
      rx: "2.5",
      ry: "2.5"
    }), react_default.a.createElement("path", {
      className: "offline--icon",
      d: "M-294.3,399.7c0-0.4,0.1-0.8,0.2-1.2c-0.1,0-0.2,0-0.4,0c-2.5,0-2.5-2-2.5-2s-1,0.1-1.2,0.5c-0.4,0.6-0.6,1.7-0.7,2.5 c0,0.1-0.1,0.5,0,0.6c0.2,1.3,2.2,2.3,4.4,2.4h0.1h0.1c0.3,0,0.7,0,1-0.1C-293.9,401.6-294.3,400.7-294.3,399.7z"
    }))), react_default.a.createElement("g", null, react_default.a.createElement("path", {
      className: "offline--icon",
      d: "M-288.9,399.4l1.8-1.8c0.1-0.1,0.1-0.3,0-0.3l-0.7-0.7c-0.1-0.1-0.3-0.1-0.3,0l-1.8,1.8l-1.8-1.8c-0.1-0.1-0.3-0.1-0.3,0 l-0.7,0.7c-0.1,0.1-0.1,0.3,0,0.3l1.8,1.8l-1.8,1.8c-0.1,0.1-0.1,0.3,0,0.3l0.7,0.7c0.1,0.1,0.3,0.1,0.3,0l1.8-1.8l1.8,1.8 c0.1,0.1,0.3,0.1,0.3,0l0.7-0.7c0.1-0.1,0.1-0.3,0-0.3L-288.9,399.4z"
    })))));
  }

}
const status_offline_avatar_icon_style = {
  enableBackground: 'new -299 391 12 12'
};
// CONCATENATED MODULE: ./components/svg/status_offline_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class status_offline_icon_StatusOfflineIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "mobile.set_status.offline.icon",
      defaultMessage: "Offline Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "100%",
      height: "100%",
      className: "offline--icon",
      viewBox: "0 0 20 20",
      style: status_offline_icon_style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("path", {
      d: "M10,0c5.519,0 10,4.481 10,10c0,5.519 -4.481,10 -10,10c-5.519,0 -10,-4.481 -10,-10c0,-5.519 4.481,-10 10,-10Zm0,2c4.415,0 8,3.585 8,8c0,4.415 -3.585,8 -8,8c-4.415,0 -8,-3.585 -8,-8c0,-4.415 3.585,-8 8,-8Z"
    }))));
  }

}
const status_offline_icon_style = {
  fillRule: 'evenodd',
  clipRule: 'evenodd',
  strokeLinejoin: 'round',
  strokeMiterlimit: 1.41421
};
// CONCATENATED MODULE: ./components/svg/status_online_avatar_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class status_online_avatar_icon_StatusOnlineAvatarIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "mobile.set_status.online.icon",
      defaultMessage: "Online Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      id: "Layer_1",
      x: "0px",
      y: "0px",
      width: "13px",
      height: "13px",
      viewBox: "-243 245 12 12",
      style: status_online_avatar_icon_style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", null, react_default.a.createElement("path", {
      className: "online--icon",
      d: "M-236,250.5C-236,250.5-236,250.5-236,250.5C-236,250.5-236,250.5-236,250.5C-236,250.5-236,250.5-236,250.5z"
    }), react_default.a.createElement("ellipse", {
      className: "online--icon",
      cx: "-238.5",
      cy: "248",
      rx: "2.5",
      ry: "2.5"
    })), react_default.a.createElement("path", {
      className: "online--icon",
      d: "M-238.9,253.8c0-0.4,0.1-0.9,0.2-1.3c-2.2-0.2-2.2-2-2.2-2s-1,0.1-1.2,0.5c-0.4,0.6-0.6,1.7-0.7,2.5c0,0.1-0.1,0.5,0,0.6 c0.2,1.3,2.2,2.3,4.4,2.4c0,0,0.1,0,0.1,0c0,0,0.1,0,0.1,0c0,0,0.1,0,0.1,0C-238.7,255.7-238.9,254.8-238.9,253.8z"
    }), react_default.a.createElement("g", null, react_default.a.createElement("g", null, react_default.a.createElement("path", {
      className: "online--icon",
      d: "M-232.3,250.1l1.3,1.3c0,0,0,0.1,0,0.1l-4.1,4.1c0,0,0,0-0.1,0c0,0,0,0,0,0l-2.7-2.7c0,0,0-0.1,0-0.1l1.2-1.2 c0,0,0.1,0,0.1,0l1.4,1.4l2.9-2.9C-232.4,250.1-232.3,250.1-232.3,250.1z"
    }))))));
  }

}
const status_online_avatar_icon_style = {
  enableBackground: 'new -243 245 12 12'
};
// CONCATENATED MODULE: ./components/svg/status_online_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class status_online_icon_StatusOnlineIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "mobile.set_status.online.icon",
      defaultMessage: "Online Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "100%",
      height: "100%",
      viewBox: "0 0 20 20",
      style: status_online_icon_style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("path", {
      className: "online--icon",
      d: "M10,0c5.519,0 10,4.481 10,10c0,5.519 -4.481,10 -10,10c-5.519,0 -10,-4.481 -10,-10c0,-5.519 4.481,-10 10,-10Zm6.19,7.18c0,0.208 -0.075,0.384 -0.224,0.53l-5.782,5.64l-1.087,1.059c-0.149,0.146 -0.33,0.218 -0.543,0.218c-0.213,0 -0.394,-0.072 -0.543,-0.218l-1.086,-1.059l-2.891,-2.82c-0.149,-0.146 -0.224,-0.322 -0.224,-0.53c0,-0.208 0.075,-0.384 0.224,-0.53l1.086,-1.059c0.149,-0.146 0.33,-0.218 0.543,-0.218c0.213,0 0.394,0.072 0.543,0.218l2.348,2.298l5.24,-5.118c0.149,-0.146 0.33,-0.218 0.543,-0.218c0.213,0 0.394,0.072 0.543,0.218l1.086,1.059c0.149,0.146 0.224,0.322 0.224,0.53Z"
    }))));
  }

}
const status_online_icon_style = {
  fillRule: 'evenodd',
  clipRule: 'evenodd',
  strokeLinejoin: 'round',
  strokeMiterlimit: 1.41421
};
// CONCATENATED MODULE: ./components/status_icon.jsx
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return status_icon_StatusIcon; });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










class status_icon_StatusIcon extends react_default.a.PureComponent {
  render() {
    const {
      button,
      status,
      type
    } = this.props;

    if (!status) {
      return null;
    }

    let className = 'status ' + this.props.className;

    if (button) {
      className = this.props.className;
    }

    let IconComponent = 'span';

    if (type === 'avatar') {
      className = 'avatar-status ' + this.props.className;

      if (status === 'online') {
        IconComponent = status_online_avatar_icon_StatusOnlineAvatarIcon;
      } else if (status === 'away') {
        IconComponent = status_away_avatar_icon_StatusAwayAvatarIcon;
      } else if (status === 'dnd') {
        IconComponent = status_dnd_avatar_icon_StatusDndAvatarIcon;
      } else {
        IconComponent = status_offline_avatar_icon_StatusDndAvatarIcon;
      }
    } else if (status === 'online') {
      IconComponent = status_online_icon_StatusOnlineIcon;
    } else if (status === 'away') {
      IconComponent = status_away_icon_StatusAwayIcon;
    } else if (status === 'dnd') {
      IconComponent = status_dnd_icon_StatusDndIcon;
    } else {
      IconComponent = status_offline_icon_StatusOfflineIcon;
    }

    return react_default.a.createElement(IconComponent, {
      className: className
    });
  }

}

_defineProperty(status_icon_StatusIcon, "propTypes", {
  button: prop_types_default.a.bool,
  status: prop_types_default.a.string,
  className: prop_types_default.a.string,
  type: prop_types_default.a.string
});

_defineProperty(status_icon_StatusIcon, "defaultProps", {
  className: '',
  button: false
});

/***/ }),

/***/ 1755:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/posts.js
var posts = __webpack_require__(61);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./actions/views/posts.js
var views_posts = __webpack_require__(1618);

// EXTERNAL MODULE: ./utils/file_utils.jsx
var file_utils = __webpack_require__(1601);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/antd/es/message/index.js
var message = __webpack_require__(3478);

// EXTERNAL MODULE: ./node_modules/antd/es/list/index.js + 5 modules
var list = __webpack_require__(3487);

// EXTERNAL MODULE: ./node_modules/antd/es/spin/index.js
var spin = __webpack_require__(2466);

// EXTERNAL MODULE: ./node_modules/antd/es/modal/index.js + 3 modules
var modal = __webpack_require__(1552);

// EXTERNAL MODULE: ./node_modules/antd/es/icon/index.js + 3 modules
var icon = __webpack_require__(93);

// EXTERNAL MODULE: ./mattermost-redux/utils/file_utils.js
var utils_file_utils = __webpack_require__(1611);

// EXTERNAL MODULE: ./actions/global_actions.jsx
var global_actions = __webpack_require__(1567);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/jquery/src/jquery.js
var jquery = __webpack_require__(175);
var jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);

// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(33);
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ./components/file_info_preview/index.js + 1 modules
var file_info_preview = __webpack_require__(1828);

// CONCATENATED MODULE: ./components/audio_video_preview.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class audio_video_preview_AudioVideoPreview extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.handleFileInfoChanged = this.handleFileInfoChanged.bind(this);
    this.handleLoadError = this.handleLoadError.bind(this);
    this.stop = this.stop.bind(this);
    this.state = {
      canPlay: true
    };
  }

  UNSAFE_componentWillMount() {
    // eslint-disable-line camelcase
    this.handleFileInfoChanged(this.props.fileInfo);
  }

  componentDidMount() {
    if (this.refs.source) {
      jquery_default()(react_dom_default.a.findDOMNode(this.refs.source)).one('error', this.handleLoadError);
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.fileUrl !== nextProps.fileUrl) {
      this.handleFileInfoChanged(nextProps.fileInfo);
    }
  }

  handleFileInfoChanged(fileInfo) {
    let video = react_dom_default.a.findDOMNode(this.refs.video);

    if (!video) {
      video = document.createElement('video');
    }

    const canPlayType = video.canPlayType(fileInfo.mime_type);
    this.setState({
      canPlay: canPlayType === 'probably' || canPlayType === 'maybe'
    });
  }

  componentDidUpdate() {
    if (this.refs.source) {
      jquery_default()(react_dom_default.a.findDOMNode(this.refs.source)).one('error', this.handleLoadError);
    }
  }

  handleLoadError() {
    this.setState({
      canPlay: false
    });
  }

  stop() {
    if (this.refs.video) {
      const video = react_dom_default.a.findDOMNode(this.refs.video);
      video.pause();
      video.currentTime = 0;
    }
  }

  render() {
    if (!this.state.canPlay) {
      return react_default.a.createElement(file_info_preview["a" /* default */], {
        fileInfo: this.props.fileInfo,
        fileUrl: this.props.fileUrl
      });
    }

    let width = constants["N" /* default */].WEB_VIDEO_WIDTH;
    let height = constants["N" /* default */].WEB_VIDEO_HEIGHT;

    if (utils["Y" /* isMobile */]()) {
      width = constants["N" /* default */].MOBILE_VIDEO_WIDTH;
      height = constants["N" /* default */].MOBILE_VIDEO_HEIGHT;
    } // add a key to the video to prevent React from using an old video source while a new one is loading


    return react_default.a.createElement("video", {
      key: this.props.fileInfo.id,
      ref: "video",
      "data-setup": "{}",
      controls: "controls",
      width: width,
      height: height
    }, react_default.a.createElement("source", {
      ref: "source",
      src: this.props.fileUrl
    }));
  }

}

_defineProperty(audio_video_preview_AudioVideoPreview, "propTypes", {
  /**
  * Compare file types
  */
  fileInfo: prop_types_default.a.object.isRequired,

  /**
  *  URL of pdf file to output and compare to update props url
  */
  fileUrl: prop_types_default.a.string.isRequired
});
// EXTERNAL MODULE: ./utils/syntax_highlighting.jsx
var syntax_highlighting = __webpack_require__(295);

// EXTERNAL MODULE: ./components/widgets/loading/loading_bars.jsx
var loading_bars = __webpack_require__(1776);

// CONCATENATED MODULE: ./components/code_preview.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class code_preview_CodePreview extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.updateStateFromProps = this.updateStateFromProps.bind(this);
    this.handleReceivedError = this.handleReceivedError.bind(this);
    this.handleReceivedCode = this.handleReceivedCode.bind(this);
    this.state = {
      code: '',
      lang: '',
      loading: true,
      success: true
    };
  }

  componentDidMount() {
    this.updateStateFromProps(this.props);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.fileUrl !== nextProps.fileUrl) {
      this.updateStateFromProps(nextProps);
    }
  }

  updateStateFromProps(props) {
    const usedLanguage = syntax_highlighting["b" /* getLanguageFromFileExtension */](props.fileInfo.extension);

    if (!usedLanguage || props.fileInfo.size > constants["N" /* default */].CODE_PREVIEW_MAX_FILE_SIZE) {
      this.setState({
        code: '',
        lang: '',
        loading: false,
        success: false
      });
      return;
    }

    this.setState({
      code: '',
      lang: usedLanguage,
      loading: true
    });
    jquery_default.a.ajax({
      async: true,
      url: props.fileUrl,
      type: 'GET',
      dataType: 'text',
      // beforeSend: function(xhr) {
      //     xhr.overrideMimeType("text/csv;charset=gb2312");
      // }, 
      error: this.handleReceivedError,
      success: this.handleReceivedCode
    });
  }

  handleReceivedCode(data) {
    let code = data;

    if (data.nodeName === '#document') {
      code = new XMLSerializer().serializeToString(data);
    }

    this.setState({
      code,
      loading: false,
      success: true
    });
  }

  handleReceivedError() {
    this.setState({
      loading: false,
      success: false
    });
  }

  static supports(fileInfo) {
    return Boolean(syntax_highlighting["b" /* getLanguageFromFileExtension */](fileInfo.extension));
  }

  render() {
    if (this.state.loading) {
      return react_default.a.createElement("div", {
        className: "view-image__loading"
      }, react_default.a.createElement(loading_bars["a" /* default */], null));
    }

    if (!this.state.success) {
      return react_default.a.createElement(file_info_preview["a" /* default */], {
        fileInfo: this.props.fileInfo,
        fileUrl: this.props.fileUrl
      });
    } // add line numbers when viewing a code file preview


    const lines = this.state.code.match(/\r\n|\r|\n|$/g).length;
    let strlines = '';

    for (let i = 1; i <= lines; i++) {
      if (strlines) {
        strlines += '\n' + i;
      } else {
        strlines += i;
      }
    }

    const language = syntax_highlighting["c" /* getLanguageName */](this.state.lang);
    const highlighted = syntax_highlighting["d" /* highlight */](this.state.lang, this.state.code);
    return react_default.a.createElement("div", {
      className: "post-code"
    }, react_default.a.createElement("span", {
      className: "post-code__language"
    }, `${this.props.fileInfo.name} - ${language}`), react_default.a.createElement("div", {
      className: "post-code__container"
    }, react_default.a.createElement("code", {
      className: "hljs"
    }, react_default.a.createElement("table", null, react_default.a.createElement("tbody", null, react_default.a.createElement("tr", null, react_default.a.createElement("td", {
      className: "post-code__lineno"
    }, strlines), react_default.a.createElement("td", {
      dangerouslySetInnerHTML: {
        __html: highlighted
      }
    })))))));
  }

}
code_preview_CodePreview.propTypes = {
  fileInfo: prop_types_default.a.object.isRequired,
  fileUrl: prop_types_default.a.string.isRequired
};
// EXTERNAL MODULE: ./components/loading_image_preview.jsx
var loading_image_preview = __webpack_require__(2001);

// EXTERNAL MODULE: ./components/async_load.jsx
var async_load = __webpack_require__(412);

// EXTERNAL MODULE: ./node_modules/bundle-loader?lazy!./components/pdf_preview.jsx
var pdf_preview = __webpack_require__(2427);

// EXTERNAL MODULE: ./node_modules/react-draggable/web/react-draggable.min.js
var react_draggable_min = __webpack_require__(2428);
var react_draggable_min_default = /*#__PURE__*/__webpack_require__.n(react_draggable_min);

// EXTERNAL MODULE: ./node_modules/react-infinite-scroller/index.js
var react_infinite_scroller = __webpack_require__(2429);
var react_infinite_scroller_default = /*#__PURE__*/__webpack_require__.n(react_infinite_scroller);

// CONCATENATED MODULE: ./components/view_image/image_preview.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



function ImagePreview({
  fileInfo,
  canDownloadFiles,
  zoomResult
}) {
  const {
    has_preview_image: hasPreviewImage,
    id,
    link
  } = fileInfo;
  const fileUrl = link || Object(utils_file_utils["getFileDownloadUrl"])(id);
  const previewUrl = hasPreviewImage ? Object(utils_file_utils["getFilePreviewUrl"])(id) : fileUrl;

  if (!canDownloadFiles) {
    return react_default.a.createElement("img", {
      src: previewUrl
    });
  }

  return react_default.a.createElement("img", {
    alt: 'preview url image',
    src: previewUrl,
    style: {
      maxWidth: 'initial',
      width: zoomResult + '%'
    }
  });
}
ImagePreview.propTypes = {
  fileInfo: prop_types_default.a.object.isRequired,
  canDownloadFiles: prop_types_default.a.bool.isRequired,
  zoomResult: prop_types_default.a.number.isRequired
};
// EXTERNAL MODULE: ./utils/user_agent.jsx
var user_agent = __webpack_require__(39);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// CONCATENATED MODULE: ./components/view_image/popover_bar/popover_bar.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function popover_bar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class popover_bar_PopoverBar extends react_default.a.PureComponent {
  render() {
    var publicLink = '';

    if (this.props.enablePublicLink && this.props.showPublicLink) {
      publicLink = react_default.a.createElement("div", null, react_default.a.createElement("a", {
        href: "#",
        className: "public-link text",
        "data-title": "Public Image",
        onClick: this.props.onGetPublicLink
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "view_image_popover.publicLink",
        defaultMessage: "Get Public Link"
      })), react_default.a.createElement("span", {
        className: "text"
      }, ' | '));
    }

    var footerClass = 'modal-button-bar';

    if (this.props.show) {
      footerClass += ' footer--show';
    }

    let downloadLinks = null;

    if (this.props.canDownloadFiles) {
      const shouldOpenFile = this.props.isExternalFile && !this.props.isDesktopApp;
      let downloadLinkText;
      const downloadLinkProps = {};

      if (shouldOpenFile) {
        downloadLinkText = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "view_image_popover.open",
          defaultMessage: "Open"
        });
      } else {
        downloadLinkText = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "view_image_popover.download",
          defaultMessage: "Download"
        });
        downloadLinkProps.download = this.props.filename;
      }

      downloadLinks = react_default.a.createElement("div", {
        className: "image-links"
      }, publicLink, react_default.a.createElement("a", _extends({
        href: this.props.fileURL,
        className: "text",
        target: "_blank",
        rel: "noopener noreferrer"
      }, downloadLinkProps), downloadLinkText));
    }

    return react_default.a.createElement("div", {
      ref: "imageFooter",
      className: footerClass
    }, react_default.a.createElement("span", {
      className: "pull-left text"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "view_image_popover.file",
      defaultMessage: "File {count, number} of {total, number}",
      values: {
        count: this.props.fileIndex + 1,
        total: this.props.totalFiles
      }
    })), downloadLinks);
  }

}

popover_bar_defineProperty(popover_bar_PopoverBar, "propTypes", {
  show: prop_types_default.a.bool.isRequired,
  fileIndex: prop_types_default.a.number.isRequired,
  totalFiles: prop_types_default.a.number.isRequired,
  filename: prop_types_default.a.string.isRequired,
  fileURL: prop_types_default.a.string.isRequired,
  showPublicLink: prop_types_default.a.bool,
  enablePublicLink: prop_types_default.a.bool.isRequired,
  canDownloadFiles: prop_types_default.a.bool.isRequired,
  isExternalFile: prop_types_default.a.bool.isRequired,
  onGetPublicLink: prop_types_default.a.func,
  isDesktopApp: prop_types_default.a.bool.isRequired
});

popover_bar_defineProperty(popover_bar_PopoverBar, "defaultProps", {
  show: false,
  fileIndex: 0,
  totalFiles: 0,
  filename: '',
  fileURL: '',
  showPublicLink: true
});
// CONCATENATED MODULE: ./components/view_image/popover_bar/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function mapStateToProps() {
  return {
    isDesktopApp: Object(user_agent["c" /* isDesktopApp */])()
  };
}

/* harmony default export */ var popover_bar = (Object(es["connect"])(mapStateToProps)(popover_bar_PopoverBar));
// EXTERNAL MODULE: ./components/view_image/index.scss
var view_image = __webpack_require__(2431);

// EXTERNAL MODULE: ./api/upload.js
var upload = __webpack_require__(2017);

// EXTERNAL MODULE: ./components/search_results/search_results.jsx + 14 modules
var search_results = __webpack_require__(2251);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tooltip.js
var Tooltip = __webpack_require__(1998);

// CONCATENATED MODULE: ./components/view_image/view_image.jsx
function view_image_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

























const KeyCodes = constants["N" /* default */].KeyCodes;
class view_image_ViewImageModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    view_image_defineProperty(this, "handleNext", e => {
      if (e) {
        e.stopPropagation();
      }

      let id = this.state.imageIndex + 1;

      if (id > this.props.fileInfos.length - 1) {
        return;
      }

      this.showImage(id);
    });

    view_image_defineProperty(this, "handlePrev", e => {
      if (e) {
        e.stopPropagation();
      }

      let id = this.state.imageIndex - 1;

      if (id < 0) {
        return;
      }

      this.showImage(id);
    });

    view_image_defineProperty(this, "handleKeyPress", e => {
      if (utils["V" /* isKeyPressed */](e, KeyCodes.RIGHT)) {
        this.handleNext();
      } else if (utils["V" /* isKeyPressed */](e, KeyCodes.LEFT)) {
        this.handlePrev();
      }
    });

    view_image_defineProperty(this, "onModalShown", nextProps => {
      document.addEventListener('keyup', this.handleKeyPress);
      this.showImage(nextProps.startIndex);
    });

    view_image_defineProperty(this, "onModalHidden", () => {
      document.removeEventListener('keyup', this.handleKeyPress);

      if (this.refs.video) {
        this.refs.video.stop();
      }
    });

    view_image_defineProperty(this, "showImage", id => {
      this.setState({
        imageIndex: id
      });
      const imageHeight = window.innerHeight - 100;
      this.setState({
        imageHeight
      });
      this.loadImage(id);
    });

    view_image_defineProperty(this, "loadImage", index => {
      const fileInfo = this.props.fileInfos[index];
      const fileType = utils["z" /* getFileType */](fileInfo.extension); // 如果是文档

      if (fileInfo && fileInfo.extension && Object(file_utils["c" /* canPreviewDoc */])(fileInfo.extension)) {
        this.setState({
          loaded: {
            [index]: false
          }
        });
        Object(upload["c" /* previewFilePage */])(fileInfo.id).then(data => {
          if (data.data.total_page < 1) {
            this.setState({
              loaded: {
                [index]: true
              }
            });
            return;
          }

          this.setState({
            totalPage: data.data.total_page,
            page: 1,
            hasMore: true,
            fileSvgList: [],
            currentPage: 1,
            zoomResult: 100
          });
          this.getFileData(fileInfo).then(() => {
            this.setState({
              loaded: {
                [index]: true
              }
            });
          });
        }).catch(() => {
          this.setState({
            loaded: {
              [index]: true
            }
          });
        });
      } else if (fileType === constants["k" /* FileTypes */].IMAGE && Boolean(fileInfo.id)) {
        let previewUrl;

        if (fileInfo.has_image_preview) {
          previewUrl = Object(utils_file_utils["getFilePreviewUrl"])(fileInfo.id);
        } else {
          // some images (eg animated gifs) just show the file itself and not a preview
          previewUrl = Object(utils_file_utils["getFileUrl"])(fileInfo.id);
        }

        console.log(11111, fileInfo.id, previewUrl);
        utils["fb" /* loadImage */](previewUrl, () => this.handleImageLoaded(index), completedPercentage => this.handleImageProgress(index, completedPercentage));
      } else {
        // there's nothing to load for non-image files
        this.handleImageLoaded(index);
      }
    });

    view_image_defineProperty(this, "handleImageLoaded", index => {
      this.setState(prevState => {
        return {
          loaded: { ...prevState.loaded,
            [index]: true
          }
        };
      });
    });

    view_image_defineProperty(this, "handleImageProgress", (index, completedPercentage) => {
      this.setState(prevState => {
        return {
          progress: { ...prevState.progress,
            [index]: completedPercentage
          }
        };
      });
    });

    view_image_defineProperty(this, "handleGetPublicLink", () => {
      this.props.onModalDismissed();
      global_actions["k" /* showGetPublicLinkModal */](this.props.fileInfos[this.state.imageIndex].id);
    });

    view_image_defineProperty(this, "onMouseEnterImage", () => {
      this.setState({
        showFooter: true
      });
    });

    view_image_defineProperty(this, "onMouseLeaveImage", () => {
      this.setState({
        showFooter: false
      });
    });

    view_image_defineProperty(this, "zoomOut", () => {
      this.setState({
        zoomResult: this.state.zoomResult - this.state.zoomStep
      });
    });

    view_image_defineProperty(this, "zoomIn", () => {
      this.setState({
        zoomResult: this.state.zoomResult + this.state.zoomStep
      });
    });

    view_image_defineProperty(this, "getFileData", fileInfo => {
      let {
        page,
        totalPage,
        hasMore,
        fileSvgList
      } = this.state;
      this.setState({
        loading: true
      });
      return Object(upload["b" /* previewFile */])(fileInfo.id, page).then(data => {
        fileSvgList = fileSvgList.concat({
          fileSvg: data.data.replace(/glyph/g, fileInfo.id + '-' + page + '-')
        });

        if (fileSvgList.length >= totalPage) {
          hasMore = false;
        }

        page++;
        this.setState({
          fileSvgList,
          hasMore,
          page,
          loading: false
        });
      });
    });

    view_image_defineProperty(this, "handleInfiniteOnLoad", fileInfo => {
      let {
        totalPage,
        fileSvgList
      } = this.state;

      if (fileSvgList.length >= totalPage) {
        return;
      }

      this.getFileData(fileInfo);
    });

    view_image_defineProperty(this, "handleCollect", e => {
      e.preventDefault();
      const {
        actions,
        isFlagged,
        post,
        postId
      } = this.props;

      if (isFlagged) {
        actions.unflagPost(postId ? postId : post.id).then(() => {
          message["a" /* default */].success('取消收藏成功');
        });
      } else {
        actions.flagPost(postId ? postId : post.id).then(() => {
          message["a" /* default */].success('收藏成功');
        });
      }
    });

    this.state = {
      imageIndex: this.props.startIndex,
      imageHeight: '100%',
      loaded: utils["q" /* fillArray */](false, this.props.fileInfos.length),
      progress: utils["q" /* fillArray */](0, this.props.fileInfos.length),
      showFooter: false,
      zoomResult: 100,
      zoomStep: 10,
      fileSvgList: [],
      loading: false,
      totalPage: 0,
      page: 1,
      // 请求的页数，从1开始
      currentPage: 1,
      // 当前定位的页数，从1开始
      hasMore: true,
      pageOperate: false // 判断是否通过分页操作

    };
  }

  componentDidMount() {
    if (this.props.show) {
      this.onModalShown(this.props);
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.show === true && this.props.show === false) {
      this.onModalShown(nextProps);
    } else if (nextProps.show === false && this.props.show === true) {
      this.onModalHidden();
    }

    if (this.props.fileInfos.length !== nextProps.fileInfos.length) {
      this.setState({
        loaded: utils["q" /* fillArray */](false, nextProps.fileInfos.length),
        progress: utils["q" /* fillArray */](0, nextProps.fileInfos.length)
      });
    }
  }

  onScrollEvent(e, isDoc) {
    const {
      fileSvgList,
      loading,
      pageOperate
    } = this.state;

    if (!isDoc || loading || fileSvgList.length < 1) {
      return;
    }

    if (pageOperate) {
      this.setState({
        pageOperate: false
      });
      return;
    }

    const domImageContent = jquery_default()(e.target);
    const scrollTop = domImageContent[0].scrollTop;
    const perPageHeight = domImageContent.find('.ant-list-item')[0].offsetHeight;
    const currentPage = Math.floor(scrollTop / perPageHeight) + 1;
    this.setState({
      currentPage
    });
  }

  prevPage(e) {
    const {
      currentPage
    } = this.state;

    if (currentPage <= 1) {
      return;
    }

    const domImageContent = jquery_default()(e.target).parents('.ant-modal-body').eq(0).find('.modal-image__content');
    const perPageHeight = domImageContent.find('.ant-list-item')[0].offsetHeight;
    domImageContent[0].scrollTop = perPageHeight * (currentPage - 2);
    this.setState({
      currentPage: currentPage - 1,
      pageOperate: true
    });
  }

  nextPage(e, fileInfo) {
    const {
      currentPage,
      fileSvgList,
      loading
    } = this.state;

    if (currentPage >= this.state.totalPage || loading || fileSvgList.length < 1) {
      return;
    }

    const domImageContent = jquery_default()(e.target).parents('.ant-modal-body').eq(0).find('.modal-image__content');
    const perPageHeight = domImageContent.find('.ant-list-item')[0].offsetHeight; // 如果数据加载过

    if (fileSvgList[currentPage]) {
      domImageContent[0].scrollTop = perPageHeight * currentPage;
      this.setState({
        currentPage: currentPage + 1,
        pageOperate: true
      });
    } else {
      this.getFileData(fileInfo).then(() => {
        domImageContent[0].scrollTop = perPageHeight * currentPage;
        this.setState({
          currentPage: currentPage + 1,
          pageOperate: true
        });
      });
    }
  } // 收藏


  // 转发
  repost() {
    this.props.actions.setChannelPostSelect({
      type: constants["f" /* ChannelPostSelectType */].SINGLE,
      visibleSelectMember: true,
      postId: this.props.postId ? this.props.postId : this.props.post.id
    });
  }

  render() {
    if (this.props.fileInfos.length < 1 || this.props.fileInfos.length - 1 < this.state.imageIndex) {
      return null;
    }

    const fileInfo = this.props.fileInfos[this.state.imageIndex];
    const showPublicLink = !fileInfo.link;
    const fileName = fileInfo.link || fileInfo.name;
    let fileUrl = fileInfo.link || Object(utils_file_utils["getFileUrl"])(fileInfo.id);
    const fileDownloadUrl = fileInfo.link || Object(utils_file_utils["getFileDownloadUrl"])(fileInfo.id);
    const isExternalFile = !fileInfo.id;
    let {
      fileSvgList,
      hasMore,
      loading,
      totalPage,
      currentPage
    } = this.state;
    let content;
    const fileType = utils["z" /* getFileType */](fileInfo.extension);
    let isImage = false;
    let isDoc = false;
    const {
      team,
      currentUser
    } = this.props;
    const waterMark = react_default.a.createElement("div", {
      className: "water-mark"
    }, new Array(4).fill('').map((item, index) => {
      return react_default.a.createElement("div", {
        key: index
      }, react_default.a.createElement("span", null, team.display_name, " ", currentUser.nickname), react_default.a.createElement("span", null, team.display_name, " ", currentUser.nickname));
    }));

    if (this.state.loaded[this.state.imageIndex]) {
      if (fileType === constants["k" /* FileTypes */].IMAGE || fileType === constants["k" /* FileTypes */].SVG) {
        isImage = true;
        content = react_default.a.createElement("div", {
          className: "image-wrapper"
        }, react_default.a.createElement(react_draggable_min_default.a, {
          axis: "x"
        }, react_default.a.createElement(ImagePreview, {
          zoomResult: this.state.zoomResult,
          fileInfo: fileInfo,
          canDownloadFiles: this.props.canDownloadFiles
        })), waterMark);
      } else if (fileType === constants["k" /* FileTypes */].VIDEO || fileType === constants["k" /* FileTypes */].AUDIO) {
        content = react_default.a.createElement(audio_video_preview_AudioVideoPreview, {
          fileInfo: fileInfo,
          fileUrl: fileUrl
        });
      } else if (fileInfo && fileInfo.extension && totalPage > 0 && Object(file_utils["c" /* canPreviewDoc */])(fileInfo.extension)) {
        isDoc = true;
        content = react_default.a.createElement(react_infinite_scroller_default.a, {
          initialLoad: false,
          pageStart: 0,
          loadMore: () => {
            this.handleInfiniteOnLoad(fileInfo);
          },
          hasMore: !loading && hasMore,
          useWindow: false,
          threshold: 3000
        }, react_default.a.createElement(list["a" /* default */], {
          style: {
            width: this.state.zoomResult + '%'
          },
          dataSource: fileSvgList,
          renderItem: (item, index) => react_default.a.createElement(list["a" /* default */].Item, {
            key: index
          }, react_default.a.createElement("div", {
            dangerouslySetInnerHTML: {
              __html: item.fileSvg
            }
          }), waterMark)
        }, loading && hasMore && react_default.a.createElement("div", {
          className: "loading-container"
        }, react_default.a.createElement(spin["a" /* default */], null))));
      } else if (code_preview_CodePreview.supports(fileInfo)) {
        content = react_default.a.createElement(code_preview_CodePreview, {
          fileInfo: fileInfo,
          fileUrl: fileUrl
        });
      } else {
        content = react_default.a.createElement(file_info_preview["a" /* default */], {
          fileInfo: fileInfo,
          fileUrl: fileUrl + '?download=1'
        });
      }
    } else {
      content = react_default.a.createElement("div", {
        className: "view-image__loading"
      }, react_default.a.createElement(loading_bars["a" /* default */], null));
    }

    for (const preview of this.props.pluginFilePreviewComponents) {
      if (preview.override(fileInfo, this.props.post)) {
        content = react_default.a.createElement(preview.component, {
          fileInfo: fileInfo,
          post: this.props.post
        });
        break;
      }
    }

    let leftArrow = null;
    let rightArrow = null;

    if (this.props.fileInfos.length > 1) {
      leftArrow = react_default.a.createElement("a", {
        id: "previewArrowLeft",
        ref: "previewArrowLeft",
        className: 'slide-prev-btn' + (this.state.imageIndex === 0 ? ' disabled' : ''),
        onClick: this.handlePrev
      });
      rightArrow = react_default.a.createElement("a", {
        id: "previewArrowRight",
        ref: "previewArrowRight",
        className: 'slide-next-btn' + (this.state.imageIndex === this.props.fileInfos.length - 1 ? ' disabled' : ''),
        onClick: this.handleNext
      });
    }

    let closeButtonClass = 'modal-close';

    if (this.state.showFooter) {
      closeButtonClass += ' modal-close--show';
    }

    const {
      isFlagged
    } = this.props;
    const flagVisible = isFlagged ? 'visible' : '';
    return react_default.a.createElement(modal["a" /* default */], {
      zIndex: 1002,
      className: "modal-image",
      closeIcon: react_default.a.createElement(icon["a" /* default */], {
        type: "close-circle",
        theme: "filled"
      }),
      visible: this.props.show,
      onCancel: this.props.onModalDismissed,
      role: "dialog",
      title: react_default.a.createElement("span", {
        title: fileName
      }, fileName),
      footer: null,
      mask: false,
      maskClosable: false,
      centered: true,
      width: '660px'
    }, react_default.a.createElement("div", {
      className: "image-func"
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      key: 'flagtooltipkey' + flagVisible,
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: react_default.a.createElement(Tooltip["a" /* default */], {
        id: "flagTooltip"
      }, isFlagged ? '取消收藏' : '收藏')
    }, react_default.a.createElement("a", {
      onClick: e => {
        this.handleCollect(e);
      },
      className: 'func-item collect-btn' + (isFlagged ? ' flagged' : '')
    })), react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      key: 'downloadtooltipkey',
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: react_default.a.createElement(Tooltip["a" /* default */], {
        id: "downloadTooltip"
      }, "\u4E0B\u8F7D")
    }, react_default.a.createElement("a", {
      href: fileUrl + '?download=1',
      target: "_blank",
      rel: "noopener noreferrer",
      download: fileName,
      className: "func-item download-btn"
    })), react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      key: 'reposttooltipkey',
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: react_default.a.createElement(Tooltip["a" /* default */], {
        id: "repostTooltip"
      }, "\u8F6C\u53D1")
    }, react_default.a.createElement("a", {
      onClick: () => {
        this.repost();
      },
      className: "func-item repost-btn"
    })), isImage || isDoc && totalPage > 0 ? react_default.a.createElement("div", {
      className: "image-zoom"
    }, react_default.a.createElement(icon["a" /* default */], {
      className: "zoom-out",
      type: "minus",
      onClick: () => {
        this.zoomOut();
      }
    }), react_default.a.createElement("div", {
      className: "func-result"
    }, this.state.zoomResult, "%"), react_default.a.createElement(icon["a" /* default */], {
      className: "zoom-in",
      type: "plus",
      onClick: () => {
        this.zoomIn();
      }
    })) : null, isDoc && totalPage > 0 ? react_default.a.createElement("div", {
      className: "image-page"
    }, react_default.a.createElement(icon["a" /* default */], {
      className: "prev-page",
      type: "caret-left",
      theme: "filled",
      onClick: e => {
        this.prevPage(e);
      }
    }), react_default.a.createElement("div", {
      className: "func-result"
    }, currentPage, "/", totalPage), react_default.a.createElement(icon["a" /* default */], {
      className: "next-page",
      type: "caret-right",
      theme: "filled",
      onClick: e => {
        this.nextPage(e, fileInfo);
      }
    })) : null), react_default.a.createElement("div", {
      className: "modal-image__content",
      onScrollCapture: e => this.onScrollEvent(e, isDoc)
    }, content), leftArrow, rightArrow);
  }

}

view_image_defineProperty(view_image_ViewImageModal, "propTypes", {
  /**
   * The post the files are attached to
   */
  post: prop_types_default.a.object,
  postId: prop_types_default.a.string,

  /**
   * Set whether to show this modal or not
   */
  show: prop_types_default.a.bool.isRequired,

  /**
   * Function to call when this modal is dismissed
   **/
  onModalDismissed: prop_types_default.a.func.isRequired,

  /**
   * List of FileInfo to view
   **/
  fileInfos: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,

  /**
   * The index number of starting image
   **/
  startIndex: prop_types_default.a.number.isRequired,
  canDownloadFiles: prop_types_default.a.bool.isRequired,
  enablePublicLink: prop_types_default.a.bool.isRequired,
  pluginFilePreviewComponents: prop_types_default.a.arrayOf(prop_types_default.a.object)
});

view_image_defineProperty(view_image_ViewImageModal, "defaultProps", {
  show: false,
  fileInfos: [],
  startIndex: 0,
  pluginFilePreviewComponents: []
});
// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// CONCATENATED MODULE: ./components/view_image/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













function view_image_mapStateToProps(state, ownProps) {
  const config = Object(general["getConfig"])(state);
  const currentTeamId = state.entities.teams.currentTeamId;
  const team = Object(teams["getTeam"])(state, currentTeamId);
  return {
    canDownloadFiles: Object(file_utils["a" /* canDownloadFiles */])(config),
    enablePublicLink: config.EnablePublicLink === 'true',
    pluginFilePreviewComponents: state.plugins.components.FilePreview,
    post: ownProps.post || Object(posts["getPost"])(state, ownProps.postId),
    isFlagged: Object(preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_FLAGGED_POST, ownProps.postId, null) != null,
    team,
    currentUser: Object(users["getCurrentUser"])(state)
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      flagPost: post_actions["f" /* flagPost */],
      unflagPost: post_actions["p" /* unflagPost */],
      setChannelPostSelect: views_posts["c" /* setChannelPostSelect */]
    }, dispatch)
  };
}

/* harmony default export */ var components_view_image = __webpack_exports__["a"] = (Object(es["connect"])(view_image_mapStateToProps, mapDispatchToProps)(view_image_ViewImageModal));

/***/ }),

/***/ 1757:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/actions/users.js
var users = __webpack_require__(35);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var entities_users = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/jquery/src/jquery.js
var jquery = __webpack_require__(175);
var jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Modal.js
var Modal = __webpack_require__(1972);

// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(33);
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./utils/i18n.jsx
var i18n = __webpack_require__(53);

// EXTERNAL MODULE: ./components/confirm_modal.jsx
var confirm_modal = __webpack_require__(1576);

// EXTERNAL MODULE: ./components/async_load.jsx
var async_load = __webpack_require__(412);

// EXTERNAL MODULE: ./node_modules/bundle-loader?lazy!./components/user_settings/index.js
var user_settings = __webpack_require__(2367);
var user_settings_default = /*#__PURE__*/__webpack_require__.n(user_settings);

// EXTERNAL MODULE: ./node_modules/bundle-loader?lazy!./components/settings_sidebar.jsx
var settings_sidebar = __webpack_require__(1851);

// CONCATENATED MODULE: ./components/user_settings/modal/user_settings_modal.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













const holders = Object(index_es["g" /* defineMessages */])({
  general: {
    id: Object(i18n["b" /* t */])('user.settings.modal.general'),
    defaultMessage: 'General'
  },
  security: {
    id: Object(i18n["b" /* t */])('user.settings.modal.security'),
    defaultMessage: 'Security'
  },
  notifications: {
    id: Object(i18n["b" /* t */])('user.settings.modal.notifications'),
    defaultMessage: 'Notifications'
  },
  display: {
    id: Object(i18n["b" /* t */])('user.settings.modal.display'),
    defaultMessage: 'Display'
  },
  sidebar: {
    id: Object(i18n["b" /* t */])('user.settings.modal.sidebar'),
    defaultMessage: 'Sidebar'
  },
  advanced: {
    id: Object(i18n["b" /* t */])('user.settings.modal.advanced'),
    defaultMessage: 'Advanced'
  },
  checkEmail: {
    id: 'user.settings.general.checkEmail',
    defaultMessage: 'Check your email at {email} to verify the address. Cannot find the email?'
  },
  confirmTitle: {
    id: Object(i18n["b" /* t */])('user.settings.modal.confirmTitle'),
    defaultMessage: 'Discard Changes?'
  },
  confirmMsg: {
    id: Object(i18n["b" /* t */])('user.settings.modal.confirmMsg'),
    defaultMessage: 'You have unsaved changes, are you sure you want to discard them?'
  },
  confirmBtns: {
    id: Object(i18n["b" /* t */])('user.settings.modal.confirmBtns'),
    defaultMessage: 'Yes, Discard'
  }
});

class user_settings_modal_UserSettingsModal extends react_default.a.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleResend", email => {
      this.setState({
        resendStatus: 'sending'
      });
      this.props.actions.sendVerificationEmail(email).then(({
        data,
        error: err
      }) => {
        if (data) {
          this.setState({
            resendStatus: 'success'
          });
        } else if (err) {
          this.setState({
            resendStatus: 'failure'
          });
        }
      });
    });

    _defineProperty(this, "handleKeyDown", e => {
      if (utils["e" /* cmdOrCtrlPressed */](e) && e.shiftKey && utils["V" /* isKeyPressed */](e, constants["N" /* default */].KeyCodes.A)) {
        this.handleHide();
      }
    });

    _defineProperty(this, "handleHide", () => {
      if (this.requireConfirm) {
        this.showConfirmModal(() => this.handleHide());
        return;
      }

      this.setState({
        show: false
      });
    });

    _defineProperty(this, "handleHidden", () => {
      this.setState({
        active_tab: this.props.activeTab || 'general',
        active_section: '',
        prev_active_section: 'dummySectionName'
      });
      this.props.onHide();
    });

    _defineProperty(this, "handleCollapse", () => {
      jquery_default()(react_dom_default.a.findDOMNode(this.modalBodyRef.current)).closest('.modal-dialog').removeClass('display--content');
      this.setState({
        active_tab: '',
        active_section: '',
        prev_active_section: ''
      });
    });

    _defineProperty(this, "handleConfirm", () => {
      this.setState({
        showConfirmModal: false,
        enforceFocus: true
      });
      this.requireConfirm = false;
      this.customConfirmAction = null;

      if (this.afterConfirm) {
        this.afterConfirm();
        this.afterConfirm = null;
      }
    });

    _defineProperty(this, "handleCancelConfirmation", () => {
      this.setState({
        showConfirmModal: false,
        enforceFocus: true
      });
      this.afterConfirm = null;
    });

    _defineProperty(this, "showConfirmModal", afterConfirm => {
      if (afterConfirm) {
        this.afterConfirm = afterConfirm;
      }

      if (this.customConfirmAction) {
        this.customConfirmAction(this.handleConfirm);
        return;
      }

      this.setState({
        showConfirmModal: true,
        enforceFocus: false
      });
    });

    _defineProperty(this, "closeModal", () => {
      if (this.requireConfirm) {
        this.showConfirmModal(this.closeModal);
      } else {
        this.handleHide();
      }
    });

    _defineProperty(this, "collapseModal", () => {
      if (this.requireConfirm) {
        this.showConfirmModal(this.collapseModal);
      } else {
        this.handleCollapse();
      }
    });

    _defineProperty(this, "updateTab", (tab, skipConfirm) => {
      if (!skipConfirm && this.requireConfirm) {
        this.showConfirmModal(() => this.updateTab(tab, true));
      } else {
        this.setState({
          active_tab: tab,
          active_section: '',
          prev_active_section: 'dummySectionName'
        });
      }
    });

    _defineProperty(this, "updateSection", (section, skipConfirm) => {
      if (!skipConfirm && this.requireConfirm) {
        this.showConfirmModal(() => this.updateSection(section, true));
      } else {
        this.setState({
          prev_active_section: section ? '' : this.state.active_section,
          active_section: section
        });
      }
    });

    this.state = {
      active_tab: props.activeTab || 'general',
      active_section: '',
      prev_active_section: 'dummySectionName',
      // dummy value that should never match any section name
      showConfirmModal: false,
      enforceFocus: true,
      show: true
    };
    this.requireConfirm = false; // Used when settings want to override the default confirm modal with their own
    // If set by a child, it will be called in place of showing the regular confirm
    // modal. It will be passed a function to call on modal confirm

    this.customConfirmAction = null;
    this.modalBodyRef = react_default.a.createRef();
  }

  componentDidMount() {
    document.addEventListener('keydown', this.handleKeyDown);
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleKeyDown);
  }

  componentDidUpdate(prevProps, prevState) {
    if (!utils["Y" /* isMobile */]()) {
      jquery_default()('.settings-content .minimize-settings').perfectScrollbar('update');
    }

    if (this.state.active_tab !== prevState.active_tab) {
      jquery_default()(react_dom_default.a.findDOMNode(this.modalBodyRef.current)).scrollTop(0);
    }
  }

  render() {
    const {
      formatMessage
    } = this.props.intl;

    if (this.props.currentUser == null) {
      return react_default.a.createElement("div", null);
    }

    var tabs = [];
    tabs.push({
      name: 'general',
      uiName: formatMessage(holders.general),
      icon: 'icon fa fa-gear',
      iconTitle: utils["gb" /* localizeMessage */]('user.settings.general.icon', 'General Settings Icon')
    });
    tabs.push({
      name: 'security',
      uiName: formatMessage(holders.security),
      icon: 'icon fa fa-lock',
      iconTitle: utils["gb" /* localizeMessage */]('user.settings.security.icon', 'Security Settings Icon')
    });
    tabs.push({
      name: 'notifications',
      uiName: formatMessage(holders.notifications),
      icon: 'icon fa fa-exclamation-circle',
      iconTitle: utils["gb" /* localizeMessage */]('user.settings.notifications.icon', 'Notification Settings Icon')
    });
    tabs.push({
      name: 'display',
      uiName: formatMessage(holders.display),
      icon: 'icon fa fa-eye',
      iconTitle: utils["gb" /* localizeMessage */]('user.settings.display.icon', 'Display Settings Icon')
    });
    tabs.push({
      name: 'sidebar',
      uiName: formatMessage(holders.sidebar),
      icon: 'icon fa fa-columns',
      iconTitle: utils["gb" /* localizeMessage */]('user.settings.sidebar.icon', 'Sidebar Settings Icon')
    });
    tabs.push({
      name: 'advanced',
      uiName: formatMessage(holders.advanced),
      icon: 'icon fa fa-list-alt',
      iconTitle: utils["gb" /* localizeMessage */]('user.settings.advance.icon', 'Advanced Settings Icon')
    });
    return react_default.a.createElement(Modal["a" /* default */], {
      id: "accountSettingsModal",
      dialogClassName: "settings-modal",
      show: this.state.show,
      onHide: this.handleHide,
      onExited: this.handleHidden,
      enforceFocus: this.state.enforceFocus,
      role: "dialog",
      "aria-labelledby": "accountSettingsModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      id: "accountSettingsHeader",
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "accountSettingsModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "user.settings.modal.title",
      defaultMessage: "Account Settings"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, {
      ref: this.modalBodyRef
    }, react_default.a.createElement("div", {
      className: "settings-table"
    }, react_default.a.createElement("div", {
      className: "settings-content minimize-settings"
    }, react_default.a.createElement(async_load["a" /* AsyncComponent */], {
      doLoad: user_settings_default.a,
      activeTab: this.state.active_tab,
      activeSection: this.state.active_section,
      prevActiveSection: this.state.prev_active_section,
      updateSection: this.updateSection,
      updateTab: this.updateTab,
      closeModal: this.closeModal,
      collapseModal: this.collapseModal,
      setEnforceFocus: enforceFocus => this.setState({
        enforceFocus
      }),
      setRequireConfirm: (requireConfirm, customConfirmAction) => {
        this.requireConfirm = requireConfirm;
        this.customConfirmAction = customConfirmAction;
      }
    })))), react_default.a.createElement(confirm_modal["a" /* default */], {
      title: formatMessage(holders.confirmTitle),
      message: formatMessage(holders.confirmMsg),
      confirmButtonText: formatMessage(holders.confirmBtns),
      show: this.state.showConfirmModal,
      onConfirm: this.handleConfirm,
      onCancel: this.handleCancelConfirmation
    }));
  }

}

_defineProperty(user_settings_modal_UserSettingsModal, "propTypes", {
  currentUser: prop_types_default.a.object.isRequired,
  onHide: prop_types_default.a.func.isRequired,
  intl: index_es["i" /* intlShape */].isRequired,
  actions: prop_types_default.a.shape({
    sendVerificationEmail: prop_types_default.a.func.isRequred
  }).isRequired
});

/* harmony default export */ var user_settings_modal = (Object(index_es["h" /* injectIntl */])(user_settings_modal_UserSettingsModal));
// CONCATENATED MODULE: ./components/user_settings/modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const closeUnusedDirectMessages = config.CloseUnusedDirectMessages === "true";
  const experimentalChannelOrganization = config.ExperimentalChannelOrganization === "true";
  const sendEmailNotifications = config.SendEmailNotifications === "true";
  const requireEmailVerification = config.RequireEmailVerification === "true";
  const activeTab = state.views.modals.modalState.user_settings.activeTab;
  console.log(state.views.modals, activeTab);
  return {
    currentUser: Object(entities_users["getCurrentUser"])(state),
    closeUnusedDirectMessages,
    experimentalChannelOrganization,
    sendEmailNotifications,
    requireEmailVerification,
    activeTab: activeTab
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      sendVerificationEmail: users["sendVerificationEmail"]
    }, dispatch)
  };
}

/* harmony default export */ var modal = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(user_settings_modal));

/***/ }),

/***/ 1758:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./components/profile_picture.jsx
var profile_picture = __webpack_require__(1656);

// EXTERNAL MODULE: ./components/svg/mattermost_logo.jsx
var mattermost_logo = __webpack_require__(2010);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/post_utils.jsx + 1 modules
var post_utils = __webpack_require__(407);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// CONCATENATED MODULE: ./components/post_profile_picture/post_profile_picture.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class post_profile_picture_PostProfilePicture extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "getProfilePicSrcForPost", (fromAutoResponder, fromWebhook) => {
      const {
        post,
        user
      } = this.props;

      if (this.props.compactDisplay) {
        return '';
      }

      let src = '';

      if (user && user.id === post.user_id) {
        src = utils["K" /* imageURLForUser */](user);
      } else if (post.user_id) {
        src = utils["K" /* imageURLForUser */](post.user_id);
      }

      if (!fromAutoResponder && fromWebhook && !post.props.use_user_icon && this.props.enablePostIconOverride) {
        if (post.props.override_icon_url) {
          src = post_utils["e" /* getImageSrc */](post.props.override_icon_url, this.props.hasImageProxy);
        } else {
          src = constants["N" /* default */].DEFAULT_WEBHOOK_LOGO;
        }
      }

      return src;
    });

    _defineProperty(this, "getStatus", (fromAutoResponder, fromWebhook, user) => {
      if (fromAutoResponder || fromWebhook || user && user.is_bot) {
        return '';
      }

      return this.props.status;
    });
  }

  render() {
    const {
      compactDisplay,
      isBusy,
      isRHS,
      post,
      user,
      isBot
    } = this.props;
    const isSystemMessage = post_utils["l" /* isSystemMessage */](post);
    const fromWebhook = post_utils["k" /* isFromWebhook */](post);

    if (isSystemMessage && !compactDisplay && !fromWebhook && !isBot) {
      return react_default.a.createElement("span", {
        className: "post-robot-icon"
      });
    }

    const fromAutoResponder = post_utils["d" /* fromAutoResponder */](post);
    const hasMention = !fromAutoResponder && !fromWebhook;
    const src = this.getProfilePicSrcForPost(fromAutoResponder, fromWebhook);
    const status = this.getStatus(fromAutoResponder, fromWebhook, user);
    return react_default.a.createElement(profile_picture["a" /* default */], {
      hasMention: hasMention,
      isBusy: isBusy,
      isRHS: isRHS,
      src: src,
      status: status,
      userId: user ? user.id : null,
      username: user ? user.username : null
    });
  }

}

_defineProperty(post_profile_picture_PostProfilePicture, "propTypes", {
  compactDisplay: prop_types_default.a.bool.isRequired,
  enablePostIconOverride: prop_types_default.a.bool.isRequired,
  hasImageProxy: prop_types_default.a.bool.isRequired,
  isBusy: prop_types_default.a.bool,
  isRHS: prop_types_default.a.bool,
  post: prop_types_default.a.object.isRequired,
  status: prop_types_default.a.string,
  user: prop_types_default.a.object,
  isBot: prop_types_default.a.bool
});

_defineProperty(post_profile_picture_PostProfilePicture, "defaultProps", {
  status: constants["L" /* UserStatuses */].OFFLINE
});
// CONCATENATED MODULE: ./components/post_profile_picture/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function mapStateToProps(state, ownProps) {
  const config = Object(general["getConfig"])(state);
  const user = Object(users["getUser"])(state, ownProps.userId);
  return {
    enablePostIconOverride: config.EnablePostIconOverride === 'true',
    hasImageProxy: config.HasImageProxy === 'true',
    status: Object(users["getStatusForUserId"])(state, ownProps.userId),
    isBot: Boolean(user && user.is_bot),
    user
  };
}

/* harmony default export */ var post_profile_picture = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(post_profile_picture_PostProfilePicture));

/***/ }),

/***/ 1759:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var constants = __webpack_require__(17);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var channels = __webpack_require__(15);

// EXTERNAL MODULE: ./selectors/rhs.jsx
var rhs = __webpack_require__(60);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./utils/post_utils.jsx + 1 modules
var post_utils = __webpack_require__(407);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/post_markdown/index.js + 7 modules
var post_markdown = __webpack_require__(2252);

// EXTERNAL MODULE: ./plugins/pluggable/index.js + 1 modules
var pluggable = __webpack_require__(1647);

// EXTERNAL MODULE: ./components/post_view/show_more/index.js + 1 modules
var show_more = __webpack_require__(2274);

// EXTERNAL MODULE: ./components/ao_post_cards/index.js + 35 modules
var ao_post_cards = __webpack_require__(1821);

// EXTERNAL MODULE: ./api/post.js
var api_post = __webpack_require__(67);

// CONCATENATED MODULE: ./components/post_view/post_message_view/post_message_view.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








 // 消息卡片



class post_message_view_PostMessageView extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleHeightReceived", height => {
      if (height > 0) {
        // Increment checkOverflow to indicate change in height
        // and recompute textContainer height at ShowMore component
        // and see whether overflow text of show more/less is necessary or not.
        this.setState(prevState => {
          return {
            checkOverflow: prevState.checkOverflow + 1
          };
        });
      }
    });

    this.state = {
      collapse: true,
      hasOverflow: false,
      checkOverflow: 0,
      meetId: -1,
      //会议zoomid
      meetName: "",
      channel_id: "",
      id: -1 //最福利会议id

    };
    this.imageProps = {
      onImageLoaded: this.handleHeightReceived
    };
  }

  renderDeletedPost() {
    return react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "post_body.deleted",
      defaultMessage: "(message deleted)"
    }));
  }

  renderEditedIndicator() {
    if (!post_utils["i" /* isEdited */](this.props.post)) {
      return null;
    }

    return react_default.a.createElement("span", {
      id: `postEdited_${this.props.post.id}`,
      className: "post-edited__indicator"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "post_message_view.edited",
      defaultMessage: "(edited)"
    }));
  }

  render() {
    const {
      post,
      enableFormatting,
      options,
      pluginPostTypes,
      compactDisplay,
      isRHS,
      theme,
      isDM
    } = this.props;

    if (post.state === constants["Posts"].POST_DELETED) {
      return this.renderDeletedPost();
    }

    if (!enableFormatting) {
      return react_default.a.createElement("span", null, post.message);
    } // console.log('[post_message_view] enableFormatting:', enableFormatting, ', pluginPostTypes:', pluginPostTypes);
    // console.log('[post_message_view] post:', post);


    const postType = post.props && post.props.type ? post.props.type : post.type;

    if (pluginPostTypes.hasOwnProperty(postType)) {
      const PluginComponent = pluginPostTypes[postType].component;
      return react_default.a.createElement(PluginComponent, {
        post: post,
        compactDisplay: compactDisplay,
        isRHS: isRHS,
        theme: theme
      });
    }

    let message = post.message;
    const isEphemeral = utils["Z" /* isPostEphemeral */](post);

    if (compactDisplay && isEphemeral) {
      const visibleMessage = utils["gb" /* localizeMessage */]("post_info.message.visible.compact", " (Only visible to you)");
      message = message.concat(visibleMessage);
    }

    let messageWithAdditionalContent;
    const Card = Object(ao_post_cards["a" /* createCard */])(post);

    if (Card) {
      messageWithAdditionalContent = react_default.a.createElement(Card, {
        post: post,
        isDM: isDM,
        channel: this.props.currentChannel
      }); //localStorage.setItem("videoInivte",JSON.stringify({members:this.props.members,teamId:this.props.teamId}));
    } else {
      messageWithAdditionalContent = react_default.a.createElement(post_markdown["a" /* default */], {
        message: message,
        imageProps: this.imageProps,
        isRHS: isRHS,
        options: options,
        post: post,
        channelId: post.channel_id
      });
    } // mock for ShipProcess
    // messageWithAdditionalContent = <ShipProcess
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       title: '安链云用户模块 (ID：28)',
    //       status: 'fail',
    //       serviceName: 'tech-anlink-user',
    //       desc: '测试原因，测试原因，测试原因，测试原因。测试原因，测试原因，测试原因，测试原因。',
    //       link: 'https://www.google.com/',
    //       applications: [
    //         {
    //             applicationName: '应用1',
    //             logUrl: 'https://www.baidu.com/',
    //             monitorUrl: 'https://www.baidu.com/',
    //         },
    //         {
    //             applicationName: '应用2',
    //             logUrl: 'https://www.baidu.com/',
    //             monitorUrl: 'https://www.baidu.com/',
    //         },
    //       ],
    //     })
    //   }}
    // />
    // mock for PubCreate
    // messageWithAdditionalContent = <PubCreate
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       desc: '创建发布计划',
    //       link: 'https://www.google.com',
    //     })
    //   }}
    // />
    // mock for Table
    // messageWithAdditionalContent = <Table
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       title: 'SHIP发布平台',
    //       appName: 'Seraph',
    //       columns: [
    //           {
    //               title: '发布计划',
    //               key: 'name',
    //           },
    //           {
    //               title: '状态',
    //               key: 'status',
    //           },
    //           {
    //               title: '状态说明',
    //               key: 'des',
    //           },
    //       ],
    //       data: [
    //           {
    //               status: '快速迭代0909',
    //               name: {
    //                   text: '应用1',
    //                   link: 'https://www.baidu.com/',
    //               },
    //               des:'快速迭代0909'
    //           },
    //           {
    //               status: '持续集成中',
    //               name: {
    //                   text: '应用2',
    //                   link: 'https://www.baidu.com/',
    //               },
    //               des:'持续集成中'
    //           },
    //           {
    //               status: '其他',
    //               name: {
    //                   text: '其他（10个）',
    //                   link: 'https://www.baidu.com/',
    //               },
    //               des:'其他'
    //           },
    //       ]
    //     })
    //   }}
    // />
    // mock for Warning
    // messageWithAdditionalContent = <Warning
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       title: '告警消息-日志监控',
    //       appName: 'seraph',
    //       data: [
    //           {"type":"监控指标名","content":"level_count"},
    //           {"type":"关联应用","content":"seraph-log-service"},
    //           {"type":"环境","content":"vpc-pub"},
    //           {"type":"命中规则","content":"错误日志监控"},
    //           {"type":"规则描述","content":"错误日志条数告警"},
    //           {"type":"阈值","content":">=1"},
    //           {"type":"数据详情","content":"在1分钟周期内，1个周期平均值>=1，周期结束时间：2019-08-26 17:17:00"}
    //       ],
    //       members: ['za-yuanjing', 'ywz-liujian'],
    //       receivers: ['za-yuanjing', 'ywz-liujian'],
    //     })
    //   }}
    // />
    //mock for Meeting
    // messageWithAdditionalContent = <Meeting
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       id: '1001',
    //       meetId: '10001',
    //       meetName: '项目需求讨论',
    //       from: 'za-yuanjing',
    //       to: ['za-lisanmei', 'za-luguiming', 'za-tanshungang'],
    //       time: '2019/08/30 13:24:48'
    //     })
    //   }}
    // />
    // mock for SeraphTracing
    // messageWithAdditionalContent = <SeraphTracing
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       id: '3f37728',
    //       time:'2019-01-01 12:00:00',
    //       link: 'http://www.baidu.com/',
    //       serviceName: 'tech-anlink-adapter-sidecar-prd',
    //       cost: '0.55ms',
    //       span: '1 Span',
    //       appName: 'Seraph'
    //     })
    //   }}
    // />
    // // mock for MonitorAreaGradient
    // messageWithAdditionalContent = <MonitorAreaGradient
    // isDM={isDM}
    // channel={this.props.currentChannel}
    // post={{
    //   ...post,
    //   message: JSON.stringify({
    //     title: "xxx",
    //     link: "http://baidu.com",
    //     appName: "serahp",
    //     result: [
    //         {
    //             type: "cpu_rate",
    //             title: "cpu使用率",
    //             unit: "%",
    //             color: [54,161,255],
    //             data: [
    //                 {timestamp: 1566802791531, value: 18},
    //                 {timestamp: 1566802798000, value: 20}
    //             ]
    //         },
    //     ]
    //   })
    // }} />
    // // mock for MonitorPointBubble
    // messageWithAdditionalContent = <MonitorPointBubble
    // isDM={isDM}
    // channel={this.props.currentChannel}
    // post={{
    //   ...post,
    //   message: JSON.stringify({
    //     title: "xxx2",
    //     link: "http://baidu.com",
    //     appName: "serahp",
    //     result: [
    //         {
    //             type: "cpu_rate",
    //             title: "cpu使用率",
    //             unit: "%",
    //             color: [54,161,255],
    //             data: [
    //                 {timestamp: 1566802791531, value: 18},
    //                 {timestamp: 1566802798000, value: 20}
    //             ]
    //         },
    //     ]
    //   })
    // }} />
    // console.log('post:', post);
    // mock for ScaffoldMeta
    // messageWithAdditionalContent = <ScaffoldMeta
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       // values: {
    //       //   projectType: 'java',
    //       //   projectName: 'project',
    //       //   version: '1.0.0',
    //       //   groupId: 'group',
    //       //   artifactId: 'artifact',
    //       //   packageName: 'package',
    //       // },
    //     }),
    // }} />
    // mock for ScaffoldDependency
    // messageWithAdditionalContent = <ScaffoldDependency
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //   ...post,
    //   message: JSON.stringify({
    //     projectId: 107,
    //     form: [
    //       {
    //         key: 'message_queue',
    //         title: '消息队列',
    //         options: ['ONS', 'kafka'],
    //         required: true,
    //       },
    //       {
    //         key: 'cache',
    //         title: '缓存',
    //         options: ['redis'],
    //         required: true,
    //       },
    //       {
    //         key: 'rpc',
    //         title: 'rpc',
    //         options: ['feign'],
    //         required: false,
    //       },
    //       {
    //         key: 'db',
    //         title: '数据库',
    //         options: ['mysql'],
    //         required: false,
    //       },
    //     ],
    //     // values: {
    //     //   message_queue: 'kafka',
    //     //   rpc: 'feign',
    //     //   db: 'mysql',
    //     // },
    //   })
    // }} />
    // mock for CreateAppApprove
    // messageWithAdditionalContent = <CreateAppApprove
    //   isDM={isDM}
    //   channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       businessData: {
    //         processInstanceId: '1',
    //         taskId: '1',
    //       },
    //       projectName: '项目名称',
    //       applicationName: '应用名称',
    //       applicantName: '申请人名称',
    //       applyTime: '申请时间（格式化后的文本）',
    //       step: '阶段',
    //     }),
    //   }}
    // />
    // mock for CreateAppStepResultForApprover
    // messageWithAdditionalContent = <CreateAppStepResultForApprover
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({   
    //       projectName: '项目名称',
    //       applicationName: '应用名称',
    //       applicantName: '申请人名称',
    //       applyTime: '申请时间（格式化后的文本）',
    //       approverName: '审批人名称',
    //       step: '阶段',
    //       result: '通过',
    //     }),
    //   }}
    // />
    // mock for CreateAppStepResultForApplicant
    // messageWithAdditionalContent = <CreateAppStepResultForApplicant
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({   
    //       projectName: '项目名称',
    //       applicationName: '应用名称',
    //       applyTime: '申请时间（格式化后的文本）',
    //       approverName: '审批人名称',
    //       step: '阶段',
    //       result: '驳回'
    //     }),
    //   }}
    // />
    // mock for CreateAppCreated
    // messageWithAdditionalContent = <CreateAppCreated
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       desc: '您的**项目...是否需要快速部署..是否需要快速部署..是否需要快速部署.是否需要快速部署...并预览Demo',
    //       orderUrl: '查看工单的url',
    //       id: '唯一标示(第一步创建应用时生成)，部署时使用',
    //     }),
    //   }}
    // />
    // mock for CreateAppDeploySuccess
    // messageWithAdditionalContent = <CreateAppDeploySuccess
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       projectName: '项目名称',
    //       applicationName: '应用名称',
    //       owner: '字符串',
    //       orderUrl: '查看发布单的url',
    //       demoUrl: '查看demo的url',
    //     }),
    //   }}
    // />
    // mock for CreateAppDeploySuccess
    // messageWithAdditionalContent = <CreateAppDeployFail
    // isDM={isDM}
    // channel={this.props.currentChannel}
    //   post={{
    //     ...post,
    //     message: JSON.stringify({
    //       id: '唯一标示(第一步创建应用时生成)，部署时使用',
    //       projectName: '项目名称',
    //       applicationName: '应用名称',
    //       reason: '失败原因',
    //       orderUrl: '查看发布单的url'
    //     }),
    //   }}
    // />


    if (this.props.type === 'card') {
      return react_default.a.createElement("div", {
        id: `postMessageText_${post.id}`,
        className: `post-message__text ${message ? '' : 'no-message'}`,
        onClick: utils["H" /* handleFormattedTextClick */]
      }, messageWithAdditionalContent);
    }

    return react_default.a.createElement(show_more["a" /* default */], {
      checkOverflow: this.state.checkOverflow,
      text: message
    }, react_default.a.createElement("div", {
      id: `postMessageText_${post.id}`,
      className: `post-message__text ${message ? '' : 'no-message'}`,
      onClick: utils["H" /* handleFormattedTextClick */]
    }, messageWithAdditionalContent), this.renderEditedIndicator(), react_default.a.createElement(pluggable["a" /* default */], {
      pluggableName: "PostMessageAttachment",
      postId: post.id,
      onHeightChange: this.handleHeightReceived
    }));
  }

}

_defineProperty(post_message_view_PostMessageView, "propTypes", {
  currentChannel: prop_types_default.a.object,
  currentUser: prop_types_default.a.object,

  /*
   * The post to render the message for
   */
  post: prop_types_default.a.object.isRequired,

  /*
   * Set to enable Markdown formatting
   */
  enableFormatting: prop_types_default.a.bool,

  /*
   * Options specific to text formatting
   */
  options: prop_types_default.a.object,

  /**
   * Set to render post body compactly
   */
  compactDisplay: prop_types_default.a.bool,

  /**
   * Flags if the post_message_view is for the RHS (Reply).
   */
  isRHS: prop_types_default.a.bool,

  /**
   * Whether or not the RHS is visible
   */
  isRHSOpen: prop_types_default.a.bool,

  /**
   * Whether or not the RHS is expanded
   */
  isRHSExpanded: prop_types_default.a.bool,

  /*
   * Logged in user's theme
   */
  theme: prop_types_default.a.object.isRequired,

  /*
   * Post type components from plugins
   */
  pluginPostTypes: prop_types_default.a.object
});

_defineProperty(post_message_view_PostMessageView, "defaultProps", {
  options: {},
  isRHS: false,
  pluginPostTypes: {}
});
// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./utils/constants.jsx
var utils_constants = __webpack_require__(0);

// CONCATENATED MODULE: ./components/post_view/post_message_view/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.














function getChannelIcon(state, _channel) {
  let channelIcon = _channel.icon_id;
  let channelDisplayName = _channel.display_name;
  const reg = /public_|private_/;

  if (!channelIcon || !reg.test(channelIcon)) {
    channelIcon = __webpack_require__(410)(`./${_channel.type === 'O' ? 'public_00.png' : 'private_00.png'}`);
  } else {
    channelIcon = __webpack_require__(410)(`./${channelIcon}`);
  }

  if (_channel.type === utils_constants["g" /* Constants */].DM_CHANNEL) {
    const teammate = Object(users["getUser"])(state, _channel.teammate_id);

    if (teammate) {
      // channelTeammateId = teammate.id;
      // channelTeammateDeletedAt = teammate.delete_at;
      // channelTeammateUsername = teammate.username;
      // channelTeammateIsBot = teammate.is_bot;
      channelIcon = utils["K" /* imageURLForUser */]({
        id: teammate.id
      });
      channelDisplayName = teammate.nickname == "" ? teammate.first_name == "" ? teammate.username : teammate.first_name : teammate.nickname; //console.log("sssssss----state",state,"ownProps",ownProps,"member----",member,"channel----",channel,"teammate----",teammate,"teammateNameDisplay----",teammateNameDisplay,"channelDisplayName----",channelDisplayName)
    }
  }

  return [channelIcon, channelDisplayName];
}

function mapStateToProps(state) {
  // const getChannel = makeGetChannel();
  // const sidebarPrefs = getSidebarPreferences(state);
  // const lastUnreadChannel = state.views.channel.keepChannelIdAsUnread;
  // const orderedChannelIds = getOrderedChannelIds(
  //   state,
  //   lastUnreadChannel,
  //   sidebarPrefs.grouping,
  //   sidebarPrefs.sorting,
  //   sidebarPrefs.unreads_at_top === "true",
  //   sidebarPrefs.favorite_at_top === "true"
  // );
  // let members = [];
  // Array.isArray(orderedChannelIds)
  //   && orderedChannelIds.map(item => members = [...members, ...item.items]);
  // members = members.map(channelId => {
  //   const _channel = getChannel(state, {id: channelId}) || {};
  //   const [channelIcon, channelDisplayName] = getChannelIcon(state, _channel);
  //   return {
  //     members,
  //     channelId,
  //     channelIcon,
  //     channelDisplayName,
  //     type: 'lately',
  //   }
  // });
  // const currentTeamId = getCurrentTeamId(state);//getCurrentTeamId
  const currentChannel = Object(channels["getCurrentChannel"])(state) || {};
  const isDM = currentChannel && currentChannel.type === 'D';
  return {
    //currentTeamId,
    //members,
    enableFormatting: Object(preferences["getBool"])(state, constants["Preferences"].CATEGORY_ADVANCED_SETTINGS, "formatting", true),
    isRHSExpanded: Object(rhs["a" /* getIsRhsExpanded */])(state),
    isRHSOpen: Object(rhs["c" /* getIsRhsOpen */])(state),
    pluginPostTypes: state.plugins.postTypes,
    theme: Object(preferences["getTheme"])(state),
    currentUser: Object(users["getCurrentUser"])(state),
    currentChannel,
    isDM
  };
}

/* harmony default export */ var post_message_view = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(post_message_view_PostMessageView));

/***/ }),

/***/ 1760:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/antd/es/message/index.js
var message = __webpack_require__(3478);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tooltip.js
var Tooltip = __webpack_require__(1998);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./components/icons/star_icon.jsx
var star_icon = __webpack_require__(1882);

// EXTERNAL MODULE: ./components/icons/star_line_icon.jsx
var star_line_icon = __webpack_require__(2062);

// EXTERNAL MODULE: ./components/icons/star_icon_filled.jsx
var star_icon_filled = __webpack_require__(2063);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/i18n.jsx
var i18n = __webpack_require__(53);

// CONCATENATED MODULE: ./components/post_view/post_flag_icon/post_flag_icon.js
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




 // import FlagIcon from 'components/svg/flag_icon';
// import FlagIconFilled from 'components/svg/flag_icon_filled';






class post_flag_icon_PostFlagIcon extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "handlePress", async (e, onlyFlag) => {
      e.preventDefault();
      const {
        actions,
        isFlagged,
        postId
      } = this.props;

      if (onlyFlag === 'onlyFlag') {
        if (!isFlagged) {
          await actions.flagPost(postId);
          message["a" /* default */].success('收藏成功');
        } else {
          message["a" /* default */].warn('该消息已收藏');
        }
      } else {
        if (isFlagged) {
          actions.unflagPost(postId);
        } else {
          actions.flagPost(postId);
        }
      }
    });
  }

  render() {
    if (this.props.isEphemeral) {
      return null;
    }

    const isFlagged = this.props.isFlagged;
    const flagVisible = isFlagged ? 'visible' : '';
    let flagIcon;

    if (isFlagged) {
      flagIcon = react_default.a.createElement(star_icon_filled["a" /* default */], {
        className: "icon"
      });
    } else {
      flagIcon = react_default.a.createElement(star_icon["a" /* default */], {
        className: "icon"
      });
    }

    return !this.props.title ? react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      key: 'flagtooltipkey' + flagVisible,
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: react_default.a.createElement(Tooltip["a" /* default */], {
        id: "flagTooltip"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: isFlagged ? Object(i18n["b" /* t */])('flag_post.unflag') : Object(i18n["b" /* t */])('flag_post.flag'),
        defaultMessage: isFlagged ? 'Unflag' : 'Flag for follow up'
      }))
    }, react_default.a.createElement("button", {
      id: `${this.props.location}_flagIcon_${this.props.postId}`,
      className: 'style--none flag-icon__container ' + flagVisible,
      onClick: this.handlePress
    }, flagIcon)) : react_default.a.createElement("div", {
      onClick: e => this.handlePress(e, 'onlyFlag')
    }, react_default.a.createElement("button", {
      id: `${this.props.location}_flagIcon_${this.props.postId}`,
      className: 'style--none flag-icon__container ' + flagVisible
    }, react_default.a.createElement(star_line_icon["a" /* default */], null)), react_default.a.createElement("span", {
      style: {
        marginLeft: 3
      }
    }, this.props.title));
  }

}

_defineProperty(post_flag_icon_PostFlagIcon, "propTypes", {
  location: prop_types_default.a.oneOf([constants["o" /* Locations */].CENTER, constants["o" /* Locations */].RHS_ROOT, constants["o" /* Locations */].RHS_COMMENT, constants["o" /* Locations */].SEARCH]).isRequired,
  postId: prop_types_default.a.string.isRequired,
  isFlagged: prop_types_default.a.bool.isRequired,
  isEphemeral: prop_types_default.a.bool,
  title: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    flagPost: prop_types_default.a.func.isRequired,
    unflagPost: prop_types_default.a.func.isRequired
  }).isRequired
});

_defineProperty(post_flag_icon_PostFlagIcon, "defaultProps", {
  isEphemeral: false,
  location: constants["o" /* Locations */].CENTER
});
// CONCATENATED MODULE: ./components/post_view/post_flag_icon/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      flagPost: post_actions["f" /* flagPost */],
      unflagPost: post_actions["p" /* unflagPost */]
    }, dispatch)
  };
}

/* harmony default export */ var post_flag_icon = __webpack_exports__["a"] = (Object(es["connect"])(null, mapDispatchToProps)(post_flag_icon_PostFlagIcon));

/***/ }),

/***/ 1765:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Badge; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _badge_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2325);
/* harmony import */ var _badge_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_badge_scss__WEBPACK_IMPORTED_MODULE_2__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class Badge extends react__WEBPACK_IMPORTED_MODULE_0___default.a.Component {
  render() {
    if (!this.props.show) {
      return null;
    }

    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "Badge"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: 'Badge__box ' + this.props.className
    }, this.props.children));
  }

}

_defineProperty(Badge, "propTypes", {
  show: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool.isRequired,
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node.isRequired,
  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string
});

_defineProperty(Badge, "defaultProps", {
  show: true,
  className: ''
});

/***/ }),

/***/ 1766:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return QuickInput; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

 // A component that can be used to make controlled inputs that function properly in certain
// environments (ie. IE11) where typing quickly would sometimes miss inputs

class QuickInput extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "updateInputFromProps", () => {
      if (!this.input || this.input.value === this.props.value) {
        return;
      }

      this.input.value = this.props.value;
    });

    _defineProperty(this, "getInput", () => {
      return this.input;
    });

    _defineProperty(this, "setInput", input => {
      this.input = input;
    });
  }

  componentDidUpdate(prevProps) {
    if (prevProps.value !== this.props.value) {
      if (this.props.delayInputUpdate) {
        requestAnimationFrame(this.updateInputFromProps);
      } else {
        this.updateInputFromProps();
      }
    }
  }

  get value() {
    return this.input.value;
  }

  set value(value) {
    this.input.value = value;
  }

  focus() {
    this.input.focus();
  }

  blur() {
    this.input.blur();
  }

  render() {
    const {
      value,
      inputComponent,
      ...props
    } = this.props;
    Reflect.deleteProperty(props, 'delayInputUpdate');
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(inputComponent || 'input', { ...props,
      ref: this.setInput,
      defaultValue: value // Only set the defaultValue since the real one will be updated using componentDidUpdate

    });
  }

}

_defineProperty(QuickInput, "propTypes", {
  /**
   * Whether to delay updating the value of the textbox from props. Should only be used
   * on textboxes that to properly compose CJK characters as the user types.
   */
  delayInputUpdate: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * An optional React component that will be used instead of an HTML input when rendering
   */
  inputComponent: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /**
   * The string value displayed in this input
   */
  value: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired
});

_defineProperty(QuickInput, "defaultProps", {
  delayInputUpdate: false,
  value: ''
});

/***/ }),

/***/ 1767:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var utils_browser_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(114);
/* harmony import */ var selectors_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(203);
/* harmony import */ var actions_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(139);
/* harmony import */ var stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var utils_utils_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(22);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const dispatch = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].dispatch;
const getState = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getState;

class BrowserStoreClass {
  setItem(name, value) {
    dispatch(actions_storage__WEBPACK_IMPORTED_MODULE_2__[/* setItem */ "f"](name, value));
  }

  getItem(name, defaultValue) {
    return selectors_storage__WEBPACK_IMPORTED_MODULE_1__[/* makeGetItem */ "d"](name, defaultValue)(getState());
  }

  removeItem(name) {
    dispatch(actions_storage__WEBPACK_IMPORTED_MODULE_2__[/* removeItem */ "d"](name));
  }

  setGlobalItem(name, value) {
    dispatch(actions_storage__WEBPACK_IMPORTED_MODULE_2__[/* setGlobalItem */ "e"](name, value));
  }

  getGlobalItem(name, defaultValue = null) {
    return selectors_storage__WEBPACK_IMPORTED_MODULE_1__[/* makeGetGlobalItem */ "c"](name, defaultValue)(getState());
  }

  removeGlobalItem(name) {
    dispatch(actions_storage__WEBPACK_IMPORTED_MODULE_2__[/* removeGlobalItem */ "c"](name));
  }

  signalLogout() {
    if (this.isLocalStorageSupported()) {
      // PLT-1285 store an identifier in session storage so we can catch if the logout came from this tab on IE11
      const logoutId = utils_utils_jsx__WEBPACK_IMPORTED_MODULE_5__[/* generateId */ "s"]();
      utils_utils_jsx__WEBPACK_IMPORTED_MODULE_5__[/* removePrefixFromLocalStorage */ "mb"](utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].ANNOUNCEMENT);
      sessionStorage.setItem(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].LOGOUT, logoutId);
      localStorage.setItem(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].LOGOUT, logoutId);
      localStorage.removeItem(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].LOGOUT);
    }
  }

  isSignallingLogout(logoutId) {
    return logoutId === sessionStorage.getItem(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].LOGOUT);
  }

  signalLogin() {
    if (this.isLocalStorageSupported()) {
      // PLT-1285 store an identifier in session storage so we can catch if the logout came from this tab on IE11
      const loginId = utils_utils_jsx__WEBPACK_IMPORTED_MODULE_5__[/* generateId */ "s"]();
      sessionStorage.setItem(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].LOGIN, loginId);
      localStorage.setItem(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].LOGIN, loginId);
      localStorage.removeItem(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].LOGIN);
    }
  }

  isSignallingLogin(loginId) {
    return loginId === sessionStorage.getItem(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].LOGIN);
  }

  clear(options) {
    dispatch(actions_storage__WEBPACK_IMPORTED_MODULE_2__[/* clear */ "b"](options));
  }

  isLocalStorageSupported() {
    if (this.hasCheckedLocalStorage) {
      return this.localStorageSupported;
    }

    this.localStorageSupported = false;

    try {
      localStorage.setItem('__testLocal__', '1');

      if (localStorage.getItem('__testLocal__') === '1') {
        this.localStorageSupported = true;
      }

      localStorage.removeItem('__testLocal__', '1');
    } catch (e) {
      this.localStorageSupported = false;
    }

    try {
      sessionStorage.setItem('__testSession__', '1');
      sessionStorage.removeItem('__testSession__');
    } catch (e) {
      // Session storage not usable, website is unusable
      utils_browser_history__WEBPACK_IMPORTED_MODULE_0__[/* browserHistory */ "a"].push('/error?type=' + utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* ErrorPageTypes */ "i"].LOCAL_STORAGE);
    }

    this.hasCheckedLocalStorage = true;
    return this.localStorageSupported;
  }

  hasSeenLandingPage() {
    return localStorage.getItem(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].LANDING_PAGE_SEEN);
  }

  setLandingPageSeen(landingPageSeen) {
    localStorage.setItem(utils_constants_jsx__WEBPACK_IMPORTED_MODULE_4__[/* StoragePrefixes */ "F"].LANDING_PAGE_SEEN, landingPageSeen);
  }

}

var BrowserStore = new BrowserStoreClass();
/* harmony default export */ __webpack_exports__["a"] = (BrowserStore);

/***/ }),

/***/ 1776:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoadingBars; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var images_load_gif__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2426);
/* harmony import */ var images_load_gif__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(images_load_gif__WEBPACK_IMPORTED_MODULE_2__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class LoadingBars extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  render() {
    const {
      text
    } = this.props;
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", {
      className: 'LoadingBars' + (text ? ' with-text' : '')
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("img", {
      alt: 'spinner icon',
      className: "spinner",
      src: images_load_gif__WEBPACK_IMPORTED_MODULE_2___default.a
    }), text);
  }

}

_defineProperty(LoadingBars, "propTypes", {
  text: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
});

_defineProperty(LoadingBars, "defaultProps", {
  text: null
});

/***/ }),

/***/ 1807:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MenuGroup; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class MenuGroup extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  render() {
    const {
      children
    } = this.props;
    const divider = this.props.divider || react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
      className: "MenuGroup menu-divider"
    });
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment, null, divider, children);
  }

}

_defineProperty(MenuGroup, "propTypes", {
  divider: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node
});

/***/ }),

/***/ 1808:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/d3bc49a25ea44e238e8641c9cea4ef81.png";

/***/ }),

/***/ 1809:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return searchContacts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return searchChannels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return searchPosts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return searchClouds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return filterPost; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return filterCloud; });
/* harmony import */ var _utils_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
// 此种组织方式不太合理
// 可以按照业务领域创建文件

const prefix = '/api/v4/'; // 搜索联系人

const searchContacts = params => {
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    url: `${prefix}users/search`,
    method: 'POST',
    data: params
  });
}; // 搜索渠道

const searchChannels = ({
  team_id,
  ...rest
}) => {
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    url: `${prefix}users/me/teams/${team_id}/channels`,
    method: 'POST',
    data: rest
  });
}; // 搜索聊天记录

const searchPosts = ({
  team_id,
  ...rest
}) => {
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    url: `${prefix}teams/${team_id}/posts/search/count`,
    method: 'POST',
    data: rest
  });
}; // 搜索云盘

const searchClouds = ({
  team_id,
  ...rest
}) => {
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    url: `${prefix}files/teams/${team_id}/search/count`,
    method: 'POST',
    data: rest
  });
}; // 筛选post

const filterPost = ({
  team_id,
  channel_id,
  ...rest
}) => {
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    url: `${prefix}teams/${team_id}/channels/${channel_id}/posts/search`,
    method: 'POST',
    data: rest
  });
}; // 筛选云盘

const filterCloud = ({
  team_id,
  channel_id,
  ...rest
}) => {
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    url: `${prefix}files/teams/${team_id}/channels/${channel_id}/search`,
    method: 'POST',
    data: rest
  });
};

/***/ }),

/***/ 1821:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./components/ao_post_cards/ship_process/icon.png
var icon = __webpack_require__(2468);
var icon_default = /*#__PURE__*/__webpack_require__.n(icon);

// CONCATENATED MODULE: ./components/ao_post_cards/_base/withParse/index.js
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }


/* harmony default export */ var withParse = (Component => {
  return props => {
    const {
      post
    } = props;

    try {
      const value = JSON.parse(post.message);
      return react_default.a.createElement(Component, _extends({}, props, {
        _value: value
      }));
    } catch (e) {
      console.log('e:', e);
      return react_default.a.createElement("div", null, react_default.a.createElement("div", null, "\u6D88\u606F\u683C\u5F0F\u9519\u8BEF\uFF0C\u8BF7\u5F00\u53D1\u540C\u5B66\u68C0\u67E5\u3002"), react_default.a.createElement("div", {
        style: {
          color: 'red'
        }
      }, "error: ", e.toString()), react_default.a.createElement("div", null, "card_type: ", post.card_type), react_default.a.createElement("div", null, "message: ", post.message));
    }
  };
});
// EXTERNAL MODULE: ./components/ao_post_cards/ship_process/index.scss
var ship_process = __webpack_require__(2469);

// CONCATENATED MODULE: ./components/ao_post_cards/ship_process/index.js




/* harmony default export */ var ao_post_cards_ship_process = (withParse(({
  post,
  _value
}) => {
  const {
    title,
    status,
    serviceName,
    desc,
    link,
    applications = [] // 兼容历史数据，历史数据没有该字段

  } = _value;
  const newApplications = applications == null ? [] : applications; // 兼容历史数据，历史数据没有该字段

  const statusText = {
    'fail': '失败',
    'success': '成功',
    'process': '进行中'
  }[status];
  return react_default.a.createElement("div", {
    className: "shipdjskhdkdehq"
  }, react_default.a.createElement("div", {
    className: "top",
    onClick: () => window.open(link, "_blank")
  }, react_default.a.createElement("div", {
    className: "left"
  }, react_default.a.createElement("span", null, "ID"), react_default.a.createElement("span", {
    className: "right"
  }, title)), react_default.a.createElement("div", {
    className: `right ${status}`
  }, statusText)), react_default.a.createElement("div", {
    className: "middle",
    onClick: () => window.open(link, "_blank")
  }, react_default.a.createElement("div", {
    className: "left"
  }, react_default.a.createElement("img", {
    src: icon_default.a
  })), react_default.a.createElement("div", {
    className: "right"
  }, serviceName)), react_default.a.createElement("div", {
    className: "bottom",
    onClick: () => window.open(link, "_blank")
  }, desc), react_default.a.createElement("table", null, react_default.a.createElement("thead", null, react_default.a.createElement("tr", null, react_default.a.createElement("th", null, "\u5E8F\u53F7"), react_default.a.createElement("th", null, "\u5E94\u7528"), react_default.a.createElement("th", null, "\u64CD\u4F5C"))), react_default.a.createElement("tbody", null, newApplications.map((record, idx) => {
    return react_default.a.createElement("tr", {
      key: idx
    }, react_default.a.createElement("td", null, idx + 1), react_default.a.createElement("td", null, record.applicationName), react_default.a.createElement("td", null, react_default.a.createElement("a", {
      href: "javascript:;",
      onClick: () => window.open(record.logUrl, "_blank")
    }, "\u67E5\u770B\u65E5\u5FD7"), react_default.a.createElement("a", {
      href: "javascript:;",
      onClick: () => window.open(record.monitorUrl, "_blank")
    }, "\u67E5\u770B\u76D1\u63A7")));
  }))));
}));
// EXTERNAL MODULE: ./components/ao_post_cards/pubcreate/index.scss
var pubcreate = __webpack_require__(2470);

// CONCATENATED MODULE: ./components/ao_post_cards/pubcreate/index.js



/* harmony default export */ var ao_post_cards_pubcreate = (withParse(({
  post,
  _value
}) => {
  const {
    desc,
    link
  } = _value;
  return react_default.a.createElement("div", {
    className: "shippubcreat"
  }, desc, "\uFF0C", react_default.a.createElement("a", {
    href: "javascript:;",
    className: "jump-opr",
    onClick: () => window.open(link, "_blank")
  }, "\u524D\u5F80\u64CD\u4F5C"));
}));
// EXTERNAL MODULE: ./components/ao_post_cards/table/index.scss
var table = __webpack_require__(2471);

// CONCATENATED MODULE: ./components/ao_post_cards/table/index.js



/* harmony default export */ var ao_post_cards_table = (withParse(({
  post,
  _value
}) => {
  const {
    title,
    appName,
    columns,
    data
  } = _value;
  return react_default.a.createElement("div", {
    className: "shipconnect"
  }, react_default.a.createElement("div", {
    className: "top"
  }, react_default.a.createElement("div", {
    className: "left"
  }, title), react_default.a.createElement("div", {
    className: "right success"
  }, appName)), react_default.a.createElement("div", {
    className: "bottom"
  }, react_default.a.createElement("table", null, react_default.a.createElement("thead", null, react_default.a.createElement("tr", null, react_default.a.createElement("th", null, "\u5E8F\u53F7"), columns.map(({
    title,
    key
  }) => react_default.a.createElement("th", {
    key: key
  }, title)))), react_default.a.createElement("tbody", null, data.map((record, idx) => {
    return react_default.a.createElement("tr", {
      key: idx
    }, react_default.a.createElement("td", null, idx + 1), columns.map(({
      key
    }) => {
      const value = record[key];
      return react_default.a.createElement("td", {
        key: key
      }, typeof value === 'object' ? react_default.a.createElement("a", {
        href: "javascript:;",
        onClick: () => window.open(value.link, "_blank")
      }, value.text) : value);
    }));
  })))));
}));
// EXTERNAL MODULE: ./components/ao_post_cards/warning/index.scss
var warning = __webpack_require__(2472);

// CONCATENATED MODULE: ./components/ao_post_cards/warning/index.js



/* harmony default export */ var ao_post_cards_warning = (withParse(({
  post,
  _value,
  isDM
}) => {
  const {
    title,
    appName,
    data,
    members,
    receivers
  } = _value;
  return react_default.a.createElement("div", {
    className: "shipwarn"
  }, react_default.a.createElement("div", {
    className: "top"
  }, react_default.a.createElement("div", {
    className: "left"
  }, react_default.a.createElement("span", null, title)), react_default.a.createElement("div", {
    className: "right warn"
  }, appName)), react_default.a.createElement("div", {
    className: "middle"
  }, react_default.a.createElement("table", null, react_default.a.createElement("thead", null, react_default.a.createElement("tr", null, react_default.a.createElement("th", null, "\u7C7B\u578B"), react_default.a.createElement("th", null, "\u5185\u5BB9"))), react_default.a.createElement("tbody", null, data.map(({
    type,
    content
  }, idx) => {
    return react_default.a.createElement("tr", {
      key: idx
    }, react_default.a.createElement("td", null, type), react_default.a.createElement("td", null, content));
  })))), !isDM && react_default.a.createElement("div", {
    className: "bottom"
  }, [['负责人', members], ['通知人', receivers]].map(item => {
    return react_default.a.createElement("div", {
      className: "warn-person"
    }, react_default.a.createElement("div", {
      className: "person-role"
    }, item[0]), item[1].map(name => {
      return react_default.a.createElement("span", {
        key: name,
        "data-mention": name
      }, '@' + name);
    }));
  })));
}));
// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/antd/es/button/index.js + 3 modules
var es_button = __webpack_require__(234);

// EXTERNAL MODULE: ./api/zoom.js
var zoom = __webpack_require__(1698);

// EXTERNAL MODULE: ./images/share_png@2x.png
var share_png_2x = __webpack_require__(1869);
var share_png_2x_default = /*#__PURE__*/__webpack_require__.n(share_png_2x);

// EXTERNAL MODULE: ./api/post.js
var api_post = __webpack_require__(67);

// EXTERNAL MODULE: ./components/ao_post_cards/meeting/index.scss
var meeting = __webpack_require__(2473);

// CONCATENATED MODULE: ./components/ao_post_cards/meeting/meeting.jsx







/* harmony default export */ var meeting_meeting = (withParse(({
  post,
  _value,
  currentUser,
  isMeeting
}) => {
  const {
    id,
    meetId,
    meetName,
    time,
    from,
    channel_id,
    meeting_id
  } = _value;
  const {
    username,
    nickname
  } = currentUser || {};

  const goMeet = () => {
    Object(api_post["f" /* isInMeet */])(meeting_id, currentUser.username, channel_id).then(res => {
      if (!res.isMeeting) {
        Object(api_post["m" /* meetingModal */])('会议已结束');
        return;
      }

      if (res.myIn) {
        Object(api_post["m" /* meetingModal */])('您已经在会议中');
        return;
      }

      if (isMeeting) {
        //如果本身在会议中
        Object(api_post["m" /* meetingModal */])("您已有在进行的会议,请结束后再加入新会议!");
        return;
      }

      Object(api_post["g" /* meetAdd */])({
        channel_id: channel_id,
        meeting_id: meeting_id,
        meeting_no: meetId.toString(),
        user_name: username,
        nick_name: nickname,
        meetName: meetName
      });
    });
  };

  return react_default.a.createElement("div", {
    className: "meeting-class"
  }, react_default.a.createElement("img", {
    src: share_png_2x_default.a,
    width: "40px",
    height: "40px"
  }), react_default.a.createElement("div", {
    className: "meeting-class-top-left"
  }, react_default.a.createElement("p", {
    className: "meeting-class-top-left-p"
  }, from, " \u9080\u8BF7\u4F60\u52A0\u5165 ", meetName, " \u89C6\u9891\u4F1A\u8BAE")), react_default.a.createElement("div", {
    className: "meeting-class-down"
  }, react_default.a.createElement("div", null, time ? time : '没有标注时间'), react_default.a.createElement(es_button["a" /* default */], {
    id: "submitButton",
    type: "primary",
    onClick: goMeet
  }, "\u70B9\u51FB\u52A0\u5165")));
}));
// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// CONCATENATED MODULE: ./components/ao_post_cards/meeting/index.js




function mapStateToProps(state) {
  const isMeeting = state.views.meeting.invitation.isMeeting || false;
  return {
    currentUser: Object(users["getCurrentUser"])(state),
    isMeeting
  };
}

/* harmony default export */ var ao_post_cards_meeting = (Object(es["connect"])(mapStateToProps)(meeting_meeting));
// CONCATENATED MODULE: ./components/ao_post_cards/meeting_json/meeting.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






class meeting_MeetingView extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "goMeet", () => {
      //console.log("2222",this.props,this.state.channel_id,this.state)
      //debugger
      // if(this.props.channel.id != this.state.channel_id){
      //     alert('会议不在该频道请切换到对应去参加')
      //     return;
      // }
      Object(api_post["f" /* isInMeet */])(this.state.id.toString(), this.props.currentUser.username, this.props.channel.id).then(res => {
        if (!res.isMeeting) {
          Object(api_post["m" /* meetingModal */])('会议已结束');
          return;
        }

        if (res.myIn) {
          Object(api_post["m" /* meetingModal */])('您已经在会议中');
          return;
        }

        this.props.actions.meetAddAction({
          channel_id: this.props.channel.id,
          meeting_id: this.state.id,
          meeting_no: this.state.meetId.toString(),
          user_name: this.props.currentUser.username,
          nick_name: this.props.currentUser.nickname,
          meetName: this.state.meetName
        });
      });
    });

    _defineProperty(this, "isMeet", str => {
      const list = str.split("]");
      const from = list[0].split(":")[1];
      const id = list[0].split(":").length > 3 ? list[0].split(":")[3] : 0;
      const meetsName = list[0].split(":").length > 4 ? list[0].split(":")[4] : "xxx"; //会议名

      const time = list[0].split(":").length > 5 ? list[0].split(":")[5] + ":" + list[0].split(":")[6] + ":" + list[0].split(":")[7] : 0;
      const channel_id = list[0].split(":").length > 8 ? list[0].split(":")[8] : "";
      this.setState({
        time: time,
        id: id,
        meetId: list[0].split(":")[2],
        meetName: meetsName,
        channel_id: channel_id
      });
      return {
        from: from,
        meetId: list[0].split(":")[2],
        time: time,
        meetsName,
        id,
        channel_id
      };
    });

    this.state = {
      meetId: -1,
      //会议zoomid
      meetName: "",
      channel_id: "",
      time: "",
      id: -1 //最福利会议id

    };
  }

  render() {
    const rlist = this.isMeet(this.props.post.message);
    const userName = rlist.from != undefined ? rlist.from.split("@").join("") : "";
    return react_default.a.createElement("div", {
      className: "meeting-class"
    }, react_default.a.createElement("img", {
      src: share_png_2x_default.a,
      width: "40px",
      height: "40px"
    }), react_default.a.createElement("div", {
      className: "meeting-class-top-left"
    }, react_default.a.createElement("p", {
      className: "meeting-class-top-left-p"
    }, userName, " \u9080\u8BF7\u4F60\u52A0\u5165 ", rlist.meetsName, " \u89C6\u9891\u4F1A\u8BAE")), react_default.a.createElement("div", {
      className: "meeting-class-down"
    }, react_default.a.createElement("div", null, rlist.time == 0 ? '没有标注时间' : rlist.time), react_default.a.createElement(es_button["a" /* default */], {
      id: "submitButton",
      type: "primary",
      onClick: this.goMeet
    }, "\u70B9\u51FB\u52A0\u5165")));
  }

}

_defineProperty(meeting_MeetingView, "propTypes", {
  actions: PropTypes.shape({
    meetAddAction: PropTypes.func.isRequired
  }).isRequired
});
// EXTERNAL MODULE: ./actions/views/meeting.js
var views_meeting = __webpack_require__(182);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// CONCATENATED MODULE: ./components/ao_post_cards/meeting_json/index.js






function meeting_json_mapStateToProps(state) {
  return {
    currentUser: Object(users["getCurrentUser"])(state)
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      meetAddAction: views_meeting["g" /* meetAddAction */]
    }, dispatch)
  };
}

/* harmony default export */ var meeting_json = (Object(es["connect"])(meeting_json_mapStateToProps, mapDispatchToProps)(meeting_MeetingView));
// EXTERNAL MODULE: ./components/ao_post_cards/seraph_tracing/index.scss
var seraph_tracing = __webpack_require__(2474);

// CONCATENATED MODULE: ./components/ao_post_cards/seraph_tracing/index.js



/* harmony default export */ var ao_post_cards_seraph_tracing = (withParse(({
  post,
  _value
}) => {
  const {
    id,
    time,
    link,
    serviceName,
    cost,
    span,
    appName
  } = _value;
  return react_default.a.createElement("div", {
    className: "trace",
    onClick: () => window.open(link, "_blank")
  }, react_default.a.createElement("div", {
    className: "top"
  }, react_default.a.createElement("div", {
    className: "left"
  }, "ID ", id), react_default.a.createElement("div", {
    className: "right warn"
  }, appName)), react_default.a.createElement("div", {
    className: "middle"
  }, react_default.a.createElement("div", {
    className: "name"
  }, serviceName), react_default.a.createElement("div", {
    className: "cost"
  }, cost)), react_default.a.createElement("div", {
    className: "bottom"
  }, react_default.a.createElement("span", {
    className: "span"
  }, span), react_default.a.createElement("span", {
    className: "time"
  }, time)));
}));
// EXTERNAL MODULE: ./selectors/emojis.js + 1 modules
var emojis = __webpack_require__(119);

// EXTERNAL MODULE: ./node_modules/antd/es/icon/index.js + 3 modules
var es_icon = __webpack_require__(93);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./components/ao_post_cards/merge_message/message_modal/index.js + 2 modules
var message_modal = __webpack_require__(2263);

// EXTERNAL MODULE: ./components/ao_post_cards/merge_message/index.scss
var merge_message = __webpack_require__(2475);

// CONCATENATED MODULE: ./components/ao_post_cards/merge_message/MergeMessage.jsx







/* harmony default export */ var MergeMessage = (withParse(props => {
  const {
    post,
    emojiMap,
    _value,
    type = 'im'
  } = props;
  const modalRef = Object(react["useRef"])(null);
  let cardTitle = '';
  let cardData = [];

  if (type === 'im') {
    const hasData = Array.isArray(_value.data) && _value.data.length > 0;

    if (!hasData) {
      return null;
    }

    cardTitle = _value.title;
    cardData = _value.data;
  }

  if (type === 'collect') {
    cardTitle = post.title;
    cardData = _value;
  }

  const handleMore = () => {
    if (modalRef.current) {
      modalRef.current.wrappedInstance.show();
    }
  };

  return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("div", {
    onClick: handleMore,
    className: "merge__post"
  }, react_default.a.createElement("h4", null, cardTitle), react_default.a.createElement("div", {
    className: "merge__post__body"
  }, cardData.slice(0, 3).map(item => {
    const formatPost = Object(utils["r" /* formatMessage */])(item, emojiMap);
    return react_default.a.createElement("div", {
      key: item.post_id
    }, react_default.a.createElement("div", {
      className: "merge__post__item"
    }, react_default.a.createElement("label", null, item.user_name), react_default.a.createElement("span", null, formatPost)));
  })), cardData.length > 3 && react_default.a.createElement("p", {
    className: "view-more"
  }, "\u66F4\u591A\u804A\u5929\u8BB0\u5F55", react_default.a.createElement(es_icon["a" /* default */], {
    type: "right"
  }))), react_default.a.createElement(message_modal["a" /* default */], {
    ref: modalRef,
    title: cardTitle,
    post: post,
    value: cardData,
    type: type
  }));
}));
// CONCATENATED MODULE: ./components/ao_post_cards/merge_message/index.js




function merge_message_mapStateToProps(state) {
  const emojiMap = Object(emojis["a" /* getEmojiMap */])(state);
  return {
    emojiMap
  };
}

/* harmony default export */ var ao_post_cards_merge_message = (Object(es["connect"])(merge_message_mapStateToProps)(MergeMessage));
// EXTERNAL MODULE: ./node_modules/moment-timezone/index.js
var moment_timezone = __webpack_require__(260);
var moment_timezone_default = /*#__PURE__*/__webpack_require__.n(moment_timezone);

// EXTERNAL MODULE: ./node_modules/uuid/v4.js
var v4 = __webpack_require__(1780);
var v4_default = /*#__PURE__*/__webpack_require__.n(v4);

// EXTERNAL MODULE: ./node_modules/antd/es/select/index.js
var es_select = __webpack_require__(2044);

// EXTERNAL MODULE: ./node_modules/@antv/g2/build/g2.js
var g2 = __webpack_require__(2043);
var g2_default = /*#__PURE__*/__webpack_require__.n(g2);

// CONCATENATED MODULE: ./components/ao_post_cards/monitor/charts/area_gradient/index.jsx







const formatData = (data = []) => {
  const options = [];
  const chartData = {};
  data.map((item, index) => {
    const color = Array.isArray(item.color) ? item.color : [54, 161, 255];
    options.push({
      label: item.title,
      value: item.type,
      unit: item.unit || '',
      color
    });
    return chartData[item.type] = item.data;
  });
  return [options, chartData];
};

const renderChart = (data, select, chart, isUpdate) => {
  chart.area().position('timestamp*value') // .tooltip('timestamp*value', (x, y) => {
  //   return {
  //     timestamp: moment(Number(x)).format('hh:mm'), value: `${y}${select.unit}`
  //   }
  // })
  .color(`l(100) 0:rgb(${select.color.join(',')}) 1:rgba(${select.color.join(',')}, 0.6)`);
  chart.line().position('timestamp*value').size(1);
  if (isUpdate) chart.changeData(data[select.value]);

  if (data.length === 0) {
    chart.guide().text({
      top: true,
      position: ['45%', '45%'],
      content: '暂无数据',
      style: {
        fill: '#999',
        fontSize: 14,
        fontWeight: 'bold'
      }
    });
  }

  if (isUpdate) {
    _chart.repaint();
  } else {
    chart.render();
  }
};

/* harmony default export */ var area_gradient = (withParse(props => {
  const _resData = props._value;
  console.log(props, '-------x--3333');
  const id = v4_default()();
  const [_chart, setChart] = Object(react["useState"])(null);
  const [options, chartData] = formatData(_resData.result || []);
  const [select, setSelect] = Object(react["useState"])(options.length > 0 && options[0]); // console.log(_resData, options, chartData, select, '-----dddd', 777777777777777)

  const handleChange = _val => {
    const val = JSON.parse(_val);

    _chart.clear();

    renderChart(chartData, val, _chart, true);
    setSelect(val);
  };

  Object(react["useEffect"])(() => {
    const _d = chartData[select.value];
    const len = _d.length;
    let chart = new g2_default.a.Chart({
      container: id,
      // forceFit: true,
      width: 380,
      height: 300,
      padding: [40, 30, 30, 'auto']
    });
    setChart(chart);
    chart.source(_d);
    chart.scale({
      value: {// min: 0,
        // max: 100,
        // tickCount: 6,
      },
      timestamp: {
        // range: [0, 24],
        // tickCount: _d.length,
        tickCount: len <= 5 ? len : 6
      }
    });
    chart.axis('timestamp', {
      label: {
        formatter(val) {
          return moment_timezone_default()(Number(val)).format('hh:mm');
        }

      }
    });
    chart.axis('value', {
      label: {
        formatter(val) {
          // return `${val}${select.unit}`;
          return val >= 1000 ? `${(val / 1000).toFixed(0)}K` : val;
        }

      }
    }); // chart.tooltip({
    //   showTitle: false,
    //   itemTpl: '<li>{timestamp}: {value}</li>'
    //   crosshairs: {
    //     type: 'line'
    //   }
    // });

    chart.tooltip(false);
    renderChart(_d, select, chart);
  }, []);
  return _resData.result && react_default.a.createElement("div", {
    className: "mode-chart-container"
  }, react_default.a.createElement("div", {
    className: "title"
  }, react_default.a.createElement("div", {
    className: "name",
    title: _resData.title
  }, _resData.title), react_default.a.createElement("div", {
    className: "tag"
  }, _resData.appName)), options.length > 1 && react_default.a.createElement("div", {
    className: "options",
    title: select.label
  }, react_default.a.createElement(es_select["a" /* default */], {
    defaultValue: select.label,
    onChange: handleChange,
    suffixIcon: react_default.a.createElement(es_icon["a" /* default */], {
      style: {
        color: '#909090'
      },
      type: "caret-down"
    })
  }, options.map(item => react_default.a.createElement(es_select["a" /* default */].Option, {
    key: item.value,
    value: JSON.stringify(item)
  }, item.label)))), select.unit && react_default.a.createElement("div", {
    className: "unit"
  }, "\u5355\u4F4D", ' ', select.unit), _resData.link ? react_default.a.createElement("div", {
    id: id,
    className: "active",
    onClick: () => window.open(_resData.link, '_blank')
  }) : react_default.a.createElement("div", {
    id: id
  }));
}));
// CONCATENATED MODULE: ./components/ao_post_cards/monitor/charts/point_bubble/index.jsx






/* harmony default export */ var point_bubble = (withParse(props => {
  const _resData = props._value;
  const id = v4_default()();
  const [chartData, setData] = Object(react["useState"])(_resData.result[0] || []);
  Object(react["useEffect"])(() => {
    const len = chartData.data.length;

    const _color = (Array.isArray(chartData.color) ? chartData.color : [54, 161, 255]).join(',');

    const color = `rgb(${_color})`; // console.log(chartData)

    let chart = new g2_default.a.Chart({
      container: id,
      // forceFit: true,
      width: 380,
      height: 300,
      padding: [40, 30, 30, 60]
    });
    chart.source(chartData.data); // 为各个字段设置别名

    chart.scale({
      timestamp: {
        // alias: '时间',
        tickCount: len <= 6 ? len : 6
      },
      value: {//  alias: '响应时间',
        // tickCount: 6,
      }
    });
    chart.axis('timestamp', {
      label: {
        formatter(val) {
          // console.log((chartData.data.length % chartData.data.length/12))
          return moment_timezone_default()(Number(val)).format('hh:mm');
        }

      }
    });
    chart.axis('value', {
      label: {
        formatter(val) {
          // return `${val}${chartData.unit || ''}`;
          return val >= 1000 ? `${(val / 1000).toFixed(0)}K` : val;
        }

      }
    });
    chart.tooltip(false); // chart.tooltip({
    //   showTitle: false,
    //   itemTpl: '<li>{timestamp}: {value}</li>'
    // });

    chart.legend('Population', false);
    chart.point().position('timestamp*value').size('Population', [10, 65]).color('continent', val => color).shape('circle') // .tooltip('timestamp*value', (x, y) => {
    //   return {
    //     timestamp: moment(Number(x)).format('hh:mm'), value: `${y}${chartData.unit || ''}`
    //   }
    // })
    .style('continent', {
      lineWidth: 0,
      // strokeOpacity: 1,
      // fillOpacity: 0.3,
      // opacity: 0.65,
      stroke: function stroke(val) {
        return color;
      }
    });
    chart.render();
  }, []);
  return _resData.result && react_default.a.createElement("div", {
    className: "mode-chart-container"
  }, react_default.a.createElement("div", {
    className: "title"
  }, react_default.a.createElement("div", {
    className: "name",
    title: _resData.title
  }, _resData.title), react_default.a.createElement("div", {
    className: "tag"
  }, _resData.appName)), chartData.unit && react_default.a.createElement("div", {
    className: "unit"
  }, "\u5355\u4F4D", ' ', chartData.unit), _resData.link ? react_default.a.createElement("div", {
    id: id,
    className: "active",
    onClick: () => window.open(_resData.link, '_blank')
  }) : react_default.a.createElement("div", {
    id: id
  }));
}));
// EXTERNAL MODULE: ./components/ao_post_cards/monitor/charts/index.scss
var charts = __webpack_require__(2487);

// CONCATENATED MODULE: ./components/ao_post_cards/monitor/charts/index.jsx




 // export default ({ modeKey, modeData }) => {
//   switch (modeKey) {
//     case 'mode-chart-line':
//       return 'Chart-Line';
//     case 'mode-chart-area_gradient':
//       return <ChartAreaGradient data={modeData} id={uuid()} />;
//     case 'mode-chart-point_bubble':
//       return <ChartPointBubble data={modeData} id={uuid()} />;
//     default:
//       return '';
//   }
// }
// skyblue: [63, 202, 233]
// blue: [54, 161, 255]
// purple: [103, 78, 238]
// green: [23, 178, 93]
// yellow: [238, 173, 45]
// orange: [239, 116, 50]
// EXTERNAL MODULE: ./mattermost-redux/action_types/index.js
var action_types = __webpack_require__(8);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/antd/es/form/index.js + 10 modules
var es_form = __webpack_require__(3483);

// EXTERNAL MODULE: ./node_modules/antd/es/radio/index.js + 3 modules
var es_radio = __webpack_require__(3489);

// EXTERNAL MODULE: ./node_modules/antd/es/row/index.js
var row = __webpack_require__(2551);

// EXTERNAL MODULE: ./node_modules/antd/es/col/index.js
var col = __webpack_require__(2552);

// EXTERNAL MODULE: ./node_modules/antd/es/input/index.js + 7 modules
var input = __webpack_require__(3484);

// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(66);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ./utils/request.js
var request = __webpack_require__(25);

// CONCATENATED MODULE: ./api/cmd.js

const prefix = '/api/v4/'; // 提交（v1）
// 后端将数据转发到接入方时，将通用参数添加到body里

const execute = params => {
  return Object(request["a" /* default */])({
    url: `${prefix}commands/execute`,
    method: 'POST',
    data: params
  });
}; // 提交（v2）
// 后端将数据转发到接入方时，将通用参数放在header里

const execute2 = params => {
  return Object(request["a" /* default */])({
    url: `${prefix}commands/executeV2`,
    method: 'POST',
    data: params
  });
};
// EXTERNAL MODULE: ./components/ao_post_cards/scaffold/meta/index.scss
var meta = __webpack_require__(2488);

// CONCATENATED MODULE: ./components/ao_post_cards/scaffold/meta/meta.jsx






const PROJECTTYPE = {
  JAVA: 'java',
  JS: 'js'
};

const Comp = ({
  form,
  actions,
  team,
  channel,
  post,
  _value
}) => {
  const {
    getFieldDecorator
  } = form;
  const values = _value.values;
  const initialType = values ? values.projectType : PROJECTTYPE.JAVA;
  const [type, setType] = Object(react["useState"])(initialType);

  const submit = () => {
    form.validateFields((err, values) => {
      if (err) {
        return;
      }

      const values2submit = { ...values,
        projectId: _value.projectId
      };
      execute({
        channel_id: channel.id,
        command: `/scaffold_savebasic ${JSON.stringify(values2submit)}`,
        team_id: team.id
      }).then(res => {
        if (res.data) {
          const now = Date.now();
          actions.editPost({ ...post,
            edit_at: now,
            update_at: now,
            message: JSON.stringify({
              values: values2submit
            })
          });
        }
      });
    });
  };

  const reset = () => {
    form.resetFields();
  };

  const disabled = !!values;
  return react_default.a.createElement("div", {
    className: classnames_default()('scaffold-meta', {
      'scaffold-meta-disabled': disabled
    })
  }, react_default.a.createElement("h6", {
    className: "scaffold-meta-title"
  }, "\u8BF7\u586B\u5199Project Metadata"), react_default.a.createElement(es_form["a" /* default */], {
    layout: "vertical"
  }, react_default.a.createElement(es_form["a" /* default */].Item, {
    label: "\u9879\u76EE\u7C7B\u578B"
  }, getFieldDecorator('projectType', {
    initialValue: initialType,
    rules: [{
      required: true,
      message: '请先选择项目类型!'
    }]
  })(react_default.a.createElement(es_radio["a" /* default */].Group, {
    disabled: disabled,
    onChange: e => setType(e.target.value)
  }, react_default.a.createElement(es_radio["a" /* default */], {
    value: PROJECTTYPE.JAVA
  }, "java"), react_default.a.createElement(es_radio["a" /* default */], {
    value: PROJECTTYPE.JS
  }, "js")))), react_default.a.createElement(row["a" /* default */], {
    gutter: 20
  }, react_default.a.createElement(col["a" /* default */], {
    span: 12
  }, react_default.a.createElement(es_form["a" /* default */].Item, {
    label: "Project Name"
  }, getFieldDecorator('projectName', {
    initialValue: values ? values.projectName : '',
    rules: [{
      required: true,
      message: '请输入项目名称!'
    }]
  })(react_default.a.createElement(input["a" /* default */], {
    disabled: disabled,
    placeholder: "\u8BF7\u8F93\u5165\u9879\u76EE\u540D\u79F0"
  })))), react_default.a.createElement(col["a" /* default */], {
    span: 12
  }, react_default.a.createElement(es_form["a" /* default */].Item, {
    label: "Version"
  }, getFieldDecorator('version', {
    initialValue: values ? values.version : '',
    rules: [{
      required: true,
      message: '请输入版本号!'
    }]
  })(react_default.a.createElement(input["a" /* default */], {
    disabled: disabled,
    placeholder: "1.0.0"
  }))))), type === PROJECTTYPE.JAVA && react_default.a.createElement(react["Fragment"], null, react_default.a.createElement(row["a" /* default */], {
    gutter: 20
  }, react_default.a.createElement(col["a" /* default */], {
    span: 12
  }, react_default.a.createElement(es_form["a" /* default */].Item, {
    label: "Group"
  }, getFieldDecorator('groupId', {
    initialValue: values ? values.groupId : '',
    rules: [{
      required: true,
      message: '请输入Group!'
    }]
  })(react_default.a.createElement(input["a" /* default */], {
    disabled: disabled,
    placeholder: "com.zhongan.tac"
  })))), react_default.a.createElement(col["a" /* default */], {
    span: 12
  }, react_default.a.createElement(es_form["a" /* default */].Item, {
    label: "Artifact"
  }, getFieldDecorator('artifactId', {
    initialValue: values ? values.artifactId : '',
    rules: [{
      required: true,
      message: '请输入Artifact!'
    }]
  })(react_default.a.createElement(input["a" /* default */], {
    disabled: disabled,
    placeholder: "tac-cloud-order"
  }))))), react_default.a.createElement(row["a" /* default */], {
    gutter: 20
  }, react_default.a.createElement(col["a" /* default */], {
    span: 12
  }, react_default.a.createElement(es_form["a" /* default */].Item, {
    label: "Package Name"
  }, getFieldDecorator('packageName', {
    initialValue: values ? values.packageName : '',
    rules: [{
      required: true,
      message: '请输入Package Name!'
    }]
  })(react_default.a.createElement(input["a" /* default */], {
    disabled: disabled,
    placeholder: "com.zhongan.tac.cloud.order"
  })))))), react_default.a.createElement("div", {
    className: "scaffold-meta-actions"
  }, react_default.a.createElement("a", {
    className: "scaffold-meta-action",
    onClick: reset
  }, "\u91CD\u7F6E"), react_default.a.createElement("a", {
    className: "scaffold-meta-action",
    onClick: submit
  }, "\u4FDD\u5B58"))));
};

/* harmony default export */ var meta_meta = (withParse(es_form["a" /* default */].create()(Comp)));
// CONCATENATED MODULE: ./components/ao_post_cards/scaffold/meta/index.js






function meta_mapStateToProps(state) {
  const team = Object(teams["getCurrentTeam"])(state);
  return {
    team
  };
}

function meta_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      editPost: post => {
        return async (dispatch, getState) => {
          dispatch({
            type: action_types["PostTypes"].RECEIVED_POST,
            data: post
          });
        };
      }
    }, dispatch)
  };
}

/* harmony default export */ var scaffold_meta = (Object(es["connect"])(meta_mapStateToProps, meta_mapDispatchToProps)(meta_meta));
// EXTERNAL MODULE: ./node_modules/lodash/chunk.js
var chunk = __webpack_require__(2553);
var chunk_default = /*#__PURE__*/__webpack_require__.n(chunk);

// EXTERNAL MODULE: ./components/ao_post_cards/scaffold/dependency/index.scss
var dependency = __webpack_require__(2555);

// CONCATENATED MODULE: ./components/ao_post_cards/scaffold/dependency/dependency.jsx







const _radioStyle = {
  display: 'block',
  height: '30px',
  lineHeight: '30px'
};
const _colCount = 3;
const _emptyText = '不使用';

const dependency_Comp = ({
  form,
  actions,
  team,
  channel,
  post,
  _value
}) => {
  const {
    getFieldDecorator
  } = form;
  const [processing, setProcessing] = Object(react["useState"])(false);
  const {
    url,
    values
  } = _value;

  const create = () => {
    form.validateFields((err, values) => {
      if (err) {
        return;
      } // 不要重复提交


      if (processing) {
        return;
      }

      setProcessing(true);
      console.log('Received values of form: ', values);
      const values2use = Object.keys(values).reduce((acc, cur) => {
        const v = values[cur];
        return { ...acc,
          [cur]: v === _emptyText ? '' : v
        };
      }, {});
      const data = {
        projectId: _value.projectId,
        scaffoldComponentBasicDTO: Object.keys(values2use).map(key => {
          return {
            componentName: key,
            componentValue: values2use[key]
          };
        })
      };
      console.log('values2use:', values2use, ', data:', data);
      execute({
        channel_id: channel.id,
        command: `/scaffold_savecomponent ${JSON.stringify(data)}`,
        team_id: team.id
      }).then(res => {
        setProcessing(false);

        if (res.data) {
          const now = Date.now();

          const url = (() => {
            // test
            // return 'http://cflp-cx.oss-cn-beijing.aliyuncs.com/2019-09-19_228_1568904998702.zip';
            const obj = JSON.parse(res.data.text);
            return obj.success ? obj.data : '';
          })();

          actions.editPost({ ...post,
            edit_at: now,
            update_at: now,
            message: JSON.stringify({ ..._value,
              values: values2use,
              url
            })
          });
        }
      });
    });
  };

  const disabled = !!values;
  const list = _value.form || [];
  return react_default.a.createElement("div", {
    className: classnames_default()('scaffold-dependency', {
      'scaffold-dependency-disabled': disabled
    })
  }, react_default.a.createElement("h6", {
    className: "scaffold-dependency-title"
  }, "\u8BF7\u9009\u62E9Dependencies\uFF0C\u4EE5\u4FBF\u5E2E\u4F60\u751F\u6210\u6587\u4EF6"), react_default.a.createElement(es_form["a" /* default */], {
    layout: "vertical"
  }, chunk_default()(list, _colCount).map((items, idx) => {
    return react_default.a.createElement(row["a" /* default */], {
      key: idx,
      gutter: 10
    }, items.map(({
      key,
      title,
      options,
      required
    }) => {
      const options2use = required ? [_emptyText, ...options] : options;

      const initialValue = (() => {
        const value = values ? values[key] : options2use[0];

        if (required) {
          return value || _emptyText;
        } else {
          return value;
        }
      })();

      return react_default.a.createElement(col["a" /* default */], {
        key: title,
        span: 24 / _colCount
      }, react_default.a.createElement(es_form["a" /* default */].Item, {
        label: title
      }, getFieldDecorator(key, {
        initialValue,
        rules: [{
          required: required,
          message: `请先选择`
        }]
      })(react_default.a.createElement(es_radio["a" /* default */].Group, {
        disabled: disabled
      }, options2use.map(opt => react_default.a.createElement(es_radio["a" /* default */], {
        key: opt,
        style: _radioStyle,
        value: opt
      }, opt))))));
    }));
  })), react_default.a.createElement("div", {
    className: "scaffold-dependency-actions"
  }, (() => {
    if (url) {
      return react_default.a.createElement("a", {
        className: "scaffold-dependency-action",
        href: url
      }, "\u4E0B\u8F7D\u5230\u672C\u5730");
    }

    if (processing) {
      return react_default.a.createElement("a", {
        className: "scaffold-dependency-action"
      }, "\u9879\u76EE\u751F\u6210\u4E2D...");
    } else {
      return react_default.a.createElement("a", {
        className: "scaffold-dependency-action",
        onClick: create
      }, "\u751F\u6210\u9879\u76EE");
    }
  })()));
};

/* harmony default export */ var dependency_dependency = (withParse(es_form["a" /* default */].create()(dependency_Comp)));
// CONCATENATED MODULE: ./components/ao_post_cards/scaffold/dependency/index.js






function dependency_mapStateToProps(state) {
  const team = Object(teams["getCurrentTeam"])(state);
  return {
    team
  };
}

function dependency_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      editPost: post => {
        return async (dispatch, getState) => {
          dispatch({
            type: action_types["PostTypes"].RECEIVED_POST,
            data: post
          });
        };
      }
    }, dispatch)
  };
}

/* harmony default export */ var scaffold_dependency = (Object(es["connect"])(dependency_mapStateToProps, dependency_mapDispatchToProps)(dependency_dependency));
// CONCATENATED MODULE: ./components/ao_post_cards/scaffold/index.js



// EXTERNAL MODULE: ./actions/views/posts.js
var posts = __webpack_require__(1618);

// EXTERNAL MODULE: ./node_modules/antd/es/message/index.js
var message = __webpack_require__(3478);

// EXTERNAL MODULE: ./components/ao_field_info/index.js
var ao_field_info = __webpack_require__(1677);

// EXTERNAL MODULE: ./components/ao_post_cards/_base/action_container/index.scss
var action_container = __webpack_require__(2557);

// CONCATENATED MODULE: ./components/ao_post_cards/_base/action_container/index.js


/* harmony default export */ var _base_action_container = (({
  width,
  children,
  actions
}) => {
  return react_default.a.createElement("div", {
    className: "ao-action-container",
    style: {
      width: width || '100%'
    }
  }, react_default.a.createElement("div", {
    className: "ao-action-container-body"
  }, children), react_default.a.createElement("div", {
    className: "ao-action-container-actions"
  }, actions.map((action, idx) => {
    return react_default.a.createElement("a", {
      key: idx,
      className: "ao-action-container-action"
    }, action);
  })));
});
// CONCATENATED MODULE: ./components/ao_post_cards/create_app/_base/status/index.js

/* harmony default export */ var _base_status = (({
  value
}) => {
  const style = {
    '待审批': {
      background: '#26B0FF'
    },
    '通过': {
      background: '#00BC70'
    },
    '驳回': {
      background: '#FF5050'
    }
  }[value] || {};
  style.lineHeight = '24px';
  style.textAlign = 'center';
  style.width = '64px';
  style.color = '#FFFFFF';
  style.borderRadius = '12px';
  return react_default.a.createElement("div", {
    style: style
  }, value);
});
// EXTERNAL MODULE: ./components/ao_post_cards/create_app/_base/status_card/index.scss
var status_card = __webpack_require__(2558);

// CONCATENATED MODULE: ./components/ao_post_cards/create_app/_base/status_card/index.js


/* harmony default export */ var _base_status_card = (({
  width,
  status,
  children
}) => {
  return react_default.a.createElement("div", {
    className: "ao-status-card",
    style: {
      width: width || '100%'
    }
  }, react_default.a.createElement("div", {
    className: "ao-status-card-status"
  }, status), children);
});
// EXTERNAL MODULE: ./components/ao_post_cards/create_app/approve/index.scss
var approve = __webpack_require__(2559);

// CONCATENATED MODULE: ./components/ao_post_cards/create_app/approve/approve.jsx
function approve_extends() { approve_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return approve_extends.apply(this, arguments); }











const FieldInfo = props => react_default.a.createElement(ao_field_info["a" /* default */], approve_extends({
  labelWidth: 60
}, props));

const APPROVECMD = {
  COMPLETE: 'workorder_task_complete',
  REJECT: 'workorder_task_reject'
};
/* harmony default export */ var approve_approve = (withParse(({
  actions,
  channel,
  team,
  currentUser,
  post,
  _value
}) => {
  const processingRef = Object(react["useRef"])(false);

  const handle = cmdName => {
    if (processingRef.current) {
      return;
    }

    processingRef.current = true;
    const data2submit = {
      businessData: _value.businessData,
      channel_id: channel.id,
      channel_name: channel.name,
      team_id: team.id,
      user_id: currentUser.id,
      user_name: currentUser.username
    };
    execute2({
      channel_id: channel.id,
      command: `/${cmdName} ${JSON.stringify(data2submit)}`,
      team_id: team.id
    }).then(res => {
      if (res.data) {
        const obj = JSON.parse(res.data.text);

        if (obj.code !== 0) {
          processingRef.current = false;
          message["a" /* default */].error('审批失败。原因：' + obj.message);
          return;
        }

        const info = (() => {
          if (obj.result.status === '0') {
            // 之前未被审批
            return {
              approverName: currentUser.username,
              result: {
                [APPROVECMD.COMPLETE]: '通过',
                [APPROVECMD.REJECT]: '驳回'
              }[cmdName]
            };
          } else {
            // 之前已经被审批
            return {
              approverName: obj.result.user,
              result: obj.result.success ? '通过' : '驳回'
            };
          }
        })(); // message.success('审批成功！');
        // 修改消息


        const now = Date.now();
        actions.editPost({ ...post,
          edit_at: now,
          update_at: now,
          card_type: '10-2',
          message: JSON.stringify({
            projectName: _value.projectName,
            applicationName: _value.applicationName,
            applicantName: _value.applicantName,
            applyTime: _value.applyTime,
            step: _value.step,
            ...info
          })
        });
      } else {
        processingRef.current = false;
        message["a" /* default */].error('审批失败。请稍后重试。');
      }
    }, () => {
      processingRef.current = false;
      message["a" /* default */].error('审批失败。请稍后重试。');
    });
  };

  const acts = [react_default.a.createElement("div", {
    className: "ao-approve-refuse",
    onClick: () => {
      handle(APPROVECMD.REJECT);
    }
  }, "\u9A73\u56DE"), react_default.a.createElement("div", {
    onClick: () => {
      handle(APPROVECMD.COMPLETE);
    }
  }, "\u901A\u8FC7")];
  return react_default.a.createElement(_base_action_container, {
    actions: acts,
    width: '350px'
  }, react_default.a.createElement(_base_status_card, {
    status: react_default.a.createElement(_base_status, {
      value: '待审批'
    })
  }, react_default.a.createElement(FieldInfo, {
    label: "\u9879\u76EE",
    value: _value['projectName'] || '无'
  }), react_default.a.createElement(FieldInfo, {
    label: "\u5E94\u7528",
    value: _value['applicationName'] || '无'
  }), react_default.a.createElement(FieldInfo, {
    label: "\u7533\u8BF7\u65F6\u95F4",
    value: _value['applyTime'] || '无'
  }), react_default.a.createElement(FieldInfo, {
    label: "\u7533\u8BF7\u4EBA",
    value: _value['applicantName'] || '无'
  }), react_default.a.createElement(FieldInfo, {
    label: "\u9636\u6BB5",
    value: _value['step'] || '无'
  })));
}));
// CONCATENATED MODULE: ./components/ao_post_cards/create_app/approve/index.js








function approve_mapStateToProps(state) {
  return {
    currentUser: Object(users["getCurrentUser"])(state),
    team: Object(teams["getCurrentTeam"])(state)
  };
}

function approve_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      editPost: posts["a" /* editPost */]
    }, dispatch)
  };
}

/* harmony default export */ var create_app_approve = (Object(es["connect"])(approve_mapStateToProps, approve_mapDispatchToProps)(approve_approve));
// CONCATENATED MODULE: ./components/ao_post_cards/create_app/step_result_for_approver/index.js
function step_result_for_approver_extends() { step_result_for_approver_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return step_result_for_approver_extends.apply(this, arguments); }







const step_result_for_approver_FieldInfo = props => react_default.a.createElement(ao_field_info["a" /* default */], step_result_for_approver_extends({
  labelWidth: 60
}, props));

/* harmony default export */ var step_result_for_approver = (withParse(({
  post,
  _value
}) => {
  return react_default.a.createElement(_base_status_card, {
    status: react_default.a.createElement(_base_status, {
      value: _value['result']
    }),
    width: '350px'
  }, react_default.a.createElement(step_result_for_approver_FieldInfo, {
    label: "\u9879\u76EE",
    value: _value['projectName'] || '无'
  }), react_default.a.createElement(step_result_for_approver_FieldInfo, {
    label: "\u5E94\u7528",
    value: _value['applicationName'] || '无'
  }), react_default.a.createElement(step_result_for_approver_FieldInfo, {
    label: "\u7533\u8BF7\u4EBA",
    value: _value['applicantName'] || '无'
  }), react_default.a.createElement(step_result_for_approver_FieldInfo, {
    label: "\u7533\u8BF7\u65F6\u95F4",
    value: _value['applyTime'] || '无'
  }), react_default.a.createElement(step_result_for_approver_FieldInfo, {
    label: "\u5BA1\u6279\u4EBA",
    value: _value['approverName'] || '无'
  }), react_default.a.createElement(step_result_for_approver_FieldInfo, {
    label: "\u9636\u6BB5",
    value: _value['step'] || '无'
  }));
}));
// CONCATENATED MODULE: ./components/ao_post_cards/create_app/step_result_for_applicant/index.js
function step_result_for_applicant_extends() { step_result_for_applicant_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return step_result_for_applicant_extends.apply(this, arguments); }







const step_result_for_applicant_FieldInfo = props => react_default.a.createElement(ao_field_info["a" /* default */], step_result_for_applicant_extends({
  labelWidth: 60
}, props));

/* harmony default export */ var step_result_for_applicant = (withParse(({
  post,
  _value
}) => {
  return react_default.a.createElement(_base_status_card, {
    status: react_default.a.createElement(_base_status, {
      value: _value['result']
    }),
    width: '350px'
  }, react_default.a.createElement(step_result_for_applicant_FieldInfo, {
    label: "\u9879\u76EE",
    value: _value['projectName'] || '无'
  }), react_default.a.createElement(step_result_for_applicant_FieldInfo, {
    label: "\u5E94\u7528",
    value: _value['applicationName'] || '无'
  }), react_default.a.createElement(step_result_for_applicant_FieldInfo, {
    label: "\u7533\u8BF7\u65F6\u95F4",
    value: _value['applyTime'] || '无'
  }), react_default.a.createElement(step_result_for_applicant_FieldInfo, {
    label: "\u5BA1\u6279\u4EBA",
    value: _value['approverName'] || '无'
  }), react_default.a.createElement(step_result_for_applicant_FieldInfo, {
    label: "\u9636\u6BB5",
    value: _value['step'] || '无'
  }));
}));
// EXTERNAL MODULE: ./components/ao_post_cards/create_app/create_app_created/index.scss
var create_app_created = __webpack_require__(2560);

// CONCATENATED MODULE: ./components/ao_post_cards/create_app/create_app_created/create_app_created.jsx
function create_app_created_extends() { create_app_created_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return create_app_created_extends.apply(this, arguments); }











const create_app_created_FieldInfo = props => react_default.a.createElement(ao_field_info["a" /* default */], create_app_created_extends({
  labelWidth: 60
}, props));

/* harmony default export */ var create_app_created_create_app_created = (withParse(({
  team,
  channel,
  post,
  _value
}) => {
  const processingRef = Object(react["useRef"])(false);
  const [success, setSuccess] = Object(react["useState"])(false);

  const btn = (() => {
    if (success) {
      return react_default.a.createElement("div", {
        className: "ao-create-app-deploy-completed"
      }, "\u5FEB\u901F\u90E8\u7F72");
    }

    return react_default.a.createElement("div", {
      onClick: () => {
        if (processingRef.current) {
          return;
        }

        processingRef.current = true;
        execute2({
          channel_id: channel.id,
          command: `/create_publication ${JSON.stringify({
            uuid: _value.id
          })}`,
          team_id: team.id
        }).then(res => {
          if (res.data) {
            const obj = JSON.parse(res.data.text);

            if (obj.code === 0) {
              message["a" /* default */].success('快速部署提交成功！');
              setSuccess(true);
            } else {
              processingRef.current = false;
              message["a" /* default */].error('快速部署失败。原因:' + obj.message);
            }
          } else {
            processingRef.current = false;
            message["a" /* default */].error('快速部署失败。请稍后重试。');
          }
        }, () => {
          processingRef.current = false;
          message["a" /* default */].error('快速部署失败。请稍后重试。');
        });
      }
    }, "\u5FEB\u901F\u90E8\u7F72");
  })();

  const acts = [react_default.a.createElement("div", {
    onClick: () => {
      window.open(_value.orderUrl);
    }
  }, "\u67E5\u770B\u5DE5\u5355"), btn];
  return react_default.a.createElement(_base_action_container, {
    actions: acts,
    width: '350px'
  }, react_default.a.createElement("div", {
    className: "ao-create-app-created-desc"
  }, _value.desc));
}));
// CONCATENATED MODULE: ./components/ao_post_cards/create_app/create_app_created/index.js






function create_app_created_mapStateToProps(state) {
  const team = Object(teams["getCurrentTeam"])(state);
  return {
    team
  };
}

function create_app_created_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({}, dispatch)
  };
}

/* harmony default export */ var create_app_create_app_created = (Object(es["connect"])(create_app_created_mapStateToProps, create_app_created_mapDispatchToProps)(create_app_created_create_app_created));
// EXTERNAL MODULE: ./components/ao_post_cards/create_app/_base/title_container/index.scss
var title_container = __webpack_require__(2561);

// CONCATENATED MODULE: ./components/ao_post_cards/create_app/_base/title_container/index.js


/* harmony default export */ var _base_title_container = (({
  title,
  children
}) => {
  return react_default.a.createElement("div", null, react_default.a.createElement("div", {
    className: "ao-title-container"
  }, title), children);
});
// CONCATENATED MODULE: ./components/ao_post_cards/create_app/deploy_success/index.js
function deploy_success_extends() { deploy_success_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return deploy_success_extends.apply(this, arguments); }







const deploy_success_FieldInfo = props => react_default.a.createElement(ao_field_info["a" /* default */], deploy_success_extends({
  labelWidth: 60
}, props));

/* harmony default export */ var deploy_success = (withParse(({
  post,
  _value
}) => {
  const actions = [react_default.a.createElement("div", {
    onClick: () => {
      window.open(_value.orderUrl);
    }
  }, "\u67E5\u770B\u53D1\u5E03"), react_default.a.createElement("div", {
    onClick: () => {
      window.open(_value.demoUrl);
    }
  }, "\u67E5\u770BDEMO")];
  return react_default.a.createElement(_base_action_container, {
    actions: actions,
    width: '350px'
  }, react_default.a.createElement(_base_title_container, {
    title: "\u811A\u624B\u67B6\u5FEB\u901F\u90E8\u7F72\u5B8C\u6210"
  }, react_default.a.createElement(deploy_success_FieldInfo, {
    label: "\u9879\u76EE",
    value: _value['projectName'] || '无'
  }), react_default.a.createElement(deploy_success_FieldInfo, {
    label: "\u5E94\u7528",
    value: _value['applicationName'] || '无'
  }), react_default.a.createElement(deploy_success_FieldInfo, {
    label: "owner",
    value: _value['owner'] || '无'
  })));
}));
// CONCATENATED MODULE: ./components/ao_post_cards/create_app/deploy_fail/deploy_fail.jsx
function deploy_fail_extends() { deploy_fail_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return deploy_fail_extends.apply(this, arguments); }









const deploy_fail_FieldInfo = props => react_default.a.createElement(ao_field_info["a" /* default */], deploy_fail_extends({
  labelWidth: 60
}, props));

/* harmony default export */ var deploy_fail = (withParse(({
  channel,
  team,
  post,
  _value
}) => {
  const processingRef = Object(react["useRef"])(false);
  const acts = [react_default.a.createElement("div", {
    onClick: () => {
      window.open(_value.orderUrl);
    }
  }, "\u67E5\u770B\u53D1\u5E03"), react_default.a.createElement("div", {
    onClick: () => {
      if (processingRef.current) {
        return;
      }

      processingRef.current = true;
      execute2({
        channel_id: channel.id,
        command: `/create_publication ${JSON.stringify({
          uuid: _value.id
        })}`,
        team_id: team.id
      }).then(res => {
        if (res.data) {
          const obj = JSON.parse(res.data.text);

          if (obj.code === 0) {
            message["a" /* default */].success('再次部署提交成功！');
          } else {
            processingRef.current = false;
            message["a" /* default */].error('再次部署失败。原因:' + obj.message);
          }
        } else {
          processingRef.current = false;
          message["a" /* default */].error('再次部署失败。请稍后重试。');
        }
      }, () => {
        processingRef.current = false;
        message["a" /* default */].error('再次部署失败。请稍后重试。');
      });
    }
  }, "\u518D\u6B21\u90E8\u7F72")];
  return react_default.a.createElement(_base_action_container, {
    actions: acts,
    width: '350px'
  }, react_default.a.createElement(_base_title_container, {
    title: "\u811A\u624B\u67B6\u5FEB\u901F\u90E8\u7F72\u5931\u8D25"
  }, react_default.a.createElement(deploy_fail_FieldInfo, {
    label: "\u9879\u76EE",
    value: _value['projectName'] || '无'
  }), react_default.a.createElement(deploy_fail_FieldInfo, {
    label: "\u5E94\u7528",
    value: _value['applicationName'] || '无'
  }), react_default.a.createElement(deploy_fail_FieldInfo, {
    label: "\u5931\u8D25\u539F\u56E0",
    value: _value['reason'] || '无'
  })));
}));
// CONCATENATED MODULE: ./components/ao_post_cards/create_app/deploy_fail/index.js






function deploy_fail_mapStateToProps(state) {
  const team = Object(teams["getCurrentTeam"])(state);
  return {
    team
  };
}

function deploy_fail_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({}, dispatch)
  };
}

/* harmony default export */ var create_app_deploy_fail = (Object(es["connect"])(deploy_fail_mapStateToProps, deploy_fail_mapDispatchToProps)(deploy_fail));
// CONCATENATED MODULE: ./components/ao_post_cards/create_app/index.js







// CONCATENATED MODULE: ./components/ao_post_cards/index.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createCard; });
/* unused concated harmony import ShipProcess */
/* unused concated harmony import PubCreate */
/* unused concated harmony import Table */
/* unused concated harmony import Warning */
/* unused concated harmony import Meeting */
/* unused concated harmony import SeraphTracing */
/* unused concated harmony import MonitorAreaGradient */
/* unused concated harmony import MonitorPointBubble */
/* unused concated harmony import Meeting_json */
/* unused concated harmony import ScaffoldMeta */
/* unused concated harmony import ScaffoldDependency */
/* unused concated harmony import CreateAppApprove */
/* unused concated harmony import CreateAppStepResultForApprover */
/* unused concated harmony import CreateAppStepResultForApplicant */
/* unused concated harmony import CreateAppCreated */
/* unused concated harmony import CreateAppDeploySuccess */
/* unused concated harmony import CreateAppDeployFail */
/* unused concated harmony import MergeMessage */











 // 配置card_type和卡片组件的对应关系

const createCard = post => {
  if (Object(utils["X" /* isMeet */])(post.message)) {
    return meeting_json;
  }

  return {
    '1': ao_post_cards_ship_process,
    '2': ao_post_cards_pubcreate,
    '3': ao_post_cards_table,
    '4': ao_post_cards_warning,
    '5': ao_post_cards_meeting,
    '6': ao_post_cards_seraph_tracing,
    '7': area_gradient,
    '8': point_bubble,
    '9-1': scaffold_meta,
    '9-2': scaffold_dependency,
    '10-1': create_app_approve,
    '10-2': step_result_for_approver,
    '10-3': step_result_for_applicant,
    '10-4': create_app_create_app_created,
    '10-5': deploy_success,
    '10-6': create_app_deploy_fail,
    '11-1': ao_post_cards_merge_message
  }[post.card_type];
};



/***/ }),

/***/ 1823:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./client/websocket_client.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
const MAX_WEBSOCKET_FAILS = 7;
const MIN_WEBSOCKET_RETRY_TIME = 3000; // 3 sec

const MAX_WEBSOCKET_RETRY_TIME = 300000; // 5 mins

class WebSocketClient {
  constructor() {
    this.conn = null;
    this.connectionUrl = null;
    this.sequence = 1;
    this.eventSequence = 0;
    this.connectFailCount = 0;
    this.eventCallback = null;
    this.responseCallbacks = {};
    this.firstConnectCallback = null;
    this.reconnectCallback = null;
    this.missedEventCallback = null;
    this.errorCallback = null;
    this.closeCallback = null;
  }

  initialize(connectionUrl = this.connectionUrl, token) {
    if (this.conn) {
      return;
    }

    if (connectionUrl != null) localStorage.setItem('connectionUrl', connectionUrl);
    this.connectionUrl = connectionUrl == null ? localStorage.getItem('connectionUrl') : connectionUrl;

    if (this.connectionUrl == null) {
      console.log('websocket must have connection url'); //eslint-disable-line no-console

      return;
    }

    if (this.connectFailCount === 0) {
      console.log('websocket connecting to ' + connectionUrl); //eslint-disable-line no-console
    }

    this.conn = new WebSocket(this.connectionUrl);

    this.conn.onopen = () => {
      this.eventSequence = 0;

      if (token) {
        this.sendMessage('authentication_challenge', {
          token
        });
      }

      if (this.connectFailCount > 0) {
        console.log('websocket re-established connection'); //eslint-disable-line no-console

        if (this.reconnectCallback) {
          this.reconnectCallback();
        }
      } else if (this.firstConnectCallback) {
        this.firstConnectCallback();
      }

      this.connectFailCount = 0;
    };

    this.conn.onclose = e => {
      this.conn = null;
      this.sequence = 1;

      if (this.connectFailCount === 0) {
        console.log('websocket closed0----', e); //eslint-disable-line no-console
      }

      this.connectFailCount++;

      if (this.closeCallback) {
        this.closeCallback(this.connectFailCount);
      }

      let retryTime = MIN_WEBSOCKET_RETRY_TIME; // If we've failed a bunch of connections then start backing off

      if (this.connectFailCount > MAX_WEBSOCKET_FAILS) {
        retryTime = MIN_WEBSOCKET_RETRY_TIME * this.connectFailCount * this.connectFailCount;

        if (retryTime > MAX_WEBSOCKET_RETRY_TIME) {
          retryTime = MAX_WEBSOCKET_RETRY_TIME;
        }
      }

      setTimeout(() => {
        this.initialize(connectionUrl, token);
      }, retryTime);
    };

    this.conn.onerror = evt => {
      if (this.connectFailCount <= 1) {
        console.log('websocket error'); //eslint-disable-line no-console

        console.log(evt); //eslint-disable-line no-console
      }

      if (this.errorCallback) {
        this.errorCallback(evt);
      }
    };

    this.conn.onmessage = evt => {
      const msg = JSON.parse(evt.data);

      if (msg.seq_reply) {
        if (msg.error) {
          console.log(msg); //eslint-disable-line no-console
        }

        if (this.responseCallbacks[msg.seq_reply]) {
          this.responseCallbacks[msg.seq_reply](msg);
          Reflect.deleteProperty(this.responseCallbacks, msg.seq_reply);
        }
      } else if (this.eventCallback) {
        if (msg.seq !== this.eventSequence && this.missedEventCallback) {
          console.log('missed websocket event, act_seq=' + msg.seq + ' exp_seq=' + this.eventSequence); //eslint-disable-line no-console

          this.missedEventCallback();
        }

        this.eventSequence = msg.seq + 1;
        this.eventCallback(msg);
      }
    };
  }

  setEventCallback(callback) {
    this.eventCallback = callback;
  }

  setFirstConnectCallback(callback) {
    this.firstConnectCallback = callback;
  }

  setReconnectCallback(callback) {
    this.reconnectCallback = callback;
  }

  setMissedEventCallback(callback) {
    this.missedEventCallback = callback;
  }

  setErrorCallback(callback) {
    this.errorCallback = callback;
  }

  setCloseCallback(callback) {
    this.closeCallback = callback;
  }

  close() {
    this.connectFailCount = 0;
    this.sequence = 1;

    if (this.conn && this.conn.readyState === WebSocket.OPEN) {
      this.conn.onclose = () => {}; //eslint-disable-line no-empty-function


      this.conn.close();
      this.conn = null;
      console.log('websocket closed'); //eslint-disable-line no-console
    }
  }

  sendMessage(action, data, responseCallback) {
    const msg = {
      action,
      seq: this.sequence++,
      data
    };

    if (responseCallback) {
      this.responseCallbacks[msg.seq] = responseCallback;
    }

    if (this.conn && this.conn.readyState === WebSocket.OPEN) {
      this.conn.send(JSON.stringify(msg));
    } else if (!this.conn || this.conn.readyState === WebSocket.CLOSED) {
      this.conn = null;
      this.initialize();
    }
  }

  userTyping(channelId, parentId, callback) {
    const data = {};
    data.channel_id = channelId;
    data.parent_id = parentId;
    this.sendMessage('user_typing', data, callback);
  }

  userUpdateActiveStatus(userIsActive, manual, callback) {
    const data = {
      user_is_active: userIsActive,
      manual
    };
    this.sendMessage('user_update_active_status', data, callback);
  }

  getStatuses(callback) {
    this.sendMessage('get_statuses', null, callback);
  }

  getStatusesByIds(userIds, callback) {
    const data = {};
    data.user_ids = userIds;
    this.sendMessage('get_statuses_by_ids', data, callback);
  } //心跳 meeting_id


  videoHeartAction(meeting_id, callback) {
    const data = {
      meeting_id
    };
    this.sendMessage('meeting_heartbeat', data, callback);
  }

}
// CONCATENATED MODULE: ./client/web_websocket_client.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

var WebClient = new WebSocketClient();
/* harmony default export */ var web_websocket_client = __webpack_exports__["a"] = (WebClient);

/***/ }),

/***/ 1824:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./actions/views/modals.js
var modals = __webpack_require__(1578);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// CONCATENATED MODULE: ./components/toggle_modal_button_redux/toggle_modal_button_redux.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class toggle_modal_button_redux_ModalToggleButtonRedux extends react_default.a.Component {
  show(e) {
    if (e) {
      e.preventDefault();
    }

    const {
      modalId,
      dialogProps,
      dialogType,
      activeTab
    } = this.props;
    const modalData = {
      modalId,
      dialogProps,
      dialogType,
      activeTab
    };
    this.props.actions.openModal(modalData);
  }

  render() {
    const {
      children,
      onClick,
      activeTab,
      ...props
    } = this.props;
    const {
      formatMessage
    } = this.context.intl;
    const ariaLabel = `${props.accessibilityLabel} ${formatMessage({
      id: 'accessibility.button.dialog',
      defaultMessage: 'Dialog'
    })}`; // removing these three props since they are not valid props on buttons

    delete props.modalId;
    delete props.dialogType;
    delete props.dialogProps;
    delete props.accessibilityLabel; // allow callers to provide an onClick which will be called before the modal is shown

    let clickHandler = () => this.show();

    if (onClick) {
      clickHandler = e => {
        onClick();
        this.show(e);
      };
    }

    return react_default.a.createElement("button", _extends({}, props, {
      className: 'style--none ' + props.className,
      "data-toggle": "modal toggle",
      "aria-label": ariaLabel,
      onClick: clickHandler
    }), children);
  }

}

_defineProperty(toggle_modal_button_redux_ModalToggleButtonRedux, "propTypes", {
  accessibilityLabel: prop_types_default.a.string.isRequired,
  children: prop_types_default.a.node.isRequired,
  modalId: prop_types_default.a.string,
  dialogType: prop_types_default.a.func.isRequired,
  dialogProps: prop_types_default.a.object,
  onClick: prop_types_default.a.func,
  className: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    openModal: prop_types_default.a.func.isRequired
  }).isRequired
});

_defineProperty(toggle_modal_button_redux_ModalToggleButtonRedux, "defaultProps", {
  dialogProps: {},
  className: ''
});

_defineProperty(toggle_modal_button_redux_ModalToggleButtonRedux, "contextTypes", {
  intl: index_es["i" /* intlShape */].isRequired
});
// CONCATENATED MODULE: ./components/toggle_modal_button_redux/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openModal: modals["b" /* openModal */]
    }, dispatch)
  };
}

/* harmony default export */ var toggle_modal_button_redux = __webpack_exports__["a"] = (Object(es["connect"])(null, mapDispatchToProps)(toggle_modal_button_redux_ModalToggleButtonRedux));

/***/ }),

/***/ 1825:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/actions/groups.js
var actions_groups = __webpack_require__(1681);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/groups.js
var entities_groups = __webpack_require__(1745);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./actions/views/search.js
var search = __webpack_require__(1626);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Modal.js
var Modal = __webpack_require__(1972);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var constants = __webpack_require__(17);

// EXTERNAL MODULE: ./utils/constants.jsx
var utils_constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/multiselect/multiselect.jsx + 1 modules
var multiselect = __webpack_require__(1685);

// EXTERNAL MODULE: ./images/groups-avatar.png
var groups_avatar = __webpack_require__(1808);
var groups_avatar_default = /*#__PURE__*/__webpack_require__.n(groups_avatar);

// EXTERNAL MODULE: ./components/icon/add_icon.jsx
var add_icon = __webpack_require__(1696);

// CONCATENATED MODULE: ./components/add_groups_to_team_modal/add_groups_to_team_modal.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const GROUPS_PER_PAGE = 50;
const MAX_SELECTABLE_VALUES = 10;
class add_groups_to_team_modal_AddGroupsToTeamModal extends react_default.a.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleHide", () => {
      this.props.actions.setModalSearchTerm('');
      this.setState({
        show: false
      });
    });

    _defineProperty(this, "handleExit", () => {
      if (this.props.onHide) {
        this.props.onHide();
      }
    });

    _defineProperty(this, "handleResponse", err => {
      let addError = null;

      if (err && err.message) {
        addError = err.message;
      }

      this.setState({
        saving: false,
        addError
      });
    });

    _defineProperty(this, "handleSubmit", async e => {
      if (e) {
        e.preventDefault();
      }

      const groupIDs = this.state.values.map(v => v.id);

      if (groupIDs.length === 0) {
        return;
      }

      if (this.props.skipCommit) {
        if (this.props.onAddCallback) {
          this.props.onAddCallback(groupIDs);
        }

        this.handleHide();
        return;
      }

      this.setState({
        saving: true
      });
      groupIDs.forEach(async groupID => {
        const {
          error
        } = await this.props.actions.linkGroupSyncable(groupID, this.props.currentTeamId, constants["Groups"].SYNCABLE_TYPE_TEAM, {
          auto_add: true
        });
        this.handleResponse(error);

        if (!error) {
          this.handleHide();
        }
      });
    });

    _defineProperty(this, "addValue", value => {
      const values = Object.assign([], this.state.values);
      const userIds = values.map(v => v.id);

      if (value && value.id && userIds.indexOf(value.id) === -1) {
        values.push(value);
      }

      this.setState({
        values
      });
    });

    _defineProperty(this, "setGroupsLoadingState", loadingState => {
      this.setState({
        loadingGroups: loadingState
      });
    });

    _defineProperty(this, "handlePageChange", (page, prevPage) => {
      if (page > prevPage) {
        this.setGroupsLoadingState(true);
        this.props.actions.getGroupsNotAssociatedToTeam(this.props.currentTeamId, this.props.searchTerm, page, GROUPS_PER_PAGE + 1).then(() => {
          this.setGroupsLoadingState(false);
        });
      }
    });

    _defineProperty(this, "handleDelete", values => {
      this.setState({
        values
      });
    });

    _defineProperty(this, "search", term => {
      this.props.actions.setModalSearchTerm(term);
    });

    this.searchTimeoutId = 0;
    this.state = {
      values: [],
      show: true,
      search: false,
      saving: false,
      addError: null,
      loadingGroups: true
    };
  }

  componentDidMount() {
    Promise.all([this.props.actions.getGroupsNotAssociatedToTeam(this.props.currentTeamId, '', 0, GROUPS_PER_PAGE + 1), this.props.actions.getAllGroupsAssociatedToTeam(this.props.currentTeamId)]).then(() => {
      this.setGroupsLoadingState(false);
    });
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.searchTerm !== nextProps.searchTerm) {
      clearTimeout(this.searchTimeoutId);
      const searchTerm = nextProps.searchTerm;

      if (searchTerm === '') {
        return;
      }

      this.searchTimeoutId = setTimeout(async () => {
        this.setGroupsLoadingState(true);
        await this.props.actions.getGroupsNotAssociatedToTeam(this.props.currentTeamId, searchTerm);
        this.setGroupsLoadingState(false);
      }, utils_constants["N" /* default */].SEARCH_TIMEOUT_MILLISECONDS);
    }
  }

  renderOption(option, isSelected, onAdd) {
    const rowSelected = isSelected ? 'more-modal__row--selected' : '';
    return react_default.a.createElement("div", {
      key: option.id,
      ref: isSelected ? 'selected' : option.id,
      className: 'more-modal__row clickable ' + rowSelected,
      onClick: () => onAdd(option)
    }, react_default.a.createElement("img", {
      className: "more-modal__image",
      src: groups_avatar_default.a,
      alt: "group picture",
      width: "32",
      height: "32"
    }), react_default.a.createElement("div", {
      className: "more-modal__details"
    }, react_default.a.createElement("div", {
      className: "more-modal__name"
    }, option.display_name, " ", '-', " ", react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "numMembers",
      defaultMessage: "{num, number} {num, plural, one {member} other {members}}",
      values: {
        num: option.member_count
      }
    })))), react_default.a.createElement("div", {
      className: "more-modal__actions"
    }, react_default.a.createElement("div", {
      className: "more-modal__actions--round"
    }, react_default.a.createElement(add_icon["a" /* default */], null))));
  }

  renderValue(props) {
    return props.data.display_name;
  }

  render() {
    const numRemainingText = react_default.a.createElement("div", {
      id: "numGroupsRemaining"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "multiselect.numGroupsRemaining",
      defaultMessage: "Use \u2191\u2193 to browse, \u21B5 to select. You can add {num, number} more {num, plural, one {group} other {groups}}. ",
      values: {
        num: MAX_SELECTABLE_VALUES - this.state.values.length
      }
    }));
    const buttonSubmitText = Object(utils["gb" /* localizeMessage */])('multiselect.add', 'Add');
    const buttonSubmitLoadingText = Object(utils["gb" /* localizeMessage */])('multiselect.adding', 'Adding...');
    let addError = null;

    if (this.state.addError) {
      addError = react_default.a.createElement("div", {
        className: "has-error col-sm-12"
      }, react_default.a.createElement("label", {
        className: "control-label font-weight--normal"
      }, this.state.addError));
    }

    let groupsToShow = this.props.groups;

    if (this.props.excludeGroups) {
      groupsToShow = groupsToShow.filter(g => !this.props.excludeGroups.includes(g));
    }

    if (this.props.includeGroups) {
      groupsToShow = [...groupsToShow, ...this.props.includeGroups.filter(g => !groupsToShow.includes(g))];
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      id: "addGroupsToTeamModal",
      dialogClassName: 'more-modal more-direct-channels',
      show: this.state.show,
      onHide: this.handleHide,
      onExited: this.handleExit
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "add_groups_to_team.title",
      defaultMessage: "Add New Groups To {teamName} Team",
      values: {
        teamName: react_default.a.createElement("strong", null, this.props.currentTeamName)
      }
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, addError, react_default.a.createElement(multiselect["a" /* default */], {
      key: "addGroupsToTeamKey",
      options: groupsToShow,
      optionRenderer: this.renderOption,
      values: this.state.values,
      valueRenderer: this.renderValue,
      perPage: GROUPS_PER_PAGE,
      handlePageChange: this.handlePageChange,
      handleInput: this.search,
      handleDelete: this.handleDelete,
      handleAdd: this.addValue,
      handleSubmit: this.handleSubmit,
      maxValues: MAX_SELECTABLE_VALUES,
      numRemainingText: numRemainingText,
      buttonSubmitText: buttonSubmitText,
      buttonSubmitLoadingText: buttonSubmitLoadingText,
      saving: this.state.saving,
      loading: this.state.loadingGroups,
      placeholderText: Object(utils["gb" /* localizeMessage */])('multiselect.addGroupsPlaceholder', 'Search and add groups')
    })));
  }

}

_defineProperty(add_groups_to_team_modal_AddGroupsToTeamModal, "propTypes", {
  currentTeamName: prop_types_default.a.string.isRequired,
  currentTeamId: prop_types_default.a.string.isRequired,
  searchTerm: prop_types_default.a.string.isRequired,
  groups: prop_types_default.a.array.isRequired,
  // used in tandem with 'skipCommit' to allow using this component without performing actual linking
  excludeGroups: prop_types_default.a.arrayOf(prop_types_default.a.object),
  includeGroups: prop_types_default.a.arrayOf(prop_types_default.a.object),
  onHide: prop_types_default.a.func,
  skipCommit: prop_types_default.a.bool,
  onAddCallback: prop_types_default.a.func,
  actions: prop_types_default.a.shape({
    getGroupsNotAssociatedToTeam: prop_types_default.a.func.isRequired,
    setModalSearchTerm: prop_types_default.a.func.isRequired,
    linkGroupSyncable: prop_types_default.a.func.isRequired,
    getAllGroupsAssociatedToTeam: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/add_groups_to_team_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function mapStateToProps(state, ownProps) {
  const searchTerm = state.views.search.modalSearch;
  const team = ownProps.team || Object(teams["getCurrentTeam"])(state) || {};
  let groups = Object(entities_groups["getGroupsNotAssociatedToTeam"])(state, team.id);

  if (searchTerm) {
    const regex = RegExp(searchTerm, 'i');
    groups = groups.filter(group => regex.test(group.display_name) || regex.test(group.name));
  }

  return {
    currentTeamName: team.display_name,
    currentTeamId: team.id,
    skipCommit: ownProps.skipCommit,
    onAddCallback: ownProps.onAddCallback,
    excludeGroups: ownProps.excludeGroups,
    searchTerm,
    groups
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getGroupsNotAssociatedToTeam: actions_groups["getGroupsNotAssociatedToTeam"],
      setModalSearchTerm: search["a" /* setModalSearchTerm */],
      linkGroupSyncable: actions_groups["linkGroupSyncable"],
      getAllGroupsAssociatedToTeam: actions_groups["getAllGroupsAssociatedToTeam"]
    }, dispatch)
  };
}

/* harmony default export */ var add_groups_to_team_modal = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(add_groups_to_team_modal_AddGroupsToTeamModal));

/***/ }),

/***/ 1826:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/actions/groups.js
var actions_groups = __webpack_require__(1681);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/groups.js
var entities_groups = __webpack_require__(1745);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var channels = __webpack_require__(15);

// EXTERNAL MODULE: ./actions/views/search.js
var search = __webpack_require__(1626);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Modal.js
var Modal = __webpack_require__(1972);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var constants = __webpack_require__(17);

// EXTERNAL MODULE: ./utils/constants.jsx
var utils_constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/multiselect/multiselect.jsx + 1 modules
var multiselect = __webpack_require__(1685);

// EXTERNAL MODULE: ./images/groups-avatar.png
var groups_avatar = __webpack_require__(1808);
var groups_avatar_default = /*#__PURE__*/__webpack_require__.n(groups_avatar);

// EXTERNAL MODULE: ./components/icon/add_icon.jsx
var add_icon = __webpack_require__(1696);

// CONCATENATED MODULE: ./components/add_groups_to_channel_modal/add_groups_to_channel_modal.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const GROUPS_PER_PAGE = 50;
const MAX_SELECTABLE_VALUES = 10;
class add_groups_to_channel_modal_AddGroupsToChannelModal extends react_default.a.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleHide", () => {
      this.props.actions.setModalSearchTerm("");
      this.setState({
        show: false
      });
    });

    _defineProperty(this, "handleExit", () => {
      if (this.props.onHide) {
        this.props.onHide();
      }
    });

    _defineProperty(this, "handleResponse", err => {
      let addError = null;

      if (err && err.message) {
        addError = err.message;
      }

      this.setState({
        saving: false,
        addError
      });
    });

    _defineProperty(this, "handleSubmit", async e => {
      if (e) {
        e.preventDefault();
      }

      const groupIDs = this.state.values.map(v => v.id);

      if (groupIDs.length === 0) {
        return;
      }

      if (this.props.skipCommit) {
        if (this.props.onAddCallback) {
          this.props.onAddCallback(groupIDs);
        }

        this.handleHide();
        return;
      }

      this.setState({
        saving: true
      });
      groupIDs.forEach(async groupID => {
        const {
          error
        } = await this.props.actions.linkGroupSyncable(groupID, this.props.currentChannelId, constants["Groups"].SYNCABLE_TYPE_CHANNEL, {
          auto_add: true
        });
        this.handleResponse(error);

        if (!error) {
          this.handleHide();
        }
      });
    });

    _defineProperty(this, "addValue", value => {
      const values = Object.assign([], this.state.values);
      const userIds = values.map(v => v.id);

      if (value && value.id && userIds.indexOf(value.id) === -1) {
        values.push(value);
      }

      this.setState({
        values
      });
    });

    _defineProperty(this, "setGroupsLoadingState", loadingState => {
      this.setState({
        loadingGroups: loadingState
      });
    });

    _defineProperty(this, "handlePageChange", (page, prevPage) => {
      if (page > prevPage) {
        this.setGroupsLoadingState(true);
        this.props.actions.getGroupsNotAssociatedToChannel(this.props.currentChannelId, this.props.searchTerm, page, GROUPS_PER_PAGE + 1).then(() => {
          this.setGroupsLoadingState(false);
        });
      }
    });

    _defineProperty(this, "handleDelete", values => {
      this.setState({
        values
      });
    });

    _defineProperty(this, "search", term => {
      this.props.actions.setModalSearchTerm(term);
    });

    this.searchTimeoutId = 0;
    this.state = {
      values: [],
      show: true,
      search: false,
      saving: false,
      addError: null,
      loadingGroups: true
    };
  }

  componentDidMount() {
    Promise.all([this.props.actions.getGroupsNotAssociatedToChannel(this.props.currentChannelId, "", 0, GROUPS_PER_PAGE + 1), this.props.actions.getAllGroupsAssociatedToChannel(this.props.currentChannelId)]).then(() => {
      this.setGroupsLoadingState(false);
    });
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.searchTerm !== nextProps.searchTerm) {
      clearTimeout(this.searchTimeoutId);
      const searchTerm = nextProps.searchTerm;

      if (searchTerm === "") {
        return;
      }

      this.searchTimeoutId = setTimeout(async () => {
        this.setGroupsLoadingState(true);
        await this.props.actions.getGroupsNotAssociatedToChannel(this.props.currentChannelId, searchTerm);
        this.setGroupsLoadingState(false);
      }, utils_constants["N" /* default */].SEARCH_TIMEOUT_MILLISECONDS);
    }
  }

  renderOption(option, isSelected, onAdd) {
    const rowSelected = isSelected ? "more-modal__row--selected" : "";
    return react_default.a.createElement("div", {
      key: option.id,
      ref: isSelected ? "selected" : option.id,
      className: "more-modal__row clickable " + rowSelected,
      onClick: () => onAdd(option)
    }, react_default.a.createElement("img", {
      className: "more-modal__image",
      src: groups_avatar_default.a,
      alt: "group picture",
      width: "32",
      height: "32"
    }), react_default.a.createElement("div", {
      className: "more-modal__details"
    }, react_default.a.createElement("div", {
      className: "more-modal__name"
    }, option.display_name, " ", "-", " ", react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "numMembers",
      defaultMessage: "{num, number} {num, plural, one {member} other {members}}",
      values: {
        num: option.member_count
      }
    })))), react_default.a.createElement("div", {
      className: "more-modal__actions"
    }, react_default.a.createElement("div", {
      className: "more-modal__actions--round"
    }, react_default.a.createElement(add_icon["a" /* default */], null))));
  }

  renderValue(props) {
    return props.data.display_name;
  }

  render() {
    const numRemainingText = react_default.a.createElement("div", {
      id: "numGroupsRemaining"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "multiselect.numGroupsRemaining",
      defaultMessage: "Use \u2191\u2193 to browse, \u21B5 to select. You can add {num, number} more {num, plural, one {group} other {groups}}. ",
      values: {
        num: MAX_SELECTABLE_VALUES - this.state.values.length
      }
    }));
    const buttonSubmitText = Object(utils["gb" /* localizeMessage */])("multiselect.add", "Add");
    const buttonSubmitLoadingText = Object(utils["gb" /* localizeMessage */])("multiselect.adding", "Adding...");
    let addError = null;

    if (this.state.addError) {
      addError = react_default.a.createElement("div", {
        className: "has-error col-sm-12"
      }, react_default.a.createElement("label", {
        className: "control-label font-weight--normal"
      }, this.state.addError));
    }

    let groupsToShow = this.props.groups;

    if (this.props.excludeGroups) {
      groupsToShow = groupsToShow.filter(g => !this.props.excludeGroups.includes(g));
    }

    if (this.props.includeGroups) {
      groupsToShow = [...groupsToShow, ...this.props.includeGroups.filter(g => !groupsToShow.includes(g))];
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      id: "addGroupsToChannelModal",
      dialogClassName: "more-modal more-direct-channels",
      show: this.state.show,
      onHide: this.handleHide,
      onExited: this.handleExit
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "add_groups_to_channel.title",
      defaultMessage: "Add New Groups To {channelName} Channel",
      values: {
        channelName: react_default.a.createElement("strong", null, this.props.currentChannelName)
      }
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, addError, react_default.a.createElement(multiselect["a" /* default */], {
      key: "addGroupsToChannelKey",
      options: groupsToShow,
      optionRenderer: this.renderOption,
      values: this.state.values,
      valueRenderer: this.renderValue,
      perPage: GROUPS_PER_PAGE,
      handlePageChange: this.handlePageChange,
      handleInput: this.search,
      handleDelete: this.handleDelete,
      handleAdd: this.addValue,
      handleSubmit: this.handleSubmit,
      maxValues: MAX_SELECTABLE_VALUES,
      numRemainingText: numRemainingText,
      buttonSubmitText: buttonSubmitText,
      buttonSubmitLoadingText: buttonSubmitLoadingText,
      saving: this.state.saving,
      loading: this.state.loadingGroups,
      placeholderText: Object(utils["gb" /* localizeMessage */])("multiselect.addGroupsPlaceholder", "Search and add groups")
    })));
  }

}

_defineProperty(add_groups_to_channel_modal_AddGroupsToChannelModal, "propTypes", {
  currentChannelName: prop_types_default.a.string.isRequired,
  currentChannelId: prop_types_default.a.string.isRequired,
  searchTerm: prop_types_default.a.string.isRequired,
  groups: prop_types_default.a.array.isRequired,
  // used in tandem with 'skipCommit' to allow using this component without performing actual linking
  excludeGroups: prop_types_default.a.arrayOf(prop_types_default.a.object),
  includeGroups: prop_types_default.a.arrayOf(prop_types_default.a.object),
  onHide: prop_types_default.a.func,
  skipCommit: prop_types_default.a.bool,
  onAddCallback: prop_types_default.a.func,
  actions: prop_types_default.a.shape({
    getGroupsNotAssociatedToChannel: prop_types_default.a.func.isRequired,
    setModalSearchTerm: prop_types_default.a.func.isRequired,
    linkGroupSyncable: prop_types_default.a.func.isRequired,
    getAllGroupsAssociatedToChannel: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/add_groups_to_channel_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function mapStateToProps(state, ownProps) {
  const searchTerm = state.views.search.modalSearch;
  const channel = ownProps.channel || Object(channels["getCurrentChannel"])(state) || {};
  let groups = Object(entities_groups["getGroupsNotAssociatedToChannel"])(state, channel.id);

  if (searchTerm) {
    const regex = RegExp(searchTerm, 'i');
    groups = groups.filter(group => regex.test(group.display_name) || regex.test(group.name));
  }

  return {
    currentChannelName: channel.display_name,
    currentChannelId: channel.id,
    skipCommit: ownProps.skipCommit,
    onAddCallback: ownProps.onAddCallback,
    excludeGroups: ownProps.excludeGroups,
    searchTerm,
    groups
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getGroupsNotAssociatedToChannel: actions_groups["getGroupsNotAssociatedToChannel"],
      setModalSearchTerm: search["a" /* setModalSearchTerm */],
      linkGroupSyncable: actions_groups["linkGroupSyncable"],
      getAllGroupsAssociatedToChannel: actions_groups["getAllGroupsAssociatedToChannel"]
    }, dispatch)
  };
}

/* harmony default export */ var add_groups_to_channel_modal = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(add_groups_to_channel_modal_AddGroupsToChannelModal));

/***/ }),

/***/ 1827:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/timezone.js
var timezone = __webpack_require__(308);

// EXTERNAL MODULE: ./mattermost-redux/utils/timezone_utils.js
var timezone_utils = __webpack_require__(306);

// EXTERNAL MODULE: ./selectors/general.js
var general = __webpack_require__(232);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// CONCATENATED MODULE: ./components/post_view/date_separator/date_separator.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class date_separator_DateSeparator extends react_default.a.PureComponent {
  render() {
    const {
      date,
      enableTimezone,
      timeZone
    } = this.props;
    const timezoneProps = enableTimezone && timeZone ? {
      timeZone
    } : {};
    return react_default.a.createElement("div", {
      className: "date-separator"
    }, react_default.a.createElement("div", {
      className: "separator__text"
    }, react_default.a.createElement(index_es["a" /* FormattedDate */], _extends({}, timezoneProps, {
      value: date,
      weekday: "short",
      month: "short",
      day: "2-digit",
      year: "numeric"
    }))));
  }

}

_defineProperty(date_separator_DateSeparator, "propTypes", {
  date: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.instanceOf(Date)]).isRequired,
  timeZone: prop_types_default.a.string,
  enableTimezone: prop_types_default.a.bool
});
// CONCATENATED MODULE: ./components/post_view/date_separator/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function mapStateToProps(state, props) {
  const currentUserId = Object(users["getCurrentUserId"])(state);
  let userTimezone;

  if (props.userTimezone) {
    userTimezone = props.userTimezone;
  } else {
    userTimezone = Object(timezone["getUserTimezone"])(state, currentUserId);
  }

  return {
    enableTimezone: Object(general["a" /* areTimezonesEnabledAndSupported */])(state),
    timeZone: Object(timezone_utils["getUserCurrentTimezone"])(userTimezone)
  };
}

/* harmony default export */ var date_separator = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(date_separator_DateSeparator));

/***/ }),

/***/ 1828:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./utils/file_utils.jsx
var file_utils = __webpack_require__(1601);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// CONCATENATED MODULE: ./components/file_info_preview/file_info_preview.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class file_info_preview_FileInfoPreview extends react_default.a.PureComponent {
  render() {
    const fileInfo = this.props.fileInfo;
    const fileUrl = this.props.fileUrl;
    const fileName = fileInfo.link || fileInfo.name; // non-image files include a section providing details about the file

    const infoParts = [];

    if (fileInfo.extension !== '') {
      infoParts.push(utils["gb" /* localizeMessage */]('file_info_preview.type', 'File type ') + fileInfo.extension.toUpperCase());
    }

    infoParts.push(utils["gb" /* localizeMessage */]('file_info_preview.size', 'Size ') + utils["p" /* fileSizeToString */](fileInfo.size));
    const infoString = infoParts.join(', ');
    let preview = null;

    if (this.props.canDownloadFiles) {
      preview = react_default.a.createElement("a", {
        className: "file-details__preview",
        href: fileUrl,
        target: "_blank",
        rel: "noopener noreferrer",
        download: fileName
      }, react_default.a.createElement("span", {
        className: "file-details__preview-helper"
      }), react_default.a.createElement("img", {
        alt: 'file preview',
        src: utils["y" /* getFileIconPath */](fileInfo)
      }));
    } else {
      preview = react_default.a.createElement("span", {
        className: "file-details__preview"
      }, react_default.a.createElement("span", {
        className: "file-details__preview-helper"
      }), react_default.a.createElement("img", {
        alt: 'file preview',
        src: utils["y" /* getFileIconPath */](fileInfo)
      }));
    }

    return react_default.a.createElement("div", {
      className: "file-details__container"
    }, preview, react_default.a.createElement("div", {
      className: "file-details"
    }, react_default.a.createElement("div", {
      className: "file-details__name"
    }, fileInfo.name), react_default.a.createElement("div", {
      className: "file-details__info"
    }, infoString)));
  }

}

_defineProperty(file_info_preview_FileInfoPreview, "propTypes", {
  fileInfo: prop_types_default.a.object.isRequired,
  fileUrl: prop_types_default.a.string.isRequired,
  canDownloadFiles: prop_types_default.a.bool.isRequired
});
// CONCATENATED MODULE: ./components/file_info_preview/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  return {
    canDownloadFiles: Object(file_utils["a" /* canDownloadFiles */])(config)
  };
}

/* harmony default export */ var file_info_preview = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(file_info_preview_FileInfoPreview));

/***/ }),

/***/ 1830:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getLastViewedChannelName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getPenultimateViewedChannelName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getLastViewedChannelNameByTeamName; });
/* harmony import */ var mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);
/* harmony import */ var mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var stores_local_storage_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(218);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


 // getLastViewedChannelName combines data from the Redux store and localStorage to return the
// previously selected channel name, returning the default channel if none exists.
//
// See LocalStorageStore for context.

const getLastViewedChannelName = state => {
  const userId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_1__["getCurrentUserId"])(state);
  const teamId = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_0__["getCurrentTeamId"])(state);
  return stores_local_storage_store__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].getPreviousChannelName(userId, teamId);
};
const getPenultimateViewedChannelName = state => {
  const userId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_1__["getCurrentUserId"])(state);
  const teamId = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_0__["getCurrentTeamId"])(state);
  return stores_local_storage_store__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].getPenultimateChannelName(userId, teamId);
}; // getLastViewedChannelNameByTeamName combines data from the Redux store and localStorage to return
// the url to the previously selected channel, returning the path to the default channel if none
// exists.
//
// See LocalStorageStore for context.

const getLastViewedChannelNameByTeamName = (state, teamName) => {
  const userId = Object(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_1__["getCurrentUserId"])(state);
  const team = Object(mattermost_redux_selectors_entities_teams__WEBPACK_IMPORTED_MODULE_0__["getTeamByName"])(state, teamName);
  const teamId = team && team.id;
  return stores_local_storage_store__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].getPreviousChannelName(userId, teamId);
};

/***/ }),

/***/ 1844:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UserProvider; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mattermost_redux_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);
/* harmony import */ var mattermost_redux_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_client__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(304);
/* harmony import */ var utils_utils_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);
/* harmony import */ var components_widgets_badges_bot_badge_jsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1588);
/* harmony import */ var _provider_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1597);
/* harmony import */ var _suggestion_jsx__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1598);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class UserSuggestion extends _suggestion_jsx__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"] {
  render() {
    const {
      item,
      isSelection
    } = this.props;
    let className = 'suggestion-list__item mentions__name';

    if (isSelection) {
      className += ' suggestion--selected';
    }

    const username = item.username;
    let description = '';

    if ((item.first_name || item.last_name) && item.nickname) {
      description = `- ${utils_utils_jsx__WEBPACK_IMPORTED_MODULE_3__[/* getFullName */ "A"](item)} (${item.nickname})`;
    } else if (item.nickname) {
      description = `- (${item.nickname})`;
    } else if (item.first_name || item.last_name) {
      description = `- ${utils_utils_jsx__WEBPACK_IMPORTED_MODULE_3__[/* getFullName */ "A"](item)}`;
    }

    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", _extends({
      className: className,
      onClick: this.handleClick
    }, _suggestion_jsx__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].baseProps), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      alt: '',
      className: "admin-setting-user__image",
      src: mattermost_redux_client__WEBPACK_IMPORTED_MODULE_1__["Client4"].getUsersRoute() + '/' + item.id + '/image?_=' + (item.last_picture_update || 0)
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      className: "admin-setting-user--align"
    }, '@' + username), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_widgets_badges_bot_badge_jsx__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], {
      show: Boolean(item.is_bot)
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      className: "admin-setting-user__fullname"
    }, ' ', description));
  }

}

class UserProvider extends _provider_jsx__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"] {
  handlePretextChanged(pretext, resultsCallback) {
    const normalizedPretext = pretext.toLowerCase();
    this.startNewRequest(normalizedPretext);
    Object(actions_user_actions_jsx__WEBPACK_IMPORTED_MODULE_2__[/* autocompleteUsers */ "b"])(normalizedPretext, data => {
      if (this.shouldCancelDispatch(normalizedPretext)) {
        return;
      }

      const users = Object.assign([], data.users);
      resultsCallback({
        matchedPretext: normalizedPretext,
        terms: users.map(user => user.username),
        items: users,
        component: UserSuggestion
      });
    });
    return true;
  }

}

/***/ }),

/***/ 1845:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var flux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2326);
/* harmony import */ var flux__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(flux__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


const PayloadSources = utils_constants_jsx__WEBPACK_IMPORTED_MODULE_1__[/* default */ "N"].PayloadSources;
const AppDispatcher = Object.assign(new flux__WEBPACK_IMPORTED_MODULE_0__["Dispatcher"](), {
  handleServerAction: function performServerAction(action) {
    if (!action.type) {
      console.warn('handleServerAction called with undefined action type'); // eslint-disable-line no-console
    }

    var payload = {
      source: PayloadSources.SERVER_ACTION,
      action
    };
    this.dispatch(payload);
  },
  handleViewAction: function performViewAction(action) {
    if (!action.type) {
      console.warn('handleViewAction called with undefined action type'); // eslint-disable-line no-console
    }

    var payload = {
      source: PayloadSources.VIEW_ACTION,
      action
    };
    this.dispatch(payload);
  }
});
/* harmony default export */ __webpack_exports__["a"] = (AppDispatcher);

/***/ }),

/***/ 1851:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 33).then((function(require) {
		cb(__webpack_require__(3336));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 1859:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return dismissNotice; });
/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

function dismissNotice(type) {
  return dispatch => {
    dispatch({
      type: utils_constants__WEBPACK_IMPORTED_MODULE_0__[/* ActionTypes */ "b"].DISMISS_NOTICE,
      data: type
    });
    return {
      data: true
    };
  };
}

/***/ }),

/***/ 1860:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/325472601571f31e1bf00674c368d335.gif";

/***/ }),

/***/ 1861:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFilePublicLink = getFilePublicLink;
exports.makeGetFilesForPost = makeGetFilesForPost;

var _reselect = __webpack_require__(94);

var _i18n = __webpack_require__(432);

var _file_utils = __webpack_require__(1611); // Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


function getAllFiles(state) {
  return state.entities.files.files;
}

function getFilesIdsForPost(state, postId) {
  if (postId) {
    return state.entities.files.fileIdsByPostId[postId] || [];
  }

  return [];
}

function getFilePublicLink(state) {
  return state.entities.files.filePublicLink;
}

function makeGetFilesForPost() {
  return (0, _reselect.createSelector)([getAllFiles, getFilesIdsForPost, _i18n.getCurrentUserLocale], function (allFiles, fileIdsForPost, locale) {
    var fileInfos = fileIdsForPost.map(function (id) {
      return allFiles[id];
    }).filter(function (id) {
      return Boolean(id);
    });
    return (0, _file_utils.sortFileInfos)(fileInfos, locale);
  });
}

/***/ }),

/***/ 1862:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FilenameOverlay; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1995);
/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1998);
/* harmony import */ var mattermost_redux_utils_file_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1611);
/* harmony import */ var mattermost_redux_utils_file_utils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_utils_file_utils__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var components_svg_attachment_icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2016);
/* harmony import */ var utils_file_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1601);
/* harmony import */ var utils_utils_jsx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(22);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class FilenameOverlay extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  render() {
    const {
      canDownload,
      children,
      compactDisplay,
      fileInfo,
      handleImageClick,
      iconClass
    } = this.props;
    const fileName = fileInfo.name;
    const trimmedFilename = Object(utils_file_utils__WEBPACK_IMPORTED_MODULE_6__[/* trimFilename */ "h"])(fileName);
    let filenameOverlay;

    if (compactDisplay) {
      filenameOverlay = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
        trigger: ['hover', 'focus'],
        delayShow: 1000,
        placement: "top",
        overlay: react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], {
          id: "file-name__tooltip"
        }, fileName)
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("a", {
        href: "#",
        onClick: handleImageClick,
        className: "post-image__name",
        rel: "noopener noreferrer"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_svg_attachment_icon__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], {
        className: "icon"
      }), trimmedFilename));
    } else if (canDownload) {
      filenameOverlay = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("a", {
        href: Object(mattermost_redux_utils_file_utils__WEBPACK_IMPORTED_MODULE_4__["getFileDownloadUrl"])(fileInfo.id),
        download: fileName,
        className: iconClass || 'post-image__name',
        target: "_blank",
        rel: "noopener noreferrer"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
        trigger: ['hover', 'focus'],
        delayShow: 1000,
        placement: "top",
        overlay: react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], {
          id: "file-name__tooltip"
        }, Object(utils_utils_jsx__WEBPACK_IMPORTED_MODULE_7__[/* localizeMessage */ "gb"])('file_attachment.download', 'Download'))
      }, children || trimmedFilename));
    } else {
      filenameOverlay = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", {
        className: "post-image__name"
      }, trimmedFilename);
    }

    return filenameOverlay;
  }

}

_defineProperty(FilenameOverlay, "propTypes", {
  /*
   * File detailed information
   */
  fileInfo: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object.isRequired,

  /*
   * Handler for when the thumbnail is clicked passed the index above
   */
  handleImageClick: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,

  /*
   * Display in compact format
   */
  compactDisplay: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /*
   * If it should display link to download on file name
   */
  canDownload: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,

  /**
   * Optional children like download icon
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.element,

  /**
   * Optional class like for icon
   */
  iconClass: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
});

/***/ }),

/***/ 1869:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/1c7af7f723968a22b1c91c2aaa21dd2f.png";

/***/ }),

/***/ 1882:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/* harmony default export */ __webpack_exports__["a"] = (({
  fill = "#909090",
  ...rest
}) => React.createElement("svg", _extends({
  height: "15",
  viewBox: "0 0 16 15",
  width: "16",
  xmlns: "http://www.w3.org/2000/svg"
}, rest), React.createElement("path", {
  d: "m1531 1042.5-3.4966 1.83827c-.48884.257-1.09347.06905-1.35047-.41979-.10234-.19466-.13765-.41763-.10047-.63439l.66779-3.89351-2.82881-2.75741c-.39548-.3855-.40358-1.01861-.01807-1.41409.1535-.15749.35465-.25998.57228-.2916l3.90932-.56806 1.74829-3.54243c.24443-.49526.84405-.6986 1.33931-.45417.19721.09733.35684.25695.45417.45417l1.74829 3.54243 3.90932.56806c.54654.07942.92522.58686.8458 1.13341-.03162.21763-.13411.41877-.29159.57228l-2.82881 2.75741.66779 3.89351c.09337.54434-.27222 1.06129-.81656 1.15466-.21676.03717-.43972.00186-.63438-.10048z",
  fill: fill,
  fillRule: "evenodd",
  transform: "translate(-1523 -1030)"
})));

/***/ }),

/***/ 1883:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InfoSmallIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class InfoSmallIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", this.props, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.info",
      defaultMessage: "Info Icon"
    }, ariaLabel => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
      className: "svg-text-color",
      "aria-label": ariaLabel,
      width: "24px",
      height: "24px",
      viewBox: "0 0 24 24",
      version: "1.1"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(-1015.000000, -516.000000)",
      fill: "inherit"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      d: "M1027,540 C1020.37258,540 1015,534.627417 1015,528 C1015,521.372583 1020.37258,516 1027,516 C1033.62742,516 1039,521.372583 1039,528 C1039,534.627417 1033.62742,540 1027,540 Z M1027,527 C1025.89543,527 1025,527.895431 1025,529 L1025,533 C1025,534.104569 1025.89543,535 1027,535 C1028.10457,535 1029,534.104569 1029,533 L1029,529 C1029,527.895431 1028.10457,527 1027,527 Z M1027,525 C1028.10457,525 1029,524.104569 1029,523 C1029,521.895431 1028.10457,521 1027,521 C1025.89543,521 1025,521.895431 1025,523 C1025,524.104569 1025.89543,525 1027,525 Z"
    }))))));
  }

}

/***/ }),

/***/ 1884:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SearchHint; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var components_formatted_markdown_message_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1564);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class SearchHint extends react__WEBPACK_IMPORTED_MODULE_0__["PureComponent"] {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, this.props.withTitle && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h4", null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
      id: "search_bar.usage.title",
      defaultMessage: "Search Options"
    })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_formatted_markdown_message_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "b"], {
      id: "search_bar.usage.tips",
      defaultMessage: "* Use **\"quotation marks\"** to search for phrases\\n* Use **from:** to find posts from specific users and **in:** to find posts in specific channels\\n* Use **on:** to find posts on a specific date\\n* Use **before:** to find posts before a specific date\\n* Use **after:** to find posts after a specific date"
    }));
  }

}

_defineProperty(SearchHint, "propTypes", {
  withTitle: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool
});

/***/ }),

/***/ 1934:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export MenuItemToggleModalReduxImpl */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var components_toggle_modal_button_redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1824);
/* harmony import */ var _menu_item_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1730);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




const MenuItemToggleModalReduxImpl = props => {
  const {
    modalId,
    dialogType,
    dialogProps,
    text,
    activeTab,
    ...rest
  } = props; // console.log(tabKey, props, '--------------tabkey')

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_toggle_modal_button_redux__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
    accessibilityLabel: text,
    modalId: modalId,
    dialogType: dialogType,
    activeTab: activeTab,
    dialogProps: dialogProps
  }, text);
};
MenuItemToggleModalReduxImpl.propTypes = {
  modalId: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  dialogType: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,
  dialogProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,
  activeTab: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  text: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node]).isRequired
};
const MenuItemToggleModalRedux = Object(_menu_item_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(MenuItemToggleModalReduxImpl);
MenuItemToggleModalRedux.displayName = 'MenuItemToggleModalRedux';
/* harmony default export */ __webpack_exports__["a"] = (MenuItemToggleModalRedux);

/***/ }),

/***/ 1935:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/9fdc87bbf5f1604342b2ea345e867ca2.ico";

/***/ }),

/***/ 1936:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/32546c9ffee03e262b4ba1de09302b44.ico";

/***/ }),

/***/ 1960:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./selectors/posts.js
var posts = __webpack_require__(415);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/actions/posts.js
var actions_posts = __webpack_require__(59);

// EXTERNAL MODULE: ./utils/post_utils.jsx + 1 modules
var post_utils = __webpack_require__(407);

// EXTERNAL MODULE: ./utils/url.jsx + 1 modules
var url = __webpack_require__(298);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/markdown/index.js + 1 modules
var components_markdown = __webpack_require__(1624);

// EXTERNAL MODULE: ./components/post_view/show_more/index.js + 1 modules
var show_more = __webpack_require__(2274);

// EXTERNAL MODULE: ./components/size_aware_image.jsx
var size_aware_image = __webpack_require__(1728);

// CONCATENATED MODULE: ./components/post_view/message_attachments/action_button.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class action_button_ActionButton extends react_default.a.PureComponent {
  render() {
    const {
      action,
      handleAction
    } = this.props;
    return react_default.a.createElement("button", {
      "data-action-id": action.id,
      "data-action-cookie": action.cookie,
      key: action.id,
      onClick: handleAction
    }, react_default.a.createElement(components_markdown["a" /* default */], {
      message: action.name,
      options: {
        mentionHighlight: false,
        markdown: false,
        autolinkedUrlSchemes: []
      }
    }));
  }

}

_defineProperty(action_button_ActionButton, "propTypes", {
  action: prop_types_default.a.object.isRequired,
  handleAction: prop_types_default.a.func.isRequired
});
// EXTERNAL MODULE: ./actions/views/posts.js
var views_posts = __webpack_require__(1618);

// EXTERNAL MODULE: ./components/suggestion/menu_action_provider.jsx
var menu_action_provider = __webpack_require__(1984);

// EXTERNAL MODULE: ./components/suggestion/generic_user_provider.jsx
var generic_user_provider = __webpack_require__(1844);

// EXTERNAL MODULE: ./components/suggestion/generic_channel_provider.jsx
var generic_channel_provider = __webpack_require__(1985);

// EXTERNAL MODULE: ./components/widgets/settings/autocomplete_selector.jsx
var autocomplete_selector = __webpack_require__(1986);

// CONCATENATED MODULE: ./components/post_view/message_attachments/action_menu/action_menu.jsx
function action_menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class action_menu_ActionMenu extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    action_menu_defineProperty(this, "handleSelected", selected => {
      if (!selected) {
        return;
      }

      const {
        action
      } = this.props;
      let value = '';
      let text = '';

      if (action.data_source === 'users') {
        text = selected.username;
        value = selected.id;
      } else if (action.data_source === 'channels') {
        text = selected.display_name;
        value = selected.id;
      } else {
        text = selected.text;
        value = selected.value;
      }

      this.props.actions.selectAttachmentMenuAction(this.props.postId, this.props.action.id, this.props.action.cookie, this.props.action.data_source, text, value);
      this.setState({
        value: text
      });
    });

    const _action = props.action;
    this.providers = [];

    if (_action) {
      if (_action.data_source === 'users') {
        this.providers = [new generic_user_provider["a" /* default */]()];
      } else if (_action.data_source === 'channels') {
        this.providers = [new generic_channel_provider["a" /* default */]()];
      } else if (_action.options) {
        this.providers = [new menu_action_provider["a" /* default */](_action.options)];
      }
    }

    let _selected;

    let _value = '';

    if (_action.default_option && _action.options) {
      _selected = _action.options.find(option => option.value === _action.default_option);
      _value = _selected ? _selected.text : '';
    }

    this.state = {
      selected: _selected,
      value: _value
    };
  }

  static getDerivedStateFromProps(props, state) {
    if (props.selected && props.selected !== state.selected) {
      return {
        value: props.selected.text,
        selected: props.selected
      };
    }

    return null;
  }

  render() {
    const {
      action
    } = this.props;
    return react_default.a.createElement(autocomplete_selector["a" /* default */], {
      providers: this.providers,
      onSelected: this.handleSelected,
      placeholder: action.name,
      inputClassName: "post-attachment-dropdown",
      value: this.state.value
    });
  }

}

action_menu_defineProperty(action_menu_ActionMenu, "propTypes", {
  postId: prop_types_default.a.string.isRequired,
  action: prop_types_default.a.object.isRequired,
  selected: prop_types_default.a.object,
  actions: prop_types_default.a.shape({
    selectAttachmentMenuAction: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/post_view/message_attachments/action_menu/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function mapStateToProps(state, ownProps) {
  const actions = state.views.posts.menuActions[ownProps.postId];
  const selected = actions && actions[ownProps.action && ownProps.action.id];
  return {
    selected
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      selectAttachmentMenuAction: views_posts["b" /* selectAttachmentMenuAction */]
    }, dispatch)
  };
}

/* harmony default export */ var action_menu = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(action_menu_ActionMenu));
// EXTERNAL MODULE: ./utils/markdown/remove_markdown.js
var remove_markdown = __webpack_require__(829);

// CONCATENATED MODULE: ./utils/markdown/link_only_renderer.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class link_only_renderer_LinkOnlyRenderer extends remove_markdown["a" /* default */] {
  link(href, title, text) {
    let outHref = href;

    if (!Object(url["c" /* getScheme */])(href)) {
      outHref = `http://${outHref}`;
    }

    let output = `<a class="theme markdown__link" href="${outHref}" target="_blank"`;

    if (title) {
      output += ' title="' + title + '"';
    }

    output += `>${text}</a>`;
    return output;
  }

}
// CONCATENATED MODULE: ./components/post_view/message_attachments/message_attachment/message_attachment.jsx
function message_attachment_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











class message_attachment_MessageAttachment extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    message_attachment_defineProperty(this, "handleHeightReceivedForThumbUrl", ({
      height
    }) => {
      const {
        attachment
      } = this.props;

      if (!this.props.imagesMetadata || this.props.imagesMetadata && !this.props.imagesMetadata[attachment.thumb_url]) {
        this.handleHeightReceived(height);
      }
    });

    message_attachment_defineProperty(this, "handleHeightReceivedForImageUrl", ({
      height
    }) => {
      const {
        attachment
      } = this.props;

      if (!this.props.imagesMetadata || this.props.imagesMetadata && !this.props.imagesMetadata[attachment.image_url]) {
        this.handleHeightReceived(height);
      }
    });

    message_attachment_defineProperty(this, "handleHeightReceived", height => {
      if (!this.mounted) {
        return;
      }

      if (height > 0) {
        // Increment checkOverflow to indicate change in height
        // and recompute textContainer height at ShowMore component
        // and see whether overflow text of show more/less is necessary or not.
        this.setState(prevState => {
          return {
            checkOverflow: prevState.checkOverflow + 1
          };
        });
      }
    });

    message_attachment_defineProperty(this, "renderPostActions", () => {
      const actions = this.props.attachment.actions;

      if (!actions || !actions.length) {
        return '';
      }

      const content = [];
      actions.forEach(action => {
        if (!action.id || !action.name) {
          return;
        }

        switch (action.type) {
          case 'select':
            content.push(react_default.a.createElement(action_menu, {
              key: action.id,
              postId: this.props.postId,
              action: action
            }));
            break;

          case 'button':
          default:
            content.push(react_default.a.createElement(action_button_ActionButton, {
              key: action.id,
              action: action,
              handleAction: this.handleAction
            }));
            break;
        }
      });
      return react_default.a.createElement("div", {
        className: "attachment-actions"
      }, content);
    });

    message_attachment_defineProperty(this, "handleAction", e => {
      e.preventDefault();
      const actionId = e.currentTarget.getAttribute('data-action-id');
      const actionCookie = e.currentTarget.getAttribute('data-action-cookie');
      this.props.actions.doPostActionWithCookie(this.props.postId, actionId, actionCookie);
    });

    message_attachment_defineProperty(this, "getFieldsTable", () => {
      const fields = this.props.attachment.fields;

      if (!fields || !fields.length) {
        return '';
      }

      const fieldTables = [];
      let headerCols = [];
      let bodyCols = [];
      let rowPos = 0;
      let lastWasLong = false;
      let nrTables = 0;
      const markdown = {
        markdown: false,
        mentionHighlight: false
      };
      fields.forEach((field, i) => {
        if (rowPos === 2 || !(field.short === true) || lastWasLong) {
          fieldTables.push(react_default.a.createElement("table", {
            className: "attachment-fields",
            key: 'attachment__table__' + nrTables
          }, react_default.a.createElement("thead", null, react_default.a.createElement("tr", null, headerCols)), react_default.a.createElement("tbody", null, react_default.a.createElement("tr", null, bodyCols))));
          headerCols = [];
          bodyCols = [];
          rowPos = 0;
          nrTables += 1;
          lastWasLong = false;
        }

        headerCols.push(react_default.a.createElement("th", {
          className: "attachment-field__caption",
          key: 'attachment__field-caption-' + i + '__' + nrTables,
          width: "50%"
        }, react_default.a.createElement(components_markdown["a" /* default */], {
          message: field.title,
          options: markdown
        })));
        bodyCols.push(react_default.a.createElement("td", {
          className: "attachment-field",
          key: 'attachment__field-' + i + '__' + nrTables
        }, react_default.a.createElement(components_markdown["a" /* default */], {
          message: field.value
        })));
        rowPos += 1;
        lastWasLong = !(field.short === true);
      });

      if (headerCols.length > 0) {
        // Flush last fields
        fieldTables.push(react_default.a.createElement("table", {
          className: "attachment-fields",
          key: 'attachment__table__' + nrTables
        }, react_default.a.createElement("thead", null, react_default.a.createElement("tr", null, headerCols)), react_default.a.createElement("tbody", null, react_default.a.createElement("tr", null, bodyCols))));
      }

      return react_default.a.createElement("div", null, fieldTables);
    });

    this.state = {
      checkOverflow: 0
    };
    this.imageProps = {
      onImageLoaded: this.handleHeightReceived
    };
  }

  componentDidMount() {
    this.mounted = true;
  }

  componentWillUnmount() {
    this.mounted = false;
  }

  render() {
    const {
      attachment,
      options
    } = this.props;
    let preTextClass = '';
    let preText;

    if (attachment.pretext) {
      preTextClass = 'attachment--pretext';
      preText = react_default.a.createElement("div", {
        className: "attachment__thumb-pretext"
      }, react_default.a.createElement(components_markdown["a" /* default */], {
        message: attachment.pretext
      }));
    }

    let author = [];

    if (attachment.author_name || attachment.author_icon) {
      if (attachment.author_icon) {
        author.push(react_default.a.createElement("img", {
          alt: 'attachment author icon',
          className: "attachment__author-icon",
          src: Object(post_utils["e" /* getImageSrc */])(attachment.author_icon, this.props.hasImageProxy),
          key: 'attachment__author-icon',
          height: "14",
          width: "14"
        }));
      }

      if (attachment.author_name) {
        author.push(react_default.a.createElement("span", {
          className: "attachment__author-name",
          key: 'attachment__author-name'
        }, attachment.author_name));
      }
    }

    if (attachment.author_link && Object(url["f" /* isUrlSafe */])(attachment.author_link)) {
      author = react_default.a.createElement("a", {
        href: attachment.author_link,
        target: "_blank",
        rel: "noopener noreferrer"
      }, author);
    }

    let title;

    if (attachment.title) {
      if (attachment.title_link && Object(url["f" /* isUrlSafe */])(attachment.title_link)) {
        title = react_default.a.createElement("h1", {
          className: "attachment__title"
        }, react_default.a.createElement("a", {
          className: "attachment__title-link",
          href: attachment.title_link,
          target: "_blank",
          rel: "noopener noreferrer"
        }, attachment.title));
      } else {
        title = react_default.a.createElement("h1", {
          className: "attachment__title"
        }, react_default.a.createElement(components_markdown["a" /* default */], {
          message: attachment.title,
          options: {
            mentionHighlight: false,
            renderer: new link_only_renderer_LinkOnlyRenderer(),
            autolinkedUrlSchemes: []
          }
        }));
      }
    }

    let attachmentText;

    if (attachment.text) {
      attachmentText = react_default.a.createElement(show_more["a" /* default */], {
        checkOverflow: this.state.checkOverflow,
        isAttachmentText: true,
        text: attachment.text
      }, react_default.a.createElement(components_markdown["a" /* default */], {
        message: attachment.text || '',
        options: options,
        imageProps: this.imageProps
      }));
    }

    let image;

    if (attachment.image_url) {
      image = react_default.a.createElement("div", {
        className: "attachment__image-container"
      }, react_default.a.createElement(size_aware_image["a" /* default */], {
        className: "attachment__image",
        onImageLoaded: this.handleHeightReceivedForImageUrl,
        src: Object(post_utils["e" /* getImageSrc */])(attachment.image_url, this.props.hasImageProxy),
        dimensions: this.props.imagesMetadata[attachment.image_url]
      }));
    }

    let thumb;

    if (attachment.thumb_url) {
      thumb = react_default.a.createElement("div", {
        className: "attachment__thumb-container"
      }, react_default.a.createElement(size_aware_image["a" /* default */], {
        onImageLoaded: this.handleHeightReceivedForThumbUrl,
        src: Object(post_utils["e" /* getImageSrc */])(attachment.thumb_url, this.props.hasImageProxy),
        dimensions: this.props.imagesMetadata[attachment.thumb_url]
      }));
    }

    const fields = this.getFieldsTable();
    const actions = this.renderPostActions();
    let useBorderStyle;

    if (attachment.color && attachment.color[0] === '#') {
      useBorderStyle = {
        borderLeftColor: attachment.color
      };
    }

    return react_default.a.createElement("div", {
      className: 'attachment ' + preTextClass,
      ref: "attachment"
    }, preText, react_default.a.createElement("div", {
      className: "attachment__content"
    }, react_default.a.createElement("div", {
      className: useBorderStyle ? 'clearfix attachment__container' : 'clearfix attachment__container attachment__container--' + attachment.color,
      style: useBorderStyle
    }, author, title, react_default.a.createElement("div", null, react_default.a.createElement("div", {
      className: thumb ? 'attachment__body' : 'attachment__body attachment__body--no_thumb',
      onClick: utils["H" /* handleFormattedTextClick */]
    }, attachmentText, image, fields, actions), thumb, react_default.a.createElement("div", {
      style: style.footer
    })))));
  }

}

message_attachment_defineProperty(message_attachment_MessageAttachment, "propTypes", {
  /**
   * The post id
   */
  postId: prop_types_default.a.string.isRequired,

  /**
   * The attachment to render
   */
  attachment: prop_types_default.a.object.isRequired,

  /**
   * Options specific to text formatting
   */
  options: prop_types_default.a.object,

  /**
   * Whether or not the server has an image proxy enabled
   */
  hasImageProxy: prop_types_default.a.bool.isRequired,

  /**
   * images object for dimensions
   */
  imagesMetadata: prop_types_default.a.object,
  actions: prop_types_default.a.shape({
    doPostActionWithCookie: prop_types_default.a.func.isRequired
  }).isRequired
});

const style = {
  footer: {
    clear: 'both'
  }
};
// CONCATENATED MODULE: ./components/post_view/message_attachments/message_attachment/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function message_attachment_mapStateToProps(state) {
  return {
    hasImageProxy: Object(general["getConfig"])(state).HasImageProxy === 'true'
  };
}

function message_attachment_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      doPostActionWithCookie: actions_posts["doPostActionWithCookie"]
    }, dispatch)
  };
}

/* harmony default export */ var message_attachment = (Object(es["connect"])(message_attachment_mapStateToProps, message_attachment_mapDispatchToProps)(message_attachment_MessageAttachment));
// CONCATENATED MODULE: ./components/post_view/message_attachments/message_attachment_list.jsx
function message_attachment_list_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class message_attachment_list_MessageAttachmentList extends react_default.a.PureComponent {
  render() {
    const content = [];
    this.props.attachments.forEach((attachment, i) => {
      content.push(react_default.a.createElement(message_attachment, {
        attachment: attachment,
        postId: this.props.postId,
        key: 'att_' + i,
        options: this.props.options,
        imagesMetadata: this.props.imagesMetadata
      }));
    });
    return react_default.a.createElement("div", {
      className: "attachment__list"
    }, content);
  }

}

message_attachment_list_defineProperty(message_attachment_list_MessageAttachmentList, "propTypes", {
  /**
   * The post id
   */
  postId: prop_types_default.a.string.isRequired,

  /**
   * Array of attachments to render
   */
  attachments: prop_types_default.a.array.isRequired,

  /**
   * Options specific to text formatting
   */
  options: prop_types_default.a.object,

  /**
   * Images object used for creating placeholders to prevent scroll popup
   */
  imagesMetadata: prop_types_default.a.object
});

message_attachment_list_defineProperty(message_attachment_list_MessageAttachmentList, "defaultProps", {
  imagesMetadata: {}
});
// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/posts.js
var entities_posts = __webpack_require__(61);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// CONCATENATED MODULE: ./components/post_view/post_attachment_opengraph/get_nearest_point.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
function getDistanceBW2Points(point1, point2, xAttr = 'x', yAttr = 'y') {
  return Math.sqrt(Math.pow(point1[xAttr] - point2[xAttr], 2) + Math.pow(point1[yAttr] - point2[yAttr], 2));
}
/**
  * Funtion to return nearest point of given pivot point.
  * It return two points one nearest and other nearest but having both coorditanes smaller than the given point's coordinates.
  */

function getNearestPoint(pivotPoint, points, xAttr = 'x', yAttr = 'y') {
  var nearestPoint = {};

  for (const point of points) {
    if (typeof nearestPoint[xAttr] === 'undefined' || typeof nearestPoint[yAttr] === 'undefined') {
      nearestPoint = point;
    } else if (getDistanceBW2Points(point, pivotPoint, xAttr, yAttr) < getDistanceBW2Points(nearestPoint, pivotPoint, xAttr, yAttr)) {
      // Check for bestImage
      nearestPoint = point;
    }
  }

  return nearestPoint;
}
// CONCATENATED MODULE: ./components/post_view/post_attachment_opengraph/post_attachment_opengraph.jsx
function post_attachment_opengraph_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const DIMENSIONS_NEAREST_POINT_IMAGE = {
  height: 80,
  width: 80
};
class post_attachment_opengraph_PostAttachmentOpenGraph extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    post_attachment_opengraph_defineProperty(this, "getImageDimensions", imageUrl => {
      if (!imageUrl) {
        return null;
      }

      const imagesMetadata = this.props.post.metadata.images;

      if (!imagesMetadata) {
        return null;
      }

      return imagesMetadata[imageUrl];
    });

    post_attachment_opengraph_defineProperty(this, "isLargeImage", dimensions => {
      if (!dimensions) {
        return false;
      }

      const {
        height,
        width
      } = dimensions;
      const largeImageMinRatio = 16 / 9;
      const largeImageMinWidth = 150;
      const imageRatio = width / height;
      return width >= largeImageMinWidth && imageRatio >= largeImageMinRatio;
    });

    post_attachment_opengraph_defineProperty(this, "handleRemovePreview", async () => {
      const props = Object.assign({}, this.props.post.props);
      props[constants["v" /* PostTypes */].REMOVE_LINK_PREVIEW] = 'true';
      const patchedPost = {
        id: this.props.post.id,
        props
      };
      return this.props.actions.editPost(patchedPost);
    });
  }

  renderImageToggle() {
    return react_default.a.createElement("a", {
      className: 'post__embed-visibility',
      "data-expanded": this.props.isEmbedVisible,
      "aria-label": "Toggle Embed Visibility",
      onClick: this.props.toggleEmbedVisibility
    });
  }

  renderLargeImage(imageUrl, dimensions) {
    if (!this.props.isEmbedVisible) {
      return null;
    }

    return react_default.a.createElement(size_aware_image["a" /* default */], {
      className: "attachment__image attachment__image--opengraph large_image",
      src: Object(post_utils["e" /* getImageSrc */])(imageUrl, this.props.hasImageProxy),
      dimensions: dimensions
    });
  }

  renderSmallImage(imageUrl, dimensions) {
    if (!this.props.isEmbedVisible) {
      return null;
    }

    return react_default.a.createElement("div", {
      className: "attachment__image__container--opengraph"
    }, react_default.a.createElement(size_aware_image["a" /* default */], {
      className: "attachment__image attachment__image--opengraph",
      src: Object(post_utils["e" /* getImageSrc */])(imageUrl, this.props.hasImageProxy),
      dimensions: dimensions
    }));
  }

  truncateText(text) {
    const maxLength = 300;
    const ellipsis = '...';

    if (text && text.length > maxLength) {
      return text.substring(0, maxLength - ellipsis.length) + ellipsis;
    }

    return text;
  }

  hasPreviewBeenRemoved() {
    const {
      post
    } = this.props;

    if (!post || !post.props) {
      return false;
    }

    return post.props[constants["v" /* PostTypes */].REMOVE_LINK_PREVIEW] === 'true';
  }

  render() {
    if (!this.props.previewEnabled || !this.props.enableLinkPreviews) {
      return null;
    }

    if (!this.props.post || Object(post_utils["l" /* isSystemMessage */])(this.props.post)) {
      return null;
    }

    if (this.hasPreviewBeenRemoved()) {
      return null;
    }

    const data = this.props.openGraphData;

    if (!data) {
      return null;
    }

    const imageUrl = getBestImageUrl(data, this.props.post.metadata.images);
    const imageDimensions = this.getImageDimensions(imageUrl);
    const hasLargeImage = this.isLargeImage(imageDimensions);
    let removePreviewButton;

    if (this.props.currentUserId === this.props.post.user_id) {
      removePreviewButton = react_default.a.createElement("button", {
        id: "removePreviewButton",
        type: "button",
        className: "btn-close",
        "aria-label": "Close",
        onClick: this.handleRemovePreview
      }, react_default.a.createElement("span", {
        "aria-hidden": "true"
      }, '×'));
    }

    let body;

    if (data.description || imageUrl) {
      body = react_default.a.createElement("div", {
        className: 'attachment__body attachment__body--opengraph'
      }, react_default.a.createElement("div", null, this.truncateText(data.description), ' ', imageUrl && hasLargeImage && this.renderImageToggle()), imageUrl && hasLargeImage && this.renderLargeImage(imageUrl, imageDimensions));
    }

    return react_default.a.createElement("div", {
      className: "attachment attachment--opengraph"
    }, react_default.a.createElement("div", {
      className: "attachment__content"
    }, react_default.a.createElement("div", {
      className: 'clearfix attachment__container attachment__container--opengraph'
    }, react_default.a.createElement("div", {
      className: 'attachment__body__wrap attachment__body__wrap--opengraph'
    }, react_default.a.createElement("span", {
      className: "sitename"
    }, this.truncateText(data.site_name)), removePreviewButton, react_default.a.createElement("h1", {
      className: 'attachment__title attachment__title--opengraph' + (data.title ? '' : ' is-url')
    }, react_default.a.createElement("a", {
      className: "attachment__title-link attachment__title-link--opengraph",
      href: Object(url["g" /* useSafeUrl */])(data.url || this.props.link),
      target: "_blank",
      rel: "noopener noreferrer",
      title: data.title || data.url || this.props.link
    }, this.truncateText(data.title || data.url || this.props.link))), body), imageUrl && !hasLargeImage && this.renderSmallImage(imageUrl, imageDimensions))));
  }

}

post_attachment_opengraph_defineProperty(post_attachment_opengraph_PostAttachmentOpenGraph, "propTypes", {
  /**
   * The link to display the open graph data for
   */
  link: prop_types_default.a.string.isRequired,

  /**
   * The ID of the current user
   */
  currentUserId: prop_types_default.a.string,

  /**
   * The post where this link is included
   */
  post: prop_types_default.a.object,

  /**
   * The open graph data to render
   */
  openGraphData: prop_types_default.a.object,

  /**
   * Whether or not the server has an image proxy enabled
   */
  hasImageProxy: prop_types_default.a.bool.isRequired,

  /**
   * Whether or not the server has link previews enabled.
   */
  enableLinkPreviews: prop_types_default.a.bool.isRequired,

  /**
   * Whether or not the user has link previews enabled.
   */
  previewEnabled: prop_types_default.a.bool.isRequired,

  /**
   * Whether or not the image in the OpenGraph preview has been collapsed.
   */
  isEmbedVisible: prop_types_default.a.bool,
  toggleEmbedVisibility: prop_types_default.a.func.isRequired,
  actions: prop_types_default.a.shape({
    editPost: prop_types_default.a.func.isRequired
  }).isRequired
});

function getBestImageUrl(openGraphData, imagesMetadata) {
  if (!openGraphData || !openGraphData.images || openGraphData.images.length === 0) {
    return null;
  } // Get the dimensions from the post metadata if they weren't provided by the website as part of the OpenGraph data


  const images = openGraphData.images.map(image => {
    const imageUrl = image.secure_url || image.url;

    if (image.width && image.height || !(imagesMetadata && imagesMetadata[imageUrl])) {
      // The image already includes dimensions or we don't have the missing dimensions
      return image;
    }

    return { ...image,
      height: image.height || imagesMetadata[imageUrl].height,
      width: image.width || imagesMetadata[imageUrl].width
    };
  });
  const bestImage = getNearestPoint(DIMENSIONS_NEAREST_POINT_IMAGE, images, 'width', 'height');
  return bestImage.secure_url || bestImage.url;
}
// CONCATENATED MODULE: ./components/post_view/post_attachment_opengraph/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function post_attachment_opengraph_mapStateToProps(state, ownProps) {
  const config = Object(general["getConfig"])(state);
  return {
    currentUserId: Object(users["getCurrentUserId"])(state),
    enableLinkPreviews: config.EnableLinkPreviews === 'true',
    hasImageProxy: config.HasImageProxy === 'true',
    openGraphData: Object(entities_posts["getOpenGraphMetadataForUrl"])(state, ownProps.link),
    previewEnabled: Object(preferences["getBool"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].LINK_PREVIEW_DISPLAY, true)
  };
}

function post_attachment_opengraph_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      editPost: views_posts["a" /* editPost */]
    }, dispatch)
  };
}

/* harmony default export */ var post_attachment_opengraph = (Object(es["connect"])(post_attachment_opengraph_mapStateToProps, post_attachment_opengraph_mapDispatchToProps)(post_attachment_opengraph_PostAttachmentOpenGraph));
// EXTERNAL MODULE: ./components/view_image/index.js + 6 modules
var view_image = __webpack_require__(1755);

// CONCATENATED MODULE: ./components/post_view/post_image/post_image.jsx
function post_image_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class post_image_PostImage extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    post_image_defineProperty(this, "showModal", e => {
      e.preventDefault();
      this.setState({
        showModal: true
      });
    });

    post_image_defineProperty(this, "hideModal", () => {
      this.setState({
        showModal: false
      });
    });

    this.state = {
      showModal: false
    };
  }

  render() {
    const link = post_utils["e" /* getImageSrc */](this.props.link, this.props.hasImageProxy);
    return react_default.a.createElement("div", {
      className: "post__embed-container"
    }, react_default.a.createElement(size_aware_image["a" /* default */], {
      className: "img-div attachment__image cursor--pointer",
      src: link,
      dimensions: this.props.imageMetadata,
      showLoader: true,
      onClick: this.showModal
    }), react_default.a.createElement(view_image["a" /* default */], {
      show: this.state.showModal,
      onModalDismissed: this.hideModal,
      post: this.props.post,
      startIndex: 0,
      fileInfos: [{
        has_preview_image: false,
        link,
        extension: this.props.imageMetadata.format
      }]
    }));
  }

}

post_image_defineProperty(post_image_PostImage, "propTypes", {
  hasImageProxy: prop_types_default.a.bool.isRequired,
  imageMetadata: prop_types_default.a.object.isRequired,
  link: prop_types_default.a.string.isRequired,
  post: prop_types_default.a.object.isRequired
});
// CONCATENATED MODULE: ./components/post_view/post_image/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function post_image_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const hasImageProxy = config.HasImageProxy === 'true';
  return {
    hasImageProxy
  };
}

/* harmony default export */ var post_image = (Object(es["connect"])(post_image_mapStateToProps)(post_image_PostImage));
// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var channels = __webpack_require__(15);

// EXTERNAL MODULE: ./actions/integration_actions.jsx
var integration_actions = __webpack_require__(1734);

// EXTERNAL MODULE: ./components/icon/warning_icon.jsx
var warning_icon = __webpack_require__(1621);

// CONCATENATED MODULE: ./components/youtube_video/youtube_video.jsx
function youtube_video_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const ytRegex = /(?:http|https):\/\/(?:www\.|m\.)?(?:(?:youtube\.com\/(?:(?:v\/)|(?:(?:watch|embed\/watch)(?:\/|.*v=))|(?:embed\/)|(?:user\/[^/]+\/u\/[0-9]\/)))|(?:youtu\.be\/))([^#&?]*)/;
class youtube_video_YoutubeVideo extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.updateStateFromProps = this.updateStateFromProps.bind(this);
    this.handleReceivedMetadata = this.handleReceivedMetadata.bind(this);
    this.handleMetadataError = this.handleMetadataError.bind(this);
    this.loadWithoutKey = this.loadWithoutKey.bind(this);
    this.play = this.play.bind(this);
    this.stop = this.stop.bind(this);
    this.state = {
      loaded: false,
      failed: false,
      playing: false,
      title: ''
    };
  }

  UNSAFE_componentWillMount() {
    // eslint-disable-line camelcase
    this.updateStateFromProps(this.props);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    this.updateStateFromProps(nextProps);
  }

  updateStateFromProps(props) {
    const link = props.link;
    const match = link.trim().match(ytRegex);

    if (!match || match[1].length !== 11) {
      return;
    }

    if (props.show === false) {
      this.stop();
    }

    if (props.channelId !== props.currentChannelId) {
      this.stop();
    }

    this.setState({
      videoId: match[1],
      time: this.handleYoutubeTime(link)
    });
  }

  handleYoutubeTime(link) {
    const timeRegex = /[\\?&](t|start|time_continue)=([0-9]+h)?([0-9]+m)?([0-9]+s?)/;
    const time = link.match(timeRegex);

    if (!time || !time[0]) {
      return '';
    }

    const hours = time[2] ? time[2].match(/([0-9]+)h/) : null;
    const minutes = time[3] ? time[3].match(/([0-9]+)m/) : null;
    const seconds = time[4] ? time[4].match(/([0-9]+)s?/) : null;
    let ticks = 0;

    if (hours && hours[1]) {
      ticks += parseInt(hours[1], 10) * 3600;
    }

    if (minutes && minutes[1]) {
      ticks += parseInt(minutes[1], 10) * 60;
    }

    if (seconds && seconds[1]) {
      ticks += parseInt(seconds[1], 10);
    }

    return '&start=' + ticks.toString();
  }

  componentDidMount() {
    const key = this.props.googleDeveloperKey;

    if (key) {
      Object(integration_actions["a" /* getYoutubeVideoInfo */])(key, this.state.videoId, this.handleReceivedMetadata, this.handleMetadataError);
    } else {
      this.loadWithoutKey();
    }
  }

  loadWithoutKey() {
    this.setState({
      loaded: true,
      thumb: post_utils["e" /* getImageSrc */]('https://i.ytimg.com/vi/' + this.state.videoId + '/hqdefault.jpg', this.props.hasImageProxy)
    });
  }

  handleMetadataError() {
    this.setState({
      failed: true,
      loaded: true,
      title: utils["gb" /* localizeMessage */]('youtube_video.notFound', 'Video not found')
    });
  }

  handleReceivedMetadata(data) {
    if (!data || !data.items || !data.items.length || !data.items[0].snippet) {
      this.setState({
        failed: true,
        loaded: true,
        title: utils["gb" /* localizeMessage */]('youtube_video.notFound', 'Video not found')
      });
      return null;
    }

    const metadata = data.items[0].snippet;
    let thumb = 'https://i.ytimg.com/vi/' + this.state.videoId + '/hqdefault.jpg';

    if (metadata.liveBroadcastContent === 'live') {
      thumb = 'https://i.ytimg.com/vi/' + this.state.videoId + '/hqdefault_live.jpg';
    }

    this.setState({
      loaded: true,
      receivedYoutubeData: true,
      title: metadata.title,
      thumb: post_utils["e" /* getImageSrc */](thumb, this.props.hasImageProxy)
    });
    return null;
  }

  play() {
    this.setState({
      playing: true
    });
  }

  stop() {
    this.setState({
      playing: false
    });
  }

  render() {
    if (!this.state.loaded) {
      return react_default.a.createElement("div", {
        className: "post__embed-container"
      }, react_default.a.createElement("div", {
        className: "video-loading"
      }));
    }

    let header;

    if (this.state.title) {
      header = react_default.a.createElement("h4", null, react_default.a.createElement("span", {
        className: "video-type"
      }, 'YouTube - '), react_default.a.createElement("span", {
        className: "video-title"
      }, react_default.a.createElement("a", {
        href: this.props.link,
        target: "blank",
        rel: "noopener noreferrer"
      }, this.state.title)));
    }

    let content;

    if (this.state.failed) {
      content = react_default.a.createElement("div", null, react_default.a.createElement("div", {
        className: "video-thumbnail__container"
      }, react_default.a.createElement("div", {
        className: "video-thumbnail__error"
      }, react_default.a.createElement("div", null, react_default.a.createElement(warning_icon["a" /* default */], {
        additionalClassName: "fa-2x"
      })), react_default.a.createElement("div", null, utils["gb" /* localizeMessage */]('youtube_video.notFound', 'Video not found')))));
    } else if (this.state.playing) {
      content = react_default.a.createElement("iframe", {
        src: 'https://www.youtube.com/embed/' + this.state.videoId + '?autoplay=1&autohide=1&border=0&wmode=opaque&fs=1&enablejsapi=1' + this.state.time,
        width: "480px",
        height: "360px",
        type: "text/html",
        frameBorder: "0",
        allowFullScreen: "allowfullscreen"
      });
    } else {
      content = react_default.a.createElement("div", {
        className: "embed-responsive embed-responsive-4by3 video-div__placeholder"
      }, react_default.a.createElement("div", {
        className: "video-thumbnail__container"
      }, react_default.a.createElement("img", {
        alt: "youtube video thumbnail",
        className: "video-thumbnail",
        src: this.state.thumb
      }), react_default.a.createElement("div", {
        className: "block"
      }, react_default.a.createElement("span", {
        className: "play-button"
      }, react_default.a.createElement("span", null)))));
    }

    return react_default.a.createElement("div", {
      className: "post__embed-container"
    }, react_default.a.createElement("div", null, header, react_default.a.createElement("div", {
      className: "video-div embed-responsive-item",
      onClick: this.play
    }, content)));
  }

  static isYoutubeLink(link) {
    return link.trim().match(ytRegex);
  }

}

youtube_video_defineProperty(youtube_video_YoutubeVideo, "propTypes", {
  channelId: prop_types_default.a.string.isRequired,
  currentChannelId: prop_types_default.a.string.isRequired,
  hasImageProxy: prop_types_default.a.bool.isRequired,
  link: prop_types_default.a.string.isRequired,
  show: prop_types_default.a.bool.isRequired,
  googleDeveloperKey: prop_types_default.a.string
});
// CONCATENATED MODULE: ./components/youtube_video/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function youtube_video_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  return {
    currentChannelId: Object(channels["getCurrentChannelId"])(state),
    googleDeveloperKey: config.GoogleDeveloperKey,
    hasImageProxy: config.HasImageProxy === 'true'
  };
}

/* harmony default export */ var youtube_video = (Object(es["connect"])(youtube_video_mapStateToProps)(youtube_video_YoutubeVideo));
// CONCATENATED MODULE: ./components/post_view/post_body_additional_content/post_body_additional_content.jsx
function post_body_additional_content_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class post_body_additional_content_PostBodyAdditionalContent extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    post_body_additional_content_defineProperty(this, "toggleEmbedVisibility", () => {
      this.props.actions.toggleEmbedVisibility(this.props.post.id);
    });

    post_body_additional_content_defineProperty(this, "getEmbed", () => {
      const {
        metadata
      } = this.props.post;

      if (!metadata || !metadata.embeds || metadata.embeds.length === 0) {
        return null;
      }

      return metadata.embeds[0];
    });

    post_body_additional_content_defineProperty(this, "isEmbedToggleable", embed => {
      return embed.type === 'image' || embed.type === 'opengraph' && youtube_video.isYoutubeLink(embed.url);
    });

    post_body_additional_content_defineProperty(this, "renderEmbed", embed => {
      switch (embed.type) {
        case 'image':
          if (!this.props.isEmbedVisible) {
            return null;
          }

          return react_default.a.createElement(post_image, {
            imageMetadata: this.props.post.metadata.images[embed.url],
            link: embed.url,
            post: this.props.post
          });

        case 'message_attachment':
          {
            let attachments = [];

            if (this.props.post.props && this.props.post.props.attachments) {
              attachments = this.props.post.props.attachments;
            }

            return react_default.a.createElement(message_attachment_list_MessageAttachmentList, {
              attachments: attachments,
              postId: this.props.post.id,
              options: this.props.options,
              imagesMetadata: this.props.post.metadata.images
            });
          }

        case 'opengraph':
          if (youtube_video.isYoutubeLink(embed.url)) {
            if (!this.props.isEmbedVisible) {
              return null;
            }

            return react_default.a.createElement(youtube_video, {
              channelId: this.props.post.channel_id,
              link: embed.url,
              show: this.props.isEmbedVisible
            });
          }

          return react_default.a.createElement(post_attachment_opengraph, {
            link: embed.url,
            isEmbedVisible: this.props.isEmbedVisible,
            post: this.props.post,
            toggleEmbedVisibility: this.toggleEmbedVisibility
          });

        default:
          return null;
      }
    });

    post_body_additional_content_defineProperty(this, "renderToggle", prependToggle => {
      return react_default.a.createElement("a", {
        key: "toggle",
        className: `post__embed-visibility ${prependToggle ? 'pull-left' : ''}`,
        "data-expanded": this.props.isEmbedVisible,
        "aria-label": "Toggle Embed Visibility",
        onClick: this.toggleEmbedVisibility
      });
    });
  }

  render() {
    const embed = this.getEmbed();

    if (embed) {
      const toggleable = this.isEmbedToggleable(embed);
      const prependToggle = /^\s*https?:\/\/.*$/.test(this.props.post.message);
      return react_default.a.createElement("div", null, toggleable && prependToggle && this.renderToggle(true), this.props.children, toggleable && !prependToggle && this.renderToggle(false), this.renderEmbed(embed));
    }

    return this.props.children;
  }

}

post_body_additional_content_defineProperty(post_body_additional_content_PostBodyAdditionalContent, "propTypes", {
  /**
   * The post to render the content of
   */
  post: prop_types_default.a.object.isRequired,

  /**
   * The post's message
   */
  children: prop_types_default.a.element,

  /**
   * Flag passed down to PostBodyAdditionalContent for determining if post embed is visible
   */
  isEmbedVisible: prop_types_default.a.bool,

  /**
   * Options specific to text formatting
   */
  options: prop_types_default.a.object,
  actions: prop_types_default.a.shape({
    toggleEmbedVisibility: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/post_view/post_body_additional_content/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function post_body_additional_content_mapStateToProps(state, ownProps) {
  return {
    isEmbedVisible: Object(posts["b" /* isEmbedVisible */])(state, ownProps.post.id)
  };
}

function post_body_additional_content_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      toggleEmbedVisibility: post_actions["o" /* toggleEmbedVisibility */]
    }, dispatch)
  };
}

/* harmony default export */ var post_body_additional_content = __webpack_exports__["a"] = (Object(es["connect"])(post_body_additional_content_mapStateToProps, post_body_additional_content_mapDispatchToProps)(post_body_additional_content_PostBodyAdditionalContent));

/***/ }),

/***/ 1962:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var entities_channels = __webpack_require__(15);

// EXTERNAL MODULE: ./actions/channel_actions.jsx
var channel_actions = __webpack_require__(1593);

// EXTERNAL MODULE: ./mattermost-redux/actions/teams.js
var actions_teams = __webpack_require__(299);

// EXTERNAL MODULE: ./mattermost-redux/actions/channels.js
var actions_channels = __webpack_require__(70);

// EXTERNAL MODULE: ./selectors/rhs.jsx
var rhs = __webpack_require__(60);

// CONCATENATED MODULE: ./actions/views/profile_popover.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function getMembershipForCurrentEntities(userId) {
  return async (dispatch, getState) => {
    const state = getState();
    const currentTeamId = Object(teams["getCurrentTeamId"])(state);
    const selectedPost = Object(rhs["q" /* getSelectedPost */])(state);
    const currentChannel = Object(entities_channels["getCurrentChannel"])(state);
    let channelId;

    if (selectedPost.exists === false) {
      channelId = currentChannel.id;
    } else {
      channelId = selectedPost.channel_id;
    }

    return Promise.all([dispatch(Object(actions_teams["getTeamMember"])(currentTeamId, userId)), dispatch(Object(actions_channels["getChannelMember"])(channelId, userId))]);
  };
}
// EXTERNAL MODULE: ./actions/views/modals.js
var modals = __webpack_require__(1578);

// EXTERNAL MODULE: ./selectors/general.js
var general = __webpack_require__(232);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tooltip.js
var Tooltip = __webpack_require__(1998);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Popover.js
var Popover = __webpack_require__(1999);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./mattermost-redux/utils/event_emitter.js
var event_emitter = __webpack_require__(414);
var event_emitter_default = /*#__PURE__*/__webpack_require__.n(event_emitter);

// EXTERNAL MODULE: ./components/local_date_time/index.js + 1 modules
var local_date_time = __webpack_require__(2269);

// EXTERNAL MODULE: ./components/user_settings/modal/index.js + 1 modules
var modal = __webpack_require__(1757);

// EXTERNAL MODULE: ./utils/browser_history.jsx
var browser_history = __webpack_require__(114);

// EXTERNAL MODULE: ./actions/global_actions.jsx
var global_actions = __webpack_require__(1567);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./plugins/pluggable/index.js + 1 modules
var pluggable = __webpack_require__(1647);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Modal.js
var Modal = __webpack_require__(1972);

// EXTERNAL MODULE: ./mattermost-redux/utils/user_utils.js
var user_utils = __webpack_require__(104);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/common.js
var common = __webpack_require__(207);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var entities_general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/i18n.js
var i18n = __webpack_require__(432);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/roles.js
var roles = __webpack_require__(90);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var mattermost_redux_constants = __webpack_require__(17);

// EXTERNAL MODULE: ./mattermost-redux/utils/channel_utils.js
var channel_utils = __webpack_require__(178);

// EXTERNAL MODULE: ./mattermost-redux/actions/errors.js
var errors = __webpack_require__(105);

// EXTERNAL MODULE: ./components/svg/globe_icon.jsx
var globe_icon = __webpack_require__(1653);

// EXTERNAL MODULE: ./components/svg/lock_icon.jsx
var lock_icon = __webpack_require__(1654);

// EXTERNAL MODULE: ./components/svg/archive_icon.jsx
var archive_icon = __webpack_require__(1691);

// EXTERNAL MODULE: ./stores/redux_store.jsx + 3 modules
var redux_store = __webpack_require__(14);

// EXTERNAL MODULE: ./components/suggestion/provider.jsx
var provider = __webpack_require__(1597);

// EXTERNAL MODULE: ./components/suggestion/suggestion.jsx
var suggestion = __webpack_require__(1598);

// CONCATENATED MODULE: ./components/suggestion/search_channel_with_permissions_provider.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



















class search_channel_with_permissions_provider_SearchChannelWithPermissionsSuggestion extends suggestion["a" /* default */] {
  static get propTypes() {
    return { ...super.propTypes
    };
  }

  render() {
    const {
      item,
      isSelection
    } = this.props;
    const channel = item.channel;
    const channelIsArchived = channel.delete_at && channel.delete_at !== 0;
    let className = 'mentions__name';

    if (isSelection) {
      className += ' suggestion--selected';
    }

    const displayName = channel.display_name;
    let icon = null;

    if (channelIsArchived) {
      icon = react_default.a.createElement(archive_icon["a" /* default */], {
        className: "icon icon__archive"
      });
    } else if (channel.type === constants["g" /* Constants */].OPEN_CHANNEL) {
      icon = react_default.a.createElement(globe_icon["a" /* default */], {
        className: "icon icon__globe icon--body"
      });
    } else if (channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
      icon = react_default.a.createElement(lock_icon["a" /* default */], {
        className: "icon icon__lock icon--body"
      });
    }

    return react_default.a.createElement("div", _extends({
      onClick: this.handleClick,
      className: className
    }, suggestion["a" /* default */].baseProps), icon, displayName);
  }

}

let prefix = '';

function channelSearchSorter(wrappedA, wrappedB) {
  const aIsArchived = wrappedA.channel.delete_at ? wrappedA.channel.delete_at !== 0 : false;
  const bIsArchived = wrappedB.channel.delete_at ? wrappedB.channel.delete_at !== 0 : false;

  if (aIsArchived && !bIsArchived) {
    return 1;
  } else if (!aIsArchived && bIsArchived) {
    return -1;
  }

  const locale = Object(i18n["getCurrentUserLocale"])(redux_store["a" /* default */].getState());
  const a = wrappedA.channel;
  const b = wrappedB.channel;
  const aDisplayName = a.display_name.toLowerCase();
  const bDisplayName = b.display_name.toLowerCase();
  const aStartsWith = aDisplayName.startsWith(prefix);
  const bStartsWith = bDisplayName.startsWith(prefix);

  if (aStartsWith && bStartsWith) {
    return Object(channel_utils["sortChannelsByTypeAndDisplayName"])(locale, a, b);
  } else if (!aStartsWith && !bStartsWith) {
    return Object(channel_utils["sortChannelsByTypeAndDisplayName"])(locale, a, b);
  } else if (aStartsWith) {
    return -1;
  }

  return 1;
}

class search_channel_with_permissions_provider_SearchChannelWithPermissionsProvider extends provider["a" /* default */] {
  makeChannelSearchFilter(channelPrefix) {
    const channelPrefixLower = channelPrefix.toLowerCase();
    return channel => {
      const state = redux_store["a" /* default */].getState();
      const channelId = channel.id;
      const teamId = Object(teams["getCurrentTeamId"])(state);
      const searchString = channel.display_name;

      if (channel.type === constants["g" /* Constants */].OPEN_CHANNEL && Object(roles["haveIChannelPermission"])(state, {
        channel: channelId,
        team: teamId,
        permission: mattermost_redux_constants["Permissions"].MANAGE_PUBLIC_CHANNEL_MEMBERS
      })) {
        return searchString.toLowerCase().includes(channelPrefixLower);
      } else if (channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL && Object(roles["haveIChannelPermission"])(state, {
        channel: channelId,
        team: teamId,
        permission: mattermost_redux_constants["Permissions"].MANAGE_PRIVATE_CHANNEL_MEMBERS
      })) {
        return searchString.toLowerCase().includes(channelPrefixLower);
      }

      return false;
    };
  }

  handlePretextChanged(channelPrefix, resultsCallback) {
    if (channelPrefix) {
      prefix = channelPrefix;
      this.startNewRequest(channelPrefix);
      const state = redux_store["a" /* default */].getState(); // Dispatch suggestions for local data

      const channels = Object(entities_channels["getChannelsInCurrentTeam"])(state);
      this.formatChannelsAndDispatch(channelPrefix, resultsCallback, channels); // Fetch data from the server and dispatch

      this.fetchChannels(channelPrefix, resultsCallback);
    }

    return true;
  }

  async fetchChannels(channelPrefix, resultsCallback) {
    const state = redux_store["a" /* default */].getState();
    const teamId = Object(teams["getCurrentTeamId"])(state);

    if (!teamId) {
      return;
    }

    const channelsAsync = actions_channels["autocompleteChannelsForSearch"](teamId, channelPrefix)(redux_store["a" /* default */].dispatch, redux_store["a" /* default */].getState);
    let channelsFromServer = [];

    try {
      const {
        data
      } = await channelsAsync;
      channelsFromServer = data;
    } catch (err) {
      redux_store["a" /* default */].dispatch(Object(errors["logError"])(err));
    }

    if (this.shouldCancelDispatch(channelPrefix)) {
      return;
    }

    const channels = Object(entities_channels["getChannelsInCurrentTeam"])(state).concat(channelsFromServer);
    this.formatChannelsAndDispatch(channelPrefix, resultsCallback, channels);
  }

  formatChannelsAndDispatch(channelPrefix, resultsCallback, allChannels) {
    const channels = [];
    const state = redux_store["a" /* default */].getState();
    const members = Object(common["getMyChannelMemberships"])(state);

    if (this.shouldCancelDispatch(channelPrefix)) {
      return;
    }

    const completedChannels = {};
    const channelFilter = this.makeChannelSearchFilter(channelPrefix);
    const config = Object(entities_general["getConfig"])(state);
    const viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';

    for (const id of Object.keys(allChannels)) {
      const channel = allChannels[id];

      if (!channel) {
        continue;
      }

      if (completedChannels[channel.id]) {
        continue;
      }

      if (channelFilter(channel)) {
        const newChannel = Object.assign({}, channel);
        const channelIsArchived = channel.delete_at !== 0;
        const wrappedChannel = {
          channel: newChannel,
          name: newChannel.name,
          deactivated: false
        };

        if (!viewArchivedChannels && channelIsArchived) {
          continue;
        } else if (!members[channel.id]) {
          continue;
        } else if (channelIsArchived && !members[channel.id]) {
          continue;
        } else if (channel.type === constants["g" /* Constants */].OPEN_CHANNEL) {
          wrappedChannel.type = constants["g" /* Constants */].OPEN_CHANNEL;
        } else if (channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
          wrappedChannel.type = constants["g" /* Constants */].PRIVATE_CHANNEL;
        } else {
          continue;
        }

        completedChannels[channel.id] = true;
        channels.push(wrappedChannel);
      }
    }

    const channelNames = channels.sort(channelSearchSorter).map(wrappedChannel => wrappedChannel.channel.name);
    resultsCallback({
      matchedPretext: channelPrefix,
      terms: channelNames,
      items: channels,
      component: search_channel_with_permissions_provider_SearchChannelWithPermissionsSuggestion
    });
  }

}
// EXTERNAL MODULE: ./components/suggestion/suggestion_box.jsx
var suggestion_box = __webpack_require__(1652);

// EXTERNAL MODULE: ./components/suggestion/suggestion_list.jsx
var suggestion_list = __webpack_require__(1667);

// CONCATENATED MODULE: ./components/add_user_to_channel_modal/add_user_to_channel_modal.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class add_user_to_channel_modal_AddUserToChannelModal extends react_default.a.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "enableChannelProvider", () => {
      this.suggestionProviders[0].disableDispatches = false;
    });

    _defineProperty(this, "focusTextbox", () => {
      if (this.channelSearchBox == null) {
        return;
      }

      const textbox = this.channelSearchBox.getTextbox();

      if (document.activeElement !== textbox) {
        textbox.focus();
        Object(utils["kb" /* placeCaretAtEnd */])(textbox);
      }
    });

    _defineProperty(this, "onInputChange", e => {
      this.setState({
        text: e.target.value,
        selectedChannelId: null
      });
    });

    _defineProperty(this, "onHide", () => {
      this.setState({
        show: false
      });
      this.props.onHide();
    });

    _defineProperty(this, "setSearchBoxRef", input => {
      this.channelSearchBox = input;
      this.focusTextbox();
    });

    _defineProperty(this, "handleSubmitError", error => {
      if (error) {
        this.setState({
          submitError: error.message,
          saving: false
        });
      }
    });

    _defineProperty(this, "didSelectChannel", selection => {
      const channel = selection.channel;
      const userId = this.props.user.id;
      this.setState({
        text: channel.display_name,
        selectedChannelId: channel.id,
        checkingForMembership: true,
        submitError: ''
      });
      this.props.actions.getChannelMember(channel.id, userId).then(() => {
        this.setState({
          checkingForMembership: false
        });
      });
    });

    _defineProperty(this, "handleSubmit", e => {
      if (e && e.preventDefault) {
        e.preventDefault();
      }

      const channelId = this.state.selectedChannelId;
      const user = this.props.user;

      if (!channelId) {
        return;
      }

      if (this.isUserMemberOfChannel(channelId) || this.state.saving) {
        return;
      }

      this.setState({
        saving: true
      });
      this.props.actions.addChannelMember(channelId, user.id).then(({
        error
      }) => {
        if (error) {
          this.handleSubmitError(error);
        } else {
          this.onHide();
        }
      });
    });

    _defineProperty(this, "isUserMemberOfChannel", channelId => {
      const user = this.props.user;
      const memberships = this.props.channelMembers;

      if (!channelId) {
        return false;
      }

      if (!memberships[channelId]) {
        return false;
      }

      return Boolean(memberships[channelId][user.id]);
    });

    this.state = {
      /**
       * Whether or not the modal is visible
       */
      show: true,

      /**
       * Whether or not a request to add the user is in progress
       */
      saving: false,

      /**
       * Whether or not a request to check for the user's channel membership
       * is in progress
       */
      checkingForMembership: false,

      /**
       * The user input in the channel search box
       */
      text: '',

      /**
       * The id for the channel that is selected
       */
      selectedChannelId: null,

      /**
       * An error to display when the add request fails
       */
      submitError: ''
    };
    this.suggestionProviders = [new search_channel_with_permissions_provider_SearchChannelWithPermissionsProvider()];
    this.enableChannelProvider();
  }

  render() {
    const user = this.props.user;
    const channelId = this.state.selectedChannelId;
    const targetUserIsMemberOfSelectedChannel = this.isUserMemberOfChannel(channelId);
    let name = Object(user_utils["getFullName"])(user);

    if (!name) {
      name = `@${user.username}`;
    }

    let errorMsg;

    if (!this.state.saving) {
      if (this.state.submitError) {
        errorMsg = react_default.a.createElement("label", {
          id: "add-user-to-channel-modal__invite-error",
          className: "modal__error has-error control-label"
        }, this.state.submitError);
      } else if (targetUserIsMemberOfSelectedChannel) {
        errorMsg = react_default.a.createElement("label", {
          id: "add-user-to-channel-modal__user-is-member",
          className: "modal__error has-error control-label"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "add_user_to_channel_modal.membershipExistsError",
          defaultMessage: "{name} is already a member of that channel",
          values: {
            name
          }
        }));
      }
    }

    const help = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "add_user_to_channel_modal.help",
      defaultMessage: "Type to find a channel. Use \u2191\u2193 to browse, \u21B5 to select, ESC to dismiss."
    });
    const content = react_default.a.createElement(suggestion_box["a" /* default */], {
      ref: this.setSearchBoxRef,
      className: "form-control focused",
      onChange: this.onInputChange,
      value: this.state.text,
      onKeyDown: this.handleKeyDown,
      onItemSelected: this.didSelectChannel,
      listComponent: suggestion_list["a" /* default */],
      maxLength: "64",
      providers: this.suggestionProviders,
      listStyle: "bottom",
      completeOnTab: false,
      renderDividers: false,
      delayInputUpdate: true,
      openWhenEmpty: true
    });
    const shouldDisableAddButton = targetUserIsMemberOfSelectedChannel || this.state.checkingForMembership || Boolean(!this.state.selectedChannelId) || this.state.saving;
    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "modal--overflow",
      show: this.state.show,
      onHide: this.onHide,
      onExited: this.props.onHide,
      ref: "modal",
      enforceFocus: true,
      role: "dialog",
      "aria-labelledby": "addChannelModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "addChannelModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "add_user_to_channel_modal.title",
      defaultMessage: "Add {name} to a channel",
      values: {
        name
      }
    }))), react_default.a.createElement("form", {
      role: "form",
      onSubmit: this.handleSubmit
    }, react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement("div", {
      className: "modal__hint"
    }, help), content, react_default.a.createElement("div", null, errorMsg, react_default.a.createElement("br", null))), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-link",
      onClick: this.onHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "add_user_to_channel_modal.cancel",
      defaultMessage: "Cancel"
    })), react_default.a.createElement("button", {
      type: "button",
      id: "add-user-to-channel-modal__add-button",
      className: "btn btn-primary",
      onClick: this.handleSubmit,
      disabled: shouldDisableAddButton
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "add_user_to_channel_modal.add",
      defaultMessage: "Add"
    })))));
  }

}

_defineProperty(add_user_to_channel_modal_AddUserToChannelModal, "propTypes", {
  /**
   * Function that's called when modal is closed
   */
  onHide: prop_types_default.a.func.isRequired,

  /**
   * The user that is being added to a channel
   */
  user: prop_types_default.a.object.isRequired,

  /**
   * Object used to determine if the user
   * is a member of a given channel
   */
  channelMembers: prop_types_default.a.object.isRequired,
  actions: prop_types_default.a.shape({
    /**
     * Function to add the user to a channel
     */
    addChannelMember: prop_types_default.a.func.isRequired,

    /**
     * Function to fetch the user's channel membership
     */
    getChannelMember: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/add_user_to_channel_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function mapStateToProps(state) {
  const channelMembers = Object(entities_channels["getChannelMembersInChannels"])(state) || {};
  return {
    channelMembers
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      addChannelMember: actions_channels["addChannelMember"],
      getChannelMember: actions_channels["getChannelMember"]
    }, dispatch)
  };
}

/* harmony default export */ var add_user_to_channel_modal = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(add_user_to_channel_modal_AddUserToChannelModal));
// EXTERNAL MODULE: ./components/toggle_modal_button_redux/index.js + 1 modules
var toggle_modal_button_redux = __webpack_require__(1824);

// CONCATENATED MODULE: ./components/profile_popover/profile_popover.jsx
function profile_popover_extends() { profile_popover_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return profile_popover_extends.apply(this, arguments); }

function profile_popover_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.














/**
 * The profile popover, or hovercard, that appears with user information when clicking
 * on the username or profile picture of a user.
 */

class profile_popover_ProfilePopover extends react_default.a.PureComponent {
  static getComponentName() {
    return 'ProfilePopover';
  }

  constructor(props) {
    super(props);
    this.handleShowDirectChannel = this.handleShowDirectChannel.bind(this);
    this.handleMentionKeyClick = this.handleMentionKeyClick.bind(this);
    this.handleEditAccountSettings = this.handleEditAccountSettings.bind(this);
    this.state = {
      loadingDMChannel: -1
    };
  }

  componentDidMount() {
    this.props.actions.getMembershipForCurrentEntities(this.props.userId);
  }

  handleShowDirectChannel(e) {
    const {
      actions
    } = this.props;
    e.preventDefault();

    if (!this.props.user) {
      return;
    }

    const user = this.props.user;

    if (this.state.loadingDMChannel !== -1) {
      return;
    }

    this.setState({
      loadingDMChannel: user.id
    });
    actions.openDirectChannelToUserId(user.id).then(result => {
      if (!result.error) {
        if (utils["Y" /* isMobile */]()) {
          global_actions["c" /* emitCloseRightHandSide */]();
        }

        this.setState({
          loadingDMChannel: -1
        });

        if (this.props.hide) {
          this.props.hide();
        }

        browser_history["a" /* browserHistory */].push(`${this.props.teamUrl}/messages/@${user.username}`);
      }
    });
  }

  handleMentionKeyClick(e) {
    e.preventDefault();

    if (!this.props.user) {
      return;
    }

    if (this.props.hide) {
      this.props.hide();
    }

    event_emitter_default.a.emit('mention_key_click', this.props.user.username, this.props.isRHS);
  }

  handleEditAccountSettings(e) {
    e.preventDefault();

    if (!this.props.user) {
      return;
    }

    if (this.props.hide) {
      this.props.hide();
    }

    this.props.actions.openModal({
      ModalId: constants["p" /* ModalIdentifiers */].USER_SETTINGS,
      dialogType: modal["a" /* default */]
    });
  }

  render() {
    if (!this.props.user) {
      return null;
    }

    const popoverProps = Object.assign({}, this.props);
    delete popoverProps.user;
    delete popoverProps.userId;
    delete popoverProps.src;
    delete popoverProps.status;
    delete popoverProps.hideStatus;
    delete popoverProps.isBusy;
    delete popoverProps.hide;
    delete popoverProps.isRHS;
    delete popoverProps.hasMention;
    delete popoverProps.dispatch;
    delete popoverProps.enableTimezone;
    delete popoverProps.currentUserId;
    delete popoverProps.currentTeamId;
    delete popoverProps.teamUrl;
    delete popoverProps.actions;
    delete popoverProps.isTeamAdmin;
    delete popoverProps.isChannelAdmin;
    delete popoverProps.canManageAnyChannelMembersInCurrentTeam;
    delete popoverProps.intl;
    const {
      formatMessage
    } = this.props.intl;
    var dataContent = [];
    dataContent.push(react_default.a.createElement("img", {
      className: "user-popover__image",
      alt: `${this.props.user.username || 'user'} profile image`,
      src: this.props.src,
      height: "128",
      width: "128",
      key: "user-popover-image"
    }));
    const fullname = utils["A" /* getFullName */](this.props.user);

    if (fullname || this.props.user.position) {
      dataContent.push(react_default.a.createElement("hr", {
        key: "user-popover-hr",
        className: "divider divider--expanded"
      }));
    }

    if (fullname) {
      dataContent.push(react_default.a.createElement(OverlayTrigger["a" /* default */], {
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        placement: "top",
        overlay: react_default.a.createElement(Tooltip["a" /* default */], {
          id: "fullNameTooltip"
        }, fullname),
        key: "user-popover-fullname"
      }, react_default.a.createElement("div", {
        className: "overflow--ellipsis text-nowrap"
      }, react_default.a.createElement("strong", null, fullname))));
    }

    if (this.props.user.is_bot) {
      dataContent.push(react_default.a.createElement("div", {
        key: "bot-description",
        className: "overflow--ellipsis text-nowrap"
      }, this.props.user.bot_description));
    }

    if (this.props.user.position) {
      const position = this.props.user.position.substring(0, constants["N" /* default */].MAX_POSITION_LENGTH);
      dataContent.push(react_default.a.createElement(OverlayTrigger["a" /* default */], {
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        placement: "top",
        overlay: react_default.a.createElement(Tooltip["a" /* default */], {
          id: "positionTooltip"
        }, position),
        key: "user-popover-position"
      }, react_default.a.createElement("div", {
        className: "overflow--ellipsis text-nowrap padding-bottom padding-top half"
      }, position)));
    }

    const email = this.props.user.email;

    if (email && !this.props.user.is_bot) {
      dataContent.push(react_default.a.createElement("hr", {
        key: "user-popover-hr2",
        className: "divider divider--expanded"
      }));
      dataContent.push(react_default.a.createElement("div", {
        "data-toggle": "tooltip",
        title: email,
        key: "user-popover-email"
      }, react_default.a.createElement("a", {
        href: 'mailto:' + email,
        className: "text-nowrap text-lowercase user-popover__email padding-bottom half"
      }, email)));
    }

    dataContent.push(react_default.a.createElement(pluggable["a" /* default */], {
      key: "profilePopoverPluggable2",
      pluggableName: "PopoverUserAttributes",
      user: this.props.user,
      status: this.props.hideStatus ? null : this.props.status
    }));

    if (this.props.enableTimezone && this.props.user.timezone) {
      dataContent.push(react_default.a.createElement("div", {
        key: "user-popover-local-time",
        className: "padding-bottom half"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "user_profile.account.localTime",
        defaultMessage: "Local Time: "
      }), react_default.a.createElement(local_date_time["a" /* default */], {
        userTimezone: this.props.user.timezone
      })));
    }

    if (this.props.user.id === this.props.currentUserId) {
      dataContent.push(react_default.a.createElement("div", {
        "data-toggle": "tooltip",
        key: "user-popover-settings",
        className: "popover__row first"
      }, react_default.a.createElement("a", {
        href: "#",
        onClick: this.handleEditAccountSettings
      }, react_default.a.createElement("i", {
        className: "fa fa-pencil-square-o",
        title: formatMessage({
          id: 'generic_icons.edit',
          defaultMessage: 'Edit Icon'
        })
      }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "user_profile.account.editSettings",
        defaultMessage: "Edit Account Settings"
      }))));
    }

    if (this.props.user.id !== this.props.currentUserId) {
      dataContent.push(react_default.a.createElement("div", {
        "data-toggle": "tooltip",
        key: "user-popover-dm",
        className: "popover__row first"
      }, react_default.a.createElement("a", {
        href: "#",
        className: "text-nowrap user-popover__email",
        onClick: this.handleShowDirectChannel
      }, react_default.a.createElement("i", {
        className: "fa fa-paper-plane",
        title: formatMessage({
          id: 'user_profile.send.dm.icon',
          defaultMessage: 'Send Message Icon'
        })
      }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "user_profile.send.dm",
        defaultMessage: "Send Message"
      }))));

      if (this.props.canManageAnyChannelMembersInCurrentTeam) {
        const addToChannelMessage = formatMessage({
          id: 'user_profile.add_user_to_channel',
          defaultMessage: 'Add to a Channel'
        });
        dataContent.push(react_default.a.createElement("div", {
          "data-toggle": "tooltip",
          className: "popover__row first",
          key: "user-popover-add-to-channel"
        }, react_default.a.createElement("a", {
          href: "#",
          className: "text-nowrap"
        }, react_default.a.createElement(toggle_modal_button_redux["a" /* default */], {
          accessibilityLabel: addToChannelMessage,
          ref: "addUserToChannelModalButton",
          modalId: constants["p" /* ModalIdentifiers */].ADD_USER_TO_CHANNEL,
          role: "menuitem",
          dialogType: add_user_to_channel_modal,
          dialogProps: {
            user: this.props.user
          },
          onClick: this.props.hide
        }, react_default.a.createElement("i", {
          className: "fa fa-user-plus",
          title: formatMessage({
            id: 'user_profile.add_user_to_channel.icon',
            defaultMessage: 'Add User to Channel Icon'
          })
        }), addToChannelMessage))));
      }
    }

    dataContent.push(react_default.a.createElement(pluggable["a" /* default */], {
      key: "profilePopoverPluggable3",
      pluggableName: "PopoverUserActions",
      user: this.props.user,
      status: this.props.hideStatus ? null : this.props.status
    }));
    let roleTitle;

    if (this.props.user.is_bot) {
      roleTitle = react_default.a.createElement("span", {
        className: "user-popover__role"
      }, utils["gb" /* localizeMessage */]('bots.is_bot', 'BOT'));
    } else if (utils["ab" /* isSystemAdmin */](this.props.user.roles)) {
      roleTitle = react_default.a.createElement("span", {
        className: "user-popover__role"
      }, utils["gb" /* localizeMessage */]('admin.permissions.roles.system_admin.name', 'System Admin'));
    } else if (this.props.isTeamAdmin) {
      roleTitle = react_default.a.createElement("span", {
        className: "user-popover__role"
      }, utils["gb" /* localizeMessage */]('admin.permissions.roles.team_admin.name', 'Team Admin'));
    } else if (this.props.isChannelAdmin) {
      roleTitle = react_default.a.createElement("span", {
        className: "user-popover__role"
      }, utils["gb" /* localizeMessage */]('admin.permissions.roles.channel_admin.name', 'Channel Admin'));
    }

    let title = `@${this.props.user.username}`;

    if (this.props.hasMention) {
      title = react_default.a.createElement("a", {
        onClick: this.handleMentionKeyClick
      }, title);
    }

    title = react_default.a.createElement("span", null, react_default.a.createElement("span", {
      className: "user-popover__username"
    }, title), roleTitle);
    return react_default.a.createElement(Popover["a" /* default */], profile_popover_extends({}, popoverProps, {
      title: title,
      id: "user-profile-popover"
    }), dataContent);
  }

}

profile_popover_defineProperty(profile_popover_ProfilePopover, "propTypes", {
  /**
   * Source URL from the image to display in the popover
   */
  src: prop_types_default.a.string.isRequired,

  /**
   * User the popover is being opened for
   */
  user: prop_types_default.a.object,

  /**
   * Status for the user, either 'offline', 'away', 'dnd' or 'online'
   */
  status: prop_types_default.a.string,
  hideStatus: prop_types_default.a.bool,

  /**
   * Function to call to hide the popover
   */
  hide: prop_types_default.a.func,

  /**
   * Set to true if the popover was opened from the right-hand
   * sidebar (comment thread, search results, etc.)
   */
  isRHS: prop_types_default.a.bool,
  currentTeamId: prop_types_default.a.string.isRequired,

  /**
   * @internal
   */
  hasMention: prop_types_default.a.bool,

  /**
   * @internal
   */
  currentUserId: prop_types_default.a.string.isRequired,

  /**
   * @internal
   */
  teamUrl: prop_types_default.a.string.isRequired,

  /**
   * @internal
   */
  isTeamAdmin: prop_types_default.a.bool.isRequired,

  /**
   * @internal
   */
  isChannelAdmin: prop_types_default.a.bool.isRequired,

  /**
   * @internal
   */
  canManageAnyChannelMembersInCurrentTeam: prop_types_default.a.bool.isRequired,

  /**
   * @internal
   */
  actions: prop_types_default.a.shape({
    getMembershipForCurrentEntities: prop_types_default.a.func.isRequired,
    openDirectChannelToUserId: prop_types_default.a.func.isRequired,
    openModal: prop_types_default.a.func.isRequired
  }).isRequired,

  /**
   * react-intl helper object
   */
  intl: index_es["i" /* intlShape */].isRequired,
  ...Popover["a" /* default */].propTypes
});

profile_popover_defineProperty(profile_popover_ProfilePopover, "defaultProps", {
  isRHS: false,
  hasMention: false,
  status: constants["L" /* UserStatuses */].OFFLINE
});

delete profile_popover_ProfilePopover.propTypes.id;
/* harmony default export */ var profile_popover = (Object(index_es["h" /* injectIntl */])(profile_popover_ProfilePopover));
// CONCATENATED MODULE: ./components/profile_popover/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












function profile_popover_mapStateToProps(state, ownProps) {
  const userId = ownProps.userId;
  const team = Object(teams["getCurrentTeam"])(state);
  const teamMember = Object(teams["getTeamMember"])(state, team.id, userId);
  let isTeamAdmin = false;

  if (teamMember && teamMember.scheme_admin) {
    isTeamAdmin = true;
  }

  const selectedPost = Object(rhs["q" /* getSelectedPost */])(state);
  const currentChannel = Object(entities_channels["getCurrentChannel"])(state);
  let channelId;

  if (selectedPost.exists === false) {
    channelId = currentChannel.id;
  } else {
    channelId = selectedPost.channel_id;
  }

  const channelMember = Object(entities_channels["getChannelMembersInChannels"])(state)[channelId][userId];
  let isChannelAdmin = false;

  if (Object(rhs["m" /* getRhsState */])(state) !== 'search' && channelMember != null && channelMember.scheme_admin) {
    isChannelAdmin = true;
  }

  return {
    currentTeamId: team.id,
    currentUserId: Object(users["getCurrentUserId"])(state),
    enableTimezone: Object(general["a" /* areTimezonesEnabledAndSupported */])(state),
    isTeamAdmin,
    isChannelAdmin,
    canManageAnyChannelMembersInCurrentTeam: Object(entities_channels["canManageAnyChannelMembersInCurrentTeam"])(state),
    status: Object(users["getStatusForUserId"])(state, userId),
    teamUrl: Object(teams["getCurrentRelativeTeamUrl"])(state),
    user: Object(users["getUser"])(state, userId)
  };
}

function profile_popover_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openDirectChannelToUserId: channel_actions["e" /* openDirectChannelToUserId */],
      openModal: modals["b" /* openModal */],
      getMembershipForCurrentEntities: getMembershipForCurrentEntities
    }, dispatch)
  };
}

/* harmony default export */ var components_profile_popover = __webpack_exports__["a"] = (Object(es["connect"])(profile_popover_mapStateToProps, profile_popover_mapDispatchToProps)(profile_popover));

/***/ }),

/***/ 1964:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/actions/integrations.js
var integrations = __webpack_require__(1591);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Modal.js
var Modal = __webpack_require__(1972);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./mattermost-redux/utils/integration_utils.js
var integration_utils = __webpack_require__(2324);

// EXTERNAL MODULE: ./components/spinner_button.jsx
var spinner_button = __webpack_require__(1666);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/suggestion/menu_action_provider.jsx
var menu_action_provider = __webpack_require__(1984);

// EXTERNAL MODULE: ./components/suggestion/generic_user_provider.jsx
var generic_user_provider = __webpack_require__(1844);

// EXTERNAL MODULE: ./components/suggestion/generic_channel_provider.jsx
var generic_channel_provider = __webpack_require__(1985);

// EXTERNAL MODULE: ./components/widgets/settings/text_setting.jsx + 1 modules
var text_setting = __webpack_require__(2268);

// EXTERNAL MODULE: ./components/widgets/settings/autocomplete_selector.jsx
var autocomplete_selector = __webpack_require__(1986);

// CONCATENATED MODULE: ./components/interactive_dialog/dialog_element.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








const TEXT_DEFAULT_MAX_LENGTH = 150;
const TEXTAREA_DEFAULT_MAX_LENGTH = 3000;
class dialog_element_DialogElement extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleSelected", selected => {
      const {
        name,
        dataSource,
        onChange
      } = this.props;

      if (dataSource === 'users') {
        onChange(name, selected.id);
        this.setState({
          value: selected.username
        });
      } else if (dataSource === 'channels') {
        onChange(name, selected.id);
        this.setState({
          value: selected.display_name
        });
      } else {
        onChange(name, selected.value);
        this.setState({
          value: selected.text
        });
      }
    });

    this.providers = [];

    if (props.type === 'select') {
      if (props.dataSource === 'users') {
        this.providers = [new generic_user_provider["a" /* default */]()];
      } else if (props.dataSource === 'channels') {
        this.providers = [new generic_channel_provider["a" /* default */]()];
      } else if (props.options) {
        this.providers = [new menu_action_provider["a" /* default */](props.options)];
      }
    }

    this.state = {
      value: ''
    };
  }

  render() {
    const {
      name,
      subtype,
      displayName,
      value,
      placeholder,
      onChange,
      helpText,
      errorText,
      optional
    } = this.props;
    let {
      type,
      maxLength
    } = this.props;
    let displayNameContent = displayName;

    if (optional) {
      displayNameContent = react_default.a.createElement(react_default.a.Fragment, null, displayName + ' ', react_default.a.createElement("span", {
        className: "font-weight--normal light"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "interactive_dialog.element.optional",
        defaultMessage: "(optional)"
      })));
    } else {
      displayNameContent = react_default.a.createElement(react_default.a.Fragment, null, displayName, react_default.a.createElement("span", {
        className: "error-text"
      }, ' *'));
    }

    let helpTextContent = helpText;

    if (errorText) {
      helpTextContent = react_default.a.createElement(react_default.a.Fragment, null, helpText, react_default.a.createElement("div", {
        className: "error-text margin-top x2"
      }, errorText));
    }

    if (type === 'text' || type === 'textarea') {
      if (type === 'text') {
        maxLength = maxLength || TEXT_DEFAULT_MAX_LENGTH;

        if (subtype && text_setting["a" /* default */].validTypes.includes(subtype)) {
          type = subtype;
        } else {
          type = 'input';
        }
      } else {
        maxLength = maxLength || TEXTAREA_DEFAULT_MAX_LENGTH;
      }

      return react_default.a.createElement(text_setting["a" /* default */], {
        id: name,
        type: type,
        label: displayNameContent,
        maxLength: maxLength,
        value: value || '',
        placeholder: placeholder,
        helpText: helpTextContent,
        onChange: onChange,
        resizable: false
      });
    } else if (type === 'select') {
      return react_default.a.createElement(autocomplete_selector["a" /* default */], {
        id: name,
        providers: this.providers,
        onSelected: this.handleSelected,
        label: displayNameContent,
        helpText: helpTextContent,
        placeholder: placeholder,
        value: this.state.value
      });
    }

    return null;
  }

}

_defineProperty(dialog_element_DialogElement, "propTypes", {
  displayName: prop_types_default.a.string.isRequired,
  name: prop_types_default.a.string.isRequired,
  type: prop_types_default.a.string.isRequired,
  subtype: prop_types_default.a.string,
  placeholder: prop_types_default.a.string,
  helpText: prop_types_default.a.string,
  errorText: prop_types_default.a.node,
  maxLength: prop_types_default.a.number,
  dataSource: prop_types_default.a.string,
  optional: prop_types_default.a.bool,
  options: prop_types_default.a.arrayOf(prop_types_default.a.object),
  value: prop_types_default.a.any,
  onChange: prop_types_default.a.func
});
// CONCATENATED MODULE: ./components/interactive_dialog/interactive_dialog.jsx
function interactive_dialog_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class interactive_dialog_InteractiveDialog extends react_default.a.Component {
  constructor(props) {
    super(props);

    interactive_dialog_defineProperty(this, "handleSubmit", async e => {
      e.preventDefault();
      const {
        elements
      } = this.props;
      const values = this.state.values;
      const errors = {};

      if (elements) {
        elements.forEach(elem => {
          const error = Object(integration_utils["checkDialogElementForError"])(elem, values[elem.name]);

          if (error) {
            errors[elem.name] = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
              id: error.id,
              defaultMessage: error.defaultMessage,
              values: error.values
            });
          }
        });
      }

      this.setState({
        errors
      });

      if (Object.keys(errors).length !== 0) {
        return;
      }

      const {
        url,
        callbackId,
        state
      } = this.props;
      const dialog = {
        url,
        callback_id: callbackId,
        state,
        submission: values
      };
      this.setState({
        submitting: true
      });
      const {
        data
      } = await this.props.actions.submitInteractiveDialog(dialog);
      this.setState({
        submitting: false
      });

      if (!data || !data.errors || Object.keys(data.errors).length === 0) {
        this.handleHide(true);
        return;
      }

      if (Object(integration_utils["checkIfErrorsMatchElements"])(data.errors, elements)) {
        this.setState({
          errors: data.errors
        });
        return;
      }

      this.handleHide(true);
    });

    interactive_dialog_defineProperty(this, "onHide", () => {
      this.handleHide(false);
    });

    interactive_dialog_defineProperty(this, "handleHide", (submitted = false) => {
      const {
        url,
        callbackId,
        state,
        notifyOnCancel
      } = this.props;

      if (!submitted && notifyOnCancel) {
        const dialog = {
          url,
          callback_id: callbackId,
          state,
          cancelled: true
        };
        this.props.actions.submitInteractiveDialog(dialog);
      }

      this.setState({
        show: false
      });
    });

    interactive_dialog_defineProperty(this, "onChange", (name, value) => {
      const values = { ...this.state.values,
        [name]: value
      };
      this.setState({
        values
      });
    });

    const _values = {};

    if (props.elements != null) {
      props.elements.forEach(e => {
        _values[e.name] = e.default || null;
      });
    }

    this.state = {
      show: true,
      values: _values,
      errors: {},
      submitting: false
    };
  }

  render() {
    const {
      title,
      iconUrl,
      submitLabel,
      elements
    } = this.props;
    let submitText = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "interactive_dialog.submit",
      defaultMessage: "Submit"
    });

    if (submitLabel) {
      submitText = submitLabel;
    }

    let icon;

    if (iconUrl) {
      icon = react_default.a.createElement("img", {
        alt: 'modal title icon',
        className: "more-modal__image",
        width: "36",
        height: "36",
        src: iconUrl
      });
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "about-modal",
      show: this.state.show,
      onHide: this.onHide,
      onExited: this.props.onHide,
      backdrop: "static",
      role: "dialog",
      "aria-labelledby": "interactiveDialogModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true,
      style: {
        borderBottom: elements == null && '0px'
      }
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "interactiveDialogModalLabel"
    }, icon, title)), elements && react_default.a.createElement(Modal["a" /* default */].Body, null, elements.map(e => {
      return react_default.a.createElement(dialog_element_DialogElement, {
        key: 'dialogelement' + e.name,
        displayName: e.display_name,
        name: e.name,
        type: e.type,
        subtype: e.subtype,
        helpText: e.help_text,
        errorText: this.state.errors[e.name],
        placeholder: e.placeholder,
        minLength: e.min_length,
        maxLength: e.max_length,
        dataSource: e.data_source,
        optional: e.optional,
        options: e.options,
        value: this.state.values[e.name],
        onChange: this.onChange
      });
    })), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-link cancel-button",
      onClick: this.onHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "interactive_dialog.cancel",
      defaultMessage: "Cancel"
    })), react_default.a.createElement(spinner_button["a" /* default */], {
      type: "button",
      className: "btn btn-primary save-button",
      onClick: this.handleSubmit,
      spinning: this.state.submitting,
      spinningText: Object(utils["gb" /* localizeMessage */])('interactive_dialog.submitting', 'Submitting...')
    }, submitText)));
  }

}

interactive_dialog_defineProperty(interactive_dialog_InteractiveDialog, "propTypes", {
  url: prop_types_default.a.string.isRequired,
  callbackId: prop_types_default.a.string,
  elements: prop_types_default.a.arrayOf(prop_types_default.a.object),
  title: prop_types_default.a.string.isRequired,
  iconUrl: prop_types_default.a.string,
  submitLabel: prop_types_default.a.string,
  notifyOnCancel: prop_types_default.a.bool,
  state: prop_types_default.a.string,
  onHide: prop_types_default.a.func,
  actions: prop_types_default.a.shape({
    submitInteractiveDialog: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/interactive_dialog/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function mapStateToProps(state) {
  const data = state.entities.integrations.dialog;

  if (!data || !data.dialog) {
    return {};
  }

  return {
    url: data.url,
    callbackId: data.dialog.callback_id,
    elements: data.dialog.elements,
    title: data.dialog.title,
    iconUrl: data.dialog.icon_url,
    submitLabel: data.dialog.submit_label,
    notifyOnCancel: data.dialog.notify_on_cancel,
    state: data.dialog.state
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      submitInteractiveDialog: integrations["submitInteractiveDialog"]
    }, dispatch)
  };
}

/* harmony default export */ var interactive_dialog = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(interactive_dialog_InteractiveDialog));

/***/ }),

/***/ 1965:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/reselect/es/index.js
var reselect_es = __webpack_require__(150);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/roles.js
var roles = __webpack_require__(90);

// EXTERNAL MODULE: ./mattermost-redux/actions/preferences.js
var actions_preferences = __webpack_require__(128);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var constants = __webpack_require__(17);

// EXTERNAL MODULE: ./mattermost-redux/actions/admin.js
var admin = __webpack_require__(1609);

// EXTERNAL MODULE: ./actions/views/notice.js
var views_notice = __webpack_require__(1859);

// EXTERNAL MODULE: ./utils/constants.jsx
var utils_constants = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./components/formatted_markdown_message.jsx
var formatted_markdown_message = __webpack_require__(1564);

// EXTERNAL MODULE: ./images/icon50x50.png
var icon50x50 = __webpack_require__(423);
var icon50x50_default = /*#__PURE__*/__webpack_require__.n(icon50x50);

// CONCATENATED MODULE: ./components/system_notice/notices.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


 // Notices are objects with the following fields:
//  - name - string identifier
//  - adminOnly - set to true if only system admins should see this message
//  - icon - the image to display for the notice icon
//  - title - JSX node to display for the notice title
//  - body - JSX node to display for the notice body
//  - allowForget - boolean to allow forget the notice
//  - show - function that check if we need to show the notice
//
// Order is important! The notices at the top are shown first.

/* harmony default export */ var notices = ([{
  name: 'apiv3_deprecation',
  adminOnly: true,
  title: react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "system_notice.title",
    defaultMessage: "**Notice**\\nfrom Mattermost"
  }),
  icon: icon50x50_default.a,
  body: react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "system_notice.body.api3",
    defaultMessage: "If you\u2019ve created or installed integrations in the last two years, find out how [recent changes](!https://about.mattermost.com/default-apiv3-deprecation-guide) may have affected them."
  }),
  allowForget: true,
  show: (serverVersion, config) => {
    if (config.InstallationDate >= new Date(2018, 5, 16, 0, 0, 0, 0).getTime()) {
      return false;
    }

    return true;
  }
}, {
  name: 'advanced_permissions',
  adminOnly: true,
  title: react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "system_notice.title",
    defaultMessage: "**Notice**\\nfrom Mattermost"
  }),
  icon: icon50x50_default.a,
  body: react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "system_notice.body.permissions",
    defaultMessage: "Some policy and permission System Console settings have moved with the release of [advanced permissions](!https://about.mattermost.com/default-advanced-permissions) in Enterprise E10 and E20."
  }),
  allowForget: true,
  show: (serverVersion, config, license) => {
    if (license.IsLicensed === 'false') {
      return false;
    }

    if (config.InstallationDate > new Date(2018, 5, 16, 0, 0, 0, 0).getTime()) {
      return false;
    }

    if (license.IsLicensed === 'true' && license.IssuedAt > new Date(2018, 5, 16, 0, 0, 0, 0).getTime()) {
      return false;
    }

    return true;
  }
}, {
  name: 'ee_upgrade_advice',
  adminOnly: true,
  title: react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "system_notice.title",
    defaultMessage: "**Notice**\\nfrom Mattermost"
  }),
  icon: icon50x50_default.a,
  body: react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "system_notice.body.ee_upgrade_advice",
    defaultMessage: "Enterprise Edition is recommended to ensure optimal operation and reliability. [Learn more](!https://mattermost.com/performance)."
  }),
  allowForget: false,
  show: (serverVersion, config, license, analytics) => {
    const USERS_THRESHOLD = 10000; // If we don't have the analytics yet, don't show

    if (!analytics.hasOwnProperty('TOTAL_USERS')) {
      return false;
    }

    if (analytics.TOTAL_USERS < USERS_THRESHOLD) {
      return false;
    }

    if (license.IsLicensed === 'true' && license.Cluster === 'true') {
      return false;
    }

    return true;
  }
}]);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./components/svg/mattermost_logo.jsx
var mattermost_logo = __webpack_require__(2010);

// CONCATENATED MODULE: ./components/system_notice/system_notice.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class system_notice_SystemNotice extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "getCurrentNotice", () => {
      for (const notice of this.props.notices) {
        // Skip if dismissed previously this session
        if (this.props.dismissedNotices[notice.name]) {
          continue;
        } // Skip if dismissed forever


        if (this.props.preferences[notice.name]) {
          continue;
        }

        if (notice.adminOnly && !this.props.isSystemAdmin) {
          continue;
        }

        if (!notice.show(this.props.serverVersion, this.props.config, this.props.license, this.props.analytics)) {
          continue;
        }

        return notice;
      }

      return null;
    });

    _defineProperty(this, "hide", (remind = false) => {
      const notice = this.getCurrentNotice();

      if (!notice) {
        return;
      }

      if (!remind) {
        this.props.actions.savePreferences(this.props.currentUserId, [{
          user_id: this.props.currentUserId,
          category: utils_constants["w" /* Preferences */].CATEGORY_SYSTEM_NOTICE,
          name: notice.name,
          value: 'dismissed'
        }]);
      }

      this.props.actions.dismissNotice(notice.name);
    });

    _defineProperty(this, "hideAndRemind", () => {
      this.hide(true);
    });

    _defineProperty(this, "hideAndForget", () => {
      this.hide(false);
    });
  }

  componentDidMount() {
    if (this.props.isSystemAdmin) {
      this.props.actions.getStandardAnalytics();
    }
  }

  componentDidUpdate(prevProps) {
    if (prevProps.isSystemAdmin !== this.props.isSystemAdmin && this.props.isSystemAdmin) {
      this.props.actions.getStandardAnalytics();
    }
  }

  render() {
    const notice = this.getCurrentNotice();
    const {
      formatMessage
    } = this.context.intl;

    if (notice == null) {
      return null;
    }

    let visibleMessage;

    if (notice.adminOnly) {
      visibleMessage = react_default.a.createElement("div", {
        className: "system-notice__info"
      }, react_default.a.createElement("i", {
        className: "fa fa-eye",
        title: formatMessage({
          id: 'system_notice.adminVisible.icon',
          defaultMessage: 'Only visible to System Admins Icon'
        })
      }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "system_notice.adminVisible",
        defaultMessage: "Only visible to System Admins"
      }));
    }

    return react_default.a.createElement("div", {
      className: "system-notice bg--white shadow--2"
    }, react_default.a.createElement("div", {
      className: "system-notice__header"
    }, react_default.a.createElement("div", {
      className: "system-notice__logo"
    }, react_default.a.createElement(mattermost_logo["a" /* default */], null)), react_default.a.createElement("div", {
      className: "system-notice__title"
    }, notice.title)), react_default.a.createElement("div", {
      className: "system-notice__body"
    }, notice.body), visibleMessage, react_default.a.createElement("div", {
      className: "system-notice__footer"
    }, react_default.a.createElement("button", {
      id: "systemnotice_remindme",
      className: "btn btn-transparent",
      onClick: this.hideAndRemind
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "system_notice.remind_me",
      defaultMessage: "Remind me later"
    })), notice.allowForget && react_default.a.createElement("button", {
      id: "systemnotice_dontshow",
      className: "btn btn-transparent",
      onClick: this.hideAndForget
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "system_notice.dont_show",
      defaultMessage: "Don't show again"
    }))));
  }

}

_defineProperty(system_notice_SystemNotice, "propTypes", {
  currentUserId: prop_types_default.a.string.isRequired,
  notices: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,
  preferences: prop_types_default.a.object.isRequired,
  dismissedNotices: prop_types_default.a.object.isRequired,
  isSystemAdmin: prop_types_default.a.bool,
  serverVersion: prop_types_default.a.string.isRequired,
  config: prop_types_default.a.object.isRequired,
  license: prop_types_default.a.object.isRequired,
  analytics: prop_types_default.a.object,
  actions: prop_types_default.a.shape({
    savePreferences: prop_types_default.a.func.isRequired,
    dismissNotice: prop_types_default.a.func.isRequired,
    getStandardAnalytics: prop_types_default.a.func.isRequired
  }).isRequired
});

_defineProperty(system_notice_SystemNotice, "contextTypes", {
  intl: index_es["i" /* intlShape */].isRequired
});
// CONCATENATED MODULE: ./components/system_notice/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.














function makeMapStateToProps() {
  const getCategory = Object(preferences["makeGetCategory"])();
  const getPreferenceNameMap = Object(reselect_es["a" /* createSelector */])(getCategory, preferences => {
    const nameMap = {};
    preferences.forEach(p => {
      nameMap[p.name] = p;
    });
    return nameMap;
  });
  return function mapStateToProps(state) {
    const license = Object(general["getLicense"])(state);
    const config = Object(general["getConfig"])(state);
    const serverVersion = state.entities.general.serverVersion;
    const analytics = state.entities.admin.analytics;
    return {
      currentUserId: state.entities.users.currentUserId,
      preferences: getPreferenceNameMap(state, utils_constants["w" /* Preferences */].CATEGORY_SYSTEM_NOTICE),
      dismissedNotices: state.views.notice.hasBeenDismissed,
      isSystemAdmin: Object(roles["haveISystemPermission"])(state, {
        permission: constants["Permissions"].MANAGE_SYSTEM
      }),
      notices: notices,
      config,
      license,
      serverVersion,
      analytics
    };
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      savePreferences: actions_preferences["savePreferences"],
      dismissNotice: views_notice["a" /* dismissNotice */],
      getStandardAnalytics: admin["getStandardAnalytics"]
    }, dispatch)
  };
}

/* harmony default export */ var system_notice = __webpack_exports__["a"] = (Object(es["connect"])(makeMapStateToProps, mapDispatchToProps)(system_notice_SystemNotice));

/***/ }),

/***/ 1969:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./actions/views/modals.js
var modals = __webpack_require__(1578);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tooltip.js
var Tooltip = __webpack_require__(1998);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// EXTERNAL MODULE: ./mattermost-redux/constants/permissions.js
var permissions = __webpack_require__(5);
var permissions_default = /*#__PURE__*/__webpack_require__.n(permissions);

// EXTERNAL MODULE: ./actions/global_actions.jsx
var global_actions = __webpack_require__(1567);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./components/delete_post_modal/index.js + 1 modules
var delete_post_modal = __webpack_require__(2267);

// EXTERNAL MODULE: ./utils/delayed_action.jsx
var delayed_action = __webpack_require__(1671);

// EXTERNAL MODULE: ./utils/post_utils.jsx + 1 modules
var post_utils = __webpack_require__(407);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/permissions_gates/channel_permission_gate/index.js + 1 modules
var channel_permission_gate = __webpack_require__(1721);

// EXTERNAL MODULE: ./mattermost-redux/utils/file_utils.js
var file_utils = __webpack_require__(1611);

// EXTERNAL MODULE: ./plugins/pluggable/index.js + 1 modules
var pluggable = __webpack_require__(1647);

// EXTERNAL MODULE: ./components/widgets/menu/menu.jsx
var menu = __webpack_require__(1619);

// EXTERNAL MODULE: ./components/widgets/menu/menu_wrapper.jsx + 1 modules
var menu_wrapper = __webpack_require__(1606);

// EXTERNAL MODULE: ./components/widgets/menu/menu_items/menu_item_action.jsx
var menu_item_action = __webpack_require__(1600);

// EXTERNAL MODULE: ./api/cloud.js
var cloud = __webpack_require__(235);

// CONCATENATED MODULE: ./components/dot_menu/dot_menu.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


















const MENU_BOTTOM_MARGIN = 80;
class dot_menu_DotMenu extends react["Component"] {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleEditDisable", () => {
      this.setState({
        canEdit: false
      });
    });

    _defineProperty(this, "handleFlagMenuItemActivated", () => {
      if (this.props.isFlagged) {
        this.props.actions.unflagPost(this.props.post.id);
      } else {
        this.props.actions.flagPost(this.props.post.id);
      }
    });

    _defineProperty(this, "handleAddReactionMenuItemActivated", e => {
      e.preventDefault(); // to be safe, make sure the handler function has been defined

      if (this.props.handleAddReactionClick) {
        this.props.handleAddReactionClick();
      }
    });

    _defineProperty(this, "handlePermalinkMenuItemActivated", e => {
      e.preventDefault();
      Object(global_actions["j" /* showGetPostLinkModal */])(this.props.post);
    });

    _defineProperty(this, "handlePinMenuItemActivated", () => {
      if (this.props.post.is_pinned) {
        this.props.actions.unpinPost(this.props.post.id);
      } else {
        this.props.actions.pinPost(this.props.post.id);
      }
    });

    _defineProperty(this, "handleDeleteMenuItemActivated", e => {
      e.preventDefault();
      const deletePostModalData = {
        ModalId: constants["p" /* ModalIdentifiers */].DELETE_POST,
        dialogType: delete_post_modal["a" /* default */],
        dialogProps: {
          post: this.props.post,
          commentCount: this.props.commentCount,
          isRHS: this.props.location === constants["o" /* Locations */].RHS_ROOT || this.props.location === constants["o" /* Locations */].RHS_COMMENT
        }
      };
      this.props.actions.openModal(deletePostModalData);
    });

    _defineProperty(this, "handleEditMenuItemActivated", () => {
      this.props.actions.setEditingPost(this.props.post.id, this.props.commentCount, this.props.location === constants["o" /* Locations */].CENTER ? 'post_textbox' : 'reply_textbox', this.props.post.root_id ? utils["gb" /* localizeMessage */]('rhs_comment.comment', 'Comment') : utils["gb" /* localizeMessage */]('create_post.post', 'Post'), this.props.location === constants["o" /* Locations */].RHS_ROOT || this.props.location === constants["o" /* Locations */].RHS_COMMENT);
    });

    _defineProperty(this, "handleDownloadCloudUp", e => {
      e.preventDefault();
      Object(cloud["b" /* downloadFile */])(this.props.post.id).then(response => {
        const content = response.data;
        const blob = new Blob([content]);
        let blobUrl = window.URL.createObjectURL(blob);
        const aElement = document.createElement('a');
        document.body.appendChild(aElement);
        aElement.style.display = 'none';
        let filename = this.props.post.name; //设置文件名称

        aElement.href = blobUrl; //设置a标签路径

        aElement.download = filename;
        aElement.click();
        document.body.removeChild(aElement);
      }).catch(error => {
        console.log('文件下载失败', error);
      });
    });

    _defineProperty(this, "handleViewCloudUp", e => {
      e.preventDefault();
      this.props.handleViewCloud();
    });

    _defineProperty(this, "handleDeleteCloudUp", e => {
      e.preventDefault();
      this.props.handleOpenDelete(this.props.post);
    });

    _defineProperty(this, "handleOpCloudUp", e => {
      e.preventDefault();
      this.props.handleOpCloudUp(this.props.post);
    });

    _defineProperty(this, "tooltip", react_default.a.createElement(Tooltip["a" /* default */], {
      id: "dotmenu-icon-tooltip",
      className: "hidden-xs"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "post_info.dot_menu.tooltip.more_actions",
      defaultMessage: "More Actions"
    })));

    _defineProperty(this, "refCallback", ref => {
      if (ref) {
        const rect = ref.rect();
        const y = rect.y || rect.top;
        const height = rect.height;
        const windowHeight = window.innerHeight;

        if (y + height > windowHeight - MENU_BOTTOM_MARGIN) {
          this.setState({
            openUp: true
          });
        }
      }
    });

    this.editDisableAction = new delayed_action["a" /* default */](this.handleEditDisable);
    this.state = {
      openUp: false
    };
    this.buttonRef = react_default.a.createRef();
  }

  disableCanEditPostByTime() {
    const {
      post,
      isLicensed,
      postEditTimeLimit
    } = this.props;
    const canEdit = post_utils["b" /* canEditPost */](post);

    if (canEdit && isLicensed) {
      if (String(postEditTimeLimit) !== String(constants["UNSET_POST_EDIT_TIME_LIMIT"])) {
        const milliseconds = 1000;
        const timeLeft = post.create_at + postEditTimeLimit * milliseconds - utils["E" /* getTimestamp */]();

        if (timeLeft > 0) {
          this.editDisableAction.fireAfter(timeLeft + milliseconds);
        }
      }
    }
  }

  componentDidMount() {
    this.disableCanEditPostByTime();
  }

  static getDerivedStateFromProps(props) {
    return {
      canDelete: post_utils["a" /* canDeletePost */](props.post) && !props.isReadOnly,
      canEdit: post_utils["b" /* canEditPost */](props.post) && !props.isReadOnly
    };
  }

  componentWillUnmount() {
    this.editDisableAction.cancel();
  }

  render() {
    const isSystemMessage = post_utils["l" /* isSystemMessage */](this.props.post);
    const isMobile = utils["Y" /* isMobile */]();
    const pluginItems = this.props.pluginMenuItems.filter(item => {
      return item.filter ? item.filter(this.props.post.id) : item;
    }).map(item => {
      return react_default.a.createElement(menu_item_action["a" /* default */], {
        key: item.id + '_pluginmenuitem',
        text: item.text,
        onClick: () => {
          if (item.action) {
            item.action(this.props.post.id);
          }
        }
      });
    });

    if (!this.state.canDelete && !this.state.canEdit && pluginItems.length === 0 && isSystemMessage) {
      return null;
    }

    return react_default.a.createElement(menu_wrapper["a" /* default */], {
      onToggle: this.props.handleDropdownOpened
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      className: "hidden-xs",
      delayShow: 500,
      placement: "top",
      overlay: this.tooltip,
      rootClose: true
    }, react_default.a.createElement("button", {
      id: `${this.props.location}_button_${this.props.post.id}`,
      className: "post__dropdown color--link style--none",
      type: "button",
      "aria-expanded": "false"
    })), react_default.a.createElement(menu["a" /* default */], {
      id: `${this.props.location}_dropdown_${this.props.post.id}`,
      openLeft: true,
      openUp: this.state.openUp,
      ref: this.refCallback,
      ariaLabel: utils["gb" /* localizeMessage */]('post_info.menuAriaLabel', 'Post extra options')
    }, react_default.a.createElement(channel_permission_gate["a" /* default */], {
      channelId: this.props.post.channel_id,
      teamId: this.props.teamId,
      permissions: [permissions_default.a.ADD_REACTION]
    }, react_default.a.createElement(menu_item_action["a" /* default */], {
      show: isMobile && !isSystemMessage && !this.props.isReadOnly && this.props.enableEmojiPicker,
      text: utils["gb" /* localizeMessage */]('rhs_root.mobile.add_reaction', 'Add Reaction'),
      onClick: this.handleAddReactionMenuItemActivated
    })), react_default.a.createElement(menu_item_action["a" /* default */], {
      show: this.props.isCloudPosts == undefined && isMobile && !isSystemMessage && this.props.isFlagged,
      text: utils["gb" /* localizeMessage */]('rhs_root.mobile.unflag', 'Unflag'),
      onClick: this.handleFlagMenuItemActivated
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      show: this.props.isCloudPosts == undefined && isMobile && !isSystemMessage && !this.props.isFlagged,
      text: utils["gb" /* localizeMessage */]('rhs_root.mobile.flag', 'Flag'),
      onClick: this.handleFlagMenuItemActivated
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      show: !isSystemMessage && this.props.location === constants["o" /* Locations */].CENTER && this.props.isCloudPosts == undefined,
      text: utils["gb" /* localizeMessage */]('post_info.reply', 'Reply'),
      onClick: this.props.handleCommentClick
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      id: `unpin_post_${this.props.post.id}`,
      show: this.props.isCloudPosts == undefined && !isSystemMessage && !this.props.isReadOnly && this.props.post.is_pinned,
      text: utils["gb" /* localizeMessage */]('post_info.unpin', 'Unpin'),
      onClick: this.handlePinMenuItemActivated
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      id: `delete_post_${this.props.post.id}`,
      show: this.state.canDelete && this.props.isCloudPosts == undefined,
      text: utils["gb" /* localizeMessage */]('post_info.del', 'Delete'),
      onClick: this.handleDeleteMenuItemActivated
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      id: `file_view_${this.props.post.id}`,
      show: this.props.isCloudPosts != undefined && !this.props.isDelete,
      text: utils["gb" /* localizeMessage */]('file.view', 'View'),
      onClick: this.handleViewCloudUp
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      id: `file_download_${this.props.post.id}`,
      show: this.props.isCloudPosts != undefined && !this.props.isDelete,
      text: utils["gb" /* localizeMessage */]('file.download', 'Download'),
      onClick: this.handleDownloadCloudUp
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      id: `file_delete_${this.props.post.id}`,
      show: this.props.isCloudPosts != undefined && !this.props.isDelete,
      text: utils["gb" /* localizeMessage */]('file.delete', 'Delete'),
      onClick: this.handleDeleteCloudUp
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      id: `file_operation_${this.props.post.id}`,
      show: this.props.isCloudPosts != undefined,
      text: utils["gb" /* localizeMessage */]('file.operation', 'Operation'),
      onClick: this.handleOpCloudUp
    }), pluginItems, react_default.a.createElement(pluggable["a" /* default */], {
      postId: this.props.post.id,
      pluggableName: "PostDropdownMenuItem"
    })));
  }

}

_defineProperty(dot_menu_DotMenu, "propTypes", {
  post: prop_types_default.a.object.isRequired,
  teamId: prop_types_default.a.string,
  location: prop_types_default.a.oneOf([constants["o" /* Locations */].CENTER, constants["o" /* Locations */].RHS_ROOT, constants["o" /* Locations */].RHS_COMMENT, constants["o" /* Locations */].SEARCH]).isRequired,
  commentCount: prop_types_default.a.number,
  isFlagged: prop_types_default.a.bool,
  isCloudPosts: prop_types_default.a.bool,
  isDelete: prop_types_default.a.bool,
  handleCommentClick: prop_types_default.a.func,
  handleDropdownOpened: prop_types_default.a.func,
  handleAddReactionClick: prop_types_default.a.func,
  isReadOnly: prop_types_default.a.bool,
  pluginMenuItems: prop_types_default.a.arrayOf(prop_types_default.a.object),
  isLicensed: prop_types_default.a.bool.isRequired,
  postEditTimeLimit: prop_types_default.a.string.isRequired,
  enableEmojiPicker: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    /**
     * Function flag the post
     */
    flagPost: prop_types_default.a.func.isRequired,

    /**
     * Function to unflag the post
     */
    unflagPost: prop_types_default.a.func.isRequired,

    /**
     * Function to set the editing post
     */
    setEditingPost: prop_types_default.a.func.isRequired,

    /**
     * Function to pin the post
     */
    pinPost: prop_types_default.a.func.isRequired,

    /**
     * Function to unpin the post
     */
    unpinPost: prop_types_default.a.func.isRequired,

    /**
     * Function to open a modal
     */
    openModal: prop_types_default.a.func.isRequired,
    handleDownloadCloud: prop_types_default.a.func,
    handleViewCloud: prop_types_default.a.func,
    handleDeleteCloud: prop_types_default.a.func,
    handleOpCloud: prop_types_default.a.func,
    handleOpCloudUp: prop_types_default.a.func,
    handleOpenDelete: prop_types_default.a.func
  }).isRequired
});

_defineProperty(dot_menu_DotMenu, "defaultProps", {
  post: {},
  commentCount: 0,
  isFlagged: false,
  isReadOnly: false,
  pluginMenuItems: [],
  location: constants["o" /* Locations */].CENTER,
  enableEmojiPicker: false
});
// CONCATENATED MODULE: ./components/dot_menu/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function mapStateToProps(state) {
  return {
    postEditTimeLimit: Object(general["getConfig"])(state).PostEditTimeLimit,
    isLicensed: Object(general["getLicense"])(state).IsLicensed === 'true',
    teamId: Object(teams["getCurrentTeamId"])(state),
    pluginMenuItems: state.plugins.components.PostDropdownMenu
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      flagPost: post_actions["f" /* flagPost */],
      unflagPost: post_actions["p" /* unflagPost */],
      setEditingPost: post_actions["n" /* setEditingPost */],
      pinPost: post_actions["k" /* pinPost */],
      unpinPost: post_actions["q" /* unpinPost */],
      openModal: modals["b" /* openModal */]
    }, dispatch)
  };
}

/* harmony default export */ var dot_menu = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(dot_menu_DotMenu));

/***/ }),

/***/ 1970:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./actions/global_actions.jsx
var global_actions = __webpack_require__(1567);

// EXTERNAL MODULE: ./utils/user_agent.jsx
var user_agent = __webpack_require__(39);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/local_date_time/index.js + 1 modules
var local_date_time = __webpack_require__(2269);

// CONCATENATED MODULE: ./components/post_view/post_time/post_time.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class post_time_PostTime extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "handleClick", () => {
      if (Object(utils["Y" /* isMobile */])()) {
        global_actions["c" /* emitCloseRightHandSide */]();
      }
    });
  }

  render() {
    const localDateTime = react_default.a.createElement(local_date_time["a" /* default */], {
      eventTime: this.props.eventTime
    });

    if (Object(user_agent["m" /* isMobile */])() || !this.props.isPermalink) {
      return localDateTime;
    }

    const {
      location,
      postId,
      teamUrl
    } = this.props;
    return localDateTime; // return (
    //     <Link
    //         id={`${location}_time_${postId}`}
    //         to={`${teamUrl}/pl/${postId}`}
    //         className='post__permalink'
    //         onClick={this.handleClick}
    //     >
    //         {localDateTime}
    //     </Link>
    // );
  }

}

_defineProperty(post_time_PostTime, "propTypes", {
  /*
   * If true, time will be rendered as a permalink to the post
   */
  isPermalink: prop_types_default.a.bool.isRequired,

  /*
   * The time to display
   */
  eventTime: prop_types_default.a.number.isRequired,
  location: prop_types_default.a.oneOf([constants["o" /* Locations */].CENTER, constants["o" /* Locations */].RHS_ROOT, constants["o" /* Locations */].RHS_COMMENT, constants["o" /* Locations */].SEARCH]).isRequired,

  /*
   * The post id of posting being rendered
   */
  postId: prop_types_default.a.string,
  teamUrl: prop_types_default.a.string
});

_defineProperty(post_time_PostTime, "defaultProps", {
  eventTime: 0,
  location: constants["o" /* Locations */].CENTER
});
// CONCATENATED MODULE: ./components/post_view/post_time/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function mapStateToProps(state) {
  return {
    teamUrl: Object(teams["getCurrentRelativeTeamUrl"])(state)
  };
}

/* harmony default export */ var post_time = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(post_time_PostTime));

/***/ }),

/***/ 1984:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MenuActionProvider; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _provider_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1597);
/* harmony import */ var _suggestion_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1598);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class MenuActionSuggestion extends _suggestion_jsx__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"] {
  render() {
    const {
      item,
      isSelection
    } = this.props;
    let className = 'mentions__name';

    if (isSelection) {
      className += ' suggestion--selected';
    }

    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", _extends({
      className: className,
      onClick: this.handleClick
    }, _suggestion_jsx__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].baseProps), item.text);
  }

}

class MenuActionProvider extends _provider_jsx__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"] {
  constructor(options) {
    super();
    this.options = options;
  }

  handlePretextChanged(prefix, resultsCallback) {
    if (prefix.length === 0) {
      this.displayAllOptions(resultsCallback);
      return true;
    }

    if (prefix) {
      this.filterOptions(prefix, resultsCallback);
      return true;
    }

    return false;
  }

  async displayAllOptions(resultsCallback) {
    const terms = this.options.map(option => option.text);
    resultsCallback({
      matchedPretext: '',
      terms,
      items: this.options,
      component: MenuActionSuggestion
    });
  }

  async filterOptions(prefix, resultsCallback) {
    const filteredOptions = this.options.filter(option => option.text.toLowerCase().indexOf(prefix) >= 0);
    const terms = filteredOptions.map(option => option.text);
    resultsCallback({
      matchedPretext: prefix,
      terms,
      items: filteredOptions,
      component: MenuActionSuggestion
    });
  }

}

/***/ }),

/***/ 1985:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChannelProvider; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var actions_channel_actions_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1593);
/* harmony import */ var _provider_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1597);
/* harmony import */ var _suggestion_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1598);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class ChannelSuggestion extends _suggestion_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"] {
  render() {
    const isSelection = this.props.isSelection;
    const item = this.props.item;
    const channelName = item.display_name;
    const purpose = item.purpose;
    let className = 'mentions__name no-flex';

    if (isSelection) {
      className += ' suggestion--selected';
    }

    const description = '(~' + item.name + ')';
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", _extends({
      className: className,
      onClick: this.handleClick
    }, _suggestion_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].baseProps), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "mention__align"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null, channelName), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      className: "mention__channelname"
    }, ' ', description)), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "mention__purpose"
    }, purpose));
  }

}

class ChannelProvider extends _provider_jsx__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"] {
  handlePretextChanged(pretext, resultsCallback) {
    const normalizedPretext = pretext.toLowerCase();
    this.startNewRequest(normalizedPretext);
    Object(actions_channel_actions_jsx__WEBPACK_IMPORTED_MODULE_1__[/* autocompleteChannels */ "b"])(normalizedPretext, data => {
      if (this.shouldCancelDispatch(normalizedPretext)) {
        return;
      }

      const channels = Object.assign([], data);
      resultsCallback({
        matchedPretext: normalizedPretext,
        terms: channels.map(channel => channel.display_name),
        items: channels,
        component: ChannelSuggestion
      });
    });
    return true;
  }

}

/***/ }),

/***/ 1986:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AutocompleteSelector; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var components_suggestion_suggestion_box_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1652);
/* harmony import */ var components_suggestion_suggestion_list_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1667);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class AutocompleteSelector extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "onChange", e => {
      if (!e || !e.target) {
        return;
      }

      this.setState({
        input: e.target.value
      });
    });

    _defineProperty(this, "handleSelected", selected => {
      this.setState({
        input: ''
      });

      if (this.props.onSelected) {
        this.props.onSelected(selected);
      }

      requestAnimationFrame(() => {
        if (this.suggestionRef) {
          this.suggestionRef.blur();
        }
      });
    });

    _defineProperty(this, "setSuggestionRef", ref => {
      this.suggestionRef = ref;
    });

    _defineProperty(this, "onFocus", () => {
      this.setState({
        focused: true
      });
    });

    _defineProperty(this, "onBlur", () => {
      this.setState({
        focused: false
      });
    });

    this.state = {
      input: ''
    };
  }

  render() {
    const {
      providers,
      placeholder,
      footer,
      label,
      labelClassName,
      helpText,
      inputClassName,
      value
    } = this.props;
    const {
      focused
    } = this.state;
    let {
      input
    } = this.state;

    if (!focused) {
      input = value;
    }

    let labelContent;

    if (label) {
      labelContent = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("label", {
        className: 'control-label ' + labelClassName
      }, label);
    }

    let helpTextContent;

    if (helpText) {
      helpTextContent = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
        className: "help-text"
      }, helpText);
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      className: "form-group"
    }, labelContent, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      className: inputClassName
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_suggestion_suggestion_box_jsx__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
      placeholder: placeholder,
      ref: this.setSuggestionRef,
      listComponent: components_suggestion_suggestion_list_jsx__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"],
      className: "form-control",
      containerClass: "select-suggestion-container",
      value: input,
      onChange: this.onChange,
      onItemSelected: this.handleSelected,
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      providers: providers,
      completeOnTab: true,
      renderDividers: false,
      renderNoResults: true,
      openOnFocus: true,
      openWhenEmpty: true,
      replaceAllInputOnSelect: true
    }), helpTextContent, footer));
  }

}

_defineProperty(AutocompleteSelector, "propTypes", {
  providers: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array.isRequired,
  value: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,
  onSelected: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  label: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
  labelClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  inputClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  helpText: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
  placeholder: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  footer: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node
});

_defineProperty(AutocompleteSelector, "defaultProps", {
  value: '',
  id: '',
  labelClassName: '',
  inputClassName: ''
});

/***/ }),

/***/ 2000:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return popOverOverlayPosition; });
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
function popOverOverlayPosition(targetBounds, innerHeight, spaceRequiredOptions) {
  const {
    above,
    below
  } = spaceRequiredOptions;
  let placement;

  if (targetBounds.top > above) {
    placement = 'top';
  } else if (innerHeight - targetBounds.bottom > (below || above)) {
    placement = 'bottom';
  } else {
    placement = 'left';
  }

  return placement;
}

/***/ }),

/***/ 2001:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoadingImagePreview; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var components_widgets_loading_loading_spinner_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1651);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



function LoadingImagePreview({
  loading,
  progress,
  containerClass
}) {
  let progressView = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", {
    className: "loader-percent"
  });

  if (progress) {
    progressView = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", {
      className: "loader-percent"
    }, `${loading} ${progress}%`);
  }

  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    className: containerClass
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_widgets_loading_loading_spinner_jsx__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], null), progressView);
}
LoadingImagePreview.propTypes = {
  /**
   * The percent number of the progress
   */
  progress: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,

  /**
   * The loading message to display
   */
  loading: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,

  /**
   * Loading style
   */
  containerClass: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
};
LoadingImagePreview.defaultProps = {
  containerClass: 'view-image__loading'
};

/***/ }),

/***/ 2008:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 27).then((function(require) {
		cb(__webpack_require__(3454));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 2009:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export importComponentSuccess */
/* unused harmony export createGetChildComponentsFunction */
/* unused harmony export notFoundParams */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return checkIfMFARequired; });
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

function importComponentSuccess(callback) {
  return comp => callback(null, comp.default);
}
function createGetChildComponentsFunction(arrayOfComponents) {
  return (locaiton, callback) => callback(null, arrayOfComponents);
}
const notFoundParams = {
  type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__[/* ErrorPageTypes */ "i"].PAGE_NOT_FOUND
};
const mfaPaths = ['/mfa/setup', '/mfa/confirm'];
const mfaAuthServices = ['', 'email', 'ldap'];
function checkIfMFARequired(user, license, config, path) {
  if (license.MFA === 'true' && config.EnableMultifactorAuthentication === 'true' && config.EnforceMultifactorAuthentication === 'true' && mfaPaths.indexOf(path) === -1) {
    if (user && !user.mfa_active && mfaAuthServices.indexOf(user.auth_service) !== -1) {
      return true;
    }
  }

  return false;
}

/***/ }),

/***/ 2010:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MattermostLogo; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class MattermostLogo extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", this.props, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.mattermost",
      defaultMessage: "Mattermost Logo"
    }, ariaLabel => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
      version: "1.1",
      id: "Layer_1",
      x: "0px",
      y: "0px",
      viewBox: "0 0 500 500",
      style: style.background,
      role: "icon",
      "aria-label": ariaLabel
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      id: "XMLID_1_"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      id: "XMLID_3_"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      id: "XMLID_4_",
      style: style.st0,
      d: "M396.9,47.7l2.6,53.1c43,47.5,60,114.8,38.6,178.1c-32,94.4-137.4,144.1-235.4,110.9 S51.1,253.1,83,158.7C104.5,95.2,159.2,52,222.5,40.5l34.2-40.4C150-2.8,49.3,63.4,13.3,169.9C-31,300.6,39.1,442.5,169.9,486.7 s272.6-25.8,316.9-156.6C522.7,223.9,483.1,110.3,396.9,47.7z"
    })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      id: "XMLID_2_",
      style: style.st0,
      d: "M335.6,204.3l-1.8-74.2l-1.5-42.7l-1-37c0,0,0.2-17.8-0.4-22c-0.1-0.9-0.4-1.6-0.7-2.2 c0-0.1-0.1-0.2-0.1-0.3c0-0.1-0.1-0.2-0.1-0.2c-0.7-1.2-1.8-2.1-3.1-2.6c-1.4-0.5-2.9-0.4-4.2,0.2c0,0-0.1,0-0.1,0 c-0.2,0.1-0.3,0.1-0.4,0.2c-0.6,0.3-1.2,0.7-1.8,1.3c-3,3-13.7,17.2-13.7,17.2l-23.2,28.8l-27.1,33l-46.5,57.8 c0,0-21.3,26.6-16.6,59.4s29.1,48.7,48,55.1c18.9,6.4,48,8.5,71.6-14.7C336.4,238.4,335.6,204.3,335.6,204.3z"
    })))));
  }

}
const style = {
  background: {
    enableBackground: 'new 0 0 500 500'
  },
  st0: {
    fillRule: 'evenodd',
    clipRule: 'evenodd'
  }
};

/***/ }),

/***/ 2014:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AutosizeTextarea; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class AutosizeTextarea extends react__WEBPACK_IMPORTED_MODULE_1___default.a.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "recalculateSize", () => {
      if (!this.refs.reference || !this.refs.textarea) {
        return;
      }

      const height = this.refs.reference.scrollHeight;
      const textarea = this.refs.textarea;

      if (height > 0 && height !== this.height) {
        const style = getComputedStyle(textarea);
        const borderWidth = parseInt(style.borderTopWidth, 10) + parseInt(style.borderBottomWidth, 10); // Directly change the height to avoid circular rerenders

        textarea.style.height = String(height + borderWidth) + 'px';
        this.height = height;

        if (this.props.onHeightChange) {
          this.props.onHeightChange(height, parseInt(style.maxHeight, 10));
        }
      }
    });

    _defineProperty(this, "getDOMNode", () => {
      return this.refs.textarea;
    });

    _defineProperty(this, "handleChange", e => {
      if (this.props.onChange) {
        this.props.onChange(e);
      }
    });

    this.height = 0;
  }

  get value() {
    return this.refs.textarea.value;
  }

  set value(value) {
    this.refs.textarea.value = value;
  }

  get selectionStart() {
    return this.refs.textarea.selectionStart;
  }

  set selectionStart(selectionStart) {
    this.refs.textarea.selectionStart = selectionStart;
  }

  get selectionEnd() {
    return this.refs.textarea.selectionEnd;
  }

  set selectionEnd(selectionEnd) {
    this.refs.textarea.selectionEnd = selectionEnd;
  }

  focus() {
    this.refs.textarea.focus();
  }

  blur() {
    this.refs.textarea.blur();
  }

  componentDidMount() {
    this.recalculateSize();
  }

  componentDidUpdate() {
    this.recalculateSize();
  }

  render() {
    const props = { ...this.props
    };
    Reflect.deleteProperty(props, 'onHeightChange');
    Reflect.deleteProperty(props, 'providers');
    Reflect.deleteProperty(props, 'channelId');
    const {
      value,
      defaultValue,
      placeholder,
      disabled,
      onInput,
      // TODO: The provided `id` is sometimes hard-coded and used to interface with the
      // component, e.g. `post_textbox`, so it can't be changed. This would ideally be
      // abstracted to avoid passing in an `id` prop at all, but we intentionally maintain
      // the old behaviour to address ABC-213.
      id,
      ...otherProps
    } = props;
    const heightProps = {};

    if (this.height <= 0) {
      // Set an initial number of rows so that the textarea doesn't appear too large when its first rendered
      heightProps.rows = 1;
    } else {
      heightProps.height = this.height;
    }

    let textareaPlaceholder = null;

    if (!this.props.value && !this.props.defaultValue) {
      textareaPlaceholder = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", _extends({}, otherProps, {
        style: style.placeholder
      }), placeholder);
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", null, textareaPlaceholder, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("textarea", _extends({
      ref: "textarea",
      id: id
    }, heightProps, otherProps, {
      disabled: disabled,
      onChange: this.handleChange,
      onInput: onInput,
      value: value,
      defaultValue: defaultValue
    })), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      style: style.container
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("textarea", _extends({
      ref: "reference",
      id: id + '-reference',
      style: style.reference,
      disabled: true,
      rows: "1"
    }, otherProps, {
      value: value || defaultValue
    }))));
  }

}

_defineProperty(AutosizeTextarea, "propTypes", {
  value: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  defaultValue: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  placeholder: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  onChange: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  onHeightChange: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func
});

const style = {
  container: {
    height: 0,
    overflow: 'hidden'
  },
  reference: {
    height: 'auto',
    width: '100%'
  },
  placeholder: {
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    opacity: 0.5,
    pointerEvents: 'none',
    position: 'absolute',
    whiteSpace: 'nowrap'
  }
};

/***/ }),

/***/ 2016:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AttachmentIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class AttachmentIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", this.props, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.attach",
      defaultMessage: "Attachment Icon"
    }, ariaLabel => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
      width: "18px",
      height: "18px",
      viewBox: "0 0 18 15",
      role: "icon",
      "aria-label": ariaLabel
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      fill: "inherit",
      fillRule: "evenodd"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(-1029.000000, -954.000000)",
      fillRule: "nonzero",
      fill: "inherit"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(25.000000, 937.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      transform: "translate(1004.000000, 17.000000)"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      d: "M5.35,15.56 C3.98,15.56 2.61,15.039 1.567,13.997 C0.557,12.984 0,11.642 0,10.212 C0,8.783 0.557,7.44 1.566,6.429 L6.869,1.126 C8.371,-0.376 10.812,-0.375 12.314,1.125 C13.815,2.627 13.815,5.069 12.314,6.57 L7.011,11.873 C6.094,12.792 4.603,12.79 3.687,11.873 C2.771,10.958 2.771,9.467 3.687,8.551 L8.99,3.248 C9.323,2.916 9.861,2.916 10.193,3.248 C10.525,3.579 10.525,4.118 10.193,4.449 L4.89,9.752 C4.637,10.006 4.637,10.418 4.89,10.672 C5.143,10.923 5.555,10.925 5.809,10.672 L11.113,5.369 C11.952,4.53 11.952,3.166 11.113,2.327 C10.276,1.49 8.911,1.488 8.073,2.327 L2.769,7.631 C2.079,8.32 1.699,9.237 1.699,10.212 C1.699,11.188 2.079,12.104 2.768,12.794 C4.19,14.216 6.502,14.216 7.925,12.798 L7.929,12.794 C7.929,12.793 7.929,12.793 7.929,12.793 L15.355,5.369 C15.687,5.037 16.224,5.037 16.556,5.369 C16.888,5.7 16.888,6.239 16.556,6.57 L8.779,14.348 L8.761,14.332 C7.776,15.15 6.562,15.56 5.35,15.56 Z"
    }))))))));
  }

}

/***/ }),

/***/ 2017:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export upFile */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return previewFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return previewFilePage; });
/* harmony import */ var _utils_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(450);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);

 // 上传文件

const upFile = function ({
  file,
  type,
  version
}) {
  const formData = new window.FormData();
  formData.append('files', file);
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    url: `/api/v4/files/ao?file_type=${type}&version=${version}`,
    method: "POST",
    data: formData
  });
}; //请求文件

const getFile = function () {
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    url: `/package/info`,
    method: "GET"
  });
}; //请求文件

const previewFile = function (fileid, page) {
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    url: `/api/v4/files/${fileid}/read?page=${page}`,
    method: "GET"
  });
}; //请求文件页数

const previewFilePage = function (fileid) {
  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    url: `/api/v4/files/${fileid}/page`,
    method: "GET"
  });
};

/***/ }),

/***/ 2031:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var components_ao_keyword_highlight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1732);
/* harmony import */ var utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);
/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2455);
/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_index_scss__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var mattermost_redux_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(27);
/* harmony import */ var mattermost_redux_client__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_client__WEBPACK_IMPORTED_MODULE_5__);





 // size: small、large
//修改于191015

/* harmony default export */ __webpack_exports__["a"] = (({
  data,
  keyword,
  onClick,
  size = 'small',
  currentUser
}) => {
  let avatarUrl = utils_utils__WEBPACK_IMPORTED_MODULE_3__[/* imageURLForUser */ "K"]({
    id: data.id
  }); // 当前用户更改头像后需要刷新

  if (currentUser && data.id === currentUser.id) {
    avatarUrl = mattermost_redux_client__WEBPACK_IMPORTED_MODULE_5__["Client4"].getProfilePictureUrl(currentUser.id, currentUser.last_picture_update);
  }

  const paddingTop = size === 'small' ? '10px' : '20px';
  const paddingRight = size === 'small' ? '20px' : '40px';
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    className: "contactsItem",
    onClick: onClick,
    style: {
      paddingTop,
      paddingRight,
      paddingBottom: paddingTop
    }
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    className: "contactsItem-inner"
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("img", {
    src: avatarUrl
  }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    className: "left"
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    className: "user-name"
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_ao_keyword_highlight__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
    content: data.nickname || 'bot',
    keyword: keyword
  })), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_ao_keyword_highlight__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
    content: data.email,
    keyword: keyword
  }))), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    className: "right"
  }, data.department_name || '部门暂无')));
});

/***/ }),

/***/ 2033:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return openUserProfile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return closeUserProfile; });
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
 // 打开用户profile

function openUserProfile(userinfo) {
  return async (dispatch, getState) => {
    return dispatch({
      type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__[/* ActionTypes */ "b"].OPEN_USERPROFILE,
      userinfo
    });
  };
} // 关闭用户profile

function closeUserProfile() {
  return async (dispatch, getState) => {
    dispatch({
      type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__[/* ActionTypes */ "b"].CLOSE_USERPROFILE
    });
  };
}

/***/ }),

/***/ 2040:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/01cd4e49b29c599a2d32938782c28a0a.png";

/***/ }),

/***/ 2042:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/* harmony default export */ __webpack_exports__["a"] = (({
  fill = "#C8CBD2",
  ...rest
}) => React.createElement("svg", _extends({
  height: "14",
  viewBox: "0 0 14 14",
  width: "14",
  xmlns: "http://www.w3.org/2000/svg"
}, rest), React.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React.createElement("circle", {
  cx: "7",
  cy: "7",
  fill: fill,
  r: "7"
}), React.createElement("path", {
  d: "m3 7h8m-4 4v-8",
  stroke: "#fff",
  strokeLinecap: "square",
  transform: "matrix(.70710678 .70710678 -.70710678 .70710678 7 -2.899495)"
}))));

/***/ }),

/***/ 2062:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/* harmony default export */ __webpack_exports__["a"] = (({
  fill = "#909090",
  ...rest
}) => React.createElement("svg", _extends({
  height: "19",
  viewBox: "0 0 20 19",
  width: "20",
  xmlns: "http://www.w3.org/2000/svg",
  fill: fill
}, rest), React.createElement("path", {
  d: "m19.7562082 29.6031827 3.2624102-1.3206474.7304654-.2952102.7304653.2952102 3.2625185 1.319521-.0971542-3.6080713-.0196474-.7145437.4476025-.5569525 2.0917724-2.6070904-3.3657814-1.0194585-.6505325-.1967346-.3861474-.5570825-2.0130958-2.903427-2.0117529 2.903427-.386169.5570825-.6505758.1967346-3.3682292 1.0207149 2.0918157 2.605834.4476242.5569525-.0196691.7145437zm10.0124508 2.92067-6.0195752-2.4348773-6.0194452 2.4348773.1757873-6.5828097-3.8969777-4.8537463 6.1277554-1.8557212 3.6128802-5.2127512 3.6141799 5.2127512 6.1241161 1.8557212-3.8957863 4.853768z",
  transform: "translate(-13.934783 -13.52381)"
})));

/***/ }),

/***/ 2063:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _star_icon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1882);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }


/* harmony default export */ __webpack_exports__["a"] = (props => React.createElement(_star_icon__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"], _extends({
  fill: "#00bc70"
}, props)));

/***/ }),

/***/ 2181:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/* harmony default export */ __webpack_exports__["a"] = (({
  fill = "#909090",
  ...rest
}) => React.createElement("svg", _extends({
  height: "14",
  viewBox: "0 0 12 14",
  width: "12",
  xmlns: "http://www.w3.org/2000/svg",
  fill: fill
}, rest), React.createElement("g", {
  fill: "none",
  fillRule: "evenodd",
  transform: "translate(-2 -1)"
}, React.createElement("path", {
  d: "m0 0h16v16h-16z",
  fillRule: "nonzero",
  opacity: "0"
}), React.createElement("path", {
  d: "m2 13h12v1.5h-12z"
}), React.createElement("g", {
  stroke: fill,
  strokeWidth: "1.5"
}, React.createElement("path", {
  d: "m4 2h8v8"
}), React.createElement("path", {
  d: "m11.5 2.76-6.70544922 6.70544922",
  strokeLinecap: "square"
})))));

/***/ }),

/***/ 2184:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EditIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class EditIcon extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_1__[/* FormattedMessage */ "c"], {
      id: "generic_icons.edit",
      defaultMessage: "Edit Icon"
    }, title => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", {
      className: "fa fa-pencil",
      title: title
    }));
  }

}

/***/ }),

/***/ 2185:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SettingPicture; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1995);
/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1998);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);
/* harmony import */ var utils_utils_jsx__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(22);
/* harmony import */ var utils_file_utils_jsx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1601);
/* harmony import */ var components_widgets_loading_loading_wrapper_jsx__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1608);
/* harmony import */ var components_form_error_jsx__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1584);
/* harmony import */ var components_formatted_markdown_message_jsx__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1564);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










class SettingPicture extends react__WEBPACK_IMPORTED_MODULE_1__["Component"] {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleCancel", e => {
      this.setState({
        removeSrc: false,
        setDefaultSrc: false
      });
      this.props.updateSection(e);
    });

    _defineProperty(this, "handleSave", e => {
      e.preventDefault();

      if (this.state.removeSrc) {
        this.props.onRemove();
      } else if (this.state.setDefaultSrc) {
        this.props.onSetDefault();
      } else {
        this.props.onSubmit();
      }
    });

    _defineProperty(this, "handleRemoveSrc", e => {
      e.preventDefault();
      this.setState({
        removeSrc: true
      });
    });

    _defineProperty(this, "handleSetDefaultSrc", e => {
      e.preventDefault();
      this.setState({
        setDefaultSrc: true
      });
    });

    _defineProperty(this, "handleFileChange", e => {
      this.setState({
        removeSrc: false,
        setDefaultSrc: false
      });
      this.props.onFileChange(e);
    });

    _defineProperty(this, "setPicture", file => {
      if (file) {
        this.previewBlob = URL.createObjectURL(file);
        var reader = new FileReader();

        reader.onload = e => {
          const orientation = utils_file_utils_jsx__WEBPACK_IMPORTED_MODULE_7__[/* getExifOrientation */ "e"](e.target.result);
          const orientationStyles = utils_file_utils_jsx__WEBPACK_IMPORTED_MODULE_7__[/* getOrientationStyles */ "g"](orientation);
          this.setState({
            image: this.previewBlob,
            orientationStyles
          });
        };

        reader.readAsArrayBuffer(file);
      }
    });

    _defineProperty(this, "renderImg", () => {
      const imageContext = this.props.imageContext;

      if (this.props.file) {
        const imageStyles = {
          backgroundImage: 'url(' + this.state.image + ')',
          ...this.state.orientationStyles
        };
        return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
          className: `${imageContext}-img-preview`
        }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
          className: "img-preview__image"
        }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
          alt: `${imageContext} image preview`,
          style: imageStyles,
          className: `${imageContext}-img-preview`
        })));
      }

      if (this.state.setDefaultSrc) {
        return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("img", {
          className: `${imageContext}-img`,
          alt: `${imageContext} image`,
          src: this.props.defaultImageSrc
        });
      }

      if (this.props.src && !this.state.removeSrc) {
        const imageElement = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("img", {
          className: `${imageContext}-img`,
          alt: `${imageContext} image`,
          src: this.props.src
        });

        if (!this.props.onRemove && !this.props.onSetDefault) {
          return imageElement;
        }

        let title;
        let handler;

        if (this.props.onRemove) {
          title = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
            id: "setting_picture.remove",
            defaultMessage: "Remove this icon"
          });
          handler = this.handleRemoveSrc;
        } else if (this.props.onSetDefault) {
          title = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
            id: "setting_picture.remove_profile_picture",
            defaultMessage: "Remove profile picture"
          });
          handler = this.handleSetDefaultSrc;
        }

        return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
          className: `${imageContext}-img__container`
        }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
          className: "img-preview__image"
        }, imageElement), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], {
          trigger: ['hover', 'focus'],
          delayShow: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_5__[/* Constants */ "g"].OVERLAY_TIME_DELAY,
          placement: "right",
          overlay: react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], {
            id: "removeIcon"
          }, title)
        }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("a", {
          className: `${imageContext}-img__remove`,
          onClick: handler
        }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", null, '×'))));
      }

      return null;
    });

    this.state = {
      image: null,
      removeSrc: false,
      setDefaultSrc: false
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.file !== this.props.file) {
      this.setState({
        image: null
      });
      this.setPicture(nextProps.file);
    }
  }

  componentWillUnmount() {
    if (this.previewBlob) {
      URL.revokeObjectURL(this.previewBlob);
    }
  }

  render() {
    const imageContext = this.props.imageContext;
    const img = this.renderImg();
    let confirmButtonClass = 'btn btn-sm';

    if (this.props.submitActive || this.state.removeSrc || this.state.setDefaultSrc) {
      confirmButtonClass += ' btn-primary';
    } else {
      confirmButtonClass += ' btn-inactive disabled';
    }

    let helpText;

    if (imageContext === 'team') {
      helpText = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_formatted_markdown_message_jsx__WEBPACK_IMPORTED_MODULE_10__[/* default */ "b"], {
        id: 'setting_picture.help.team',
        defaultMessage: "Upload a team icon in BMP, JPG or PNG format.\\nSquare images with a solid background color are recommended."
      });
    } else {
      helpText = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
        id: 'setting_picture.help.profile',
        defaultMessage: "Upload a picture in BMP, JPG or PNG format. Maximum file size: {max}",
        values: {
          max: Object(utils_utils_jsx__WEBPACK_IMPORTED_MODULE_6__[/* fileSizeToString */ "p"])(this.props.maxFileSize)
        }
      });
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("ul", {
      className: "section-max form-horizontal"
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
      className: "col-xs-12 section-title"
    }, this.props.title), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
      className: "col-xs-offset-3 col-xs-8"
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("ul", {
      className: "setting-list"
    }, img ? react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
      className: "setting-list-item"
    }, " ", img, " ") : '', react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
      className: "setting-list-item padding-top x2"
    }, helpText), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", {
      className: "setting-list-item"
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("hr", null), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_form_error_jsx__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"], {
      errors: [this.props.clientError, this.props.serverError],
      type: 'modal'
    }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      className: "btn btn-sm btn-primary btn-file sel-btn",
      disabled: this.props.loadingPicture
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
      id: "setting_picture.select",
      defaultMessage: "Select"
    }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("input", {
      ref: "input",
      accept: ".jpg,.png,.bmp",
      type: "file",
      onChange: this.handleFileChange,
      disabled: this.props.loadingPicture
    })), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("a", {
      className: confirmButtonClass,
      onClick: this.props.loadingPicture ? () => true : this.handleSave
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(components_widgets_loading_loading_wrapper_jsx__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"], {
      loading: this.props.loadingPicture,
      text: Object(utils_utils_jsx__WEBPACK_IMPORTED_MODULE_6__[/* localizeMessage */ "gb"])('setting_picture.uploading', 'Uploading...')
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
      id: "setting_picture.save",
      defaultMessage: "Save"
    }))), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("a", {
      className: "btn btn-link btn-sm theme",
      href: "#",
      onClick: this.handleCancel
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_intl__WEBPACK_IMPORTED_MODULE_2__[/* FormattedMessage */ "c"], {
      id: "setting_picture.cancel",
      defaultMessage: "Cancel"
    }))))));
  }

}

_defineProperty(SettingPicture, "defaultProps", {
  imageContext: 'profile'
});

_defineProperty(SettingPicture, "propTypes", {
  clientError: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  serverError: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  src: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  defaultImageSrc: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  file: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,
  loadingPicture: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  submitActive: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  onRemove: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  onSetDefault: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  onSubmit: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  title: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  onFileChange: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  updateSection: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  imageContext: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  maxFileSize: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number
});

/***/ }),

/***/ 2186:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export MenuItemExternalLinkImpl */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _menu_item_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1730);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



const MenuItemExternalLinkImpl = ({
  url,
  text
}) => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", {
  target: "_blank",
  rel: "noopener noreferrer",
  href: url
}, text);
MenuItemExternalLinkImpl.propTypes = {
  url: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  text: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node]).isRequired
};
const MenuItemExternalLink = Object(_menu_item_jsx__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(MenuItemExternalLinkImpl);
MenuItemExternalLink.displayName = 'MenuItemExternalLink';
/* harmony default export */ __webpack_exports__["a"] = (MenuItemExternalLink);

/***/ }),

/***/ 2251:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-custom-scrollbars/lib/index.js
var lib = __webpack_require__(1729);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./mattermost-redux/actions/helpers.js
var helpers = __webpack_require__(117);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./mattermost-redux/actions/channels.js
var channels = __webpack_require__(70);

// EXTERNAL MODULE: ./node_modules/react-outside-click-handler/index.js
var react_outside_click_handler = __webpack_require__(1863);
var react_outside_click_handler_default = /*#__PURE__*/__webpack_require__.n(react_outside_click_handler);

// EXTERNAL MODULE: ./components/search_chat_contact_item/index.jsx
var search_chat_contact_item = __webpack_require__(2031);

// EXTERNAL MODULE: ./utils/browser_history.jsx
var browser_history = __webpack_require__(114);

// EXTERNAL MODULE: ./node_modules/antd/es/message/index.js
var es_message = __webpack_require__(3478);

// EXTERNAL MODULE: ./components/ao_channel_member_item/ao_channel_member_item.scss
var ao_channel_member_item = __webpack_require__(2456);

// CONCATENATED MODULE: ./components/ao_channel_member_item/ao_channel_member_item.jsx







/* harmony default export */ var ao_channel_member_item_ao_channel_member_item = (({
  teamUrl,
  userinfo,
  channel,
  currentUserId,
  channelMembers,
  currentUser,
  actions
}) => {
  const [visible, setVisible] = Object(react["useState"])(false);
  const timeOut = 172;
  const timeGap = 170;
  let timeLast;
  let firstClick = false;
  let timeLine = -1; // 默认频道不允许转让管理员

  const isDefaultChannel = channel && (channel.name === constants["g" /* Constants */].DEFAULT_CHANNEL || channel.name === constants["g" /* Constants */].OFFTOPIC_CHANNEL);
  const content = react_default.a.createElement("div", {
    className: "ao-channel-member-actions"
  }, currentUserId !== userinfo.id ? react_default.a.createElement("a", {
    href: "javascript:;",
    onClick: () => {
      const link = `${teamUrl}/messages/@${userinfo.username}`;
      browser_history["a" /* browserHistory */].push(link);
    }
  }, "\u53D1\u9001\u6D88\u606F") : null, react_default.a.createElement("a", {
    href: "javascript:;",
    onClick: () => actions.openUserProfile(userinfo)
  }, "\u67E5\u770B\u8D44\u6599"), !isDefaultChannel && currentUserId !== userinfo.id && channelMembers[currentUser.id] && channelMembers[currentUser.id].scheme_admin ? react_default.a.createElement("a", {
    href: "javascript:;",
    onClick: () => updateChannelMemberSchemeRoles(channel, userinfo)
  }, "\u8F6C\u8BA9\u7BA1\u7406\u5458") : null);

  const updateChannelMemberSchemeRoles = async () => {
    actions.updateChannelMemberSchemeRoles(channel.id, userinfo.id, true, true).then(data => {
      if (data.error) {
        es_message["a" /* default */].error(data.error.message);
        return;
      }

      actions.updateChannelMemberSchemeRoles(channel.id, currentUserId, true, false).then(data => {
        if (data.error) {
          es_message["a" /* default */].error(data.error.message);
          return;
        }

        es_message["a" /* default */].success('转让成功');
      });
    });
  };

  const removeChannelMember = (channel, userinfo) => {
    if (channel) {
      actions.removeChannelMember(channel.id, userinfo.id).then(data => {
        if (data.error) {
          es_message["a" /* default */].error(data.error.message);
          return;
        }

        actions.getChannelStats(channel.id);
        setVisible(false);
      });
    }
  };

  const setTime = e => {
    clearTimeout(timeLine);
    timeLine = -1;
    timeLine = setTimeout(() => {
      //console.log("33333")
      firstClick = false;
      actions.openUserProfile(userinfo);
    }, timeOut, undefined);
  };

  const clickDouble = e => {
    if (currentUserId === userinfo.id) {
      //如果是自己则变成单击
      actions.openUserProfile(userinfo);
      return;
    }

    const currTime = new Date().getTime();

    if (firstClick) {
      //console.log("111111",currTime,timeLast,currTime-timeLast)
      if (currTime - timeLast <= timeGap) {
        firstClick = false;
        clearTimeout(timeLine);
        timeLine = -1;
        const link = `${teamUrl}/messages/@${userinfo.username}`;
        browser_history["a" /* browserHistory */].push(link);
      } else {
        //console.log("22222")
        firstClick = false;
        setTime();
      }
    } else {
      //console.log("44444")
      firstClick = true;
      timeLast = new Date().getTime();
      setTime();
    }
  };

  return react_default.a.createElement("div", {
    className: "ao-channel-member"
  }, react_default.a.createElement(react_outside_click_handler_default.a, {
    onOutsideClick: () => {
      setVisible(false);
    }
  }, react_default.a.createElement(search_chat_contact_item["a" /* default */], {
    currentUser: currentUser,
    data: userinfo,
    onClick: e => {
      e.stopPropagation();
      clickDouble(e);
    },
    size: "large"
  }), react_default.a.createElement("div", {
    className: "ao-channel-member-menus",
    onClick: () => setVisible(!visible)
  }), visible && content));
});
// EXTERNAL MODULE: ./actions/views/user_profile.js
var user_profile = __webpack_require__(2033);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var entities_channels = __webpack_require__(15);

// CONCATENATED MODULE: ./components/ao_channel_member_item/index.js










function mapStateToProps(state, ownProps) {
  const channelMembers = Object(entities_channels["getChannelMembersInChannels"])(state) || {};
  const currentUserId = Object(users["getCurrentUserId"])(state);
  return {
    teamUrl: Object(teams["getCurrentRelativeTeamUrl"])(state),
    currentUserId,
    currentUser: Object(users["getCurrentUser"])(state),
    currentTeam: Object(teams["getCurrentTeam"])(state),
    channelMembers: channelMembers[ownProps.channel.id]
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openUserProfile: user_profile["b" /* openUserProfile */],
      removeChannelMember: channels["removeChannelMember"],
      getChannelStats: channels["getChannelStats"],
      updateChannelMemberSchemeRoles: channels["updateChannelMemberSchemeRoles"]
    }, dispatch)
  };
}

/* harmony default export */ var components_ao_channel_member_item = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(ao_channel_member_item_ao_channel_member_item));
// EXTERNAL MODULE: ./components/search_results_header/index.jsx + 3 modules
var search_results_header = __webpack_require__(2257);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/posts.js
var posts = __webpack_require__(61);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var entities_preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./mattermost-redux/utils/post_utils.js
var post_utils = __webpack_require__(57);

// EXTERNAL MODULE: ./actions/views/rhs.js
var rhs = __webpack_require__(116);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var mattermost_redux_constants = __webpack_require__(17);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tooltip.js
var Tooltip = __webpack_require__(1998);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Modal.js
var Modal = __webpack_require__(1972);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Button.js
var Button = __webpack_require__(1693);

// EXTERNAL MODULE: ./components/post_view/post_message_view/index.js + 1 modules
var post_message_view = __webpack_require__(1759);

// EXTERNAL MODULE: ./components/file_attachment_list/index.js + 7 modules
var file_attachment_list = __webpack_require__(1718);

// EXTERNAL MODULE: ./components/common/comment_icon.jsx + 1 modules
var comment_icon = __webpack_require__(2272);

// EXTERNAL MODULE: ./components/dot_menu/index.js + 1 modules
var dot_menu = __webpack_require__(1969);

// EXTERNAL MODULE: ./components/post_profile_picture/index.jsx + 1 modules
var post_profile_picture = __webpack_require__(1758);

// EXTERNAL MODULE: ./components/user_profile/index.js + 1 modules
var components_user_profile = __webpack_require__(1720);

// EXTERNAL MODULE: ./components/post_view/date_separator/index.js + 1 modules
var date_separator = __webpack_require__(1827);

// EXTERNAL MODULE: ./components/post_view/post_body_additional_content/index.js + 15 modules
var post_body_additional_content = __webpack_require__(1960);

// EXTERNAL MODULE: ./components/post_view/post_flag_icon/index.js + 1 modules
var post_flag_icon = __webpack_require__(1760);

// EXTERNAL MODULE: ./components/svg/archive_icon.jsx
var archive_icon = __webpack_require__(1691);

// EXTERNAL MODULE: ./components/post_view/post_time/index.js + 1 modules
var post_time = __webpack_require__(1970);

// EXTERNAL MODULE: ./components/widgets/badges/bot_badge.jsx
var bot_badge = __webpack_require__(1588);

// EXTERNAL MODULE: ./components/svg/info_small_icon.jsx
var info_small_icon = __webpack_require__(1883);

// EXTERNAL MODULE: ./utils/post_utils.jsx + 1 modules
var utils_post_utils = __webpack_require__(407);

// EXTERNAL MODULE: ./components/view_image/index.js + 6 modules
var view_image = __webpack_require__(1755);

// CONCATENATED MODULE: ./components/search_results_item/search_results_item.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
























function renderView(props) {
  return react_default.a.createElement("div", _extends({}, props, {
    className: "scrollbar--view"
  }));
}
function renderThumbHorizontal(props) {
  return react_default.a.createElement("div", _extends({}, props, {
    className: "scrollbar--horizontal"
  }));
}
function renderThumbVertical(props) {
  return react_default.a.createElement("div", _extends({}, props, {
    className: "scrollbar--vertical"
  }));
}
class search_results_item_SearchResultsItem extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleFocusRHSClick", e => {
      e.preventDefault();
      this.props.actions.selectPost(this.props.post);
    });

    _defineProperty(this, "handleJumpClick", () => {
      if (utils["Y" /* isMobile */]()) {
        this.props.actions.closeRightHandSide();
      }

      this.props.actions.setRhsExpanded(false);
      browser_history["a" /* browserHistory */].push(`/${this.props.currentTeamName}/pl/${this.props.post.id}`);
    });

    _defineProperty(this, "handleCardClick", post => {
      if (!post) {
        return;
      }

      this.props.actions.selectPostCard(post);
    });

    _defineProperty(this, "handleDropdownOpened", isOpened => {
      this.setState({
        dropdownOpened: isOpened
      });
    });

    _defineProperty(this, "handleImageClick", () => {
      this.setState({
        showPreviewModal: true,
        startImgIndex: 0
      });
    });

    _defineProperty(this, "hidePreviewModal", () => {
      this.setState({
        showPreviewModal: false
      });
    });

    _defineProperty(this, "renderPostTime", () => {
      const post = this.props.post;
      const isPermalink = !this.props.isCloudPosts && !(mattermost_redux_constants["Posts"].POST_DELETED === post.state || post_utils["isPostPendingOrFailed"](post));
      return react_default.a.createElement(post_time["a" /* default */], {
        isPermalink: isPermalink,
        eventTime: post.create_at,
        postId: post.id,
        location: constants["o" /* Locations */].SEARCH
      });
    });

    _defineProperty(this, "getClassName", () => {
      let className = 'post post--thread';

      if (this.props.compactDisplay) {
        className += ' post--compact';
      }

      if (this.state.dropdownOpened) {
        className += ' post--hovered';
      }

      return className;
    });

    _defineProperty(this, "handleOpCloudUp", e => {
      this.props.actions.handleOpCloud(e).then(result => {
        if (result && result.data && result.data.infos) {
          // let arr = [];
          // arr.push(result.data.infos[0])
          // arr.push(result.data.infos[0])
          // arr.push(result.data.infos[0])
          // arr.push(result.data.infos[0])
          // arr.push(result.data.infos[0])
          // arr.push(result.data.infos[0])
          // arr.push(result.data.infos[0])
          // this.setState({operationList:arr,showOpModal:true})
          this.setState({
            operationList: result.data.infos,
            showOpModal: true
          });
        }
      });
    });

    _defineProperty(this, "handleOpenDelete", post => {
      this.setState({
        showDeleteModal: true,
        deletePost: post
      });
    });

    this.state = {
      dropdownOpened: false,
      showPreviewModal: false,
      startImgIndex: 0,
      showOpModal: false,
      showDeleteModal: false,
      deletePost: null,
      operationList: []
    };
    this.handleImageClick = this.handleImageClick.bind(this);
  }

  //关闭详情
  handleClose() {
    this.setState({
      showOpModal: false
    });
  }

  //详情滚动赖加载
  handleScroll() {} // if (!this.props.isFlaggedPosts && !this.props.isPinnedPosts && !this.props.isSearchingTerm && !this.props.isSearchGettingMore && !this.props.isCloudPosts) {
  //     const scrollHeight = this.refs.scrollbars.getScrollHeight();
  //     const scrollTop = this.refs.scrollbars.getScrollTop();
  //     const clientHeight = this.refs.scrollbars.getClientHeight();
  //     if ((scrollTop + clientHeight + GET_MORE_BUFFER) >= scrollHeight) {
  //         this.loadMorePosts();
  //     }
  // }
  //打开删除对话


  //确定删除
  handleDeleteOk() {
    this.props.actions.handleDeleteCloud(this.state.deletePost);
  }

  //取消删除
  handleDeleteClose() {
    this.setState({
      showDeleteModal: false
    });
  }

  render() {
    let channelName = null;
    const {
      channel,
      post
    } = this.props;
    const channelIsArchived = channel ? channel.delete_at !== 0 : true;

    if (channel) {
      channelName = channel.display_name;

      if (channel.type === constants["N" /* default */].DM_CHANNEL) {
        channelName = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "search_item.direct",
          defaultMessage: "Direct Message (with {username})",
          values: {
            username: utils["w" /* getDisplayNameByUser */](utils["v" /* getDirectTeammate */](channel.id))
          }
        });
      }
    }

    let overrideUsername;
    let disableProfilePopover = false;

    if (post.props && post.props.from_webhook && post.props.override_username && this.props.enablePostUsernameOverride) {
      overrideUsername = post.props.override_username;
      disableProfilePopover = true;
    }

    const profilePic = react_default.a.createElement(post_profile_picture["a" /* default */], {
      compactDisplay: this.props.compactDisplay,
      post: post,
      userId: post.user_id
    });
    const profilePicContainer = react_default.a.createElement("div", {
      className: "post__img"
    }, profilePic);
    let postClass = '';

    if (utils_post_utils["i" /* isEdited */](this.props.post)) {
      postClass += ' post--edited';
    }

    let fileAttachment = null;

    if (post.file_ids && post.file_ids.length > 0) {
      fileAttachment = react_default.a.createElement(file_attachment_list["a" /* default */], {
        post: post,
        compactDisplay: this.props.compactDisplay
      });
    }

    let message;
    let flagContent;
    let postInfoIcon;
    let rhsControls;
    let sortedFileInfos = null;
    let ctls;

    if (post.state === constants["N" /* default */].POST_DELETED) {
      message = react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "post_body.deleted",
        defaultMessage: "(message deleted)"
      }));
    } else {
      if (post.props && post.props.card) {
        postInfoIcon = react_default.a.createElement(OverlayTrigger["a" /* default */], {
          trigger: ['hover', 'focus'],
          delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
          placement: "top",
          overlay: react_default.a.createElement(Tooltip["a" /* default */], {
            id: "recentMentionsTooltip"
          }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "post_info.info.view_additional_info",
            defaultMessage: "View additional info"
          }))
        }, react_default.a.createElement("button", {
          className: "card-icon__container icon--show style--none",
          onClick: e => {
            e.preventDefault();
            this.handleCardClick(this.props.post);
          }
        }, react_default.a.createElement(info_small_icon["a" /* default */], {
          className: "icon icon__info",
          "aria-hidden": "true"
        })));
      }

      if (!this.props.isCloudPosts) {
        flagContent = react_default.a.createElement(post_flag_icon["a" /* default */], {
          location: constants["o" /* Locations */].SEARCH,
          postId: post.id,
          isFlagged: this.props.isFlagged
        });
        message = react_default.a.createElement(Tooltip["a" /* default */], {
          id: "cloudTooltip"
        }, react_default.a.createElement("a", {
          onClick: this.handleJumpClick,
          className: "search-item__jump"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "search_item.jump",
          defaultMessage: "Jump"
        })));
        rhsControls = react_default.a.createElement("div", {
          className: "col__controls col__reply"
        }, react_default.a.createElement(dot_menu["a" /* default */], {
          post: post,
          location: constants["o" /* Locations */].SEARCH,
          isFlagged: this.props.isFlagged,
          handleDropdownOpened: this.handleDropdownOpened,
          commentCount: this.props.commentCountForPost,
          isReadOnly: channelIsArchived || null
        }), react_default.a.createElement(comment_icon["a" /* default */], {
          location: constants["o" /* Locations */].SEARCH,
          handleCommentClick: this.handleFocusRHSClick,
          postId: post.id,
          searchStyle: 'search-item__comment'
        }), react_default.a.createElement("a", {
          onClick: this.handleJumpClick,
          className: "search-item__jump"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "search_item.jump",
          defaultMessage: "Jump"
        })));
      } else {
        sortedFileInfos = [this.props.post];
        const isDelete = this.props.post.delete_at > 0;

        if (!isDelete) {
          message = react_default.a.createElement("a", {
            onClick: e => {
              e.preventDefault();
              this.handleImageClick();
            }
          }, react_default.a.createElement("div", null, this.props.post.name));
        } else {
          message = react_default.a.createElement("div", {
            className: "message_delete"
          }, this.props.post.name);
        }

        rhsControls = react_default.a.createElement("div", {
          className: "col__controls col__reply"
        }, react_default.a.createElement(dot_menu["a" /* default */], {
          post: post,
          location: constants["o" /* Locations */].SEARCH,
          isFlagged: this.props.isFlagged,
          isCloudPosts: this.props.isCloudPosts,
          handleDropdownOpened: this.handleDropdownOpened,
          commentCount: this.props.commentCountForPost,
          handleViewCloud: this.handleImageClick,
          isDelete: isDelete,
          handleOpCloudUp: this.handleOpCloudUp,
          handleOpenDelete: this.handleOpenDelete,
          isReadOnly: channelIsArchived || null
        }));
        let lastAccessTime;
        ctls = this.state.operationList.map(op => {
          lastAccessTime = new Date(op.create_at);
          return react_default.a.createElement("div", null, op.operator_name, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: constants["B" /* Search_Operation */][op.operation],
            defaultMessage: ""
          }), react_default.a.createElement(index_es["d" /* FormattedTime */], {
            value: lastAccessTime,
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          }));
        }, this);
      }
    }

    let pinnedBadge;

    if (post.is_pinned && !this.props.isCloudPosts) {
      pinnedBadge = react_default.a.createElement("span", {
        className: "post__pinned-badge"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "post_info.pinned",
        defaultMessage: "Pinned"
      }));
    }

    const currentPostDay = utils["t" /* getDateForUnixTicks */](post.create_at);
    return react_default.a.createElement("div", {
      "data-testid": "search-item-container",
      className: "search-item__container"
    }, react_default.a.createElement(date_separator["a" /* default */], {
      date: currentPostDay
    }), react_default.a.createElement("div", {
      className: this.getClassName()
    }, react_default.a.createElement("div", {
      className: "search-channel__name"
    }, channelName, channelIsArchived && react_default.a.createElement("span", {
      className: "search-channel__archived"
    }, react_default.a.createElement(archive_icon["a" /* default */], {
      className: "icon icon__archive channel-header-archived-icon svg-text-color"
    }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_item.channelArchived",
      defaultMessage: "Archived"
    }))), react_default.a.createElement("div", {
      className: "post__content"
    }, !this.props.isCloudPosts && profilePicContainer, react_default.a.createElement("div", null, react_default.a.createElement("div", {
      className: "post__header"
    }, react_default.a.createElement("div", {
      className: "col col__name"
    }, react_default.a.createElement(components_user_profile["a" /* default */], {
      userId: post.user_id,
      overwriteName: overrideUsername,
      disablePopover: disableProfilePopover,
      isRHS: true
    }), react_default.a.createElement(bot_badge["a" /* default */], {
      show: Boolean(post.props && post.props.from_webhook && !this.props.isBot)
    })), react_default.a.createElement("div", {
      className: "col"
    }, this.renderPostTime(), pinnedBadge, postInfoIcon, flagContent), rhsControls), react_default.a.createElement("div", {
      className: "search-item-snippet post__body"
    }, react_default.a.createElement("div", {
      className: postClass
    }, message, fileAttachment))))), this.props.isCloudPosts && react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(view_image["a" /* default */], {
      show: this.state.showPreviewModal,
      onModalDismissed: this.hidePreviewModal,
      startIndex: this.state.startImgIndex,
      fileInfos: sortedFileInfos,
      postId: this.props.post.id,
      post: this.props.post
    })), react_default.a.createElement(Modal["a" /* default */], {
      show: this.state.showOpModal,
      onHide: this.handleClose.bind(this)
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.operation",
      defaultMessage: "Operation"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, ctls), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement(Button["a" /* default */], {
      onClick: this.handleClose.bind(this)
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.okay",
      defaultMessage: "OK"
    })))), react_default.a.createElement(Modal["a" /* default */], {
      show: this.state.showDeleteModal
    }, react_default.a.createElement(Modal["a" /* default */].Header, null, react_default.a.createElement(Modal["a" /* default */].Title, null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.title",
      defaultMessage: "Confirm Cloud Disk Delete"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.body",
      defaultMessage: "Are you sure you want to delete this Cloud Disk?"
    })), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement(Button["a" /* default */], {
      onClick: this.handleDeleteClose.bind(this)
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.cancel",
      defaultMessage: "CANCEL"
    })), react_default.a.createElement(Button["a" /* default */], {
      bsStyle: "primary",
      onClick: this.handleDeleteOk.bind(this)
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.delete",
      defaultMessage: "DELETE"
    })))));
  }

}

_defineProperty(search_results_item_SearchResultsItem, "propTypes", {
  /**
  *  Data used for rendering post
  */
  post: prop_types_default.a.object,

  /**
  * An array of strings in this post that were matched by the search
  */
  matches: prop_types_default.a.array,

  /**
  *  channel object for rendering channel name on top of result
  */
  channel: prop_types_default.a.object,

  /**
  *  Flag for determining result display setting
  */
  compactDisplay: prop_types_default.a.bool,

  /**
  *  Flag for highlighting mentions
  */
  isMentionSearch: prop_types_default.a.bool,

  /**
  *  Flag for highlighting search term
  */
  term: prop_types_default.a.string,

  /**
  *  Flag for determining result flag state
  */
  isFlagged: prop_types_default.a.bool,

  /**
  *  Data used creating URl for jump to post
  */
  currentTeamName: prop_types_default.a.string,

  /**
  *  Data used for delete in DotMenu
  */
  commentCountForPost: prop_types_default.a.number,

  /**
   * Whether post username overrides are to be respected.
   */
  enablePostUsernameOverride: prop_types_default.a.bool.isRequired,

  /**
   * Is the search results item from a bot.
   */
  isBot: prop_types_default.a.bool.isRequired,
  isCloudPosts: prop_types_default.a.bool,

  /**
  *  Function used for closing LHS
  */
  actions: prop_types_default.a.shape({
    closeRightHandSide: prop_types_default.a.func.isRequired,
    selectPost: prop_types_default.a.func.isRequired,
    selectPostCard: prop_types_default.a.func.isRequired,
    setRhsExpanded: prop_types_default.a.func.isRequired
  }).isRequired
});

_defineProperty(search_results_item_SearchResultsItem, "defaultProps", {
  isBot: false
});
// CONCATENATED MODULE: ./components/search_results_item/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













function search_results_item_mapStateToProps() {
  const getCommentCountForPost = Object(posts["makeGetCommentCountForPost"])();
  return (state, ownProps) => {
    const config = Object(general["getConfig"])(state);
    const preferences = Object(entities_preferences["getMyPreferences"])(state);
    const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
    const {
      post
    } = ownProps;
    const user = Object(users["getUser"])(state, post.user_id);
    return {
      channel: Object(entities_channels["getChannel"])(state, post.channel_id),
      currentTeamName: Object(teams["getCurrentTeam"])(state).name,
      commentCountForPost: getCommentCountForPost(state, {
        post
      }),
      enablePostUsernameOverride,
      isFlagged: Object(post_utils["isPostFlagged"])(post.id, preferences),
      isBot: user ? user.is_bot : false
    };
  };
}

function search_results_item_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      closeRightHandSide: rhs["b" /* closeRightHandSide */],
      selectPost: rhs["j" /* selectPostFromRightHandSideSearch */],
      selectPostCard: rhs["i" /* selectPostCardFromRightHandSideSearch */],
      setRhsExpanded: rhs["l" /* setRhsExpanded */],
      handleOpCloud: post_actions["i" /* handleOpCloud */],
      handleDeleteCloud: post_actions["g" /* handleDeleteCloud */]
    }, dispatch)
  };
}

/* harmony default export */ var search_results_item = (Object(es["connect"])(search_results_item_mapStateToProps, search_results_item_mapDispatchToProps)(search_results_item_SearchResultsItem));
// EXTERNAL MODULE: ./components/search_hint/search_hint.jsx
var search_hint = __webpack_require__(1884);

// EXTERNAL MODULE: ./components/icons/star_icon.jsx
var star_icon = __webpack_require__(1882);

// CONCATENATED MODULE: ./components/search_hint/data_retention_hint.jsx
function data_retention_hint_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class data_retention_hint_DataRetentionHint extends react["PureComponent"] {
  render() {
    return react_default.a.createElement("li", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.usage.dataRetention",
      defaultMessage: "Only messages posted in the last {days} days are returned. Contact your System Administrator for more detail.",
      values: {
        days: this.props.dataRetentionMessageRetentionDays
      }
    }));
  }

}

data_retention_hint_defineProperty(data_retention_hint_DataRetentionHint, "propTypes", {
  dataRetentionMessageRetentionDays: prop_types_default.a.string
});
// CONCATENATED MODULE: ./components/search_hint/flag_post_search_hint.jsx
function flag_post_search_hint_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class flag_post_search_hint_FlagPostSearchHint extends react["PureComponent"] {
  render() {
    return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("ul", null, react_default.a.createElement("li", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.usageFlag1",
      defaultMessage: "You haven't flagged any messages yet."
    })), react_default.a.createElement("li", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.usageFlag2",
      defaultMessage: "You can add a flag to messages and comments by clicking the {flagIcon} icon next to the timestamp.",
      values: {
        flagIcon: react_default.a.createElement(star_icon["a" /* default */], {
          className: "usage__icon"
        })
      }
    })), react_default.a.createElement("li", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.usageFlag4",
      defaultMessage: "Flags are a way to mark messages for follow up. Your flags are personal, and cannot be seen by other users."
    })), this.props.dataRetentionEnableMessageDeletion && react_default.a.createElement(data_retention_hint_DataRetentionHint, {
      dataRetentionMessageRetentionDays: this.props.dataRetentionMessageRetentionDays
    })));
  }

}

flag_post_search_hint_defineProperty(flag_post_search_hint_FlagPostSearchHint, "propTypes", {
  dataRetentionEnableMessageDeletion: prop_types_default.a.bool,
  dataRetentionMessageRetentionDays: prop_types_default.a.string
});
// CONCATENATED MODULE: ./components/search_hint/no_result_search_hint.jsx
function no_result_search_hint_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class no_result_search_hint_PinPostSearchHint extends react["PureComponent"] {
  render() {
    return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("h4", {
      id: "noResultsMessage"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.noResults",
      defaultMessage: "No results found. Try again?"
    })), react_default.a.createElement("ul", null, react_default.a.createElement("li", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.noResults.partialPhraseSuggestion",
      defaultMessage: "If you're searching a partial phrase (ex. searching \"rea\", looking for \"reach\" or \"reaction\"), append a * to your search term."
    })), react_default.a.createElement("li", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.noResults.stopWordsSuggestion",
      defaultMessage: "Two letter searches and common words like \"this\", \"a\" and \"is\" won't appear in search results due to the excessive results returned."
    })), this.props.dataRetentionEnableMessageDeletion && react_default.a.createElement(data_retention_hint_DataRetentionHint, {
      dataRetentionMessageRetentionDays: this.props.dataRetentionMessageRetentionDays
    })));
  }

}

no_result_search_hint_defineProperty(no_result_search_hint_PinPostSearchHint, "propTypes", {
  dataRetentionEnableMessageDeletion: prop_types_default.a.bool,
  dataRetentionMessageRetentionDays: prop_types_default.a.string
});
// CONCATENATED MODULE: ./components/search_hint/pin_post_search_hint.jsx
function pin_post_search_hint_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class pin_post_search_hint_PinPostSearchHint extends react["PureComponent"] {
  render() {
    return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("ul", null, react_default.a.createElement("li", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.usagePin1",
      defaultMessage: "There are no pinned messages yet."
    })), react_default.a.createElement("li", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.usagePin2",
      defaultMessage: "All members of this channel can pin important or useful messages."
    })), react_default.a.createElement("li", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.usagePin3",
      defaultMessage: "Pinned messages are visible to all channel members."
    })), react_default.a.createElement("li", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_results.usagePin4",
      defaultMessage: 'To pin a message: Go to the message that you want to pin and click [...] > "Pin to channel".'
    })), this.props.dataRetentionEnableMessageDeletion && react_default.a.createElement(data_retention_hint_DataRetentionHint, {
      dataRetentionMessageRetentionDays: this.props.dataRetentionMessageRetentionDays
    })));
  }

}

pin_post_search_hint_defineProperty(pin_post_search_hint_PinPostSearchHint, "propTypes", {
  dataRetentionEnableMessageDeletion: prop_types_default.a.bool,
  dataRetentionMessageRetentionDays: prop_types_default.a.string
});
// EXTERNAL MODULE: ./components/widgets/loading/loading_wrapper.jsx
var loading_wrapper = __webpack_require__(1608);

// EXTERNAL MODULE: ./components/ao_collect_item/ao_collect_item.jsx
var ao_collect_item = __webpack_require__(2567);

// EXTERNAL MODULE: ./actions/views/posts.js
var views_posts = __webpack_require__(1618);

// CONCATENATED MODULE: ./components/ao_collect_item/index.js








function ao_collect_item_mapStateToProps(state, ownProps) {
  const currentChannel = Object(entities_channels["getCurrentChannel"])(state) || {};
  return {
    currentChannel,
    getUserById: userid => Object(users["getUser"])(state, userid)
  };
}

function ao_collect_item_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      setChannelPostSelect: views_posts["c" /* setChannelPostSelect */],
      deleteMergeCollect: post_actions["e" /* deleteMergeCollect */]
    }, dispatch)
  };
}

/* harmony default export */ var components_ao_collect_item = (Object(es["connect"])(ao_collect_item_mapStateToProps, ao_collect_item_mapDispatchToProps)(ao_collect_item["a" /* default */]));
// EXTERNAL MODULE: ./components/ao_cloud/ao_cloud.jsx
var ao_cloud = __webpack_require__(2945);

// CONCATENATED MODULE: ./components/ao_cloud/index.js





function ao_cloud_mapStateToProps(state, ownProps) {
  const searchTerm = state.views.search.sidebarSearch;
  return {
    searchTerm,
    cloudList: state.views.rhs.cloudList
  };
}

function ao_cloud_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getCloudData: rhs["d" /* getCloudData */]
    }, dispatch)
  };
}

/* harmony default export */ var components_ao_cloud = (Object(es["connect"])(ao_cloud_mapStateToProps, ao_cloud_mapDispatchToProps)(ao_cloud["a" /* default */]));
// EXTERNAL MODULE: ./components/ao_meeting_item/index.scss
var ao_meeting_item = __webpack_require__(2949);

// EXTERNAL MODULE: ./node_modules/moment/moment.js
var moment = __webpack_require__(2);
var moment_default = /*#__PURE__*/__webpack_require__.n(moment);

// EXTERNAL MODULE: ./api/post.js
var api_post = __webpack_require__(67);

// CONCATENATED MODULE: ./components/ao_meeting_item/ao_meeting_item.jsx
function ao_meeting_item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // import MeetingItemMoreFunc from './ao_meeting_item_more_func'
// import FileAttachmentListContainer from 'components/file_attachment_list';
// import {Locations} from "utils/constants";
// import {createCard} from "components/ao_post_cards";
// import * as TextFormatting from 'utils/text_formatting.jsx';
// import messageHtmlToComponent from 'utils/message_html_to_component';




class ao_meeting_item_MeetingItem extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }

  handleClickJoin(post) {
    this.props.actions.joinMeet({
      channel_id: post.channel_id,
      meeting_id: post.meeting_id,
      meeting_no: post.meeting_no,
      meetName: post.meeting_name,
      nick_name: this.props.user.nickname,
      user_name: this.props.user.username
    });
  }

  render() {
    const {
      post
    } = this.props;
    const message_join = react_default.a.createElement("div", {
      className: "meet_item un_in"
    }, react_default.a.createElement("div", {
      className: "meet_item-inner"
    }, react_default.a.createElement("div", {
      className: "meet_header"
    }, `${post.nick_name}发起的${post.meeting_name}`), react_default.a.createElement("div", {
      className: "meet_time"
    }, moment_default()(post.create_at).format('YYYY-MM-DD HH:mm:ss')), react_default.a.createElement("div", {
      className: "status status_ing"
    }, react_default.a.createElement("div", {
      className: "border"
    }), react_default.a.createElement("span", null, "\u4F1A\u8BAE\u4E2D"))));
    const message_toIn = react_default.a.createElement("div", {
      className: "meet_item to_in"
    }, react_default.a.createElement("div", {
      className: "meet_item-inner"
    }, react_default.a.createElement("div", {
      className: "meet_header"
    }, `${post.nick_name}发起的${post.meeting_name}`), react_default.a.createElement("div", {
      className: "meet_time"
    }, moment_default()(post.create_at).format('YYYY-MM-DD HH:mm:ss')), react_default.a.createElement(Button["a" /* default */], {
      className: "join-btn",
      onClick: this.handleClickJoin.bind(this, post)
    }, "\u70B9\u51FB\u52A0\u5165")));
    const message_unIn = react_default.a.createElement("div", {
      className: "meet_item un_in"
    }, react_default.a.createElement("div", {
      className: "meet_item-inner"
    }, react_default.a.createElement("div", {
      className: "meet_header"
    }, `${post.nick_name}发起的${post.meeting_name}`), react_default.a.createElement("div", {
      className: "meet_time"
    }, moment_default()(post.update_at).format('YYYY-MM-DD HH:mm:ss')), react_default.a.createElement("div", {
      className: "status status_unin"
    }, react_default.a.createElement("div", {
      className: "border"
    }), react_default.a.createElement("span", null, "\u672A\u53C2\u52A0"))));
    const message_ended = react_default.a.createElement("div", {
      className: "meet_item un_in"
    }, react_default.a.createElement("div", {
      className: "meet_item-inner"
    }, react_default.a.createElement("div", {
      className: "meet_header"
    }, `${post.nick_name}发起的${post.meeting_name}`), react_default.a.createElement("div", {
      className: "meet_time"
    }, moment_default()(post.update_at).format('YYYY-MM-DD HH:mm:ss')), react_default.a.createElement("div", {
      className: "status status_ended"
    }, react_default.a.createElement("div", {
      className: "border"
    }), react_default.a.createElement("span", null, "\u5DF2\u7ED3\u675F"))));

    if (utils["U" /* isJoin */](post)) {
      return message_join;
    } else if (utils["bb" /* isToin */](post)) {
      return message_toIn;
    } else if (utils["cb" /* isUnin */](post)) {
      return message_unIn;
    } else if (utils["Q" /* isEnded */](post)) {
      return message_ended;
    }

    return '';
  }

}

ao_meeting_item_defineProperty(ao_meeting_item_MeetingItem, "propTypes", {
  /**
  *  Data used for rendering post
  */
  post: PropTypes.object,
  user: PropTypes.object,
  currentChannel: PropTypes.object,
  actions: PropTypes.shape({
    joinMeet: PropTypes.func.isRequired
  }).isRequired
});
// EXTERNAL MODULE: ./actions/views/meeting.js
var meeting = __webpack_require__(182);

// CONCATENATED MODULE: ./components/ao_meeting_item/index.js







function ao_meeting_item_mapStateToProps(state, ownProps) {
  const {
    post
  } = ownProps;
  const user = Object(users["getCurrentUser"])(state);
  const currentChannel = Object(entities_channels["getCurrentChannel"])(state) || {};
  return {
    user,
    currentChannel
  };
}

function ao_meeting_item_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      joinMeet: meeting["f" /* joinMeet */]
    }, dispatch)
  };
}

/* harmony default export */ var components_ao_meeting_item = (Object(es["connect"])(ao_meeting_item_mapStateToProps, ao_meeting_item_mapDispatchToProps)(ao_meeting_item_MeetingItem));
// EXTERNAL MODULE: ./components/ao_mention_item/index.scss
var ao_mention_item = __webpack_require__(2950);

// EXTERNAL MODULE: ./components/ao_post_cards/index.js + 35 modules
var ao_post_cards = __webpack_require__(1821);

// EXTERNAL MODULE: ./utils/text_formatting.jsx
var text_formatting = __webpack_require__(81);

// EXTERNAL MODULE: ./utils/message_html_to_component.jsx + 3 modules
var message_html_to_component = __webpack_require__(1684);

// CONCATENATED MODULE: ./components/ao_mention_item/ao_mention_item.jsx
function ao_mention_item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // import MeetingItemMoreFunc from './ao_meeting_item_more_func'
// import FileAttachmentListContainer from 'components/file_attachment_list';
// import {Locations} from "utils/constants";








class ao_mention_item_MentionItem extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }

  handleJumpClick(post) {
    if (utils["Y" /* isMobile */]()) {
      this.props.actions.closeRightHandSide();
    }

    this.props.actions.setRhsExpanded(false);
    browser_history["a" /* browserHistory */].push(`/${this.props.currentTeamName}/pl/${this.props.post.id}`);
  }

  render() {
    const {
      post,
      user,
      currentChannel
    } = this.props;
    let messageContent = null;
    const Card = Object(ao_post_cards["a" /* createCard */])(post); // console.log(Card)

    const htmlFormattedText = text_formatting["e" /* formatText */](post.message); // console.log(htmlFormattedText)

    if (Card) {
      messageContent = react_default.a.createElement("div", {
        style: {
          border: '1px solid #E6E6E6',
          display: 'inline-block',
          margin: '5px 0 0 0'
        }
      }, react_default.a.createElement(Card, {
        post: post,
        channel: currentChannel
      }));
    } else {
      messageContent = react_default.a.createElement("div", {
        className: "message-text",
        onClick: this.handleJumpClick.bind(this, post)
      }, Object(message_html_to_component["a" /* default */])(htmlFormattedText));
    }

    let className = 'mention-item';

    if (!post.isRead) {
      className += ' unread';
    }

    return react_default.a.createElement("div", {
      className: className
    }, react_default.a.createElement("div", {
      className: "mention-item-inner"
    }, react_default.a.createElement("div", {
      className: "header"
    }, react_default.a.createElement("span", {
      className: "name"
    }, user.nickname), react_default.a.createElement("span", {
      className: "time"
    }, moment_default()(post.create_at).format('YYYY-MM-DD HH:mm:ss'))), react_default.a.createElement("div", {
      className: "content"
    }, messageContent)));
  }

}

ao_mention_item_defineProperty(ao_mention_item_MentionItem, "propTypes", {
  /**
  *  Data used for rendering post
  */
  post: PropTypes.object,
  user: PropTypes.object,
  currentChannel: PropTypes.object,

  /**
  *  Data used creating URl for jump to post
  */
  currentTeamName: PropTypes.string,
  actions: PropTypes.shape({
    closeRightHandSide: PropTypes.func.isRequired,
    setRhsExpanded: PropTypes.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/ao_mention_item/index.js









function ao_mention_item_mapStateToProps(state, ownProps) {
  const {
    post
  } = ownProps;
  const user = Object(users["getUser"])(state, post.user_id);
  const currentChannel = Object(entities_channels["getCurrentChannel"])(state) || {};
  return {
    user,
    currentChannel,
    currentTeamName: Object(teams["getCurrentTeam"])(state).name
  };
}

function ao_mention_item_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      setRhsExpanded: rhs["l" /* setRhsExpanded */],
      closeRightHandSide: rhs["b" /* closeRightHandSide */]
    }, dispatch)
  };
}

/* harmony default export */ var components_ao_mention_item = (Object(es["connect"])(ao_mention_item_mapStateToProps, ao_mention_item_mapDispatchToProps)(ao_mention_item_MentionItem));
// CONCATENATED MODULE: ./components/search_results/search_results.jsx
/* unused harmony export renderView */
/* unused harmony export renderThumbHorizontal */
/* unused harmony export renderThumbVertical */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return search_results_SearchResults; });
function search_results_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function search_results_extends() { search_results_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return search_results_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



















const GET_MORE_BUFFER = 30;
function search_results_renderView(props) {
  return react_default.a.createElement("div", search_results_extends({}, props, {
    className: "scrollbar--view"
  }));
}
function search_results_renderThumbHorizontal(props) {
  return react_default.a.createElement("div", search_results_extends({}, props, {
    className: "scrollbar--horizontal"
  }));
}
function search_results_renderThumbVertical(props) {
  return react_default.a.createElement("div", search_results_extends({}, props, {
    className: "scrollbar--vertical"
  }));
}
class search_results_SearchResults extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    search_results_defineProperty(this, "handleResize", () => {
      this.setState({
        windowWidth: utils["sb" /* windowWidth */](),
        windowHeight: utils["rb" /* windowHeight */]()
      });
    });

    search_results_defineProperty(this, "scrollToTop", () => {
      this.refs.scrollbars.scrollToTop();
    });

    search_results_defineProperty(this, "handleScroll", () => {
      if (!this.props.isFlaggedPosts && !this.props.isMembers && !this.props.isPinnedPosts && !this.props.isSearchingTerm && !this.props.isSearchGettingMore && !this.props.isCloudPosts) {
        const scrollHeight = this.refs.scrollbars.getScrollHeight();
        const scrollTop = this.refs.scrollbars.getScrollTop();
        const clientHeight = this.refs.scrollbars.getClientHeight();

        if (scrollTop + clientHeight + GET_MORE_BUFFER >= scrollHeight) {
          this.loadMorePosts();
        }
      }
    });

    search_results_defineProperty(this, "loadMorePosts", Object(helpers["debounce"])(() => {
      this.props.actions.getMorePostsForSearch();
    }, 100));

    this.state = {
      windowWidth: utils["sb" /* windowWidth */](),
      windowHeight: utils["rb" /* windowHeight */](),
      timeNum: -1
    };
  }

  componentDidMount() {
    this.scrollToTop();
    window.addEventListener("resize", this.handleResize); // this.state.timeNum = setInterval(
    //   () => {
    //    if(this.props.isCloudPosts) this.props.actions.showCloud(true);
    //   },
    //   3000,
    //   this
    // );
  }

  componentWillUnmount() {
    window.removeEventListener("resize", this.handleResize);
    clearInterval(this.state.timeNum);
    console.log("clearInterval_search");
  }

  componentDidUpdate(prevProps) {
    if (this.props.searchTerms !== prevProps.searchTerms) {
      this.scrollToTop();
    }
  }

  render() {
    let results = [];

    if (this.props.isFlaggedPosts) {
      results = this.props.collectList;
    } else {
      results = this.props.results;
    }

    const noResults = !results || results.length === 0;
    const searchTerms = this.props.searchTerms;
    let ctls = null;
    let loadingMorePostsComponent = null;
    let hasSearch = false; // 是否显示搜索

    let searchPlaceholder = ''; // 搜索placeholder

    if (this.props.isSearchingTerm || this.props.isSearchingFlaggedPost || this.props.isSearchingPinnedPost) {
      ctls = react_default.a.createElement("div", {
        key: "sidebar1",
        className: "sidebar--right__subheader"
      }, react_default.a.createElement("div", {
        className: "sidebar--right__loading"
      }, react_default.a.createElement(loading_wrapper["a" /* default */], {
        text: utils["gb" /* localizeMessage */]("search_header.loading", "Searching")
      })));
    } else if (this.props.isMembers) {
      ctls = react_default.a.createElement("div", {
        key: "sidebar2",
        className: "sidebar--right__subheader",
        style: {
          paddingTop: 0
        }
      }, this.props.users.map((userinfo, idx) => react_default.a.createElement(components_ao_channel_member_item, {
        key: `${idx}a`,
        userinfo: userinfo,
        channel: this.props.channel
      })));
    } else if (this.props.isCloudPosts) {
      searchPlaceholder = '搜索文件、图片、视频…';
      hasSearch = true;
      ctls = react_default.a.createElement(components_ao_cloud, {
        channel: this.props.channel
      });
    } else if (this.props.isFlaggedPosts && noResults) {
      ctls = react_default.a.createElement("div", {
        key: "sidebar3",
        className: "sidebar--right__subheader"
      }, react_default.a.createElement(flag_post_search_hint_FlagPostSearchHint, {
        dataRetentionEnableMessageDeletion: this.props.dataRetentionEnableMessageDeletion,
        dataRetentionMessageRetentionDays: this.props.dataRetentionMessageRetentionDays
      }));
    } else if (this.props.isPinnedPosts && noResults) {
      ctls = react_default.a.createElement("div", {
        key: "sidebar4",
        className: "sidebar--right__subheader"
      }, react_default.a.createElement(pin_post_search_hint_PinPostSearchHint, {
        dataRetentionEnableMessageDeletion: this.props.dataRetentionEnableMessageDeletion,
        dataRetentionMessageRetentionDays: this.props.dataRetentionMessageRetentionDays
      }));
    } else if (!searchTerms && noResults) {
      ctls = react_default.a.createElement("div", {
        key: "sidebar6",
        className: "sidebar--right__subheader"
      }, react_default.a.createElement(search_hint["a" /* default */], null));
    } else if (noResults) {
      ctls = react_default.a.createElement("div", {
        key: "sidebar7",
        className: "sidebar--right__subheader"
      }, react_default.a.createElement(no_result_search_hint_PinPostSearchHint, {
        dataRetentionEnableMessageDeletion: this.props.dataRetentionEnableMessageDeletion,
        dataRetentionMessageRetentionDays: this.props.dataRetentionMessageRetentionDays
      }));
    } else if (this.props.isFlaggedPosts) {
      ctls = results.map(collect => {
        return react_default.a.createElement(components_ao_collect_item, {
          key: `${collect.id}_collect`,
          collect: collect,
          compactDisplay: this.props.compactDisplay
        });
      });
    } else if (this.props.isMentionSearch && this.props.mentionTab === constants["O" /* mentionTabKeys */].AT_ME) {
      // console.log('results.mention', results)
      let sortedResults;

      if (this.props.isPinnedPosts) {
        sortedResults = [...results];
        sortedResults.sort((postA, postB) => postB.create_at - postA.create_at);
      } else {
        sortedResults = results;
      } // console.log('sortedResults.mention', sortedResults)


      if (sortedResults.length > 0) {
        ctls = sortedResults.map(post => {
          return react_default.a.createElement(components_ao_mention_item, {
            key: `${post.id}a`,
            post: post,
            compactDisplay: this.props.compactDisplay
          });
        });
      } else {
        ctls = react_default.a.createElement("div", {
          key: "sidebar9",
          className: "sidebar--right__subheader"
        }, "\u60A8\u672A\u6709\u4EFB\u4F55\u201C@\u6211\u7684\u201D\u6D88\u606F");
      }
    } else if (this.props.isMentionSearch && this.props.mentionTab === constants["O" /* mentionTabKeys */].MEETING) {
      console.log('results.meeting', results);
      let sortedResults; // 筛选出进行中、点击加入、未参加、已结束的会议
      // sortedResults = results.filter(post => {
      //   if (isJoin(post) || isToin(post) || isUnin(post) || isEnded(post)) {
      //     return post;
      //   }
      // });
      // level1:会议中>点击加入>其他，level2：时间倒序

      let joinPosts = [],
          toinPosts = [],
          otherPosts = [];
      results.forEach((post, i) => {
        if (utils["U" /* isJoin */](post)) {
          joinPosts.push(post);
        } else if (utils["bb" /* isToin */](post)) {
          toinPosts.push(post);
        } else {
          otherPosts.push(post);
        }
      });
      otherPosts.sort((postA, postB) => postB.update_at - postA.update_at);
      sortedResults = joinPosts.concat(toinPosts, otherPosts);
      console.log('sortedResults.meeting', sortedResults);

      if (sortedResults.length > 0) {
        ctls = sortedResults.map(post => {
          return react_default.a.createElement(components_ao_meeting_item, {
            key: post.meeting_id,
            post: post,
            compactDisplay: this.props.compactDisplay
          });
        });
      } else {
        ctls = react_default.a.createElement("div", {
          key: "sidebar8",
          className: "sidebar--right__subheader"
        }, "\u60A8\u672A\u6709\u4EFB\u4F55\u4F1A\u8BAE\u901A\u77E5");
      }
    } else {
      let sortedResults;

      if (this.props.isPinnedPosts) {
        sortedResults = [...results];
        sortedResults.sort((postA, postB) => postB.create_at - postA.create_at);
      } else {
        sortedResults = results;
      }

      ctls = sortedResults.map(post => {
        return react_default.a.createElement(search_results_item, {
          key: `${post.id}a`,
          compactDisplay: this.props.compactDisplay,
          post: post,
          matches: this.props.matches[post.id],
          term: !this.props.isFlaggedPosts && !this.props.isMembers && !this.props.isPinnedPosts && !this.props.isMentionSearch && !this.props.isCloudPosts ? searchTerms : "",
          isMentionSearch: this.props.isMentionSearch,
          isCloudPosts: this.props.isCloudPosts
        });
      }, this);

      if (!this.props.isSearchAtEnd && !this.props.isFlaggedPosts && !this.props.isMembers && !this.props.isPinnedPosts && !this.props.isCloudPosts) {
        loadingMorePostsComponent = react_default.a.createElement("div", {
          className: "loading-screen"
        }, react_default.a.createElement("div", {
          className: "loading__content"
        }, react_default.a.createElement("div", {
          className: "round round-1"
        }), react_default.a.createElement("div", {
          className: "round round-2"
        }), react_default.a.createElement("div", {
          className: "round round-3"
        })));
      }
    }

    var formattedTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_header.results",
      defaultMessage: "Search Results"
    });

    if (this.props.isMentionSearch) {
      formattedTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "search_header.title2",
        defaultMessage: "Recent Mentions"
      });
    } else if (this.props.isFlaggedPosts) {
      formattedTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "search_header.title3",
        defaultMessage: "Flagged Posts"
      });
    } else if (this.props.isMembers) {
      formattedTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "search_header.todo",
        defaultMessage: "\u9891\u9053\u6210\u5458"
      });
    } else if (this.props.isPinnedPosts) {
      formattedTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "search_header.title4",
        defaultMessage: "Pinned posts in {channelDisplayName}",
        values: {
          channelDisplayName: this.props.channelDisplayName
        }
      });
    } else if (this.props.isCard) {
      formattedTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "search_header.title5",
        defaultMessage: "Extra information"
      });
    } else if (this.props.isCloudPosts) {
      formattedTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "search_header.title6",
        defaultMessage: "Cloud Disk"
      });
    }

    return react_default.a.createElement("div", {
      className: "sidebar-right__body"
    }, react_default.a.createElement(search_results_header["a" /* default */], {
      isMembers: this.props.isMembers,
      isMentionSearch: this.props.isMentionSearch,
      hasSearch: hasSearch,
      searchPlaceholder: searchPlaceholder
    }, formattedTitle), react_default.a.createElement(lib_default.a, {
      ref: "scrollbars",
      autoHide: true,
      autoHideTimeout: 500,
      autoHideDuration: 500,
      renderThumbHorizontal: search_results_renderThumbHorizontal,
      renderThumbVertical: search_results_renderThumbVertical,
      renderView: search_results_renderView,
      onScroll: this.handleScroll
    }, react_default.a.createElement("div", {
      id: "search-items-container",
      className: "search-items-container"
    }, ctls, loadingMorePostsComponent)));
  }

}

search_results_defineProperty(search_results_SearchResults, "propTypes", {
  results: prop_types_default.a.array,
  users: prop_types_default.a.array,
  matches: prop_types_default.a.object,
  currentUser: prop_types_default.a.object,
  searchTerms: prop_types_default.a.string,
  isSearchingTerm: prop_types_default.a.bool,
  isSearchingFlaggedPost: prop_types_default.a.bool,
  isSearchingPinnedPost: prop_types_default.a.bool,
  isSearchGettingMore: prop_types_default.a.bool,
  isSearchAtEnd: prop_types_default.a.bool,
  compactDisplay: prop_types_default.a.bool,
  isMentionSearch: prop_types_default.a.bool,
  mentionTab: prop_types_default.a.string,
  isFlaggedPosts: prop_types_default.a.bool,
  isMembers: prop_types_default.a.bool,
  isCloudPosts: prop_types_default.a.bool,
  isPinnedPosts: prop_types_default.a.bool,
  isCard: prop_types_default.a.bool,
  channelDisplayName: prop_types_default.a.string.isRequired,
  dataRetentionEnableMessageDeletion: prop_types_default.a.bool.isRequired,
  dataRetentionMessageRetentionDays: prop_types_default.a.string,
  channel: prop_types_default.a.object,
  actions: prop_types_default.a.shape({
    getMorePostsForSearch: prop_types_default.a.func.isRequired,
    showCloud: prop_types_default.a.func.isRequired
  })
});

search_results_defineProperty(search_results_SearchResults, "defaultProps", {
  matches: {},
  currentUser: {}
});

/***/ }),

/***/ 2252:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var channels = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./components/markdown/index.js + 1 modules
var markdown = __webpack_require__(1624);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var constants = __webpack_require__(17);

// EXTERNAL MODULE: ./utils/channel_utils.jsx
var channel_utils = __webpack_require__(310);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/actions/users.js
var users = __webpack_require__(35);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var entities_users = __webpack_require__(10);

// EXTERNAL MODULE: ./utils/i18n.jsx
var i18n = __webpack_require__(53);

// CONCATENATED MODULE: ./components/post_view/combined_system_message/last_users.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const typeMessage = {
  [constants["Posts"].POST_TYPES.ADD_TO_CHANNEL]: {
    id: Object(i18n["b" /* t */])('last_users_message.added_to_channel.type'),
    defaultMessage: 'were **added to the channel** by {actor}.'
  },
  [constants["Posts"].POST_TYPES.JOIN_CHANNEL]: {
    id: Object(i18n["b" /* t */])('last_users_message.joined_channel.type'),
    defaultMessage: '**joined the channel**.'
  },
  [constants["Posts"].POST_TYPES.LEAVE_CHANNEL]: {
    id: Object(i18n["b" /* t */])('last_users_message.left_channel.type'),
    defaultMessage: '**left the channel**.'
  },
  [constants["Posts"].POST_TYPES.REMOVE_FROM_CHANNEL]: {
    id: Object(i18n["b" /* t */])('last_users_message.removed_from_channel.type'),
    defaultMessage: 'were **removed from the channel**.'
  },
  [constants["Posts"].POST_TYPES.ADD_TO_TEAM]: {
    id: Object(i18n["b" /* t */])('last_users_message.added_to_team.type'),
    defaultMessage: 'were **added to the team** by {actor}.'
  },
  [constants["Posts"].POST_TYPES.JOIN_TEAM]: {
    id: Object(i18n["b" /* t */])('last_users_message.joined_team.type'),
    defaultMessage: '**joined the team**.'
  },
  [constants["Posts"].POST_TYPES.LEAVE_TEAM]: {
    id: Object(i18n["b" /* t */])('last_users_message.left_team.type'),
    defaultMessage: '**left the team**.'
  },
  [constants["Posts"].POST_TYPES.REMOVE_FROM_TEAM]: {
    id: Object(i18n["b" /* t */])('last_users_message.removed_from_team.type'),
    defaultMessage: 'were **removed from the team**.'
  }
};
class last_users_LastUsers extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleOnClick", e => {
      e.preventDefault();
      this.setState({
        expand: true
      });
    });

    _defineProperty(this, "renderMessage", formattedMessage => {
      return react_default.a.createElement(markdown["a" /* default */], {
        message: formattedMessage,
        options: this.props.formatOptions
      });
    });

    this.state = {
      expand: false
    };
  }

  render() {
    const {
      formatMessage
    } = this.context.intl;
    const {
      expand
    } = this.state;
    const {
      actor,
      expandedLocale,
      postType,
      usernames
    } = this.props;
    const firstUser = usernames[0];
    const lastIndex = usernames.length - 1;
    const lastUser = usernames[lastIndex];

    if (expand) {
      const formattedMessage = formatMessage(expandedLocale, {
        users: usernames.slice(0, lastIndex).join(', '),
        lastUser,
        actor
      });
      return this.renderMessage(formattedMessage);
    }

    const firstUserMessage = formatMessage({
      id: 'last_users_message.first',
      defaultMessage: '{firstUser} and '
    }, {
      firstUser
    });
    const otherUsersMessage = formatMessage({
      id: 'last_users_message.others',
      defaultMessage: '{numOthers} others '
    }, {
      numOthers: lastIndex
    });
    const actorMessage = formatMessage({
      id: typeMessage[postType].id,
      defaultMessage: typeMessage[postType].defaultMessage
    }, {
      actor
    });
    return react_default.a.createElement("span", null, this.renderMessage(firstUserMessage), react_default.a.createElement("a", {
      onClick: this.handleOnClick
    }, otherUsersMessage), this.renderMessage(actorMessage));
  }

}

_defineProperty(last_users_LastUsers, "propTypes", {
  actor: prop_types_default.a.string,
  expandedLocale: prop_types_default.a.object.isRequired,
  formatOptions: prop_types_default.a.object.isRequired,
  postType: prop_types_default.a.string.isRequired,
  usernames: prop_types_default.a.array.isRequired
});

_defineProperty(last_users_LastUsers, "contextTypes", {
  intl: index_es["i" /* intlShape */]
});
// CONCATENATED MODULE: ./components/post_view/combined_system_message/combined_system_message.jsx
function combined_system_message_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const {
  JOIN_CHANNEL,
  ADD_TO_CHANNEL,
  REMOVE_FROM_CHANNEL,
  LEAVE_CHANNEL,
  JOIN_TEAM,
  ADD_TO_TEAM,
  REMOVE_FROM_TEAM,
  LEAVE_TEAM
} = constants["Posts"].POST_TYPES;
const postTypeMessage = {
  [JOIN_CHANNEL]: {
    one: {
      id: Object(i18n["b" /* t */])('combined_system_message.joined_channel.one'),
      defaultMessage: '{firstUser} **joined the channel**.'
    },
    one_you: {
      id: Object(i18n["b" /* t */])('combined_system_message.joined_channel.one_you'),
      defaultMessage: 'You **joined the channel**.'
    },
    two: {
      id: Object(i18n["b" /* t */])('combined_system_message.joined_channel.two'),
      defaultMessage: '{firstUser} and {secondUser} **joined the channel**.'
    },
    many_expanded: {
      id: Object(i18n["b" /* t */])('combined_system_message.joined_channel.many_expanded'),
      defaultMessage: '{users} and {lastUser} **joined the channel**.'
    }
  },
  [ADD_TO_CHANNEL]: {
    one: {
      id: Object(i18n["b" /* t */])('combined_system_message.added_to_channel.one'),
      defaultMessage: '{firstUser} **added to the channel** by {actor}.'
    },
    one_you: {
      id: Object(i18n["b" /* t */])('combined_system_message.added_to_channel.one_you'),
      defaultMessage: 'You were **added to the channel** by {actor}.'
    },
    two: {
      id: Object(i18n["b" /* t */])('combined_system_message.added_to_channel.two'),
      defaultMessage: '{firstUser} and {secondUser} **added to the channel** by {actor}.'
    },
    many_expanded: {
      id: Object(i18n["b" /* t */])('combined_system_message.added_to_channel.many_expanded'),
      defaultMessage: '{users} and {lastUser} were **added to the channel** by {actor}.'
    }
  },
  [REMOVE_FROM_CHANNEL]: {
    one: {
      id: Object(i18n["b" /* t */])('combined_system_message.removed_from_channel.one'),
      defaultMessage: '{firstUser} was **removed from the channel**.'
    },
    one_you: {
      id: Object(i18n["b" /* t */])('combined_system_message.removed_from_channel.one_you'),
      defaultMessage: 'You were **removed from the channel**.'
    },
    two: {
      id: Object(i18n["b" /* t */])('combined_system_message.removed_from_channel.two'),
      defaultMessage: '{firstUser} and {secondUser} were **removed from the channel**.'
    },
    many_expanded: {
      id: Object(i18n["b" /* t */])('combined_system_message.removed_from_channel.many_expanded'),
      defaultMessage: '{users} and {lastUser} were **removed from the channel**.'
    }
  },
  [LEAVE_CHANNEL]: {
    one: {
      id: Object(i18n["b" /* t */])('combined_system_message.left_channel.one'),
      defaultMessage: '{firstUser} **left the channel**.'
    },
    one_you: {
      id: Object(i18n["b" /* t */])('combined_system_message.left_channel.one_you'),
      defaultMessage: 'You **left the channel**.'
    },
    two: {
      id: Object(i18n["b" /* t */])('combined_system_message.left_channel.two'),
      defaultMessage: '{firstUser} and {secondUser} **left the channel**.'
    },
    many_expanded: {
      id: Object(i18n["b" /* t */])('combined_system_message.left_channel.many_expanded'),
      defaultMessage: '{users} and {lastUser} **left the channel**.'
    }
  },
  [JOIN_TEAM]: {
    one: {
      id: Object(i18n["b" /* t */])('combined_system_message.joined_team.one'),
      defaultMessage: '{firstUser} **joined the team**.'
    },
    one_you: {
      id: Object(i18n["b" /* t */])('combined_system_message.joined_team.one_you'),
      defaultMessage: 'You **joined the team**.'
    },
    two: {
      id: Object(i18n["b" /* t */])('combined_system_message.joined_team.two'),
      defaultMessage: '{firstUser} and {secondUser} **joined the team**.'
    },
    many_expanded: {
      id: Object(i18n["b" /* t */])('combined_system_message.joined_team.many_expanded'),
      defaultMessage: '{users} and {lastUser} **joined the team**.'
    }
  },
  [ADD_TO_TEAM]: {
    one: {
      id: Object(i18n["b" /* t */])('combined_system_message.added_to_team.one'),
      defaultMessage: '{firstUser} **added to the team** by {actor}.'
    },
    one_you: {
      id: Object(i18n["b" /* t */])('combined_system_message.added_to_team.one_you'),
      defaultMessage: 'You were **added to the team** by {actor}.'
    },
    two: {
      id: Object(i18n["b" /* t */])('combined_system_message.added_to_team.two'),
      defaultMessage: '{firstUser} and {secondUser} **added to the team** by {actor}.'
    },
    many_expanded: {
      id: Object(i18n["b" /* t */])('combined_system_message.added_to_team.many_expanded'),
      defaultMessage: '{users} and {lastUser} were **added to the team** by {actor}.'
    }
  },
  [REMOVE_FROM_TEAM]: {
    one: {
      id: Object(i18n["b" /* t */])('combined_system_message.removed_from_team.one'),
      defaultMessage: '{firstUser} was **removed from the team**.'
    },
    one_you: {
      id: Object(i18n["b" /* t */])('combined_system_message.removed_from_team.one_you'),
      defaultMessage: 'You were **removed from the team**.'
    },
    two: {
      id: Object(i18n["b" /* t */])('combined_system_message.removed_from_team.two'),
      defaultMessage: '{firstUser} and {secondUser} were **removed from the team**.'
    },
    many_expanded: {
      id: Object(i18n["b" /* t */])('combined_system_message.removed_from_team.many_expanded'),
      defaultMessage: '{users} and {lastUser} were **removed from the team**.'
    }
  },
  [LEAVE_TEAM]: {
    one: {
      id: Object(i18n["b" /* t */])('combined_system_message.left_team.one'),
      defaultMessage: '{firstUser} **left the team**.'
    },
    one_you: {
      id: Object(i18n["b" /* t */])('combined_system_message.left_team.one_you'),
      defaultMessage: 'You **left the team**.'
    },
    two: {
      id: Object(i18n["b" /* t */])('combined_system_message.left_team.two'),
      defaultMessage: '{firstUser} and {secondUser} **left the team**.'
    },
    many_expanded: {
      id: Object(i18n["b" /* t */])('combined_system_message.left_team.many_expanded'),
      defaultMessage: '{users} and {lastUser} **left the team**.'
    }
  }
};
class combined_system_message_CombinedSystemMessage extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    combined_system_message_defineProperty(this, "loadUserProfiles", (allUserIds, allUsernames) => {
      if (allUserIds.length > 0) {
        this.props.actions.getMissingProfilesByIds(allUserIds);
      }

      if (allUsernames.length > 0) {
        this.props.actions.getMissingProfilesByUsernames(allUsernames);
      }
    });

    combined_system_message_defineProperty(this, "getAllUsernames", () => {
      const {
        allUserIds,
        allUsernames,
        currentUserId,
        currentUsername,
        userProfiles
      } = this.props;
      const {
        formatMessage
      } = this.context.intl;
      const usernames = userProfiles.reduce((acc, user) => {
        acc[user.id] = user.username;
        acc[user.username] = user.username;
        return acc;
      }, {});
      const currentUserDisplayName = formatMessage({
        id: Object(i18n["b" /* t */])('combined_system_message.you'),
        defaultMessage: 'You'
      });

      if (allUserIds.includes(currentUserId)) {
        usernames[currentUserId] = currentUserDisplayName;
      } else if (allUsernames.includes(currentUsername)) {
        usernames[currentUsername] = currentUserDisplayName;
      }

      return usernames;
    });

    combined_system_message_defineProperty(this, "getUsernamesByIds", (userIds = []) => {
      const {
        currentUserId,
        currentUsername
      } = this.props;
      const allUsernames = this.getAllUsernames();
      const {
        formatMessage
      } = this.context.intl;
      const someone = formatMessage({
        id: Object(i18n["b" /* t */])('channel_loader.someone'),
        defaultMessage: 'Someone'
      });
      const usernames = userIds.filter(userId => {
        return userId !== currentUserId && userId !== currentUsername;
      }).map(userId => {
        return allUsernames[userId] ? `@${allUsernames[userId]}` : someone;
      }).filter(username => {
        return username && username !== '';
      });

      if (userIds.includes(currentUserId)) {
        usernames.unshift(allUsernames[currentUserId]);
      } else if (userIds.includes(currentUsername)) {
        usernames.unshift(allUsernames[currentUsername]);
      }

      return usernames;
    });
  }

  componentDidMount() {
    this.loadUserProfiles(this.props.allUserIds, this.props.allUsernames);
  }

  componentDidUpdate(prevProps) {
    const {
      allUserIds,
      allUsernames
    } = this.props;

    if (allUserIds !== prevProps.allUserIds || allUsernames !== prevProps.allUsernames) {
      this.loadUserProfiles(allUserIds, allUsernames);
    }
  }

  renderFormattedMessage(postType, userIds, actorId) {
    const {
      formatMessage
    } = this.context.intl;
    const {
      currentUserId,
      currentUsername
    } = this.props;
    const usernames = this.getUsernamesByIds(userIds);
    let actor = actorId ? this.getUsernamesByIds([actorId])[0] : '';

    if (actor && (actorId === currentUserId || actorId === currentUsername)) {
      actor = actor.toLowerCase();
    }

    const firstUser = usernames[0];
    const secondUser = usernames[1];
    const numOthers = usernames.length - 1;
    const options = {
      atMentions: true,
      mentionKeys: [{
        key: firstUser
      }, {
        key: secondUser
      }, {
        key: actor
      }],
      mentionHighlight: false,
      singleline: true
    };

    if (numOthers > 1) {
      return react_default.a.createElement(last_users_LastUsers, {
        actor: actor,
        expandedLocale: postTypeMessage[postType].many_expanded,
        formatOptions: options,
        postType: postType,
        usernames: usernames
      });
    }

    let localeHolder;

    if (numOthers === 0) {
      localeHolder = postTypeMessage[postType].one;

      if ((userIds[0] === this.props.currentUserId || userIds[0] === this.props.currentUsername) && postTypeMessage[postType].one_you) {
        localeHolder = postTypeMessage[postType].one_you;
      }
    } else if (numOthers === 1) {
      localeHolder = postTypeMessage[postType].two;
    }

    const formattedMessage = formatMessage(localeHolder, {
      firstUser,
      secondUser,
      actor
    });
    return react_default.a.createElement(markdown["a" /* default */], {
      message: formattedMessage,
      options: options
    });
  }

  renderMessage(postType, userIds, actorId) {
    return react_default.a.createElement(react_default.a.Fragment, {
      key: postType + actorId
    }, this.renderFormattedMessage(postType, userIds, actorId), react_default.a.createElement("br", null));
  }

  render() {
    const {
      currentUserId,
      messageData
    } = this.props;
    const content = [];
    const removedUserIds = [];

    for (const message of messageData) {
      const {
        postType,
        actorId
      } = message;
      let userIds = message.userIds;

      if (!this.props.showJoinLeave && actorId !== currentUserId) {
        const affectsCurrentUser = userIds.indexOf(currentUserId) !== -1;

        if (affectsCurrentUser) {
          // Only show the message that the current user was added, etc
          userIds = [currentUserId];
        } else {
          // Not something the current user did or was affected by
          continue;
        }
      }

      if (postType === REMOVE_FROM_CHANNEL) {
        removedUserIds.push(...userIds);
        continue;
      }

      content.push(this.renderMessage(postType, userIds, actorId));
    }

    if (removedUserIds.length > 0) {
      const uniqueRemovedUserIds = removedUserIds.filter((id, index, arr) => arr.indexOf(id) === index);
      content.push(this.renderMessage(REMOVE_FROM_CHANNEL, uniqueRemovedUserIds, currentUserId));
    }

    return react_default.a.createElement(react_default.a.Fragment, null, content);
  }

}

combined_system_message_defineProperty(combined_system_message_CombinedSystemMessage, "propTypes", {
  allUserIds: prop_types_default.a.array.isRequired,
  allUsernames: prop_types_default.a.array.isRequired,
  currentUserId: prop_types_default.a.string.isRequired,
  currentUsername: prop_types_default.a.string.isRequired,
  messageData: prop_types_default.a.array.isRequired,
  showJoinLeave: prop_types_default.a.bool.isRequired,
  userProfiles: prop_types_default.a.array.isRequired,
  actions: prop_types_default.a.shape({
    getMissingProfilesByIds: prop_types_default.a.func.isRequired,
    getMissingProfilesByUsernames: prop_types_default.a.func.isRequired
  }).isRequired
});

combined_system_message_defineProperty(combined_system_message_CombinedSystemMessage, "defaultProps", {
  allUserIds: [],
  allUsernames: []
});

combined_system_message_defineProperty(combined_system_message_CombinedSystemMessage, "contextTypes", {
  intl: index_es["i" /* intlShape */]
});
// CONCATENATED MODULE: ./components/post_view/combined_system_message/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function makeMapStateToProps() {
  const getProfilesByIdsAndUsernames = Object(entities_users["makeGetProfilesByIdsAndUsernames"])();
  return (state, ownProps) => {
    const currentUser = Object(entities_users["getCurrentUser"])(state);
    const {
      allUserIds,
      allUsernames
    } = ownProps;
    return {
      currentUserId: currentUser.id,
      currentUsername: currentUser.username,
      showJoinLeave: Object(preferences["getBool"])(state, constants["Preferences"].CATEGORY_ADVANCED_SETTINGS, constants["Preferences"].ADVANCED_FILTER_JOIN_LEAVE, true),
      userProfiles: getProfilesByIdsAndUsernames(state, {
        allUserIds,
        allUsernames
      })
    };
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getMissingProfilesByIds: users["getMissingProfilesByIds"],
      getMissingProfilesByUsernames: users["getMissingProfilesByUsernames"]
    }, dispatch)
  };
}

/* harmony default export */ var combined_system_message = (Object(es["connect"])(makeMapStateToProps, mapDispatchToProps)(combined_system_message_CombinedSystemMessage));
// EXTERNAL MODULE: ./mattermost-redux/actions/channels.js
var actions_channels = __webpack_require__(70);

// EXTERNAL MODULE: ./mattermost-redux/actions/posts.js
var posts = __webpack_require__(59);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/posts.js
var entities_posts = __webpack_require__(61);

// EXTERNAL MODULE: ./actions/global_actions.jsx
var global_actions = __webpack_require__(1567);

// EXTERNAL MODULE: ./utils/constants.jsx
var utils_constants = __webpack_require__(0);

// EXTERNAL MODULE: ./components/at_mention/index.jsx + 1 modules
var at_mention = __webpack_require__(2264);

// CONCATENATED MODULE: ./components/post_view/post_add_channel_member/post_add_channel_member.jsx
function post_add_channel_member_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class post_add_channel_member_PostAddChannelMember extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    post_add_channel_member_defineProperty(this, "handleAddChannelMember", () => {
      const {
        currentUser,
        post,
        userIds,
        usernames
      } = this.props;

      if (post && post.channel_id) {
        let createAt = post.create_at;
        userIds.forEach((userId, index) => {
          createAt++;
          this.props.actions.addChannelMember(post.channel_id, userId);
          Object(global_actions["g" /* sendAddToChannelEphemeralPost */])(currentUser, usernames[index], userId, post.channel_id, post.root_id, createAt);
        });
        this.props.actions.removePost(post);
      }
    });
  }

  generateAtMentions(usernames = []) {
    if (usernames.length === 1) {
      return react_default.a.createElement(at_mention["a" /* default */], {
        mentionName: usernames[0]
      });
    } else if (usernames.length > 1) {
      function andSeparator(key) {
        return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          key: key,
          id: 'post_body.check_for_out_of_channel_mentions.link.and',
          defaultMessage: ' and '
        });
      }

      function commaSeparator(key) {
        return react_default.a.createElement("span", {
          key: key
        }, ', ');
      }

      return react_default.a.createElement("span", null, usernames.map(username => {
        return react_default.a.createElement(at_mention["a" /* default */], {
          key: username,
          mentionName: username
        });
      }).reduce((acc, el, idx, arr) => {
        if (idx === 0) {
          return [el];
        } else if (idx === arr.length - 1) {
          return [...acc, andSeparator(idx), el];
        }

        return [...acc, commaSeparator(idx), el];
      }, []));
    }

    return '';
  }

  render() {
    const {
      channelType,
      postId,
      usernames,
      noGroupsUsernames
    } = this.props;

    if (!postId || !channelType) {
      return null;
    }

    let linkId;
    let linkText;

    if (channelType === utils_constants["g" /* Constants */].PRIVATE_CHANNEL) {
      linkId = Object(i18n["b" /* t */])('post_body.check_for_out_of_channel_mentions.link.private');
      linkText = 'add them to this private channel';
    } else if (channelType === utils_constants["g" /* Constants */].OPEN_CHANNEL) {
      linkId = Object(i18n["b" /* t */])('post_body.check_for_out_of_channel_mentions.link.public');
      linkText = 'add them to the channel';
    }

    let outOfChannelMessageID;
    let outOfChannelMessageText;
    const outOfChannelAtMentions = this.generateAtMentions(usernames);

    if (usernames.length === 1) {
      outOfChannelMessageID = Object(i18n["b" /* t */])('post_body.check_for_out_of_channel_mentions.message.one');
      outOfChannelMessageText = 'did not get notified by this mention because they are not in the channel. Would you like to ';
    } else if (usernames.length > 1) {
      outOfChannelMessageID = Object(i18n["b" /* t */])('post_body.check_for_out_of_channel_mentions.message.multiple');
      outOfChannelMessageText = 'did not get notified by this mention because they are not in the channel. Would you like to ';
    }

    let outOfGroupsMessageID;
    let outOfGroupsMessageText;
    const outOfGroupsAtMentions = this.generateAtMentions(noGroupsUsernames);

    if (noGroupsUsernames.length) {
      outOfGroupsMessageID = Object(i18n["b" /* t */])('post_body.check_for_out_of_channel_groups_mentions.message');
      outOfGroupsMessageText = 'did not get notified by this mention because they are not in the channel. They cannot be added to the channel because they are not a member of the linked groups. To add them to this channel, they must be added to the linked groups.';
    }

    var outOfChannelMessage = null;
    var outOfGroupsMessage = null;

    if (usernames.length) {
      outOfChannelMessage = react_default.a.createElement("p", null, outOfChannelAtMentions, ' ', react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: outOfChannelMessageID,
        defaultMessage: outOfChannelMessageText
      }), react_default.a.createElement("a", {
        id: "add_channel_member_link",
        onClick: this.handleAddChannelMember
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: linkId,
        defaultMessage: linkText
      })), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: 'post_body.check_for_out_of_channel_mentions.message_last',
        defaultMessage: '? They will have access to all message history.'
      }));
    }

    if (noGroupsUsernames.length) {
      outOfGroupsMessage = react_default.a.createElement("p", null, outOfGroupsAtMentions, ' ', react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: outOfGroupsMessageID,
        defaultMessage: outOfGroupsMessageText
      }));
    }

    return react_default.a.createElement(react_default.a.Fragment, null, outOfChannelMessage, outOfGroupsMessage);
  }

}

post_add_channel_member_defineProperty(post_add_channel_member_PostAddChannelMember, "propTypes", {
  /*
  * Current user
  */
  currentUser: prop_types_default.a.object.isRequired,

  /*
  * Type of current channel
  */
  channelType: prop_types_default.a.string.isRequired,

  /*
  * ID of ephemeral post (at-mention's "add to channel" post)
  */
  postId: prop_types_default.a.string.isRequired,

  /*
  * Ephemeral post (at-mention's "add to channel" post)
  */
  post: prop_types_default.a.object.isRequired,

  /*
  * user ids to add to channel
  */
  userIds: prop_types_default.a.array.isRequired,

  /*
  * usernames to add to channel
  */
  usernames: prop_types_default.a.array.isRequired,
  noGroupsUsernames: prop_types_default.a.array.isRequired,
  actions: prop_types_default.a.shape({
    /*
    * Function to add members to channel
    */
    addChannelMember: prop_types_default.a.func.isRequired,

    /*
    * Function to remove post (ephemeral)
    */
    removePost: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/post_view/post_add_channel_member/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









function mapStateToProps(state, ownProps) {
  const post = Object(entities_posts["getPost"])(state, ownProps.postId) || {};
  let channelType = '';

  if (post && post.channel_id) {
    const channel = Object(channels["getChannel"])(state, post.channel_id);

    if (channel && channel.type) {
      channelType = channel.type;
    }
  }

  return {
    channelType,
    currentUser: Object(entities_users["getCurrentUser"])(state),
    post
  };
}

function post_add_channel_member_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      addChannelMember: actions_channels["addChannelMember"],
      removePost: posts["removePost"]
    }, dispatch)
  };
}

/* harmony default export */ var post_add_channel_member = (Object(es["connect"])(mapStateToProps, post_add_channel_member_mapDispatchToProps)(post_add_channel_member_PostAddChannelMember));
// CONCATENATED MODULE: ./components/post_markdown/system_message_helpers.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









function renderUsername(value) {
  const username = value[0] === '@' ? value : `@${value}`;
  const options = {
    markdown: false
  };
  return renderFormattedText(username, options);
}

function renderFormattedText(value, options) {
  return react_default.a.createElement(markdown["a" /* default */], {
    message: value,
    options: options
  });
}

function renderJoinChannelMessage(post) {
  const username = renderUsername(post.props.username);
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.channel.join_channel.post_and_forget",
    defaultMessage: "{username} joined the channel.",
    values: {
      username
    }
  });
}

function renderLeaveChannelMessage(post) {
  const username = renderUsername(post.props.username);
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.channel.leave.left",
    defaultMessage: "{username} has left the channel.",
    values: {
      username
    }
  });
}

function renderAddToChannelMessage(post) {
  const username = renderUsername(post.props.username);
  const addedUsername = renderUsername(post.props.addedUsername);
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.channel.add_member.added",
    defaultMessage: "{addedUsername} added to the channel by {username}.",
    values: {
      username,
      addedUsername
    }
  });
}

function renderRemoveFromChannelMessage(post) {
  const removedUsername = renderUsername(post.props.removedUsername);
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.channel.remove_member.removed",
    defaultMessage: "{removedUsername} was removed from the channel",
    values: {
      removedUsername
    }
  });
}

function renderJoinTeamMessage(post) {
  const username = renderUsername(post.props.username);
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.team.join_team.post_and_forget",
    defaultMessage: "{username} joined the team.",
    values: {
      username
    }
  });
}

function renderLeaveTeamMessage(post) {
  const username = renderUsername(post.props.username);
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.team.leave.left",
    defaultMessage: "{username} left the team.",
    values: {
      username
    }
  });
}

function renderAddToTeamMessage(post) {
  const username = renderUsername(post.props.username);
  const addedUsername = renderUsername(post.props.addedUsername);
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.team.add_member.added",
    defaultMessage: "{addedUsername} added to the team by {username}.",
    values: {
      username,
      addedUsername
    }
  });
}

function renderRemoveFromTeamMessage(post) {
  const removedUsername = renderUsername(post.props.username);
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.team.remove_user_from_team.removed",
    defaultMessage: "{removedUsername} was removed from the team.",
    values: {
      removedUsername
    }
  });
}

function renderHeaderChangeMessage(post) {
  if (!post.props.username) {
    return null;
  }

  const headerOptions = {
    singleline: true,
    channelNamesMap: post.props && post.props.channel_mentions
  };
  const username = renderUsername(post.props.username);
  const oldHeader = post.props.old_header ? renderFormattedText(post.props.old_header, headerOptions) : null;
  const newHeader = post.props.new_header ? renderFormattedText(post.props.new_header, headerOptions) : null;

  if (post.props.new_header) {
    if (post.props.old_header) {
      return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "api.channel.post_update_channel_header_message_and_forget.updated_from",
        defaultMessage: "{username} updated the channel header from: {old} to: {new}",
        values: {
          username,
          old: oldHeader,
          new: newHeader
        }
      });
    }

    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "api.channel.post_update_channel_header_message_and_forget.updated_to",
      defaultMessage: "{username} updated the channel header to: {new}",
      values: {
        username,
        new: newHeader
      }
    });
  } else if (post.props.old_header) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "api.channel.post_update_channel_header_message_and_forget.removed",
      defaultMessage: "{username} removed the channel header (was: {old})",
      values: {
        username,
        old: oldHeader
      }
    });
  }

  return null;
}

function renderDisplayNameChangeMessage(post) {
  if (!(post.props.username && post.props.old_displayname && post.props.new_displayname)) {
    return null;
  }

  const username = renderUsername(post.props.username);
  const oldDisplayName = post.props.old_displayname;
  const newDisplayName = post.props.new_displayname;
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.channel.post_update_channel_displayname_message_and_forget.updated_from",
    defaultMessage: "{username} updated the channel display name from: {old} to: {new}",
    values: {
      username,
      old: oldDisplayName,
      new: newDisplayName
    }
  });
}

function renderConvertChannelToPrivateMessage(post) {
  if (!post.props.username) {
    return null;
  }

  const username = renderUsername(post.props.username);
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.channel.post_convert_channel_to_private.updated_from",
    defaultMessage: "{username} converted the channel from public to private",
    values: {
      username
    }
  });
}

function renderPurposeChangeMessage(post) {
  if (!post.props.username) {
    return null;
  }

  const username = renderUsername(post.props.username);
  const oldPurpose = post.props.old_purpose;
  const newPurpose = post.props.new_purpose;

  if (post.props.new_purpose) {
    if (post.props.old_purpose) {
      return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "app.channel.post_update_channel_purpose_message.updated_from",
        defaultMessage: "{username} updated the channel purpose from: {old} to: {new}",
        values: {
          username,
          old: oldPurpose,
          new: newPurpose
        }
      });
    }

    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "app.channel.post_update_channel_purpose_message.updated_to",
      defaultMessage: "{username} updated the channel purpose to: {new}",
      values: {
        username,
        new: newPurpose
      }
    });
  } else if (post.props.old_purpose) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "app.channel.post_update_channel_purpose_message.removed",
      defaultMessage: "{username} removed the channel purpose (was: {old})",
      values: {
        username,
        old: oldPurpose
      }
    });
  }

  return null;
}

function renderChannelDeletedMessage(post) {
  if (!post.props.username) {
    return null;
  }

  const username = renderUsername(post.props.username);
  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "api.channel.delete_channel.archived",
    defaultMessage: "{username} has archived the channel.",
    values: {
      username
    }
  });
}

function renderMeMessage(post) {
  return renderFormattedText(post.props && post.props.message ? post.props.message : post.message);
}

const systemMessageRenderers = {
  [constants["Posts"].POST_TYPES.JOIN_CHANNEL]: renderJoinChannelMessage,
  [constants["Posts"].POST_TYPES.LEAVE_CHANNEL]: renderLeaveChannelMessage,
  [constants["Posts"].POST_TYPES.ADD_TO_CHANNEL]: renderAddToChannelMessage,
  [constants["Posts"].POST_TYPES.REMOVE_FROM_CHANNEL]: renderRemoveFromChannelMessage,
  [constants["Posts"].POST_TYPES.JOIN_TEAM]: renderJoinTeamMessage,
  [constants["Posts"].POST_TYPES.LEAVE_TEAM]: renderLeaveTeamMessage,
  [constants["Posts"].POST_TYPES.ADD_TO_TEAM]: renderAddToTeamMessage,
  [constants["Posts"].POST_TYPES.REMOVE_FROM_TEAM]: renderRemoveFromTeamMessage,
  [constants["Posts"].POST_TYPES.HEADER_CHANGE]: renderHeaderChangeMessage,
  [constants["Posts"].POST_TYPES.DISPLAYNAME_CHANGE]: renderDisplayNameChangeMessage,
  [constants["Posts"].POST_TYPES.CONVERT_CHANNEL]: renderConvertChannelToPrivateMessage,
  [constants["Posts"].POST_TYPES.PURPOSE_CHANGE]: renderPurposeChangeMessage,
  [constants["Posts"].POST_TYPES.CHANNEL_DELETED]: renderChannelDeletedMessage,
  [constants["Posts"].POST_TYPES.ME]: renderMeMessage
};
function renderSystemMessage(post, channel) {
  if (post.props && post.props.add_channel_member) {
    const isUserCanManageMembers = Object(channel_utils["a" /* canManageMembers */])(channel);
    const isEphemeral = utils["Z" /* isPostEphemeral */](post);

    if ((channel.type === constants["General"].PRIVATE_CHANNEL || channel.type === constants["General"].OPEN_CHANNEL) && isUserCanManageMembers && isEphemeral) {
      const addMemberProps = post.props.add_channel_member;
      return react_default.a.createElement(post_add_channel_member, {
        postId: addMemberProps.post_id,
        userIds: addMemberProps.not_in_channel_user_ids,
        noGroupsUsernames: addMemberProps.not_in_groups_usernames,
        usernames: addMemberProps.not_in_channel_usernames
      });
    }

    return null;
  } else if (systemMessageRenderers[post.type]) {
    return systemMessageRenderers[post.type](post);
  } else if (post.type === constants["Posts"].POST_TYPES.EPHEMERAL_ADD_TO_CHANNEL) {
    return renderAddToChannelMessage(post);
  } else if (post.type === constants["Posts"].POST_TYPES.COMBINED_USER_ACTIVITY) {
    const {
      allUserIds,
      allUsernames,
      messageData
    } = post.props.user_activity;
    return react_default.a.createElement(combined_system_message, {
      allUserIds: allUserIds,
      allUsernames: allUsernames,
      messageData: messageData
    });
  }

  return null;
}
// CONCATENATED MODULE: ./components/post_markdown/post_markdown.jsx
function post_markdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class post_markdown_PostMarkdown extends react_default.a.PureComponent {
  render() {
    if (this.props.post) {
      const renderedSystemMessage = renderSystemMessage(this.props.post, this.props.channel);

      if (renderedSystemMessage) {
        return react_default.a.createElement("div", null, renderedSystemMessage);
      }
    } // Proxy images if we have an image proxy and the server hasn't already rewritten the post's image URLs.


    const proxyImages = !this.props.post || !this.props.post.message_source || this.props.post.message === this.props.post.message_source;
    const channelNamesMap = this.props.post && this.props.post.props && this.props.post.props.channel_mentions;
    let {
      message
    } = this.props;
    const {
      post
    } = this.props;
    this.props.pluginHooks.forEach(o => {
      if (o && o.hook && post) {
        message = o.hook(post, message);
      }
    });
    return react_default.a.createElement(markdown["a" /* default */], {
      imageProps: this.props.imageProps,
      isRHS: this.props.isRHS,
      message: message,
      proxyImages: proxyImages,
      options: this.props.options,
      channelNamesMap: channelNamesMap,
      hasPluginTooltips: this.props.hasPluginTooltips,
      imagesMetadata: this.props.post && this.props.post.metadata && this.props.post.metadata.images
    });
  }

}

post_markdown_defineProperty(post_markdown_PostMarkdown, "propTypes", {
  /*
   * Any extra props that should be passed into the image component
   */
  imageProps: prop_types_default.a.object,

  /*
   * Whether or not this text is part of the RHS
   */
  isRHS: prop_types_default.a.bool,

  /*
   * The post text to be rendered
   */
  message: prop_types_default.a.string.isRequired,

  /*
   * The optional post for which this message is being rendered
   */
  post: prop_types_default.a.object,
  channel: prop_types_default.a.object,
  options: prop_types_default.a.object,
  pluginHooks: prop_types_default.a.arrayOf(prop_types_default.a.object),

  /**
   * Whether or not to place the LinkTooltip component inside links
   */
  hasPluginTooltips: prop_types_default.a.bool
});

post_markdown_defineProperty(post_markdown_PostMarkdown, "defaultProps", {
  isRHS: false,
  pluginHooks: []
});
// CONCATENATED MODULE: ./components/post_markdown/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function post_markdown_mapStateToProps(state, ownProps) {
  return {
    channel: Object(channels["getChannel"])(state, ownProps.channelId),
    pluginHooks: state.plugins.components.MessageWillFormat,
    hasPluginTooltips: Boolean(state.plugins.components.LinkTooltip)
  };
}

/* harmony default export */ var post_markdown = __webpack_exports__["a"] = (Object(es["connect"])(post_markdown_mapStateToProps)(post_markdown_PostMarkdown));

/***/ }),

/***/ 2256:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/jquery/src/jquery.js
var jquery = __webpack_require__(175);
var jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(33);
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./components/quick_input.jsx
var quick_input = __webpack_require__(1766);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./components/loading_screen.jsx
var loading_screen = __webpack_require__(1569);

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var entities_users = __webpack_require__(10);

// EXTERNAL MODULE: ./mattermost-redux/client/index.js
var client = __webpack_require__(27);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/profile_picture.jsx
var profile_picture = __webpack_require__(1656);

// EXTERNAL MODULE: ./components/widgets/badges/bot_badge.jsx
var bot_badge = __webpack_require__(1588);

// EXTERNAL MODULE: ./components/formatted_markdown_message.jsx
var formatted_markdown_message = __webpack_require__(1564);

// CONCATENATED MODULE: ./components/user_list_row/user_list_row.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class user_list_row_UserListRow extends react_default.a.Component {
  render() {
    let buttons = null;

    if (this.props.actions) {
      buttons = this.props.actions.map((Action, index) => {
        return react_default.a.createElement(Action, _extends({
          key: index.toString(),
          user: this.props.user,
          index: this.props.index,
          totalUsers: this.props.totalUsers
        }, this.props.actionProps, this.props.actionUserProps));
      });
    } // QUICK HACK, NEEDS A PROP FOR TOGGLING STATUS


    let email = this.props.user.email;
    let emailStyle = 'more-modal__description';
    let status;

    if (this.props.extraInfo && this.props.extraInfo.length > 0) {
      email = react_default.a.createElement(formatted_markdown_message["b" /* default */], {
        id: "admin.user_item.emailTitle",
        defaultMessage: "**Email:** {email}",
        values: {
          email: this.props.user.email
        }
      });
      emailStyle = '';
    } else if (this.props.user.status) {
      status = this.props.user.status;
    } else {
      status = this.props.status;
    }

    if (this.props.user.is_bot) {
      status = null;
      email = null;
    }

    let userCountID = null;
    let userCountEmail = null;

    if (this.props.userCount >= 0) {
      userCountID = utils["h" /* createSafeId */]('userListRowName' + this.props.userCount);
      userCountEmail = utils["h" /* createSafeId */]('userListRowEmail' + this.props.userCount);
    }

    return react_default.a.createElement("div", {
      key: this.props.user.id,
      className: "more-modal__row"
    }, react_default.a.createElement(profile_picture["a" /* default */], {
      src: client["Client4"].getProfilePictureUrl(this.props.user.id, this.props.user.last_picture_update),
      status: status,
      width: "32",
      height: "32"
    }), react_default.a.createElement("div", {
      className: "more-modal__details"
    }, react_default.a.createElement("div", {
      id: userCountID,
      className: "more-modal__name"
    }, utils["m" /* displayEntireNameForUser */](this.props.user), react_default.a.createElement(bot_badge["a" /* default */], {
      className: "badge-popoverlist",
      show: Boolean(this.props.user.is_bot)
    })), react_default.a.createElement("div", {
      id: userCountEmail,
      className: emailStyle
    }, email), this.props.extraInfo), react_default.a.createElement("div", {
      className: "more-modal__actions"
    }, buttons));
  }

}

_defineProperty(user_list_row_UserListRow, "propTypes", {
  user: prop_types_default.a.object.isRequired,
  status: prop_types_default.a.string,
  extraInfo: prop_types_default.a.arrayOf(prop_types_default.a.object),
  actions: prop_types_default.a.arrayOf(prop_types_default.a.func),
  actionProps: prop_types_default.a.object,
  actionUserProps: prop_types_default.a.object,
  index: prop_types_default.a.number,
  totalUsers: prop_types_default.a.number,
  userCount: prop_types_default.a.number
});

_defineProperty(user_list_row_UserListRow, "defaultProps", {
  extraInfo: [],
  actions: [],
  actionProps: {},
  actionUserProps: {}
});
// CONCATENATED MODULE: ./components/user_list_row/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function mapStateToProps(state, ownProps) {
  const user = ownProps.user || {};
  return {
    status: Object(entities_users["getStatusForUserId"])(state, user.id)
  };
}

/* harmony default export */ var user_list_row = (Object(es["connect"])(mapStateToProps)(user_list_row_UserListRow));
// CONCATENATED MODULE: ./components/user_list.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class user_list_UserList extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.scrollToTop = this.scrollToTop.bind(this);
  }

  scrollToTop() {
    if (this.refs.container) {
      this.refs.container.scrollTop = 0;
    }
  }

  render() {
    const users = this.props.users;
    const RowComponentType = this.props.rowComponentType;
    let content;

    if (users == null) {
      return react_default.a.createElement(loading_screen["a" /* default */], null);
    } else if (users.length > 0) {
      content = users.map((user, index) => {
        return react_default.a.createElement(RowComponentType, {
          key: user.id,
          user: user,
          extraInfo: this.props.extraInfo[user.id],
          actions: this.props.actions,
          actionProps: this.props.actionProps,
          actionUserProps: this.props.actionUserProps[user.id],
          index: index,
          totalUsers: users.length,
          userCount: index >= 0 && index < constants["N" /* default */].TEST_ID_COUNT ? index : -1
        });
      });
    } else {
      content = react_default.a.createElement("div", {
        key: "no-users-found",
        className: "more-modal__placeholder-row"
      }, react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "user_list.notFound",
        defaultMessage: "No users found"
      })));
    }

    return react_default.a.createElement("div", {
      ref: "container"
    }, content);
  }

}
user_list_UserList.defaultProps = {
  users: [],
  extraInfo: {},
  actions: [],
  actionProps: {},
  rowComponentType: user_list_row
};
user_list_UserList.propTypes = {
  users: prop_types_default.a.arrayOf(prop_types_default.a.object),
  extraInfo: prop_types_default.a.object,
  actions: prop_types_default.a.arrayOf(prop_types_default.a.func),
  actionProps: prop_types_default.a.object,
  actionUserProps: prop_types_default.a.object,
  // the type of user list row to render
  rowComponentType: prop_types_default.a.func
};
// EXTERNAL MODULE: ./components/localized_input/localized_input.jsx
var localized_input = __webpack_require__(1577);

// EXTERNAL MODULE: ./utils/i18n.jsx
var i18n = __webpack_require__(53);

// CONCATENATED MODULE: ./components/searchable_user_list/searchable_user_list.jsx
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return searchable_user_list_SearchableUserList; });
function searchable_user_list_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









const NEXT_BUTTON_TIMEOUT = 500;
class searchable_user_list_SearchableUserList extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.nextPage = this.nextPage.bind(this);
    this.previousPage = this.previousPage.bind(this);
    this.focusSearchBar = this.focusSearchBar.bind(this);
    this.handleInput = this.handleInput.bind(this);
    this.renderCount = this.renderCount.bind(this);
    this.nextTimeoutId = 0;
    this.state = {
      nextDisabled: false
    };
  }

  componentDidMount() {
    this.focusSearchBar();
  }

  componentDidUpdate(prevProps) {
    if (this.props.page !== prevProps.page || this.props.term !== prevProps.term) {
      this.refs.userList.scrollToTop();
    }

    this.focusSearchBar();
  }

  componentWillUnmount() {
    clearTimeout(this.nextTimeoutId);
  }

  nextPage(e) {
    e.preventDefault();
    this.setState({
      nextDisabled: true
    });
    this.nextTimeoutId = setTimeout(() => this.setState({
      nextDisabled: false
    }), NEXT_BUTTON_TIMEOUT);
    this.props.nextPage();
    jquery_default()(react_dom_default.a.findDOMNode(this.refs.channelListScroll)).scrollTop(0);
  }

  previousPage(e) {
    e.preventDefault();
    this.props.previousPage();
    jquery_default()(react_dom_default.a.findDOMNode(this.refs.channelListScroll)).scrollTop(0);
  }

  focusSearchBar() {
    if (this.props.focusOnMount) {
      this.refs.filter.focus();
    }
  }

  handleInput(e) {
    this.props.onTermChange(e.target.value);
    this.props.search(e.target.value);
  }

  renderCount(users) {
    if (!users) {
      return null;
    }

    if (this.props.filter) {
      return null;
    }

    const count = users.length;
    const total = this.props.total;
    const isSearch = Boolean(this.props.term);
    let startCount;
    let endCount;

    if (isSearch) {
      startCount = -1;
      endCount = -1;
    } else {
      startCount = this.props.page * this.props.usersPerPage;
      endCount = Math.min(startCount + this.props.usersPerPage, total);
    }

    if (this.props.renderCount) {
      return this.props.renderCount(count, this.props.total, startCount, endCount, isSearch);
    }

    if (this.props.total) {
      if (isSearch) {
        return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "filtered_user_list.countTotal",
          defaultMessage: "{count, number} {count, plural, one {member} other {members}} of {total, number} total",
          values: {
            count,
            total
          }
        });
      }

      return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "filtered_user_list.countTotalPage",
        defaultMessage: "{startCount, number} - {endCount, number} {count, plural, one {member} other {members}} of {total, number} total",
        values: {
          count,
          startCount: startCount + 1,
          endCount,
          total
        }
      });
    }

    return null;
  }

  render() {
    let nextButton;
    let previousButton;
    let usersToDisplay;

    if (this.props.term || !this.props.users) {
      usersToDisplay = this.props.users;
    } else if (!this.props.term) {
      const pageStart = this.props.page * this.props.usersPerPage;
      const pageEnd = pageStart + this.props.usersPerPage;
      usersToDisplay = this.props.users.slice(pageStart, pageEnd);

      if (pageEnd < this.props.users.length) {
        nextButton = react_default.a.createElement("button", {
          id: "searchableUserListNextBtn",
          className: "btn btn-link filter-control filter-control__next",
          onClick: this.nextPage,
          disabled: this.state.nextDisabled
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "filtered_user_list.next",
          defaultMessage: "Next"
        }));
      }

      if (this.props.page > 0) {
        previousButton = react_default.a.createElement("button", {
          id: "searchableUserListPrevBtn",
          className: "btn btn-link filter-control filter-control__prev",
          onClick: this.previousPage
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "filtered_user_list.prev",
          defaultMessage: "Previous"
        }));
      }
    }

    let filterRow;

    if (this.props.renderFilterRow) {
      filterRow = this.props.renderFilterRow(this.handleInput);
    } else {
      filterRow = react_default.a.createElement("div", {
        className: "col-xs-12"
      }, react_default.a.createElement(quick_input["a" /* default */], {
        id: "searchUsersInput",
        ref: "filter",
        className: "form-control filter-textbox",
        placeholder: {
          id: Object(i18n["b" /* t */])('filtered_user_list.search'),
          defaultMessage: 'Search users'
        },
        inputComponent: localized_input["a" /* default */],
        value: this.props.term,
        onInput: this.handleInput
      }));
    }

    return react_default.a.createElement("div", {
      className: "filtered-user-list"
    }, react_default.a.createElement("div", {
      className: "filter-row"
    }, filterRow, react_default.a.createElement("div", {
      className: "col-sm-12"
    }, react_default.a.createElement("span", {
      id: "searchableUserListTotal",
      className: "member-count pull-left"
    }, this.renderCount(usersToDisplay)))), react_default.a.createElement("div", {
      className: "more-modal__list"
    }, react_default.a.createElement(user_list_UserList, {
      ref: "userList",
      users: usersToDisplay,
      extraInfo: this.props.extraInfo,
      actions: this.props.actions,
      actionProps: this.props.actionProps,
      actionUserProps: this.props.actionUserProps,
      rowComponentType: this.props.rowComponentType
    })), react_default.a.createElement("div", {
      className: "filter-controls"
    }, previousButton, nextButton));
  }

}

searchable_user_list_defineProperty(searchable_user_list_SearchableUserList, "propTypes", {
  users: prop_types_default.a.arrayOf(prop_types_default.a.object),
  usersPerPage: prop_types_default.a.number,
  total: prop_types_default.a.number,
  extraInfo: prop_types_default.a.object,
  nextPage: prop_types_default.a.func.isRequired,
  previousPage: prop_types_default.a.func.isRequired,
  search: prop_types_default.a.func.isRequired,
  actions: prop_types_default.a.arrayOf(prop_types_default.a.func),
  actionProps: prop_types_default.a.object,
  actionUserProps: prop_types_default.a.object,
  focusOnMount: prop_types_default.a.bool,
  renderCount: prop_types_default.a.func,
  filter: prop_types_default.a.string,
  renderFilterRow: prop_types_default.a.func,
  page: prop_types_default.a.number.isRequired,
  term: prop_types_default.a.string.isRequired,
  onTermChange: prop_types_default.a.func.isRequired,
  // the type of user list row to render
  rowComponentType: prop_types_default.a.func
});

searchable_user_list_defineProperty(searchable_user_list_SearchableUserList, "defaultProps", {
  users: [],
  usersPerPage: 50,
  // eslint-disable-line no-magic-numbers
  extraInfo: {},
  actions: [],
  actionProps: {},
  actionUserProps: {},
  showTeamToggle: false,
  focusOnMount: false
});

/***/ }),

/***/ 2257:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./actions/views/search.js
var search = __webpack_require__(1626);

// EXTERNAL MODULE: ./actions/views/rhs.js
var rhs = __webpack_require__(116);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var channels = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tooltip.js
var Tooltip = __webpack_require__(1998);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./components/channel_new_invite_modal/index.js + 1 modules
var channel_new_invite_modal = __webpack_require__(1687);

// EXTERNAL MODULE: ./node_modules/antd/es/input/index.js + 7 modules
var input = __webpack_require__(3484);

// EXTERNAL MODULE: ./components/svg/search_icon.jsx
var search_icon = __webpack_require__(1672);

// EXTERNAL MODULE: ./mattermost-redux/actions/helpers.js
var helpers = __webpack_require__(117);

// EXTERNAL MODULE: ./node_modules/react-outside-click-handler/index.js
var react_outside_click_handler = __webpack_require__(1863);
var react_outside_click_handler_default = /*#__PURE__*/__webpack_require__.n(react_outside_click_handler);

// EXTERNAL MODULE: ./components/search_results_header/index.scss
var search_results_header = __webpack_require__(2467);

// EXTERNAL MODULE: ./selectors/rhs.jsx
var selectors_rhs = __webpack_require__(60);

// EXTERNAL MODULE: ./node_modules/antd/es/tabs/index.js + 8 modules
var tabs = __webpack_require__(3434);

// CONCATENATED MODULE: ./components/search_results_header_mention/search_results_header_mention.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class search_results_header_mention_SearchResultsHeaderMention extends react_default.a.Component {
  constructor(props) {
    super(props);
  }

  onChange(key) {
    this.props.actions.onMentionTabChange(key);
  }

  render() {
    let className1 = 'tab-label',
        className2 = 'tab-label';

    if (this.props.isMentioned) {
      className1 += ' unread';
    }

    if (this.props.isBeingInvited) {
      className2 += ' unread';
    }

    const tab1 = react_default.a.createElement("div", {
      className: className1
    }, "@\u6211\u7684");
    const tab2 = react_default.a.createElement("div", {
      className: className2
    }, "\u4F1A\u8BAE\u901A\u77E5");
    return react_default.a.createElement("div", {
      className: "mention-search-tab"
    }, react_default.a.createElement(tabs["a" /* default */], {
      defaultActiveKey: this.props.activeKey,
      onChange: key => {
        this.onChange(key);
      }
    }, react_default.a.createElement(tabs["a" /* default */].TabPane, {
      tab: tab1,
      key: this.props.key1
    }), react_default.a.createElement(tabs["a" /* default */].TabPane, {
      tab: tab2,
      key: this.props.key2
    })));
  }

}

_defineProperty(search_results_header_mention_SearchResultsHeaderMention, "propTypes", {
  activeKey: prop_types_default.a.string.isRequired,
  key1: prop_types_default.a.string.isRequired,
  key2: prop_types_default.a.string.isRequired,
  isMentioned: prop_types_default.a.bool,
  isBeingInvited: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    onMentionTabChange: prop_types_default.a.func.isRequired
  })
});
// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// CONCATENATED MODULE: ./components/search_results_header_mention/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function mapStateToProps(state, ownProps) {
  const activeKey = Object(selectors_rhs["i" /* getMentionTab */])(state);
  return {
    activeKey,
    key1: constants["O" /* mentionTabKeys */].AT_ME,
    key2: constants["O" /* mentionTabKeys */].MEETING,
    isMentioned: Object(channels["getUnreads"])(state).mentionCount > 0,
    isBeingInvited: state.views.meeting.unreadMeetingIds.length > 0
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      onMentionTabChange: rhs["e" /* onMentionTabChange */]
    }, dispatch)
  };
}

/* harmony default export */ var search_results_header_mention = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(search_results_header_mention_SearchResultsHeaderMention));
// CONCATENATED MODULE: ./components/search_results_header/search_results_header.jsx
function search_results_header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












class search_results_header_SearchResultsHeader extends react_default.a.Component {
  constructor(props) {
    super(props);

    search_results_header_defineProperty(this, "showAddMembers", () => {
      this.setState({
        showAdd: true
      });
    });

    search_results_header_defineProperty(this, "onHide", () => {
      this.setState({
        showAdd: false
      });
    });

    search_results_header_defineProperty(this, "search", Object(helpers["debounce"])(value => {
      this.props.actions.setSidebarSearchTerm(value);
    }, 300));

    this.state = {
      showAdd: false,
      //邀请面板
      focused: false,
      searchVisible: false
    };
  }

  handleFocus() {
    this.setState({
      focused: true
    });
  }

  handleBlur() {
    this.setState({
      focused: false
    });
  }

  showSearch() {
    this.setState({
      searchVisible: true
    });
  }

  hideSearch() {
    this.setState({
      searchVisible: false
    });
  }

  render() {
    const closeSidebarTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "closeSidebarTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.closeSidebarTooltip",
      defaultMessage: "Close Sidebar"
    }));
    const addSidebarTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "addSidebarTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.addTooltip.icon",
      defaultMessage: "Add Members",
      channel: this.props.currentChannel
    }));
    const expandSidebarTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "expandSidebarTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.expandSidebarTooltip",
      defaultMessage: "Expand Sidebar"
    }));
    const shrinkSidebarTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "shrinkSidebarTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.shrinkSidebarTooltip",
      defaultMessage: "Shrink Sidebar"
    }));
    let addMember = null;

    if (this.state.showAdd) {
      addMember = react_default.a.createElement(channel_new_invite_modal["a" /* default */], {
        onHide: this.onHide,
        channel: this.props.currentChannel
      });
    }

    let leftcontent = null; //左侧显示区域 默认是文本 提及需要显示tab页签

    if (this.props.isMentionSearch) {
      leftcontent = react_default.a.createElement(search_results_header_mention, null);
    } else {
      leftcontent = react_default.a.createElement("span", {
        className: "sidebar--right__title"
      }, this.props.children);
    }

    const {
      focused,
      searchVisible
    } = this.state;
    return react_default.a.createElement("div", {
      className: "sidebar--right__header"
    }, leftcontent, react_default.a.createElement("div", {
      className: "header-right"
    }, this.props.hasSearch && react_default.a.createElement(react_outside_click_handler_default.a, {
      onOutsideClick: () => {
        this.hideSearch();
      }
    }, react_default.a.createElement("div", {
      className: "search-cont"
    }, react_default.a.createElement("div", {
      className: 'input-box' + (focused ? ' focused' : '') + (searchVisible ? '' : ' hide')
    }, react_default.a.createElement(input["a" /* default */], {
      className: "search-members",
      placeholder: this.props.searchPlaceholder,
      onChange: e => {
        this.search(e.target.value);
      },
      onFocus: () => {
        this.handleFocus();
      },
      onBlur: () => {
        this.handleBlur();
      }
    }), react_default.a.createElement(search_icon["a" /* default */], {
      className: "search__icon",
      "aria-hidden": "true"
    })), react_default.a.createElement(search_icon["a" /* default */], {
      onClick: () => {
        this.showSearch();
      },
      className: 'search-btn' + (searchVisible ? ' hide' : ''),
      "aria-hidden": "true"
    }))), react_default.a.createElement("button", {
      type: "button",
      className: "sidebar--right__expand",
      "aria-label": "Expand",
      onClick: this.props.actions.toggleRhsExpanded
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: expandSidebarTooltip
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.expandSidebarTooltip.icon",
      defaultMessage: "Expand Sidebar Icon"
    }, ariaLabel => react_default.a.createElement("i", {
      "aria-label": ariaLabel,
      className: 'expand-sidebar'
    }))), react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: shrinkSidebarTooltip
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.expandTooltip.icon",
      defaultMessage: "Shrink Sidebar Icon"
    }, ariaLabel => react_default.a.createElement("i", {
      "aria-label": ariaLabel,
      className: 'compress-sidebar'
    })))), this.props.isMembers && this.props.currentChannel.type != "D" && react_default.a.createElement("button", {
      id: "searchResultsAddButton",
      type: "button",
      className: "sidebar--right__close",
      "aria-label": "add",
      onClick: this.showAddMembers
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: addSidebarTooltip
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.addTooltip.icon",
      defaultMessage: "Add Members"
    }, ariaLabel => react_default.a.createElement("i", {
      "aria-label": ariaLabel,
      className: 'add-sidebar'
    })))), react_default.a.createElement("button", {
      id: "searchResultsCloseButton",
      type: "button",
      className: "sidebar--right__close",
      "aria-label": "Close",
      onClick: this.props.actions.closeRightHandSide
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: closeSidebarTooltip
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.closeTooltip.icon",
      defaultMessage: "Close Sidebar Icon"
    }, ariaLabel => react_default.a.createElement("i", {
      "aria-label": ariaLabel,
      className: 'close-sidebar'
    }))))), addMember);
  }

}

search_results_header_defineProperty(search_results_header_SearchResultsHeader, "propTypes", {
  children: prop_types_default.a.element,
  actions: prop_types_default.a.shape({
    closeRightHandSide: prop_types_default.a.func,
    toggleRhsExpanded: prop_types_default.a.func.isRequired
  }),
  currentChannel: prop_types_default.a.object.isRequired
});
// CONCATENATED MODULE: ./components/search_results_header/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function search_results_header_mapStateToProps(state, ownProps) {
  const currentChannel = Object(channels["getCurrentChannel"])(state) || {};
  return {
    currentChannel
  };
}

function search_results_header_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      closeRightHandSide: rhs["b" /* closeRightHandSide */],
      toggleRhsExpanded: rhs["u" /* toggleRhsExpanded */],
      setSidebarSearchTerm: search["b" /* setSidebarSearchTerm */]
    }, dispatch)
  };
}

/* harmony default export */ var components_search_results_header = __webpack_exports__["a"] = (Object(es["connect"])(search_results_header_mapStateToProps, search_results_header_mapDispatchToProps)(search_results_header_SearchResultsHeader));

/***/ }),

/***/ 2260:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var entities_channels = __webpack_require__(15);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./actions/views/posts.js
var posts = __webpack_require__(1618);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./actions/channel_actions.jsx
var channel_actions = __webpack_require__(1593);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/antd/es/message/index.js
var message = __webpack_require__(3478);

// EXTERNAL MODULE: ./node_modules/antd/es/modal/index.js + 3 modules
var modal = __webpack_require__(1552);

// EXTERNAL MODULE: ./node_modules/antd/es/input/index.js + 7 modules
var input = __webpack_require__(3484);

// EXTERNAL MODULE: ./node_modules/antd/es/checkbox/index.js + 2 modules
var es_checkbox = __webpack_require__(3492);

// EXTERNAL MODULE: ./node_modules/antd/es/button/index.js + 3 modules
var es_button = __webpack_require__(234);

// EXTERNAL MODULE: ./node_modules/use-debounce/esm/useDebouncedCallback.js
var useDebouncedCallback = __webpack_require__(3479);

// EXTERNAL MODULE: ./components/icons/x_icon.jsx
var x_icon = __webpack_require__(2042);

// CONCATENATED MODULE: ./components/icons/search_icon.jsx
/* harmony default export */ var search_icon = (({
  fill = "#e0e0e0",
  ...rest
}) => React.createElement("svg", {
  height: "14",
  viewBox: "0 0 14 14",
  width: "14",
  xmlns: "http://www.w3.org/2000/svg"
}, React.createElement("path", {
  className: "aoicon",
  d: "m6.25 0c3.45177969 0 6.25 2.79822031 6.25 6.25 0 1.40507738-.4636564 2.701862-1.2463153 3.74569997l2.5983348 2.59965943-1.0606601 1.0606601-2.5752029-2.5754537c-1.07899354.8869449-2.46039025 1.4194342-3.9661565 1.4194342-3.45177969 0-6.25-2.79822031-6.25-6.25s2.79822031-6.25 6.25-6.25zm0 1.5c-2.62335256 0-4.75 2.12664744-4.75 4.75s2.12664744 4.75 4.75 4.75 4.75-2.12664744 4.75-4.75-2.12664744-4.75-4.75-4.75z",
  fill: fill
})));
// EXTERNAL MODULE: ./api/post.js
var api_post = __webpack_require__(67);

// EXTERNAL MODULE: ./api/search.js
var search = __webpack_require__(1809);

// EXTERNAL MODULE: ./mattermost-redux/client/index.js
var client = __webpack_require__(27);

// EXTERNAL MODULE: ./components/select_member/index.scss
var select_member = __webpack_require__(3197);

// CONCATENATED MODULE: ./components/select_member/select_member_modal.jsx










/* harmony default export */ var select_member_modal = (Object(react["forwardRef"])((props, ref) => {
  const {
    visible = false,
    channelPostSelect = {},
    actions,
    messageMergeForward
  } = props;
  let {
    teamId,
    members = []
  } = props; //const inivteData = JSON.parse(localStorage.getItem("videoInivte")); // members,teamId

  const [state, setState] = Object(react["useReducer"])((o, n) => ({ ...o,
    ...n
  }), {
    listData: [],
    selectedMember: [],
    visible,
    loading: false,
    searching: false,
    searchTerm: ''
  });
  Object(react["useEffect"])(() => {
    setState({
      visible
    });
  }, [visible]);
  const count = state.selectedMember.length;

  const handleSelectMember = e => {
    let val = JSON.parse(e.target.value);
    let list;

    if (e.target.checked) {
      // add
      list = addItem(state.selectedMember, val, 'channelId');
    } else {
      // remove
      list = deleteItem(state.selectedMember, val, 'channelId');
    }

    setState({
      selectedMember: list
    }); // console.log(list, '---list')
  };

  const handleDelete = item => {
    const list = deleteItem(state.selectedMember, item, 'channelId');
    setState({
      selectedMember: list
    });
  };

  const setData = (_state, _visible) => {
    setState(_state);
    actions.setChannelPostSelect({ ...channelPostSelect,
      visibleSelectMember: _visible
    });
  };

  const show = () => {
    setData({
      visible: true
    }, true);
  };

  const hide = () => {
    setData({
      loading: false,
      visible: false,
      selectedMember: [],
      listData: [],
      searching: false,
      searchTerm: ''
    }, false);
    actions.setChannelPostSelect({
      __TYPE__: 'RESET'
    });
    actions.setMessageMergeForward({
      __TYPE__: 'RESET'
    });
  };

  Object(react["useImperativeHandle"])(ref, () => ({
    show,
    hide
  }));

  const handleSubmit = () => {
    if (count === 0) {
      return message["a" /* default */].warn('请选择成员');
    }

    setState({
      loading: true
    });

    if (constants["f" /* ChannelPostSelectType */].INVITE === channelPostSelect.type) {
      handleForwardInvite();
    } else {
      handleForward();
    }
  }; //邀请


  const handleForwardInvite = () => {
    const channelIdList = state.selectedMember;
    let postList = [];
    channelIdList.forEach((channel, index) => {
      let post = { ...channelPostSelect.postData
      };
      post.channel_id = channel.channelId;
      post.pending_post_id = `${post.user_id}:${post.create_at + index}`;
      postList.push(post);
    });
    Object(api_post["p" /* sendPostList */])({
      posts: postList
    });
    hide();
  };

  const channelShow = () => {
    const _channelIds = state.selectedMember.map(c => c.channelId);

    actions.setChannelVisible(_channelIds, 'true');
  };

  const handleForward = () => {
    // channelId list
    const channelIdList = state.selectedMember; // single forward

    if (constants["f" /* ChannelPostSelectType */].SINGLE === channelPostSelect.type) {
      // console.log(channelPostSelect.postId, '---single forward submit')
      const [a, b] = formatSubmit(members, channelIdList);
      Object(api_post["n" /* postForward */])(a, [channelPostSelect.postId], b).then(res => {
        if (res.status === 201) {
          // ok: init redux store & show delete channel
          channelShow();
          hide();
        } else {
          // fail
          setState({
            loading: false
          });
          message["a" /* default */].error('转发失败，请重新尝试');
        }
      });
    } // merge forward


    const isCollect = constants["f" /* ChannelPostSelectType */].COLLECT === channelPostSelect.type;
    const isMerge = constants["f" /* ChannelPostSelectType */].MERGE === channelPostSelect.type;

    if (isMerge || isCollect) {
      // console.log(messageMergeForward, '---merge forward submit')
      // postId list
      let postIdList = [];

      if (isCollect) {
        postIdList = channelPostSelect.postIds;
      }

      if (isMerge) {
        postIdList = Object.keys(messageMergeForward);
      }

      const [a, b] = formatSubmit(members, channelIdList); // console.log(postIdList, '---postIdList')

      Object(api_post["o" /* postMergeForward */])(a, postIdList, b).then(res => {
        if (res.status === 201) {
          // console.log(res, '----merge forward success');
          // ok: init redux store & show delete channel
          channelShow();
          hide();
        } else {
          setState({
            loading: false
          });
          message["a" /* default */].error('转发失败，请重新尝试');
        }
      });
    } // console.log(state.selectedMember, '---selectedMember')
    // console.log(channelIdList, '---channelIdList')

  };

  const [debouncedCallback] = Object(useDebouncedCallback["a" /* default */])(async term => {
    setState({
      searchTerm: term
    });

    if (term) {
      const [contacts, channels] = await searchResult({
        team_id: teamId,
        term
      });
      setState({
        listData: formatResult(contacts, channels),
        searching: true
      });
    } else {
      setState({
        listData: [],
        searching: false
      });
    }
  }, 500); //members = ChannelPostSelectType.INVITE === channelPostSelect.type ? inivteData.members : members ;
  //teamId = ChannelPostSelectType.INVITE === channelPostSelect.type ? inivteData.teamId : teamId ;

  return react_default.a.createElement(modal["a" /* default */], {
    className: "select__member",
    zIndex: 1001,
    visible: state.visible,
    title: "\u9009\u62E9\u6210\u5458",
    destroyOnClose: true,
    centered: true,
    mask: false,
    onCancel: hide,
    footer: null,
    closeIcon: react_default.a.createElement(x_icon["a" /* default */], null)
  }, react_default.a.createElement("div", {
    className: "modal__lf"
  }, react_default.a.createElement("div", {
    className: "list__head"
  }, react_default.a.createElement(input["a" /* default */].Search, {
    placeholder: "\u641C\u7D22\u8054\u7CFB\u4EBA",
    suffix: react_default.a.createElement(search_icon, {
      className: "modal__search__icon",
      "aria-hidden": true
    }),
    onChange: e => debouncedCallback(e.target.value)
  }), react_default.a.createElement("p", {
    className: "tips"
  }, !state.searching ? '最近聊天' : '', state.searching && state.listData.length === 0 && `没有关于“${state.searchTerm}”的结果`)), react_default.a.createElement("div", {
    className: "scroll__list"
  }, react_default.a.createElement("div", {
    className: "modal__list"
  }, (state.searching ? state.listData : members).map((item, index) => item.visible !== false && react_default.a.createElement(es_checkbox["a" /* default */], {
    key: `${item}_${index}`,
    checked: isChecked(state.selectedMember, item, 'channelId'),
    value: JSON.stringify(item),
    onChange: handleSelectMember
  }, react_default.a.createElement("img", {
    src: item.channelIcon,
    className: "channel-icon"
  }), react_default.a.createElement("div", {
    className: `content ${item.type}`
  }, react_default.a.createElement("span", {
    className: "name"
  }, item.channelDisplayName), item.type === 'search_contact' && react_default.a.createElement("span", {
    className: "department"
  }, item.departmentName || '部门暂无'))))))), react_default.a.createElement("div", {
    className: "modal__lr"
  }, react_default.a.createElement("div", {
    className: "list__head"
  }, react_default.a.createElement("p", null, count > 0 ? `已选择了${count}位联系人` : '请选择联系人')), react_default.a.createElement("ul", {
    className: "scroll__list"
  }, state.selectedMember.map((item, index) => {
    return react_default.a.createElement("li", {
      key: item.channelId
    }, react_default.a.createElement("img", {
      src: item.channelIcon,
      className: "channel-icon"
    }), react_default.a.createElement("span", {
      className: "name"
    }, item.channelDisplayName), react_default.a.createElement("span", {
      className: "delete",
      onClick: () => handleDelete(item)
    }, react_default.a.createElement(x_icon["a" /* default */], null)));
  }), state.selectedMember.length === 0 && react_default.a.createElement("span", {
    className: "no-data"
  }, "\u6682\u65E0\u6210\u5458~")), react_default.a.createElement("div", {
    className: "btns"
  }, react_default.a.createElement(es_button["a" /* default */], {
    onClick: hide
  }, "\u53D6\u6D88"), react_default.a.createElement(es_button["a" /* default */], {
    loading: state.loading,
    type: "primary",
    onClick: handleSubmit
  }, "\u8F6C\u53D1"))));
}));

async function searchResult({
  team_id,
  term
}) {
  const reqContacts = new Promise(res => {
    Object(search["e" /* searchContacts */])({
      team_id,
      term
    }).then(_res => res(_res.data || []));
  });
  const reqChannels = new Promise(res => {
    Object(search["c" /* searchChannels */])({
      team_id,
      term
    }).then(_res => res(_res.data || []));
  });
  return await Promise.all([reqContacts, reqChannels]);
}

function formatResult(contacts, channels) {
  let a = [];
  let b = [];

  if (contacts.length > 0) {
    contacts.map(item => {
      const avatarUrl = client["Client4"].getProfilePictureUrl(item.id, item.last_picture_update);
      if (item.is_bot) return;
      a.push({
        channelIcon: avatarUrl,
        channelDisplayName: item.nickname || item.username,
        channelId: item.id,
        departmentName: item.department_name,
        type: 'search_contact'
      });
    });
  }

  if (channels.length > 0) {
    channels.map(item => {
      const iconName = item.icon_id ? item.icon_id : 'private_00.png';

      const iconURL = __webpack_require__(410)(`./${iconName}`);

      b.push({
        channelIcon: iconURL,
        channelDisplayName: item.display_name,
        channelId: item.id,
        type: 'search_channel'
      });
    });
  } // console.log(contacts, channels)


  return [...b, ...a];
}

function deleteItem(array, record, key) {
  if (Array.isArray(array)) {
    let _index = -1;

    array.map((item, index) => {
      if (item[key] === record[key]) {
        _index = index;
      }
    });

    if (_index !== -1) {
      array.splice(_index, 1);
    } // console.log(array, record, index, 'deleteItem');


    return array;
  }

  return console.error('deleteItem(array: Array<Object>, record: Object, key: String)');
}

function addItem(array, record, key) {
  if (Array.isArray(array)) {
    let _index = -1;

    if (array.length === 0) {
      return [record];
    }

    let _arr = [];
    array.map((item, index) => {
      if (item[key] !== record[key]) {
        _arr = [...array, record];
      }
    });
    return _arr;
  }

  return console.error('deleteItem(array: Array<Object>, record: Object, key: String)');
}

function isChecked(array, record, key) {
  let isCheck = false;
  array.map((item, index) => {
    if (item[key] === record[key]) {
      isCheck = true;
    }
  });
  return isCheck;
}

function formatSubmit(latelyList, list) {
  let a = [];
  let b = [];
  list.map(item => {
    let c = true;
    latelyList.map(item2 => {
      if (item.channelId === item2.channelId) {
        a.push(item.channelId);
        c = false;
      }
    });

    if (c) {
      b.push(item.channelId);
    }
  });
  return [a, b]; // a: contacts, b: channels
}
// CONCATENATED MODULE: ./components/select_member/index.js













function getChannelIcon(state, _channel) {
  let channelIcon = _channel.icon_id;
  let channelDisplayName = _channel.display_name;
  const reg = /public_|private_/;

  if (!channelIcon || !reg.test(channelIcon)) {
    channelIcon = __webpack_require__(410)(`./${_channel.type === 'O' ? 'public_00.png' : 'private_00.png'}`);
  } else {
    channelIcon = __webpack_require__(410)(`./${channelIcon}`);
  }

  if (_channel.type === constants["g" /* Constants */].DM_CHANNEL) {
    const teammate = Object(users["getUser"])(state, _channel.teammate_id);

    if (teammate) {
      // channelTeammateId = teammate.id;
      // channelTeammateDeletedAt = teammate.delete_at;
      // channelTeammateUsername = teammate.username;
      // channelTeammateIsBot = teammate.is_bot;
      channelIcon = utils["K" /* imageURLForUser */]({
        id: teammate.id
      });
      channelDisplayName = teammate.nickname == "" ? teammate.first_name == "" ? teammate.username : teammate.first_name : teammate.nickname; //console.log("sssssss----state",state,"ownProps",ownProps,"member----",member,"channel----",channel,"teammate----",teammate,"teammateNameDisplay----",teammateNameDisplay,"channelDisplayName----",channelDisplayName)
    }
  }

  return [channelIcon, channelDisplayName];
}

function onSubmitPost(post, fileInfos) {
  return dispatch => {
    dispatch(Object(post_actions["c" /* createPost */])(post, fileInfos));
  };
}

function mapStateToProps(state) {
  const getChannel = Object(entities_channels["makeGetChannel"])();
  const sidebarPrefs = Object(preferences["getSidebarPreferences"])(state);
  const lastUnreadChannel = state.views.channel.keepChannelIdAsUnread;
  const orderedChannelIds = Object(entities_channels["getOrderedChannelIds"])(state, lastUnreadChannel, sidebarPrefs.grouping, sidebarPrefs.sorting, sidebarPrefs.unreads_at_top === "true", sidebarPrefs.favorite_at_top === "true");
  let members = [];
  Array.isArray(orderedChannelIds) && orderedChannelIds.map(item => members = [...members, ...item.items]);
  members = members.map(channelId => {
    const _channel = getChannel(state, {
      id: channelId
    }) || {};

    const [channelIcon, channelDisplayName] = getChannelIcon(state, _channel);
    const visible = Object(preferences["getBool"])(state, constants["g" /* Constants */].Preferences.CATEGORY_PRIVATE_CHANNEL_SHOW, channelId, true);
    return {
      channelId,
      channelIcon,
      channelDisplayName,
      type: 'lately',
      visible
    };
  });
  let visible = false;
  let channelPostSelect;
  let messageMergeForward;

  if (state.views.posts) {
    channelPostSelect = state.views.posts.channelPostSelect;
    messageMergeForward = state.views.posts.messageMergeForward;

    if (channelPostSelect) {
      visible = channelPostSelect.visibleSelectMember;
    }
  }

  const teamId = state.entities.teams.currentTeamId;
  return {
    members,
    visible,
    channelPostSelect,
    messageMergeForward,
    teamId
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      setChannelPostSelect: posts["c" /* setChannelPostSelect */],
      setMessageMergeForward: posts["d" /* setMessageMergeForward */],
      setChannelVisible: channel_actions["h" /* setChannelVisible */],
      onSubmitPost
    }, dispatch)
  };
}

/* harmony default export */ var components_select_member = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps, null, {
  withRef: true
})(select_member_modal));

/***/ }),

/***/ 2263:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/antd/es/modal/index.js + 3 modules
var modal = __webpack_require__(1552);

// EXTERNAL MODULE: ./node_modules/moment/moment.js
var moment = __webpack_require__(2);
var moment_default = /*#__PURE__*/__webpack_require__.n(moment);

// EXTERNAL MODULE: ./components/icons/x_icon.jsx
var x_icon = __webpack_require__(2042);

// EXTERNAL MODULE: ./components/post_view/post_message_view/index.js + 1 modules
var post_message_view = __webpack_require__(1759);

// EXTERNAL MODULE: ./components/file_attachment_list/index.js + 7 modules
var file_attachment_list = __webpack_require__(1718);

// CONCATENATED MODULE: ./components/ao_post_cards/merge_message/message_modal/MessageModal.jsx







const dateFormat = time => moment_default()(time).format('YYYY-MM-DD HH:mm:ss');

/* harmony default export */ var MessageModal = (Object(react["forwardRef"])((props, ref) => {
  const {
    value,
    compactDisplay,
    title = '聊天记录',
    files = {},
    filesInfos,
    actions
  } = props;
  const [isVisible, setVisible] = Object(react["useState"])(false);
  Object(react["useEffect"])(() => {
    actions.setFileInfos(filesInfos);
  }, [filesInfos]);

  const hide = () => {
    setVisible(false);
  };

  const show = () => {
    setVisible(true);
  };

  Object(react["useImperativeHandle"])(ref, () => ({
    show,
    hide
  }));
  return react_default.a.createElement(modal["a" /* default */], {
    className: "merge__post__modal",
    zIndex: 1001,
    visible: isVisible,
    title: title,
    destroyOnClose: true,
    width: 660 // centered
    ,
    onCancel: hide,
    footer: null,
    closeIcon: react_default.a.createElement(x_icon["a" /* default */], null),
    mask: false
  }, value.map(item => {
    let fileAttachmentHolder = null;
    let _fileInfo = [];
    const hasFiles = item.file_ids && item.file_ids.length > 0;
    item = { ...item,
      id: item.post_id
    };

    if (hasFiles || item.filenames && item.filenames.length > 0) {
      hasFiles && item.file_ids.map(fileId => {
        const _file = files[fileId];

        if (_file) {
          _fileInfo.push(_file);
        }
      });
      fileAttachmentHolder = react_default.a.createElement(file_attachment_list["a" /* default */], {
        post: item,
        fileInfos: _fileInfo,
        compactDisplay: compactDisplay
      }); // console.log(fileAttachmentHolder, compactDisplay, '----fileAttachmentHolder')
    }

    return react_default.a.createElement("div", {
      key: item.post_id,
      className: "merge__item"
    }, react_default.a.createElement("div", {
      className: "merge__info"
    }, react_default.a.createElement("span", null, item.user_name), react_default.a.createElement("time", null, dateFormat(item.create_at))), react_default.a.createElement("div", {
      className: `merge__post ${item.card_type === '11-1' ? 'merge__card' : ''}`
    }, react_default.a.createElement(post_message_view["a" /* default */], {
      post: item,
      isRHS: true,
      hasMention: true,
      type: "card"
    }), item.card_type ? '' : fileAttachmentHolder));
  }));
}));
// CONCATENATED MODULE: ./actions/views/files.js

function setFileInfos(data) {
  return dispatch => {
    dispatch({
      type: constants["b" /* ActionTypes */].FILE_INFO,
      data
    });
    return {
      data: true
    };
  };
}
// CONCATENATED MODULE: ./components/ao_post_cards/merge_message/message_modal/index.js







function mapStateToProps(state) {
  let files = null;

  if (state.entities.files) {
    files = state.entities.files.files;
  }

  if (state.views.files) {
    files = { ...files,
      ...state.views.files.files
    };
  }

  return {
    files,
    compactDisplay: Object(preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].MESSAGE_DISPLAY, constants["w" /* Preferences */].MESSAGE_DISPLAY_DEFAULT) === constants["w" /* Preferences */].MESSAGE_DISPLAY_COMPACT
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      setFileInfos: setFileInfos
    }, dispatch)
  };
}

/* harmony default export */ var message_modal = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps, null, {
  withRef: true
})(MessageModal));

/***/ }),

/***/ 2264:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Overlay.js
var Overlay = __webpack_require__(1852);

// EXTERNAL MODULE: ./mattermost-redux/client/index.js
var client = __webpack_require__(27);

// EXTERNAL MODULE: ./mattermost-redux/utils/user_utils.js
var user_utils = __webpack_require__(104);

// EXTERNAL MODULE: ./components/profile_popover/index.js + 5 modules
var profile_popover = __webpack_require__(1962);

// EXTERNAL MODULE: ./utils/position_utils.jsx
var position_utils = __webpack_require__(2000);

// CONCATENATED MODULE: ./components/at_mention/at_mention.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const spaceRequiredForPopOver = 300;
class at_mention_AtMention extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleClick", e => {
      const targetBounds = this.overlayRef.current.getBoundingClientRect();
      const placement = Object(position_utils["a" /* popOverOverlayPosition */])(targetBounds, window.innerHeight, {
        above: spaceRequiredForPopOver
      });
      this.setState({
        target: e.target,
        show: !this.state.show,
        placement
      });
    });

    _defineProperty(this, "hideOverlay", () => {
      this.setState({
        show: false
      });
    });

    this.state = {
      user: this.getUserFromMentionName(props),
      show: false
    };
    this.overlayRef = react_default.a.createRef();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.mentionName !== this.props.mentionName || nextProps.usersByUsername !== this.props.usersByUsername) {
      this.setState({
        user: this.getUserFromMentionName(nextProps)
      });
    }
  }

  getUserFromMentionName(props) {
    const usersByUsername = props.usersByUsername;
    let mentionName = props.mentionName.toLowerCase();

    while (mentionName.length > 0) {
      if (usersByUsername.hasOwnProperty(mentionName)) {
        return usersByUsername[mentionName];
      } // Repeatedly trim off trailing punctuation in case this is at the end of a sentence


      if (/[._-]$/.test(mentionName)) {
        mentionName = mentionName.substring(0, mentionName.length - 1);
      } else {
        break;
      }
    }

    return '';
  }

  render() {
    if (!this.state.user) {
      return react_default.a.createElement(react_default.a.Fragment, null, this.props.children);
    }

    const user = this.state.user;
    const suffix = this.props.mentionName.substring(user.username.length);
    let className = 'mention-link';

    if (user.id === this.props.currentUserId) {
      className += ' mention--highlight';
    }

    return react_default.a.createElement("span", null, react_default.a.createElement(Overlay["a" /* default */], {
      placement: this.state.placement,
      show: this.state.show,
      target: this.state.target,
      rootClose: true,
      onHide: this.hideOverlay
    }, react_default.a.createElement(profile_popover["a" /* default */], {
      userId: user.id,
      src: client["Client4"].getProfilePictureUrl(user.id, user.last_picture_update),
      isRHS: this.props.isRHS,
      hasMention: this.props.hasMention,
      hide: this.hideOverlay
    })), react_default.a.createElement("a", {
      className: className,
      onClick: this.handleClick,
      ref: this.overlayRef
    }, '@' + Object(user_utils["displayUsername"])(user, this.props.teammateNameDisplay)), suffix);
  }

}

_defineProperty(at_mention_AtMention, "propTypes", {
  children: prop_types_default.a.node,
  currentUserId: prop_types_default.a.string.isRequired,
  hasMention: prop_types_default.a.bool,
  isRHS: prop_types_default.a.bool,
  mentionName: prop_types_default.a.string.isRequired,
  teammateNameDisplay: prop_types_default.a.string.isRequired,
  usersByUsername: prop_types_default.a.object.isRequired
});

_defineProperty(at_mention_AtMention, "defaultProps", {
  isRHS: false,
  hasMention: false
});
// CONCATENATED MODULE: ./components/at_mention/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function mapStateToProps(state) {
  return {
    currentUserId: Object(users["getCurrentUserId"])(state),
    teammateNameDisplay: Object(preferences["getTeammateNameDisplaySetting"])(state),
    usersByUsername: Object(users["getUsersByUsername"])(state)
  };
}

/* harmony default export */ var at_mention = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(at_mention_AtMention));

/***/ }),

/***/ 2267:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var channels = __webpack_require__(15);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var teams = __webpack_require__(32);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Modal.js
var Modal = __webpack_require__(1972);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./utils/browser_history.jsx
var browser_history = __webpack_require__(114);

// EXTERNAL MODULE: ./utils/user_agent.jsx
var user_agent = __webpack_require__(39);

// CONCATENATED MODULE: ./components/delete_post_modal/delete_post_modal.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class delete_post_modal_DeletePostModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleDelete", async () => {
      const {
        actions,
        channelName,
        focusedPostId,
        post,
        teamName
      } = this.props;
      const result = await actions.deleteAndRemovePost(post);

      if (post.id === focusedPostId && channelName) {
        browser_history["a" /* browserHistory */].push('/' + teamName + '/channels/' + channelName);
      }

      if (result.data) {
        this.onHide();
      }
    });

    _defineProperty(this, "handleEntered", () => {
      if (this.deletePostBtn) {
        this.deletePostBtn.focus();
      }
    });

    _defineProperty(this, "onHide", () => {
      this.setState({
        show: false
      });

      if (!user_agent["m" /* isMobile */]()) {
        var element;

        if (this.props.isRHS) {
          element = document.getElementById('reply_textbox');
        } else {
          element = document.getElementById('post_textbox');
        }

        if (element) {
          element.focus();
        }
      }
    });

    this.state = {
      show: true
    };
  }

  render() {
    var commentWarning = '';

    if (this.props.commentCount > 0 && this.props.post.root_id === '') {
      commentWarning = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "delete_post.warning",
        defaultMessage: "This post has {count, number} {count, plural, one {comment} other {comments}} on it.",
        values: {
          count: this.props.commentCount
        }
      });
    }

    const postTerm = this.props.post.root_id ? react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "delete_post.comment",
      defaultMessage: "Comment"
    }) : react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "delete_post.post",
      defaultMessage: "Post"
    });
    return react_default.a.createElement(Modal["a" /* default */], {
      show: this.state.show,
      onEntered: this.handleEntered,
      onHide: this.onHide,
      onExited: this.props.onHide,
      enforceFocus: false,
      id: "deletePostModal",
      role: "dialog",
      "aria-labelledby": "deletePostModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "deletePostModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "delete_post.confirm",
      defaultMessage: "Confirm {term} Delete",
      values: {
        term: postTerm
      }
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "delete_post.question",
      defaultMessage: "Are you sure you want to delete this {term}?",
      values: {
        term: postTerm
      }
    }), react_default.a.createElement("br", null), react_default.a.createElement("br", null), commentWarning), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-link",
      onClick: this.onHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "delete_post.cancel",
      defaultMessage: "Cancel"
    })), react_default.a.createElement("button", {
      ref: deletePostBtn => {
        this.deletePostBtn = deletePostBtn;
      },
      type: "button",
      autoFocus: true,
      className: "btn btn-danger",
      onClick: this.handleDelete,
      id: "deletePostModalButton"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "delete_post.del",
      defaultMessage: "Delete"
    }))));
  }

}

_defineProperty(delete_post_modal_DeletePostModal, "propTypes", {
  channelName: prop_types_default.a.string,
  focusedPostId: prop_types_default.a.string,
  teamName: prop_types_default.a.string,
  post: prop_types_default.a.object.isRequired,
  commentCount: prop_types_default.a.number.isRequired,
  isRHS: prop_types_default.a.bool.isRequired,
  onHide: prop_types_default.a.func.isRequired,
  actions: prop_types_default.a.shape({
    deleteAndRemovePost: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/delete_post_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function mapStateToProps(state, ownProps) {
  const channel = Object(channels["getChannel"])(state, ownProps.post.channel_id);
  let channelName = '';

  if (channel) {
    channelName = channel.name;
  }

  const {
    focusedPostId
  } = state.views.channel;
  return {
    channelName,
    focusedPostId,
    teamName: Object(teams["getCurrentTeam"])(state).name
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      deleteAndRemovePost: post_actions["d" /* deleteAndRemovePost */]
    }, dispatch)
  };
}

/* harmony default export */ var delete_post_modal = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(delete_post_modal_DeletePostModal));

/***/ }),

/***/ 2268:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// CONCATENATED MODULE: ./components/widgets/settings/setting.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



const Setting = props => {
  const {
    children,
    footer,
    helpText,
    inputId,
    label,
    labelClassName,
    inputClassName
  } = props;
  return react_default.a.createElement("div", {
    className: "form-group"
  }, react_default.a.createElement("label", {
    className: 'control-label ' + labelClassName,
    htmlFor: inputId
  }, label), react_default.a.createElement("div", {
    className: inputClassName
  }, children, react_default.a.createElement("div", {
    className: "help-text"
  }, helpText), footer));
};

Setting.propTypes = {
  inputId: prop_types_default.a.string,
  label: prop_types_default.a.node.isRequired,
  labelClassName: prop_types_default.a.string,
  inputClassName: prop_types_default.a.string,
  children: prop_types_default.a.node.isRequired,
  helpText: prop_types_default.a.node,
  footer: prop_types_default.a.node
};
/* harmony default export */ var setting = (Setting);
// CONCATENATED MODULE: ./components/widgets/settings/text_setting.jsx
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return text_setting_TextSetting; });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class text_setting_TextSetting extends react_default.a.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "handleChange", e => {
      if (this.props.type === 'number') {
        this.props.onChange(this.props.id, parseInt(e.target.value, 10));
      } else {
        this.props.onChange(this.props.id, e.target.value);
      }
    });
  }

  render() {
    const {
      resizable
    } = this.props;
    let {
      type
    } = this.props;
    let input = null;

    if (type === 'textarea') {
      const style = {};

      if (!resizable) {
        style.resize = 'none';
      }

      input = react_default.a.createElement("textarea", {
        id: this.props.id,
        style: style,
        className: "form-control",
        rows: "5",
        placeholder: this.props.placeholder,
        value: this.props.value,
        maxLength: this.props.maxLength,
        onChange: this.handleChange,
        disabled: this.props.disabled
      });
    } else {
      type = ['input', 'email', 'tel', 'number', 'url'].includes(type) ? type : 'input';
      input = react_default.a.createElement("input", {
        id: this.props.id,
        className: "form-control",
        type: type,
        placeholder: this.props.placeholder,
        value: this.props.value,
        maxLength: this.props.maxLength,
        onChange: this.handleChange,
        disabled: this.props.disabled
      });
    }

    return react_default.a.createElement(setting, {
      label: this.props.label,
      labelClassName: this.props.labelClassName,
      inputClassName: this.props.inputClassName,
      helpText: this.props.helpText,
      inputId: this.props.id,
      footer: this.props.footer
    }, input);
  }

}

_defineProperty(text_setting_TextSetting, "validTypes", ['input', 'textarea', 'number', 'email', 'tel', 'url']);

_defineProperty(text_setting_TextSetting, "propTypes", {
  id: prop_types_default.a.string.isRequired,
  label: prop_types_default.a.node.isRequired,
  labelClassName: prop_types_default.a.string,
  placeholder: prop_types_default.a.string,
  helpText: prop_types_default.a.node,
  footer: prop_types_default.a.node,
  value: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]).isRequired,
  inputClassName: prop_types_default.a.string,
  maxLength: prop_types_default.a.number,
  resizable: prop_types_default.a.bool,
  onChange: prop_types_default.a.func,
  disabled: prop_types_default.a.bool,
  type: prop_types_default.a.oneOf(text_setting_TextSetting.validTypes)
});

_defineProperty(text_setting_TextSetting, "defaultProps", {
  labelClassName: '',
  inputClassName: '',
  type: 'input',
  maxLength: null,
  resizable: true
});

/***/ }),

/***/ 2269:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/timezone.js
var timezone = __webpack_require__(308);

// EXTERNAL MODULE: ./mattermost-redux/utils/timezone_utils.js
var timezone_utils = __webpack_require__(306);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./selectors/general.js
var general = __webpack_require__(232);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./node_modules/moment-timezone/index.js
var moment_timezone = __webpack_require__(260);
var moment_timezone_default = /*#__PURE__*/__webpack_require__.n(moment_timezone);

// CONCATENATED MODULE: ./components/local_date_time/local_date_time.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class local_date_time_LocalDateTime extends react_default.a.PureComponent {
  render() {
    const {
      enableTimezone,
      eventTime,
      timeZone,
      useMilitaryTime
    } = this.props;
    const date = eventTime ? new Date(eventTime) : new Date();
    let title = moment_timezone_default()(date);

    if (enableTimezone && timeZone) {
      title.tz(timeZone);
      title = title.toString() + ' (' + title.tz() + ')';
    } else {
      title = title.toString();
    }

    const timezoneProps = enableTimezone && timeZone ? {
      timeZone
    } : {};
    return react_default.a.createElement("time", {
      className: "post__time",
      dateTime: date.toISOString(),
      title: title,
      id: "localDateTime"
    }, react_default.a.createElement(index_es["d" /* FormattedTime */], _extends({}, timezoneProps, {
      hour12: !useMilitaryTime,
      value: date
    })));
  }

}

_defineProperty(local_date_time_LocalDateTime, "propTypes", {
  /*
   * The time to display
   */
  eventTime: prop_types_default.a.number,

  /*
   * Set to display using 24 hour format
   */
  useMilitaryTime: prop_types_default.a.bool,

  /*
   * Current timezone of the user
   */
  timeZone: prop_types_default.a.string,

  /*
   * Enable timezone feature
   */
  enableTimezone: prop_types_default.a.bool
});
// CONCATENATED MODULE: ./components/local_date_time/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









function mapStateToProps(state, props) {
  const currentUserId = Object(users["getCurrentUserId"])(state);
  let userTimezone;

  if (props.userTimezone) {
    userTimezone = props.userTimezone;
  } else {
    userTimezone = Object(timezone["getUserTimezone"])(state, currentUserId);
  }

  return {
    enableTimezone: Object(general["a" /* areTimezonesEnabledAndSupported */])(state),
    useMilitaryTime: Object(preferences["getBool"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].USE_MILITARY_TIME, false),
    timeZone: Object(timezone_utils["getUserCurrentTimezone"])(userTimezone)
  };
}

/* harmony default export */ var local_date_time = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(local_date_time_LocalDateTime));

/***/ }),

/***/ 2270:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./selectors/views/modals.js
var modals = __webpack_require__(1710);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Modal.js
var Modal = __webpack_require__(1972);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./components/formatted_markdown_message.jsx
var formatted_markdown_message = __webpack_require__(1564);

// EXTERNAL MODULE: ./images/icon.ico
var icon = __webpack_require__(2965);
var icon_default = /*#__PURE__*/__webpack_require__.n(icon);

// CONCATENATED MODULE: ./components/about_build_modal/about_build_modal.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class about_build_modal_AboutBuildModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.doHide = this.doHide.bind(this);
  }

  doHide() {
    this.props.onHide();
  }

  render() {
    const config = this.props.config;
    const license = this.props.license;
    let title = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "about.teamEditiont0",
      defaultMessage: "Team Edition"
    });
    let subTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "about.teamEditionSt",
      defaultMessage: "All your team communication in one place, instantly searchable and accessible anywhere."
    });
    let learnMore = react_default.a.createElement("div", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "about.teamEditionLearn",
      defaultMessage: "Join the Mattermost community at "
    }), react_default.a.createElement("a", {
      target: "_blank",
      rel: "noopener noreferrer",
      href: "http://www.mattermost.org/"
    }, 'mattermost.org'));
    let licensee;

    if (config.BuildEnterpriseReady === 'true') {
      title = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "about.teamEditiont1",
        defaultMessage: "Enterprise Edition"
      });
      subTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "about.enterpriseEditionSt",
        defaultMessage: "Modern communication from behind your firewall."
      });
      learnMore = react_default.a.createElement("div", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "about.enterpriseEditionLearn",
        defaultMessage: "Learn more about Enterprise Edition at "
      }), react_default.a.createElement("a", {
        target: "_blank",
        rel: "noopener noreferrer",
        href: "http://about.mattermost.com/"
      }, 'about.mattermost.com'));

      if (license.IsLicensed === 'true') {
        title = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "about.enterpriseEditione1",
          defaultMessage: "Enterprise Edition"
        });
        licensee = react_default.a.createElement("div", {
          className: "form-group"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "about.licensed",
          defaultMessage: "Licensed to:"
        }), "\xA0", license.Company);
      }
    }

    let termsOfService;

    if (config.TermsOfServiceLink) {
      termsOfService = react_default.a.createElement("a", {
        target: "_blank",
        rel: "noopener noreferrer",
        href: config.TermsOfServiceLink
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "about.tos",
        defaultMessage: "Terms of Service"
      }));
    }

    let privacyPolicy;

    if (config.PrivacyPolicyLink) {
      privacyPolicy = react_default.a.createElement("a", {
        target: "_blank",
        rel: "noopener noreferrer",
        href: config.PrivacyPolicyLink
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "about.privacy",
        defaultMessage: "Privacy Policy"
      }));
    }

    let tosPrivacyHyphen;

    if (config.TermsOfServiceLink && config.PrivacyPolicyLink) {
      tosPrivacyHyphen = react_default.a.createElement("span", null, ' - ');
    } // Only show build number if it's a number (so only builds from Jenkins)


    let buildnumber = react_default.a.createElement("div", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "about.buildnumber",
      defaultMessage: "Build Number:"
    }), react_default.a.createElement("span", {
      id: "buildnumberString"
    }, '\u00a0' + config.BuildNumber));

    if (isNaN(config.BuildNumber)) {
      buildnumber = null;
    }

    let mmversion = config.BuildNumber;

    if (!isNaN(config.BuildNumber)) {
      mmversion = 'V0.1.2';
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "about-modal",
      show: this.props.show,
      onHide: this.doHide,
      role: "dialog",
      "aria-labelledby": "aboutModalLabel",
      backdrop: false
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "aboutModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "about.title",
      values: {
        appTitle: config.SiteName || 'Aboutone'
      },
      defaultMessage: "About {appTitle}"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement("div", {
      className: "about-modal__content"
    }, react_default.a.createElement("div", {
      className: "about-modal__logo"
    }, react_default.a.createElement("img", {
      src: icon_default.a
    })), react_default.a.createElement("div", null, react_default.a.createElement("h3", {
      className: "about-modal__title"
    }, 'Aboutone', " ", title), react_default.a.createElement("p", {
      className: "about-modal__subtitle padding-bottom"
    }, subTitle), react_default.a.createElement("div", {
      className: "form-group less"
    }, react_default.a.createElement("div", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "about.version",
      defaultMessage: "Mattermost Version:"
    }), react_default.a.createElement("span", {
      id: "versionString"
    }, '\u00a0' + mmversion))), licensee)), react_default.a.createElement("div", {
      className: "about-modal__footer"
    }, react_default.a.createElement("div", {
      className: "form-group"
    }, react_default.a.createElement("div", {
      className: "about-modal__copyright"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "about.copyright",
      defaultMessage: "Copyright 2015 - {currentYear} Mattermost, Inc. All rights reserved",
      values: {
        currentYear: new Date().getFullYear()
      }
    })), react_default.a.createElement("div", {
      className: "about-modal__links"
    })))));
  }

}

_defineProperty(about_build_modal_AboutBuildModal, "defaultProps", {
  show: false
});

_defineProperty(about_build_modal_AboutBuildModal, "propTypes", {
  /**
   * Determines whether modal is shown or not
   */
  show: prop_types_default.a.bool.isRequired,

  /**
   * Function that is called when the modal is dismissed
   */
  onHide: prop_types_default.a.func.isRequired,

  /**
   * Global config object
   */
  config: prop_types_default.a.object.isRequired,

  /**
   * Global license object
   */
  license: prop_types_default.a.object.isRequired,

  /**
   * Webapp build hash override. By default, webpack sets this (so it must be overridden in tests).
   */
  webappBuildHash: prop_types_default.a.string
});
// CONCATENATED MODULE: ./components/about_build_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function mapStateToProps(state) {
  const modalId = constants["p" /* ModalIdentifiers */].ABOUT;
  return {
    config: Object(general["getConfig"])(state),
    license: Object(general["getLicense"])(state),
    show: Object(modals["a" /* isModalOpen */])(state, modalId)
  };
}

/* harmony default export */ var about_build_modal = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(about_build_modal_AboutBuildModal));

/***/ }),

/***/ 2271:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./mattermost-redux/client/index.js
var client = __webpack_require__(27);

// EXTERNAL MODULE: ./stores/redux_store.jsx + 3 modules
var redux_store = __webpack_require__(14);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/url.jsx + 1 modules
var url = __webpack_require__(298);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./mattermost-redux/store/reducer_registry.js
var reducer_registry = __webpack_require__(451);
var reducer_registry_default = /*#__PURE__*/__webpack_require__.n(reducer_registry);

// EXTERNAL MODULE: ./actions/websocket_actions.jsx
var websocket_actions = __webpack_require__(1723);

// EXTERNAL MODULE: ./actions/views/rhs.js
var rhs = __webpack_require__(116);

// EXTERNAL MODULE: ./actions/views/root.js
var root = __webpack_require__(421);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// CONCATENATED MODULE: ./plugins/registry.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









function dispatchPluginComponentAction(name, pluginId, component, id = Object(utils["s" /* generateId */])()) {
  redux_store["a" /* default */].dispatch({
    type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
    name,
    data: {
      id,
      pluginId,
      component
    }
  });
  return id;
}

const resolveReactElement = element => {
  if (typeof element === 'function') {
    // Allow element to be passed as the name of the component, instead of a React element.
    return react_default.a.createElement(element);
  }

  return element;
};

class registry_PluginRegistry {
  constructor(id) {
    this.id = id;
  } // Register a component at the root of the channel view of the app.
  // Accepts a React component. Returns a unique identifier.


  registerRootComponent(component) {
    return dispatchPluginComponentAction('Root', this.id, component);
  } // Register a component in the user attributes section of the profile popover (hovercard), below the default user attributes.
  // Accepts a React component. Returns a unique identifier.


  registerPopoverUserAttributesComponent(component) {
    return dispatchPluginComponentAction('PopoverUserAttributes', this.id, component);
  } // Register a component in the user actions of the profile popover (hovercard), below the default actions.
  // Accepts a React component. Returns a unique identifier.


  registerPopoverUserActionsComponent(component) {
    return dispatchPluginComponentAction('PopoverUserActions', this.id, component);
  } // Register a component fixed to the top of the left-hand channel sidebar.
  // Accepts a React component. Returns a unique identifier.


  registerLeftSidebarHeaderComponent(component) {
    return dispatchPluginComponentAction('LeftSidebarHeader', this.id, component);
  } // Register a component fixed to the bottom of the team sidebar. Does not render if
  // user is only on one team and the team sidebar is not shown.
  // Accepts a React component. Returns a unique identifier.


  registerBottomTeamSidebarComponent(component) {
    return dispatchPluginComponentAction('BottomTeamSidebar', this.id, component);
  } // Register a component fixed to the bottom of the post message.
  // Accepts a React component. Returns a unique identifier.


  registerPostMessageAttachmentComponent(component) {
    return dispatchPluginComponentAction('PostMessageAttachment', this.id, component);
  } // Register a component to show as a tooltip when a user hovers on a link in a post.
  // Accepts a React component. Returns a unique identifier.


  registerLinkTooltipComponent(component) {
    return dispatchPluginComponentAction('LinkTooltip', this.id, component);
  } // Add a button to the channel header. If there are more than one buttons registered by any
  // plugin, a dropdown menu is created to contain all the plugin buttons.
  // Accepts the following:
  // - icon - React element to use as the button's icon
  // - action - a function called when the button is clicked, passed the channel and channel member as arguments
  // - dropdown_text - string or React element shown for the dropdown button description
  // - tooltip_text - string shown for tooltip appear on hover


  registerChannelHeaderButtonAction(icon, action, dropdownText, tooltipText) {
    const id = Object(utils["s" /* generateId */])();
    const data = {
      id,
      pluginId: this.id,
      icon: resolveReactElement(icon),
      action,
      dropdownText: resolveReactElement(dropdownText),
      tooltipText
    };
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'ChannelHeaderButton',
      data
    });
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'MobileChannelHeaderButton',
      data
    });
    return id;
  } // Register a component to render a custom body for posts with a specific type.
  // Custom post types must be prefixed with 'custom_'.
  // Custom post types can also apply for ephemeral posts.
  // Accepts a string type and a component.
  // Returns a unique identifier.


  registerPostTypeComponent(type, component) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_POST_COMPONENT,
      data: {
        id,
        pluginId: this.id,
        type,
        component
      }
    });
    return id;
  } // Register a component to render a custom body for post cards with a specific type.
  // Custom post types must be prefixed with 'custom_'.
  // Accepts a string type and a component.
  // Returns a unique identifier.


  registerPostCardTypeComponent(type, component) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_POST_CARD_COMPONENT,
      data: {
        id,
        pluginId: this.id,
        type,
        component
      }
    });
    return id;
  } // Register a main menu list item by providing some text and an action function.
  // Accepts the following:
  // - text - A string or React element to display in the menu
  // - action - A function to trigger when component is clicked on
  // - mobileIcon - A React element to display as the icon in the menu in mobile view
  // Returns a unique identifier.


  registerMainMenuAction(text, action, mobileIcon) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'MainMenu',
      data: {
        id,
        pluginId: this.id,
        text: resolveReactElement(text),
        action,
        mobileIcon: resolveReactElement(mobileIcon)
      }
    });
    return id;
  } // Register a post menu list item by providing some text and an action function.
  // Accepts the following:
  // - text - A string or React element to display in the menu
  // - action - A function to trigger when component is clicked on
  // - filter - A function whether to apply the plugin into the post' dropdown menu
  // Returns a unique identifier.


  registerPostDropdownMenuAction(text, action, filter) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'PostDropdownMenu',
      data: {
        id,
        pluginId: this.id,
        text: resolveReactElement(text),
        action,
        filter
      }
    });
    return id;
  } // Register a component at the bottom of the post dropdown menu.
  // Accepts a React component. Returns a unique identifier.


  registerPostDropdownMenuComponent(component) {
    return dispatchPluginComponentAction('PostDropdownMenuItem', this.id, component);
  } // Register a file upload method by providing some text, an icon, and an action function.
  // Accepts the following:
  // - icon - JSX element to use as the button's icon
  // - text - A string or JSX element to display in the file upload menu
  // - action - A function to trigger when the menu item is selected.
  // Returns a unique identifier.


  registerFileUploadMethod(icon, action, text) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'FileUploadMethod',
      data: {
        id,
        pluginId: this.id,
        text,
        action,
        icon
      }
    });
    return id;
  } // Register a hook to intercept file uploads before they take place.
  // Accepts a function to run before files get uploaded. Receives an array of
  // files and a function to upload files at a later time as arguments. Must
  // return an object that can contain two properties:
  // - message - An error message to display, leave blank or null to display no message
  // - files - Modified array of files to upload, set to null to reject all files
  // Returns a unique identifier.


  registerFilesWillUploadHook(hook) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'FilesWillUploadHook',
      data: {
        id,
        pluginId: this.id,
        hook
      }
    });
    return id;
  } // Unregister a component, action or hook using the unique identifier returned after registration.
  // Accepts a string id.
  // Returns undefined in all cases.


  unregisterComponent(componentId) {
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].REMOVED_PLUGIN_COMPONENT,
      id: componentId
    });
  } // Unregister a component that provided a custom body for posts with a specific type.
  // Accepts a string id.
  // Returns undefined in all cases.


  unregisterPostTypeComponent(componentId) {
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].REMOVED_PLUGIN_POST_COMPONENT,
      id: componentId
    });
  } // Register a reducer against the Redux store. It will be accessible in redux state
  // under "state['plugins-<yourpluginid>']"
  // Accepts a reducer. Returns undefined.


  registerReducer(reducer) {
    reducer_registry_default.a.register('plugins-' + this.id, reducer);
  } // Register a handler for WebSocket events.
  // Accepts the following:
  // - event - the event type, can be a regular server event or an event from plugins.
  // Plugin events will have "custom_<pluginid>_" prepended
  // - handler - a function to handle the event, receives the event message as an argument
  // Returns undefined.


  registerWebSocketEventHandler(event, handler) {
    Object(websocket_actions["e" /* registerPluginWebSocketEvent */])(this.id, event, handler);
  } // Unregister a handler for a custom WebSocket event.
  // Accepts a string event type.
  // Returns undefined.


  unregisterWebSocketEventHandler(event) {
    Object(websocket_actions["j" /* unregisterPluginWebSocketEvent */])(this.id, event);
  } // Register a handler that will be called when the app reconnects to the
  // internet after previously disconnecting.
  // Accepts a function to handle the event. Returns undefined.


  registerReconnectHandler(handler) {
    Object(websocket_actions["d" /* registerPluginReconnectHandler */])(this.id, handler);
  } // Unregister a previously registered reconnect handler.
  // Returns undefined.


  unregisterReconnectHandler() {
    Object(websocket_actions["i" /* unregisterPluginReconnectHandler */])(this.id);
  } // Register a hook that will be called when a message is posted by the user before it
  // is sent to the server. Accepts a function that receives the post as an argument.
  //
  // To reject a post, return an object containing an error such as
  //     {error: {message: 'Rejected'}}
  // To modify or allow the post without modifcation, return an object containing the post
  // such as
  //     {post: {...}}
  //
  // If the hook function is asynchronous, the message will not be sent to the server
  // until the hook returns.


  registerMessageWillBePostedHook(hook) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'MessageWillBePosted',
      data: {
        id,
        pluginId: this.id,
        hook
      }
    });
    return id;
  } // Register a hook that will be called when a slash command is posted by the user before it
  // is sent to the server. Accepts a function that receives the message (string) and the args
  // (object) as arguments.
  // The args object is:
  //        {
  //            channel_id: channelId,
  //            team_id: teamId,
  //            root_id: rootId,
  //            parent_id: rootId,
  //        }
  //
  // To reject a command, return an object containing an error:
  //     {error: {message: 'Rejected'}}
  // To ignore a command, return an empty object (to prevent an error from being displayed):
  //     {}
  // To modify or allow the command without modification, return an object containing the new message
  // and args. It is not likely that you will need to change the args, so return the object that was provided:
  //     {message: {...}, args}
  //
  // If the hook function is asynchronous, the command will not be sent to the server
  // until the hook returns.


  registerSlashCommandWillBePostedHook(hook) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'SlashCommandWillBePosted',
      data: {
        id,
        pluginId: this.id,
        hook
      }
    });
    return id;
  } // Register a hook that will be called before a message is formatted into Markdown.
  // Accepts a function that receives the unmodified post and the message (potentially
  // already modified by other hooks) as arguments. This function must return a string
  // message that will be formatted.
  // Returns a unique identifier.


  registerMessageWillFormatHook(hook) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'MessageWillFormat',
      data: {
        id,
        pluginId: this.id,
        hook
      }
    });
    return id;
  } // Register a component to override file previews. Accepts a function to run before file is
  // previewed and a react component to be rendered as the file preview.
  // - override - A function to check whether preview needs to be overridden. Receives fileInfo and post as arguments.
  // Returns true is preview should be overridden and false otherwise.
  // - component - A react component to display instead of original preview. Receives fileInfo and post as props.
  // Returns a unique identifier.
  // Only one plugin can override a file preview at a time. If two plugins try to override the same file preview, the first plugin will perform the override and the second will not. Plugin precedence is ordered alphabetically by plugin ID.


  registerFilePreviewComponent(override, component) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'FilePreview',
      data: {
        id,
        pluginId: this.id,
        override,
        component
      }
    });
    return id;
  }

  registerTranslations(getTranslationsForLocale) {
    Object(root["d" /* registerPluginTranslationsSource */])(this.id, getTranslationsForLocale);
  } // Register a Right-Hand Sidebar component by providing a title for the right hand component.
  // Accepts the following:
  // - title - A string or JSX element to display as a title for the RHS.
  // - component - A react component to display in the Right-Hand Sidebar.
  // Returns:
  // - id: a unique identifier
  // - showRHSPlugin: the action to dispatch that will open the RHS.


  registerRightHandSidebarComponent(component, title) {
    const id = Object(utils["s" /* generateId */])();
    redux_store["a" /* default */].dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_PLUGIN_COMPONENT,
      name: 'RightHandSidebarComponent',
      data: {
        id,
        pluginId: this.id,
        component,
        title
      }
    });
    return {
      id,
      showRHSPlugin: Object(rhs["r" /* showRHSPlugin */])(id)
    };
  }

}
// CONCATENATED MODULE: ./plugins/index.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return initializePlugins; });
/* unused harmony export getPlugins */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return loadPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return removePlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return loadPluginsIfNecessary; });
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





 // plugins records all active web app plugins by id.

window.plugins = {}; // registerPlugin, on the global window object, should be invoked by a plugin's web app bundle as
// it is loaded.
//
// During the beta, plugins manipulated the global window.plugins data structure directly. This
// remains possible, but is officially deprecated and may be removed in a future release.

function registerPlugin(id, plugin) {
  window.plugins[id] = plugin;
}

window.registerPlugin = registerPlugin; // initializePlugins queries the server for all enabled plugins and loads each in turn.

async function initializePlugins() {
  if (redux_store["a" /* default */].getState().entities.general.config.PluginsEnabled !== 'true') {
    return;
  }

  const {
    data,
    error
  } = await getPlugins()(redux_store["a" /* default */].dispatch);

  if (error) {
    console.error(error); //eslint-disable-line no-console

    return;
  }

  if (data == null || data.length === 0) {
    return;
  }

  await Promise.all(data.map(m => {
    return loadPlugin(m);
  }));
} // getPlugins queries the server for all enabled plugins

function getPlugins() {
  return async dispatch => {
    let plugins;

    try {
      plugins = await client["Client4"].getWebappPlugins();
    } catch (error) {
      return {
        error
      };
    }

    dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_WEBAPP_PLUGINS,
      data: plugins
    });
    return {
      data: plugins
    };
  };
} // loadedPlugins tracks which plugins have been added as script tags to the page

const loadedPlugins = {}; // loadPlugin fetches the web app bundle described by the given manifest, waits for the bundle to
// load, and then ensures the plugin has been initialized.

function loadPlugin(manifest) {
  return new Promise(resolve => {
    // Don't load it again if previously loaded
    if (loadedPlugins[manifest.id]) {
      resolve();
      return;
    }

    function onLoad() {
      initializePlugin(manifest);
      console.log('Loaded ' + manifest.id + ' plugin'); //eslint-disable-line no-console

      resolve();
    } // Backwards compatibility for old plugins


    let bundlePath = manifest.webapp.bundle_path;

    if (bundlePath.includes('/static/') && !bundlePath.includes('/static/plugins/')) {
      bundlePath = bundlePath.replace('/static/', '/static/plugins/');
    }

    const script = document.createElement('script');
    script.id = 'plugin_' + manifest.id;
    script.type = 'text/javascript';
    script.src = Object(url["e" /* getSiteURL */])() + bundlePath;
    script.onload = onLoad;
    console.log('Loading ' + manifest.id + ' plugin'); //eslint-disable-line no-console

    document.getElementsByTagName('head')[0].appendChild(script);
    loadedPlugins[manifest.id] = true;
  });
} // initializePlugin creates a registry specific to the plugin and invokes any initialize function
// on the registered plugin class.

function initializePlugin(manifest) {
  // Initialize the plugin
  const plugin = window.plugins[manifest.id];
  const registry = new registry_PluginRegistry(manifest.id);

  if (plugin && plugin.initialize) {
    plugin.initialize(registry, redux_store["a" /* default */]);
  }
} // removePlugin triggers any uninitialize callback on the registered plugin, unregisters any
// event handlers, and removes the plugin script from the DOM entirely. The plugin is responsible
// for removing any of its registered components.


function removePlugin(manifest) {
  console.log('Removing ' + manifest.id + ' plugin'); //eslint-disable-line no-console

  loadedPlugins[manifest.id] = false;
  const plugin = window.plugins[manifest.id];

  if (plugin && plugin.uninitialize) {
    plugin.uninitialize(); // Support the deprecated deinitialize callback from the plugins beta.
  } else if (plugin && plugin.deinitialize) {
    plugin.deinitialize();
  }

  Object(websocket_actions["h" /* unregisterAllPluginWebSocketEvents */])(manifest.id);
  Object(websocket_actions["i" /* unregisterPluginReconnectHandler */])(manifest.id);
  const script = document.getElementById('plugin_' + manifest.id);

  if (!script) {
    return;
  }

  script.parentNode.removeChild(script);
  console.log('Removed ' + manifest.id + ' plugin'); //eslint-disable-line no-console
} // loadPluginsIfNecessary synchronizes the current state of loaded plugins with that of the server,
// loading any newly added plugins and unloading any removed ones.

async function loadPluginsIfNecessary() {
  if (redux_store["a" /* default */].getState().entities.general.config.PluginsEnabled !== 'true') {
    return;
  }

  const oldManifests = redux_store["a" /* default */].getState().plugins.plugins;
  const {
    error
  } = await getPlugins()(redux_store["a" /* default */].dispatch);

  if (error) {
    console.error(error); //eslint-disable-line no-console

    return;
  }

  const newManifests = redux_store["a" /* default */].getState().plugins.plugins; // Get new plugins and update existing plugins if version changed

  Object.values(newManifests).forEach(newManifest => {
    const oldManifest = oldManifests[newManifest.id];

    if (!oldManifest || oldManifest.version !== newManifest.version) {
      loadPlugin(newManifest);
    }
  }); // Remove old plugins

  Object.keys(oldManifests).forEach(id => {
    if (!newManifests.hasOwnProperty(id)) {
      const oldManifest = oldManifests[id];
      redux_store["a" /* default */].dispatch({
        type: constants["b" /* ActionTypes */].REMOVED_WEBAPP_PLUGIN,
        data: oldManifest
      });
      removePlugin(oldManifest);
    }
  });
}

/***/ }),

/***/ 2272:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tooltip.js
var Tooltip = __webpack_require__(1998);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// CONCATENATED MODULE: ./components/svg/reply_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class reply_icon_ReplyIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.reply",
      defaultMessage: "Reply Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      id: "Layer_1",
      x: "0px",
      y: "0px",
      width: "17px",
      height: "17px",
      viewBox: "-158 242 18 18",
      style: style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("path", {
      d: "M-142.2,252.6c-2-3-4.8-4.7-8.3-4.8v-3.3c0-0.2-0.1-0.3-0.2-0.3s-0.3,0-0.4,0.1l-6.9,6.2c-0.1,0.1-0.1,0.2-0.1,0.3 c0,0.1,0,0.2,0.1,0.3l6.9,6.4c0.1,0.1,0.3,0.1,0.4,0.1c0.1-0.1,0.2-0.2,0.2-0.4v-3.8c4.2,0,7.4,0.4,9.6,4.4c0.1,0.1,0.2,0.2,0.3,0.2 c0,0,0.1,0,0.1,0c0.2-0.1,0.3-0.3,0.2-0.4C-140.2,257.3-140.6,255-142.2,252.6z M-150.8,252.5c-0.2,0-0.4,0.2-0.4,0.4v3.3l-6-5.5 l6-5.3v2.8c0,0.2,0.2,0.4,0.4,0.4c3.3,0,6,1.5,8,4.5c0.5,0.8,0.9,1.6,1.2,2.3C-144,252.8-147.1,252.5-150.8,252.5z"
    }))));
  }

}
const style = {
  enableBackground: 'new -158 242 18 18'
};
// CONCATENATED MODULE: ./components/common/comment_icon.jsx
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return comment_icon_CommentIcon; });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class comment_icon_CommentIcon extends react_default.a.PureComponent {
  render() {
    let commentCountSpan = '';
    let iconStyle = 'comment-icon__container';

    if (this.props.commentCount > 0) {
      iconStyle += ' icon--show';
      commentCountSpan = react_default.a.createElement("span", {
        className: "comment-count"
      }, this.props.commentCount);
    } else if (this.props.searchStyle !== '') {
      iconStyle = iconStyle + ' ' + this.props.searchStyle;
    }

    const tooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "comment-icon-tooltip",
      className: "hidden-xs"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "post_info.comment_icon.tooltip.reply",
      defaultMessage: "Reply"
    }));
    return react_default.a.createElement(OverlayTrigger["a" /* default */], {
      className: "hidden-xs",
      delayShow: 500,
      placement: "top",
      overlay: tooltip
    }, react_default.a.createElement("button", {
      id: `${this.props.location}_commentIcon_${this.props.postId}`,
      className: iconStyle + ' color--link style--none ' + this.props.extraClass,
      onClick: this.props.handleCommentClick
    }, react_default.a.createElement(reply_icon_ReplyIcon, {
      className: "comment-icon"
    }), commentCountSpan));
  }

}

_defineProperty(comment_icon_CommentIcon, "propTypes", {
  location: prop_types_default.a.oneOf([constants["o" /* Locations */].CENTER, constants["o" /* Locations */].SEARCH]).isRequired,
  handleCommentClick: prop_types_default.a.func.isRequired,
  searchStyle: prop_types_default.a.string,
  commentCount: prop_types_default.a.number,
  postId: prop_types_default.a.string,
  extraClass: prop_types_default.a.string
});

_defineProperty(comment_icon_CommentIcon, "defaultProps", {
  searchStyle: '',
  commentCount: 0,
  extraClass: '',
  location: constants["o" /* Locations */].CENTER
});

/***/ }),

/***/ 2273:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./actions/views/modals.js
var views_modals = __webpack_require__(1578);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// CONCATENATED MODULE: ./components/modal_controller/modal_controller.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class modal_controller_ModalController extends react_default.a.PureComponent {
  render() {
    const {
      modals,
      ...props
    } = this.props;
    const {
      modalState
    } = modals;

    if (!modals) {
      return react_default.a.createElement("div", null);
    }

    const modalOutput = [];

    for (const modalId in modalState) {
      if (modalState.hasOwnProperty(modalId)) {
        const modal = modalState[modalId];

        if (modal.open) {
          const modalComponent = react_default.a.createElement(modal.dialogType, Object.assign({}, modal.dialogProps, {
            onHide: props.actions.closeModal.bind(this, modalId),
            key: `${modalId}_modal`
          }));
          modalOutput.push(modalComponent);
        }
      }
    }

    return react_default.a.createElement("div", null, modalOutput);
  }

}

_defineProperty(modal_controller_ModalController, "propTypes", {
  /**
   * Object that has map of modal's id and element
   */
  modals: prop_types_default.a.object.isRequired,

  /**
   * Object with action creators
   */
  actions: prop_types_default.a.shape({
    /**
     * Action creator to close modal
     */
    closeModal: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/modal_controller/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function mapStateToProps(state) {
  return {
    modals: state.views.modals
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      closeModal: views_modals["a" /* closeModal */]
    }, dispatch)
  };
}

/* harmony default export */ var modal_controller = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(modal_controller_ModalController));

/***/ }),

/***/ 2274:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./selectors/rhs.jsx
var rhs = __webpack_require__(60);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// CONCATENATED MODULE: ./components/post_view/show_more/show_more.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



const MAX_POST_HEIGHT = 600;
const MAX_ATTACHMENT_TEXT_HEIGHT = 200;
const MARGIN_CHANGE_FOR_COMPACT_POST = 22;
class show_more_ShowMore extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "toggleCollapse", e => {
      e.preventDefault();
      this.setState(prevState => {
        return {
          isCollapsed: !prevState.isCollapsed
        };
      });
    });

    _defineProperty(this, "checkTextOverflow", () => {
      if (this.overflowRef) {
        window.cancelAnimationFrame(this.overflowRef);
      }

      this.overflowRef = window.requestAnimationFrame(() => {
        const textContainer = this.refs.textContainer;
        let isOverflow = false;

        if (textContainer && textContainer.scrollHeight > this.maxHeight) {
          isOverflow = true;
        }

        if (isOverflow !== this.state.isOverflow) {
          this.setState({
            isOverflow
          });
        }
      });
    });

    _defineProperty(this, "handleResize", () => {
      this.checkTextOverflow();
    });

    this.maxHeight = this.props.isAttachmentText ? MAX_ATTACHMENT_TEXT_HEIGHT : MAX_POST_HEIGHT;
    this.state = {
      isCollapsed: true,
      isOverflow: false
    };
  }

  componentDidMount() {
    this.checkTextOverflow();
    window.addEventListener('resize', this.handleResize);
  }

  componentDidUpdate(prevProps) {
    if (this.props.text !== prevProps.text || this.props.isRHSExpanded !== prevProps.isRHSExpanded || this.props.isRHSOpen !== prevProps.isRHSOpen || this.props.checkOverflow !== prevProps.checkOverflow) {
      this.checkTextOverflow();
    }
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);

    if (this.overflowRef) {
      window.cancelAnimationFrame(this.overflowRef);
    }
  }

  render() {
    const {
      isCollapsed,
      isOverflow
    } = this.state;
    const {
      children,
      isAttachmentText,
      compactDisplay
    } = this.props;
    let className = 'post-message';
    let collapsedMaxHeightStyle;

    if (isCollapsed) {
      collapsedMaxHeightStyle = this.maxHeight;
      className += ' post-message--collapsed';
    } else {
      className += ' post-message--expanded';
    }

    let collapseGradientClass = 'post-collapse__gradient';
    let collapseShowMoreClass = 'post-collapse__show-more';

    if (isAttachmentText) {
      collapseGradientClass = 'post-attachment-collapse__gradient';
      collapseShowMoreClass = 'post-attachment-collapse__show-more';
    }

    let attachmentTextOverflow = null;

    if (isOverflow) {
      if (!isAttachmentText && isCollapsed && compactDisplay) {
        collapsedMaxHeightStyle -= MARGIN_CHANGE_FOR_COMPACT_POST;
      }

      let showIcon = 'fa fa-angle-up';
      let showText = Object(utils["gb" /* localizeMessage */])('post_info.message.show_less', 'Show Less');

      if (isCollapsed) {
        showIcon = 'fa fa-angle-down';
        showText = Object(utils["gb" /* localizeMessage */])('post_info.message.show_more', 'Show More');
      }

      attachmentTextOverflow = react_default.a.createElement("div", {
        className: "post-collapse"
      }, react_default.a.createElement("div", {
        id: "collapseGradient",
        className: collapseGradientClass
      }), react_default.a.createElement("div", {
        className: collapseShowMoreClass
      }, react_default.a.createElement("div", {
        className: "post-collapse__show-more-line"
      }), react_default.a.createElement("button", {
        id: "showMoreButton",
        className: "post-collapse__show-more-button",
        onClick: this.toggleCollapse
      }, react_default.a.createElement("span", {
        className: showIcon
      }), showText), react_default.a.createElement("div", {
        className: "post-collapse__show-more-line"
      })));
      className += ' post-message--overflow';
    }

    return react_default.a.createElement("div", {
      className: className
    }, react_default.a.createElement("div", {
      style: {
        maxHeight: collapsedMaxHeightStyle
      },
      className: "post-message__text-container",
      ref: "textContainer"
    }, children), attachmentTextOverflow);
  }

}

_defineProperty(show_more_ShowMore, "propTypes", {
  children: prop_types_default.a.node,
  checkOverflow: prop_types_default.a.number,
  isAttachmentText: prop_types_default.a.bool,
  isRHSExpanded: prop_types_default.a.bool.isRequired,
  isRHSOpen: prop_types_default.a.bool.isRequired,
  text: prop_types_default.a.string,
  compactDisplay: prop_types_default.a.bool.isRequired
});
// CONCATENATED MODULE: ./components/post_view/show_more/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function mapStateToProps(state) {
  return {
    isRHSExpanded: Object(rhs["a" /* getIsRhsExpanded */])(state),
    isRHSOpen: Object(rhs["c" /* getIsRhsOpen */])(state),
    compactDisplay: Object(preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].MESSAGE_DISPLAY, constants["w" /* Preferences */].MESSAGE_DISPLAY_DEFAULT) === constants["w" /* Preferences */].MESSAGE_DISPLAY_COMPACT
  };
}

/* harmony default export */ var show_more = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps)(show_more_ShowMore));

/***/ }),

/***/ 2279:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Root; });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(175);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var fastclick__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2296);
/* harmony import */ var fastclick__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fastclick__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(433);
/* harmony import */ var mattermost_redux_actions_general__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(253);
/* harmony import */ var mattermost_redux_actions_general__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_general__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var mattermost_redux_actions_emojis__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(208);
/* harmony import */ var mattermost_redux_actions_emojis__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_actions_emojis__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/* harmony import */ var mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(15);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var mattermost_redux_selectors_entities_posts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(61);
/* harmony import */ var mattermost_redux_selectors_entities_posts__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_posts__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var utils_user_agent_jsx__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(39);
/* harmony import */ var utils_emoji_jsx__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(100);
/* harmony import */ var actions_diagnostics_actions_jsx__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(300);
/* harmony import */ var actions_global_actions_jsx__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(1567);
/* harmony import */ var stores_browser_store_jsx__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1767);
/* harmony import */ var actions_emoji_actions_jsx__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(374);
/* harmony import */ var i18n_i18n_jsx__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(416);
/* harmony import */ var plugins__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(2271);
/* harmony import */ var plugins_export_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(3473);
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(0);
/* harmony import */ var selectors_rhs_jsx__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(60);
/* harmony import */ var components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(2387);
/* harmony import */ var components_meeting_invitation__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(3472);
/* harmony import */ var components_intl_provider__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(3471);
/* harmony import */ var components_needs_team__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(3424);
/* harmony import */ var components_async_load__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(412);
/* harmony import */ var bundle_loader_lazy_components_error_page__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(3211);
/* harmony import */ var bundle_loader_lazy_components_error_page__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_error_page__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var bundle_loader_lazy_components_login_login_controller__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(3212);
/* harmony import */ var bundle_loader_lazy_components_login_login_controller__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_login_login_controller__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var bundle_loader_lazy_components_admin_console__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(3213);
/* harmony import */ var bundle_loader_lazy_components_admin_console__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_admin_console__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var bundle_loader_lazy_components_logged_in__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(2008);
/* harmony import */ var bundle_loader_lazy_components_logged_in__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_logged_in__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var bundle_loader_lazy_components_password_reset_send_link__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(3214);
/* harmony import */ var bundle_loader_lazy_components_password_reset_send_link__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_password_reset_send_link__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var bundle_loader_lazy_components_password_reset_form__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(3215);
/* harmony import */ var bundle_loader_lazy_components_password_reset_form__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_password_reset_form__WEBPACK_IMPORTED_MODULE_31__);
/* harmony import */ var bundle_loader_lazy_components_signup_signup_controller__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(3216);
/* harmony import */ var bundle_loader_lazy_components_signup_signup_controller__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_signup_signup_controller__WEBPACK_IMPORTED_MODULE_32__);
/* harmony import */ var bundle_loader_lazy_components_signup_signup_email__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(3217);
/* harmony import */ var bundle_loader_lazy_components_signup_signup_email__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_signup_signup_email__WEBPACK_IMPORTED_MODULE_33__);
/* harmony import */ var bundle_loader_lazy_components_terms_of_service__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(3218);
/* harmony import */ var bundle_loader_lazy_components_terms_of_service__WEBPACK_IMPORTED_MODULE_34___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_terms_of_service__WEBPACK_IMPORTED_MODULE_34__);
/* harmony import */ var bundle_loader_lazy_components_should_verify_email__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(3219);
/* harmony import */ var bundle_loader_lazy_components_should_verify_email__WEBPACK_IMPORTED_MODULE_35___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_should_verify_email__WEBPACK_IMPORTED_MODULE_35__);
/* harmony import */ var bundle_loader_lazy_components_do_verify_email__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(3220);
/* harmony import */ var bundle_loader_lazy_components_do_verify_email__WEBPACK_IMPORTED_MODULE_36___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_do_verify_email__WEBPACK_IMPORTED_MODULE_36__);
/* harmony import */ var bundle_loader_lazy_components_claim__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(3221);
/* harmony import */ var bundle_loader_lazy_components_claim__WEBPACK_IMPORTED_MODULE_37___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_claim__WEBPACK_IMPORTED_MODULE_37__);
/* harmony import */ var bundle_loader_lazy_components_help_help_controller__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(3222);
/* harmony import */ var bundle_loader_lazy_components_help_help_controller__WEBPACK_IMPORTED_MODULE_38___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_help_help_controller__WEBPACK_IMPORTED_MODULE_38__);
/* harmony import */ var bundle_loader_lazy_components_get_ios_app__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(3223);
/* harmony import */ var bundle_loader_lazy_components_get_ios_app__WEBPACK_IMPORTED_MODULE_39___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_get_ios_app__WEBPACK_IMPORTED_MODULE_39__);
/* harmony import */ var bundle_loader_lazy_components_get_android_app__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(3224);
/* harmony import */ var bundle_loader_lazy_components_get_android_app__WEBPACK_IMPORTED_MODULE_40___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_get_android_app__WEBPACK_IMPORTED_MODULE_40__);
/* harmony import */ var bundle_loader_lazy_components_select_team__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(3225);
/* harmony import */ var bundle_loader_lazy_components_select_team__WEBPACK_IMPORTED_MODULE_41___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_select_team__WEBPACK_IMPORTED_MODULE_41__);
/* harmony import */ var bundle_loader_lazy_components_authorize__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(3226);
/* harmony import */ var bundle_loader_lazy_components_authorize__WEBPACK_IMPORTED_MODULE_42___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_authorize__WEBPACK_IMPORTED_MODULE_42__);
/* harmony import */ var bundle_loader_lazy_components_create_team__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(3227);
/* harmony import */ var bundle_loader_lazy_components_create_team__WEBPACK_IMPORTED_MODULE_43___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_create_team__WEBPACK_IMPORTED_MODULE_43__);
/* harmony import */ var bundle_loader_lazy_components_mfa_mfa_controller__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(3228);
/* harmony import */ var bundle_loader_lazy_components_mfa_mfa_controller__WEBPACK_IMPORTED_MODULE_44___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_mfa_mfa_controller__WEBPACK_IMPORTED_MODULE_44__);
/* harmony import */ var stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(14);
/* harmony import */ var utils_url_jsx__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(298);
/* harmony import */ var utils_auth_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(428);
/* harmony import */ var api_login_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(974);
/* harmony import */ var _video_video_index_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(3229);
/* harmony import */ var _download_jsx__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(3256);
/* harmony import */ var antd_dist_antd_css__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(3259);
/* harmony import */ var antd_dist_antd_css__WEBPACK_IMPORTED_MODULE_51___default = /*#__PURE__*/__webpack_require__.n(antd_dist_antd_css__WEBPACK_IMPORTED_MODULE_51__);
/* harmony import */ var utils_utils__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(22);
/* harmony import */ var utils_browser_history__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(114);
/* harmony import */ var actions_team_actions__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(1639);
/* harmony import */ var api_zoom_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(1698);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


__webpack_require__(2280)(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);
























































const CreateTeam = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_create_team__WEBPACK_IMPORTED_MODULE_43___default.a);
const ErrorPage = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_error_page__WEBPACK_IMPORTED_MODULE_26___default.a);
const TermsOfService = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_terms_of_service__WEBPACK_IMPORTED_MODULE_34___default.a);
const LoginController = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_login_login_controller__WEBPACK_IMPORTED_MODULE_27___default.a);
const AdminConsole = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_admin_console__WEBPACK_IMPORTED_MODULE_28___default.a);
const LoggedIn = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_logged_in__WEBPACK_IMPORTED_MODULE_29___default.a);
const PasswordResetSendLink = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_password_reset_send_link__WEBPACK_IMPORTED_MODULE_30___default.a);
const PasswordResetForm = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_password_reset_form__WEBPACK_IMPORTED_MODULE_31___default.a);
const SignupController = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_signup_signup_controller__WEBPACK_IMPORTED_MODULE_32___default.a);
const SignupEmail = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_signup_signup_email__WEBPACK_IMPORTED_MODULE_33___default.a);
const ShouldVerifyEmail = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_should_verify_email__WEBPACK_IMPORTED_MODULE_35___default.a);
const DoVerifyEmail = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_do_verify_email__WEBPACK_IMPORTED_MODULE_36___default.a);
const ClaimController = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_claim__WEBPACK_IMPORTED_MODULE_37___default.a);
const HelpController = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_help_help_controller__WEBPACK_IMPORTED_MODULE_38___default.a);
const GetIosApp = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_get_ios_app__WEBPACK_IMPORTED_MODULE_39___default.a);
const GetAndroidApp = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_get_android_app__WEBPACK_IMPORTED_MODULE_40___default.a);
const SelectTeam = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_select_team__WEBPACK_IMPORTED_MODULE_41___default.a);
const Authorize = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_authorize__WEBPACK_IMPORTED_MODULE_42___default.a);
const Mfa = Object(components_async_load__WEBPACK_IMPORTED_MODULE_25__[/* makeAsyncComponent */ "b"])(bundle_loader_lazy_components_mfa_mfa_controller__WEBPACK_IMPORTED_MODULE_44___default.a);

const LoggedInRoute = ({
  component: Component,
  ...rest
}) => react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__[/* Route */ "b"], _extends({}, rest, {
  render: props => react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(LoggedIn, props, react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(Component, props))
}));

class Root extends react__WEBPACK_IMPORTED_MODULE_2___default.a.Component {
  constructor(_props) {
    super(_props);

    _defineProperty(this, "getSidebarCategories", () => {
      const sidebarCategories = [document.getElementById("unreadsChannelList"), document.getElementById("favoriteChannelList"), document.getElementById("publicChannelList"), document.getElementById("privateChannelList"), document.getElementById("directChannelList")].filter(element => Boolean(element));
      return sidebarCategories;
    });

    _defineProperty(this, "handleKeyDownSidebar", e => {
      const lhsList = document.getElementById("lhsList");

      if (!lhsList.contains(e.target)) {
        return;
      }

      const sidebarCategories = this.getSidebarCategories();

      const containsElement = (element, i, elementsList) => {
        if (element.contains(e.target)) {
          this.currentSidebarFocus = i + 1;
          return true;
        } else if (element.contains(e.target) && i === elementsList.length - 1) {
          this.currentSidebarFocus++;
          return false;
        }

        return false;
      };

      if (!sidebarCategories.some(containsElement)) {
        this.currentSidebarFocus = 0;
      }

      if (this.currentSidebarFocus === sidebarCategories.length) {
        this.currentSidebarFocus = 0;
      }

      const activeElement = sidebarCategories[this.currentSidebarFocus];
      this.addFocusClass(activeElement);
      this.currentSidebarFocus++;
    });

    _defineProperty(this, "handleKeyUpSidebar", e => {
      const lhsList = document.getElementById("lhsList");

      if (!lhsList.contains(e.target)) {
        return;
      }

      const sidebarCategories = this.getSidebarCategories();

      const containsElement = (element, i) => {
        if (element.contains(e.target)) {
          this.currentSidebarFocus = i - 1;
          return true;
        } else if (element.contains(e.target) && i === 0) {
          this.currentSidebarFocus = 0;
          return false;
        }

        return false;
      };

      if (!sidebarCategories.some(containsElement)) {
        this.currentSidebarFocus = 0;
      }

      if (this.currentSidebarFocus === -1) {
        this.currentSidebarFocus = sidebarCategories.length - 1;
      }

      const activeElement = sidebarCategories[this.currentSidebarFocus];
      this.addFocusClass(activeElement);
      this.currentSidebarFocus--;
    });

    _defineProperty(this, "handleTabKey", e => {
      const activeElement = e.target;
      activeElement.classList.add("keyboard-focus");
      this.addFocusClass(activeElement);
    });

    _defineProperty(this, "handleF6Key", e => {
      const state = stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_45__[/* default */ "a"].getState();
      const currentChannel = Object(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_8__["getCurrentChannel"])(state) || {};
      const recentPostIdInChannel = Object(mattermost_redux_selectors_entities_posts__WEBPACK_IMPORTED_MODULE_9__["getMostRecentPostIdInChannel"])(state, currentChannel.id);
      const getPostsForThread = Object(mattermost_redux_selectors_entities_posts__WEBPACK_IMPORTED_MODULE_9__["makeGetPostsForThread"])();
      const selected = Object(selectors_rhs_jsx__WEBPACK_IMPORTED_MODULE_20__[/* getSelectedPost */ "q"])(state);
      const rhsPosts = getPostsForThread(state, {
        rootId: selected.id
      });
      let rhsLastPostId;

      if (rhsPosts[0]) {
        rhsLastPostId = rhsPosts[0].id;
      }

      const elements = [document.getElementById("post_" + recentPostIdInChannel), document.getElementById("centerChannelFooter"), document.getElementById("rhsPost_" + rhsLastPostId), document.getElementById("rhsFooter"), document.getElementById("lhsHeader"), document.getElementById("lhsList"), document.getElementById("channel-header"), document.getElementById("searchBox")].filter(element => Boolean(element));

      if (this.currentCategoryFocus === elements.length) {
        this.currentCategoryFocus = 0;
      }

      const lastElement = elements[this.currentCategoryFocus - 1];

      if (e.target !== lastElement && this.currentCategoryFocus !== 0) {
        this.currentCategoryFocus = 0;
      }

      const activeElement = elements[this.currentCategoryFocus];
      this.addFocusClass(activeElement);
      this.currentCategoryFocus++;
    });

    _defineProperty(this, "handleAccessibilityKeys", e => {
      if (Object(utils_utils__WEBPACK_IMPORTED_MODULE_52__[/* isKeyPressed */ "V"])(e, utils_constants_jsx__WEBPACK_IMPORTED_MODULE_19__[/* default */ "N"].KeyCodes.DOWN)) {
        this.handleKeyDownSidebar(e);
      } else if (Object(utils_utils__WEBPACK_IMPORTED_MODULE_52__[/* isKeyPressed */ "V"])(e, utils_constants_jsx__WEBPACK_IMPORTED_MODULE_19__[/* default */ "N"].KeyCodes.UP)) {
        this.handleKeyUpSidebar(e);
      } else if (Object(utils_utils__WEBPACK_IMPORTED_MODULE_52__[/* isKeyPressed */ "V"])(e, utils_constants_jsx__WEBPACK_IMPORTED_MODULE_19__[/* default */ "N"].KeyCodes.TAB)) {
        this.handleTabKey(e);
      } else if (Object(utils_utils__WEBPACK_IMPORTED_MODULE_52__[/* isKeyPressed */ "V"])(e, utils_constants_jsx__WEBPACK_IMPORTED_MODULE_19__[/* default */ "N"].KeyCodes.F6)) {
        this.handleF6Key(e);
      }
    });

    _defineProperty(this, "addFocusClass", element => {
      element.classList.add("keyboard-focus");
      element.focus();

      function removeClass() {
        element.classList.remove("keyboard-focus");
      }

      element.addEventListener("blur", removeClass, {
        once: true
      });
    });

    _defineProperty(this, "onConfigLoaded", () => {
      if (Object(utils_utils__WEBPACK_IMPORTED_MODULE_52__[/* isDevMode */ "O"])()) {
        Object(utils_utils__WEBPACK_IMPORTED_MODULE_52__[/* enableDevModeFeatures */ "o"])();
      }

      const segmentKey = utils_constants_jsx__WEBPACK_IMPORTED_MODULE_19__[/* default */ "N"].DIAGNOSTICS_SEGMENT_KEY;
      const diagnosticId = this.props.diagnosticId;
      /*eslint-disable */

      if (segmentKey != null && segmentKey !== "" && !segmentKey.startsWith("placeholder") && this.props.diagnosticsEnabled) {
        !function () {
          var analytics = global.window.analytics = global.window.analytics || [];
          if (!analytics.initialize) if (analytics.invoked) window.console && console.error && console.error("Segment snippet included twice.");else {
            analytics.invoked = !0;
            analytics.methods = ["trackSubmit", "trackClick", "trackLink", "trackForm", "pageview", "identify", "group", "track", "ready", "alias", "page", "once", "off", "on"];

            analytics.factory = function (t) {
              return function (...args) {
                var e = Array.prototype.slice.call(args);
                e.unshift(t);
                analytics.push(e);
                return analytics;
              };
            };

            for (var t = 0; t < analytics.methods.length; t++) {
              var e = analytics.methods[t];
              analytics[e] = analytics.factory(e);
            }

            analytics.load = function (t) {
              var e = document.createElement("script");
              e.type = "text/javascript";
              e.async = !0;
              e.src = ("https:" === document.location.protocol ? "https://" : "http://") + "cdn.segment.com/analytics.js/v1/" + t + "/analytics.min.js";
              var n = document.getElementsByTagName("script")[0];
              n.parentNode.insertBefore(e, n);
            };

            analytics.SNIPPET_VERSION = "3.0.1";
            analytics.load(segmentKey);
            analytics.identify(diagnosticId, {}, {
              context: {
                ip: "0.0.0.0"
              },
              page: {
                path: "",
                referrer: "",
                search: "",
                title: "",
                url: ""
              },
              anonymousId: "00000000000000000000000000"
            });
            analytics.page("ApplicationLoaded", {
              path: "",
              referrer: "",
              search: "",
              title: "",
              url: ""
            }, {
              context: {
                ip: "0.0.0.0"
              },
              anonymousId: "00000000000000000000000000"
            });
          }
        }();
      }
      /*eslint-enable */


      const afterIntl = () => {
        if (this.props.location.pathname === "/" && this.props.noAccounts) {
          this.props.history.push("/signup_user_complete");
        }

        Object(plugins__WEBPACK_IMPORTED_MODULE_17__[/* initializePlugins */ "a"])().then(() => {
          this.setState({
            configLoaded: true
          });
        });
      };

      if (global.Intl) {
        afterIntl();
      } else {
        i18n_i18n_jsx__WEBPACK_IMPORTED_MODULE_16__[/* safariFix */ "f"](afterIntl);
      }

      Object(actions_emoji_actions_jsx__WEBPACK_IMPORTED_MODULE_15__[/* loadRecentlyUsedCustomEmojis */ "c"])()(stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_45__[/* default */ "a"].dispatch, stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_45__[/* default */ "a"].getState);
      const iosDownloadLink = Object(mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_7__["getConfig"])(stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_45__[/* default */ "a"].getState()).IosAppDownloadLink;
      const androidDownloadLink = Object(mattermost_redux_selectors_entities_general__WEBPACK_IMPORTED_MODULE_7__["getConfig"])(stores_redux_store_jsx__WEBPACK_IMPORTED_MODULE_45__[/* default */ "a"].getState()).AndroidAppDownloadLink;
      const toResetPasswordScreen = this.props.location.pathname === "/reset_password_complete"; // redirect to the mobile landing page if the user hasn't seen it before

      if (iosDownloadLink && utils_user_agent_jsx__WEBPACK_IMPORTED_MODULE_10__[/* isIosWeb */ "k"]() && !stores_browser_store_jsx__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"].hasSeenLandingPage() && !toResetPasswordScreen) {
        this.props.history.push("/get_ios_app?redirect_to=" + encodeURIComponent(this.props.location.pathname) + encodeURIComponent(this.props.location.search));
        stores_browser_store_jsx__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"].setLandingPageSeen(true);
      } else if (androidDownloadLink && utils_user_agent_jsx__WEBPACK_IMPORTED_MODULE_10__[/* isAndroidWeb */ "b"]() && !stores_browser_store_jsx__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"].hasSeenLandingPage() && !toResetPasswordScreen) {
        this.props.history.push("/get_android_app?redirect_to=" + encodeURIComponent(this.props.location.pathname) + encodeURIComponent(this.props.location.search));
        stores_browser_store_jsx__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"].setLandingPageSeen(true);
      }
    });

    _defineProperty(this, "redirectIfNecessary", props => {
      if (props.location.pathname === "/") {
        if (this.props.noAccounts) {
          this.props.history.push("/signup_user_complete");
        } else if (props.showTermsOfService) {
          this.props.history.push("/terms_of_service");
        }
      }
    });

    this.currentCategoryFocus = 0;
    this.currentSidebarFocus = 0; // Redux

    Object(mattermost_redux_actions_general__WEBPACK_IMPORTED_MODULE_5__["setUrl"])(Object(utils_url_jsx__WEBPACK_IMPORTED_MODULE_46__[/* getSiteURL */ "e"])());
    Object(mattermost_redux_actions_emojis__WEBPACK_IMPORTED_MODULE_6__["setSystemEmojis"])(utils_emoji_jsx__WEBPACK_IMPORTED_MODULE_11__[/* EmojiIndicesByAlias */ "a"]); // Force logout of all tabs if one tab is logged out

    jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).bind("storage", e => {
      // when one tab on a browser logs out, it sets __logout__ in localStorage to trigger other tabs to log out
      if (e.originalEvent.key === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_19__[/* StoragePrefixes */ "F"].LOGOUT && e.originalEvent.storageArea === localStorage && e.originalEvent.newValue) {
        // make sure it isn't this tab that is sending the logout signal (only necessary for IE11)
        if (stores_browser_store_jsx__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"].isSignallingLogout(e.originalEvent.newValue)) {
          return;
        }

        console.log("detected logout from a different tab"); //eslint-disable-line no-console

        actions_global_actions_jsx__WEBPACK_IMPORTED_MODULE_13__[/* emitUserLoggedOutEvent */ "e"]("/", false, false);
      }

      if (e.originalEvent.key === utils_constants_jsx__WEBPACK_IMPORTED_MODULE_19__[/* StoragePrefixes */ "F"].LOGIN && e.originalEvent.storageArea === localStorage && e.originalEvent.newValue) {
        // make sure it isn't this tab that is sending the logout signal (only necessary for IE11)
        if (stores_browser_store_jsx__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"].isSignallingLogin(e.originalEvent.newValue)) {
          return;
        }

        console.log("detected login from a different tab"); //eslint-disable-line no-console

        location.reload();
      }
    }); // Prevent drag and drop files from navigating away from the app

    document.addEventListener("drop", e => {
      e.preventDefault();
      e.stopPropagation();
    });
    document.addEventListener("dragover", e => {
      e.preventDefault();
      e.stopPropagation();
    }); // Fastclick

    fastclick__WEBPACK_IMPORTED_MODULE_3___default.a.attach(document.body);
    this.state = {
      configLoaded: false
    };
  }

  UNSAFE_componentWillReceiveProps(newProps) {
    // eslint-disable-line camelcase
    this.redirectIfNecessary(newProps);
  }

  isLocation() {
    return window.location.hostname + "" === "localhost";
  }

  componentDidMount() {
    var zoomRoot = document.getElementById("zmmtg-root");
    if (zoomRoot) zoomRoot.style.visibility = this.props.location.pathname === "/video" ? "inherit" : "hidden"; //判断接入途径是端还是web

    if (!this.isLocation()) {// checkClient().then(res=>{
      //   if(res.data.status==="false"){ //不是端 显示 download页面
      //     browserHistory.push("/download")
      //   }
      // })
      // .finally(() => {});
    }

    this.props.actions.loadMeAndConfig().then(response => {
      if (this.props.location.pathname === "/" && response[2] && response[2].data) {
        actions_global_actions_jsx__WEBPACK_IMPORTED_MODULE_13__[/* redirectUserToDefaultTeam */ "f"]();
      } else {
        const ticket = Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_47__[/* getUrlTicket */ "b"])("ticket", this.props.location.search); //const ticket = getUrlTicket("userName", this.props.location.search);

        if (this.props.location.pathname === "/login" || this.props.location.pathname === "/") {
          if (!ticket) {
            if (response.length <= 2 || !response[2].data) {
              window.location.href = `https://nsso.zhonganinfo.com/login?service=za-white-screen&target=${document.location.protocol}//${window.location.host}/login`;
            }
          } else {
            Object(api_login_js__WEBPACK_IMPORTED_MODULE_48__[/* ossLogin */ "a"])(ticket) //noossLogin(ticket)
            .then(res => {
              window.localStorage.setItem('is_new', res.data.is_new);
              window.location.href = `${document.location.protocol}//${window.location.host}`;
            }).finally(() => {});
          }
        } else if (this.props.location.pathname === "/download") {
          console.log("download......");
        }
      }

      this.onConfigLoaded();
    });
    Object(actions_diagnostics_actions_jsx__WEBPACK_IMPORTED_MODULE_12__[/* trackLoadTime */ "e"])();
    document.addEventListener("keyup", this.handleAccessibilityKeys);
  }

  componentWillUnmount() {
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).unbind("storage");
    document.removeEventListener("keyup", this.handleAccessibilityKeys);
  }

  render() {
    if (!this.state.configLoaded) {
      return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("div", null);
    }

    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_intl_provider__WEBPACK_IMPORTED_MODULE_23__[/* default */ "a"], null, react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_2__["Fragment"], null, react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_meeting_invitation__WEBPACK_IMPORTED_MODULE_22__[/* default */ "a"], null), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__[/* Switch */ "d"], null, react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__[/* Route */ "b"], {
      path: "/error",
      component: ErrorPage
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__[/* Route */ "b"], {
      path: "/video",
      component: _video_video_index_js__WEBPACK_IMPORTED_MODULE_49__[/* default */ "a"]
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__[/* Route */ "b"], {
      path: "/download",
      component: _download_jsx__WEBPACK_IMPORTED_MODULE_50__[/* default */ "a"]
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* HFTRoute */ "a"], {
      path: "/login",
      component: LoginController
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* HFTRoute */ "a"], {
      path: "/reset_password",
      component: PasswordResetSendLink
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* HFTRoute */ "a"], {
      path: "/reset_password_complete",
      component: PasswordResetForm
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* HFTRoute */ "a"], {
      path: "/signup_user_complete",
      component: SignupController
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* HFTRoute */ "a"], {
      path: "/signup_email",
      component: SignupEmail
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* HFTRoute */ "a"], {
      path: "/should_verify_email",
      component: ShouldVerifyEmail
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* HFTRoute */ "a"], {
      path: "/do_verify_email",
      component: DoVerifyEmail
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* HFTRoute */ "a"], {
      path: "/claim",
      component: ClaimController
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* HFTRoute */ "a"], {
      path: "/help",
      component: HelpController
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(LoggedInRoute, {
      path: "/terms_of_service",
      component: TermsOfService
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__[/* Route */ "b"], {
      path: "/get_ios_app",
      component: GetIosApp
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__[/* Route */ "b"], {
      path: "/get_android_app",
      component: GetAndroidApp
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(LoggedInRoute, {
      path: "/admin_console",
      component: AdminConsole
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* LoggedInHFTRoute */ "b"], {
      path: "/select_team",
      component: SelectTeam
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* LoggedInHFTRoute */ "b"], {
      path: "/oauth/authorize",
      component: Authorize
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(components_header_footer_template_route__WEBPACK_IMPORTED_MODULE_21__[/* LoggedInHFTRoute */ "b"], {
      path: "/create_team",
      component: CreateTeam
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(LoggedInRoute, {
      path: "/mfa",
      component: Mfa
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(LoggedInRoute, {
      path: "/:team",
      component: components_needs_team__WEBPACK_IMPORTED_MODULE_24__[/* default */ "a"]
    }), react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__[/* Redirect */ "a"], {
      to: { ...this.props.location,
        pathname: "/login"
      }
    }))));
  }

}

_defineProperty(Root, "propTypes", {
  state: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,
  currentUser: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,
  diagnosticsEnabled: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  diagnosticId: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  noAccounts: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  showTermsOfService: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  actions: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({
    loadMeAndConfig: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired
  }).isRequired
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(37)))

/***/ }),

/***/ 2297:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return incrementWsErrorCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return resetWsErrorCount; });
/* harmony import */ var utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

function incrementWsErrorCount() {
  return async dispatch => {
    dispatch({
      type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__[/* ActionTypes */ "b"].INCREMENT_WS_ERROR_COUNT
    });
  };
}
function resetWsErrorCount() {
  return async dispatch => {
    dispatch({
      type: utils_constants_jsx__WEBPACK_IMPORTED_MODULE_0__[/* ActionTypes */ "b"].RESET_WS_ERROR_COUNT
    });
  };
}

/***/ }),

/***/ 2324:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*:: import type {DialogElement} from 'types/integrations';*/

/*:: type DialogError = {|
    id: string,
    defaultMessage: string,
    values?: Object,
|};*/


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkDialogElementForError = checkDialogElementForError;
exports.checkIfErrorsMatchElements = checkIfErrorsMatchElements;

__webpack_require__(62);

__webpack_require__(19);

__webpack_require__(20);

__webpack_require__(12);

__webpack_require__(73);

__webpack_require__(74); // Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow


function checkDialogElementForError(elem
/*: DialogElement*/
, value
/*: Object*/
)
/*: ?DialogError*/
{
  if (!value && !elem.optional) {
    return {
      id: 'interactive_dialog.error.required',
      defaultMessage: 'This field is required.'
    };
  }

  var type = elem.type;

  if (type === 'text' || type === 'textarea') {
    if (value && value.length < elem.min_length) {
      return {
        id: 'interactive_dialog.error.too_short',
        defaultMessage: 'Minimum input length is {minLength}.',
        values: {
          minLength: elem.min_length
        }
      };
    }

    if (elem.subtype === 'email') {
      if (value && !value.includes('@')) {
        return {
          id: 'interactive_dialog.error.bad_email',
          defaultMessage: 'Must be a valid email address.'
        };
      }
    }

    if (elem.subtype === 'number') {
      if (value && isNaN(value)) {
        return {
          id: 'interactive_dialog.error.bad_number',
          defaultMessage: 'Must be a number.'
        };
      }
    }

    if (elem.subtype === 'url') {
      if (value && !value.includes('http://') && !value.includes('https://')) {
        return {
          id: 'interactive_dialog.error.bad_url',
          defaultMessage: 'URL must include http:// or https://.'
        };
      }
    }
  }

  return null;
} // If we're returned errors that don't match any of the elements we have,
// ignore them and complete the dialog


function checkIfErrorsMatchElements() {
  var errors
  /*: {[string]: DialogError}*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var elements
  /*: Array<DialogElement>*/
  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  for (var name in errors) {
    if (!errors.hasOwnProperty(name)) {
      continue;
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var elem = _step.value;

        if (elem.name === name) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return false;
}

/***/ }),

/***/ 2325:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2367:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	Promise.all(/* require.ensure */[__webpack_require__.e(1), __webpack_require__.e(34), __webpack_require__.e(2), __webpack_require__.e(28)]).then((function(require) {
		cb(__webpack_require__(3427));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 2373:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LinkTooltip; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2002);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var plugins_pluggable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1647);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const tooltipContainerStyles = {
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  zIndex: '10'
};
class LinkTooltip extends react__WEBPACK_IMPORTED_MODULE_1___default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "showTooltip", e => {
      //clear the hideTimeout in the case when the cursor is moved from a tooltipContainer child to the link
      clearTimeout(this.hideTimeout);

      if (!this.show) {
        const target = $(e.target);
        const tooltipContainer = $(this.tooltipContainerRef.current); //clear the old this.showTimeout if there is any before overriding

        clearTimeout(this.showTimeout);
        this.showTimeout = setTimeout(() => {
          this.show = true;
          tooltipContainer.show();
          tooltipContainer.children().on('mouseover', () => clearTimeout(this.hideTimeout));
          tooltipContainer.children().on('mouseleave', event => {
            if (event.toElement !== null) {
              this.hideTooltip();
            }
          });
          this.popper = new popper_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](target, tooltipContainer, {
            placement: 'bottom',
            modifiers: {
              preventOverflow: {
                enabled: false
              },
              hide: {
                enabled: false
              }
            }
          });
        }, utils_constants__WEBPACK_IMPORTED_MODULE_4__[/* Constants */ "g"].OVERLAY_TIME_DELAY);
      }
    });

    _defineProperty(this, "hideTooltip", () => {
      //clear the old this.hideTimeout if there is any before overriding
      clearTimeout(this.hideTimeout);
      this.hideTimeout = setTimeout(() => {
        this.show = false; //prevent executing the showTimeout after the hideTooltip

        clearTimeout(this.showTimeout);
        $(this.tooltipContainerRef.current).hide();
      }, utils_constants__WEBPACK_IMPORTED_MODULE_4__[/* Constants */ "g"].OVERLAY_TIME_DELAY_SMALL);
    });

    this.tooltipContainerRef = react__WEBPACK_IMPORTED_MODULE_1___default.a.createRef();
    this.show = false;
  }

  render() {
    const {
      href,
      title
    } = this.props;
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment, null, react_dom__WEBPACK_IMPORTED_MODULE_3___default.a.createPortal(react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      style: tooltipContainerStyles,
      ref: this.tooltipContainerRef
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(plugins_pluggable__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], {
      href: href,
      pluggableName: "LinkTooltip"
    })), document.getElementById('root')), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("span", {
      onMouseOver: this.showTooltip,
      onMouseLeave: this.hideTooltip
    }, title));
  }

}

_defineProperty(LinkTooltip, "propTypes", {
  href: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,
  title: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175)))

/***/ }),

/***/ 2387:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HFTRoute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LoggedInHFTRoute; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(433);
/* harmony import */ var bundle_loader_lazy_components_header_footer_template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2388);
/* harmony import */ var bundle_loader_lazy_components_header_footer_template__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_header_footer_template__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var bundle_loader_lazy_components_logged_in__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2008);
/* harmony import */ var bundle_loader_lazy_components_logged_in__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(bundle_loader_lazy_components_logged_in__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var components_async_load__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(412);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const HFTRoute = ({
  component: Component,
  ...rest
}) => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_1__[/* Route */ "b"], _extends({}, rest, {
  render: props => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_async_load__WEBPACK_IMPORTED_MODULE_4__[/* AsyncComponent */ "a"], _extends({
    doLoad: bundle_loader_lazy_components_header_footer_template__WEBPACK_IMPORTED_MODULE_2___default.a
  }, props), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, props))
}));
const LoggedInHFTRoute = ({
  component: Component,
  ...rest
}) => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_1__[/* Route */ "b"], _extends({}, rest, {
  render: props => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_async_load__WEBPACK_IMPORTED_MODULE_4__[/* AsyncComponent */ "a"], _extends({
    doLoad: bundle_loader_lazy_components_logged_in__WEBPACK_IMPORTED_MODULE_3___default.a
  }, props), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_async_load__WEBPACK_IMPORTED_MODULE_4__[/* AsyncComponent */ "a"], _extends({
    doLoad: bundle_loader_lazy_components_header_footer_template__WEBPACK_IMPORTED_MODULE_2___default.a
  }, props), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, props)))
}));

/***/ }),

/***/ 2388:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 29).then((function(require) {
		cb(__webpack_require__(3474));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 2389:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2390:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/69448375252ab2999bdfc39997b271c7.png";

/***/ }),

/***/ 2391:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/8e21fc9d6ee5f93a420728866a8a8e8b.png";

/***/ }),

/***/ 2393:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 8).then((function(require) {
		cb(__webpack_require__(3426));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 2394:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDisplayableErrors = getDisplayableErrors; // Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

function getDisplayableErrors(state) {
  return state.errors.filter(function (error) {
    return error.displayable;
  });
}

/***/ }),

/***/ 2397:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _gfycatSdk = _interopRequireDefault(__webpack_require__(2398));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
} // Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow


var defaultKey = '2_KtH_W5';
var defaultSecret = '3wLVZPiswc3DnaiaFoLkDvB4X0IV6CpMkj4tf2inJRsBY6-FnkT08zGmppWFgeof';
var activeKey = null;
var activeSecret = null;
var instance = null;

function _default(key
/*: string*/
, secret
/*: string*/
)
/*: Gfycat*/
{
  if (instance && activeKey === key && activeSecret === secret) {
    return instance;
  }

  if (!key || !secret) {
    instance = new _gfycatSdk.default({
      client_id: defaultKey,
      client_secret: defaultSecret
    });
    return instance;
  }

  activeKey = key;
  activeSecret = secret;
  instance = new _gfycatSdk.default({
    client_id: key,
    client_secret: secret
  });
  return instance;
}

/***/ }),

/***/ 2399:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2400:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2401:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2402:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2403:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2407:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFilesForPost = getFilesForPost;
exports.getMissingFilesForPost = getMissingFilesForPost;
exports.uploadFile = uploadFile;
exports.getFilePublicLink = getFilePublicLink;

__webpack_require__(23);

__webpack_require__(12);

__webpack_require__(13);

__webpack_require__(18);

__webpack_require__(83);

__webpack_require__(84);

var _reduxBatchedActions = __webpack_require__(132);

var _client = __webpack_require__(27);

var _action_types = __webpack_require__(8);

var _errors = __webpack_require__(105);

var _helpers = __webpack_require__(117);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function getFilesForPost(postId
/*: string*/
) {
  return (
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(dispatch
      /*: DispatchFunc*/
      , getState
      /*: GetStateFunc*/
      ) {
        var files;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return _client.Client4.getFileInfosForPost(postId);

              case 3:
                files = _context.sent;
                _context.next = 11;
                break;

              case 6:
                _context.prev = 6;
                _context.t0 = _context["catch"](0);
                (0, _helpers.forceLogoutIfNecessary)(_context.t0, dispatch, getState);
                dispatch((0, _errors.logError)(_context.t0));
                return _context.abrupt("return", {
                  error: _context.t0
                });

              case 11:
                dispatch({
                  type: _action_types.FileTypes.RECEIVED_FILES_FOR_POST,
                  data: files,
                  postId: postId
                });
                return _context.abrupt("return", {
                  data: true
                });

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 6]]);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}

function getMissingFilesForPost(postId
/*: string*/
) {
  return (
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(dispatch
      /*: DispatchFunc*/
      , getState
      /*: GetStateFunc*/
      ) {
        var fileIdsByPostId, posts;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                fileIdsByPostId = getState().entities.files.fileIdsByPostId;
                posts = [];

                if (fileIdsByPostId[postId]) {
                  _context2.next = 6;
                  break;
                }

                _context2.next = 5;
                return getFilesForPost(postId)(dispatch, getState);

              case 5:
                posts = _context2.sent;

              case 6:
                return _context2.abrupt("return", {
                  data: posts
                });

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }()
  );
}

function uploadFile(channelId
/*: string*/
, rootId
/*: string*/
, clientIds
/*: Array<String>*/
, fileFormData
/*: File*/
, formBoundary
/*: string*/
) {
  return (
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(dispatch
      /*: DispatchFunc*/
      , getState
      /*: GetStateFunc*/
      ) {
        var files, failure, data;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                dispatch({
                  type: _action_types.FileTypes.UPLOAD_FILES_REQUEST,
                  data: {}
                }, getState);
                _context3.prev = 1;
                _context3.next = 4;
                return _client.Client4.uploadFile(fileFormData, formBoundary);

              case 4:
                files = _context3.sent;
                _context3.next = 13;
                break;

              case 7:
                _context3.prev = 7;
                _context3.t0 = _context3["catch"](1);
                (0, _helpers.forceLogoutIfNecessary)(_context3.t0, dispatch, getState);
                failure = {
                  type: _action_types.FileTypes.UPLOAD_FILES_FAILURE,
                  clientIds: clientIds,
                  channelId: channelId,
                  rootId: rootId,
                  error: _context3.t0
                };
                dispatch((0, _reduxBatchedActions.batchActions)([failure, (0, _errors.logError)(_context3.t0)]), getState);
                return _context3.abrupt("return", {
                  error: _context3.t0
                });

              case 13:
                data = files.file_infos.map(function (file, index) {
                  return _objectSpread({}, file, {
                    clientId: files.client_ids[index]
                  });
                });
                dispatch((0, _reduxBatchedActions.batchActions)([{
                  type: _action_types.FileTypes.RECEIVED_UPLOAD_FILES,
                  data: data,
                  channelId: channelId,
                  rootId: rootId
                }, {
                  type: _action_types.FileTypes.UPLOAD_FILES_SUCCESS
                }]), getState);
                return _context3.abrupt("return", {
                  data: files
                });

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[1, 7]]);
      }));

      return function (_x5, _x6) {
        return _ref3.apply(this, arguments);
      };
    }()
  );
}

function getFilePublicLink(fileId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getFilePublicLink,
    onSuccess: _action_types.FileTypes.RECEIVED_FILE_PUBLIC_LINK,
    params: [fileId]
  });
}

/***/ }),

/***/ 2410:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/84c1ce7412135b70309723274272115a.png";

/***/ }),

/***/ 2411:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/9dc4f9f5baa077351c60cab4a53afd4b.png";

/***/ }),

/***/ 2426:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/1171271cb71e89919600b8c3ae1774cb.gif";

/***/ }),

/***/ 2427:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 32).then((function(require) {
		cb(__webpack_require__(3339));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 2431:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2455:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2456:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2464:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getUAToken; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getUABuList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getUAListMember; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return queryEmployeeByAd; });
/* harmony import */ var q__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2037);
/* harmony import */ var q__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(q__WEBPACK_IMPORTED_MODULE_0__);

const pathUrl =  false ? undefined : 'https://uan.zhonganonline.com'; // 获取token

const getUAToken = function () {
  return new q__WEBPACK_IMPORTED_MODULE_0__["Promise"](resolve => {
    $.ajax({
      async: true,
      url: pathUrl + '/uangateway',
      type: "POST",
      contentType: "application/json",
      data: JSON.stringify({
        serviceName: "ua.service.getToken",
        bizContent: '{"appKey":"ua2zuifuliAdinfo20180809"}'
      }),

      success(data) {
        if (data.success == "Y") {
          resolve(data.result);
        }
      },

      error(xhr, type) {
        console.log(xhr);
      }

    });
  });
}; // 获取层级列表

const getUABuList = function (token) {
  return new q__WEBPACK_IMPORTED_MODULE_0__["Promise"](resolve => {
    $.ajax({
      async: true,
      url: pathUrl + '/uangateway',
      type: "POST",
      contentType: "application/json",
      data: JSON.stringify({
        serviceName: "ua.service.allZuifuliDepartments",
        bizContent: JSON.stringify({
          token: token
        })
      }),

      success(data) {
        if (data.success == "Y") {
          resolve(data.result);
        }
      },

      error(xhr, type) {
        console.log(xhr);
      }

    });
  });
}; //获取层级人员

const getUAListMember = function (token, deptId) {
  return new q__WEBPACK_IMPORTED_MODULE_0__["Promise"](resolve => {
    $.ajax({
      async: true,
      url: pathUrl + '/uangateway',
      type: "POST",
      contentType: "application/json",
      data: JSON.stringify({
        serviceName: "ua.service.employeesByDeptId",
        bizContent: JSON.stringify({
          token: token,
          departmentId: deptId
        })
      }),

      success(data) {
        if (data.success == "Y") {
          resolve(data.result);
        }
      },

      error(xhr, type) {
        console.log(xhr);
      }

    });
  });
}; //获取人员

const queryEmployeeByAd = function (token, value) {
  return new q__WEBPACK_IMPORTED_MODULE_0__["Promise"](resolve => {
    $.ajax({
      async: true,
      url: pathUrl + '/v2/public/queryEmployeeByAd',
      type: "POST",
      contentType: "application/json",
      headers: {
        appKey: 'ua2zuifuliAdinfo20180809',
        token
      },
      data: JSON.stringify({
        param: value
      }),

      success(data) {
        if (data.success) {
          resolve(data.info);
        }
      },

      error(xhr, type) {
        console.log(xhr);
      }

    });
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175)))

/***/ }),

/***/ 2465:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2467:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2468:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/05d10553b9a43f2524d336e0b79ba97b.png";

/***/ }),

/***/ 2469:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2470:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2471:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2472:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2473:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2474:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2475:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2487:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2488:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2555:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2556:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2557:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2558:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2559:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2560:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2561:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2567:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CollectItem; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2568);
/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_scss__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1552);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93);
/* harmony import */ var components_file_attachment_list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1718);
/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);
/* harmony import */ var components_post_view_post_flag_icon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1760);
/* harmony import */ var _ao_merge_collect_icon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3475);
/* harmony import */ var components_ao_post_cards__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1821);
/* harmony import */ var utils_text_formatting_jsx__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(81);
/* harmony import */ var utils_message_html_to_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(1684);
/* harmony import */ var components_ao_post_cards_merge_message_message_modal__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(2263);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(3485);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(3490);
/* harmony import */ var antd_lib_index__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(2064);
/* harmony import */ var antd_lib_index__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(antd_lib_index__WEBPACK_IMPORTED_MODULE_15__);















const {
  confirm
} = antd__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"];
class CollectItem extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      visible: false,
      showMore: false,
      isSingle: props.collect.post_id
    };
    this.collectItemRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.createRef();
    this.modalRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.createRef();
  }

  componentDidMount() {
    $(this.collectItemRef.current).find('.message-text').map((index, el) => {
      if (index < 2 && el.offsetHeight > 50) {
        el.classList.add('text-overflow');
        this.setState({
          showMore: true
        });
      }
    });
  }

  handleHide() {
    this.setState({
      visible: false
    });
  }

  renderPost(post) {
    const {
      compactDisplay,
      currentChannel,
      getUserById
    } = this.props;
    const {
      isSingle
    } = this.state;
    const user = getUserById(post.user_id);
    let messageContent = null;
    let fileCont = null;
    const Card = post.post_id ? Object(components_ao_post_cards__WEBPACK_IMPORTED_MODULE_9__[/* createCard */ "a"])(post) : null;
    const htmlFormattedText = utils_text_formatting_jsx__WEBPACK_IMPORTED_MODULE_10__[/* formatText */ "e"]((user && post.message && !isSingle ? user.nickname + '：' : '') + post.message);

    if (Card) {
      messageContent = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: 'card-wrap card-type-' + post.card_type
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Card, {
        post: post,
        channel: currentChannel
      }));
    } else {
      messageContent = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "message-text"
      }, Object(utils_message_html_to_component__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"])(htmlFormattedText));
    }

    if (post.card_type !== '11-1' && post.file_ids && post.file_ids.length > 0) {
      fileCont = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_file_attachment_list__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], {
        post: post,
        fileInfos: post.fileInfos,
        compactDisplay: compactDisplay
      });
    }

    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, messageContent, fileCont);
  }

  viewMore() {
    if (this.modalRef.current) {
      this.modalRef.current.wrappedInstance.show();
    }
  }

  async delete() {
    const {
      actions,
      collect
    } = this.props;
    const result = await actions.deleteMergeCollect(collect.id);

    if (result.data) {
      antd_lib_index__WEBPACK_IMPORTED_MODULE_15__["message"].success('删除成功');
    } else {
      antd_lib_index__WEBPACK_IMPORTED_MODULE_15__["message"].error('删除失败');
    }
  }

  async handleClick({
    key
  }) {
    const {
      collect,
      actions
    } = this.props;

    if (key === 'forward') {
      if (collect.post_ids.length === 1) {
        actions.setChannelPostSelect({
          type: utils_constants__WEBPACK_IMPORTED_MODULE_6__[/* ChannelPostSelectType */ "f"].SINGLE,
          visibleSelectMember: true,
          postId: collect.post_ids[0]
        });
      } else {
        actions.setChannelPostSelect({
          type: utils_constants__WEBPACK_IMPORTED_MODULE_6__[/* ChannelPostSelectType */ "f"].COLLECT,
          visibleSelectMember: true,
          postIds: collect.post_ids
        });
      }
    } else if (key === 'delete') {
      let _this = this;

      confirm({
        title: '确定要删除吗？',
        cancelText: '取消',
        okText: '确定',

        onOk() {
          _this.delete();
        }

      });
    }
  }

  render() {
    const {
      collect,
      compactDisplay
    } = this.props;
    const {
      isSingle
    } = this.state;
    let content = null;
    let posts = JSON.parse(collect.message);
    posts.forEach(item => {
      item.id = item.post_id;

      if (item.file_ids) {
        item.fileInfos = [collect.files[item.file_ids[0]]];
      }
    });
    let showOne = false; // 如果第一条信息中有文件或图片，则只展示一条信息

    if (posts[0].card_type || posts[0].file_ids) {
      showOne = true;
    }

    if (showOne) {
      content = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "post-item"
      }, this.renderPost(posts[0]));
    } else {
      content = posts.map((item, index) => {
        return index < 2 && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          className: "post-item",
          key: index
        }, this.renderPost(item));
      });
    }

    const menu = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"], {
      onClick: val => {
        this.handleClick(val);
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].Item, {
      key: "forward",
      className: "forward"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", {
      className: "repost-icon"
    }), " \u8F6C\u53D1"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].Item, {
      key: "delete",
      className: "delete"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", {
      className: "delete-icon"
    }), " \u5220\u9664"));
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "collect-item",
      ref: this.collectItemRef
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "collect-item-inner"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "header"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      className: "name"
    }, collect.title), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      className: "time"
    }, moment__WEBPACK_IMPORTED_MODULE_2___default()(collect.create_at).format('YYYY-MM-DD HH:mm:ss')), isSingle ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_post_view_post_flag_icon__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"], {
      location: utils_constants__WEBPACK_IMPORTED_MODULE_6__[/* Locations */ "o"].SEARCH,
      postId: collect.post_id,
      isFlagged: true
    }) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_ao_merge_collect_icon__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"], {
      collectId: collect.id
    })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "content"
    }, content, (posts.length > 2 || posts.length > 1 && showOne || this.state.showMore) && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "view-more",
      onClick: () => {
        this.viewMore();
      }
    }, "\u66F4\u591A\u804A\u5929\u8BB0\u5F55", react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], {
      type: "right"
    }))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"], {
      overlayClassName: "my-collect-dropdown",
      overlay: menu,
      placement: "bottomRight",
      trigger: ['hover', 'click']
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "more-icon"
    })), this.state.visible && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], {
      title: "\u8BE6\u60C5",
      className: "shortcuts-modal",
      closeIcon: react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], {
        type: "close-circle",
        theme: "filled"
      }),
      visible: true,
      onCancel: () => {
        this.handleHide();
      },
      role: "dialog",
      footer: null,
      mask: false,
      maskClosable: false,
      centered: true,
      width: '660px'
    }, Object(utils_message_html_to_component__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"])(htmlFormattedText))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_ao_post_cards_merge_message_message_modal__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"], {
      ref: this.modalRef,
      value: posts,
      filesInfos: collect.files,
      title: collect.title
    }));
  }

}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175)))

/***/ }),

/***/ 2568:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2945:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Cloud; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2946);
/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_scss__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3434);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1552);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3485);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3490);
/* harmony import */ var _ao_cloud_item__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3445);
/* harmony import */ var components_widgets_loading_loading_wrapper_jsx__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1608);
/* harmony import */ var utils_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(22);
/* harmony import */ var components_view_image__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1755);
/* harmony import */ var utils_file_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(1601);
/* harmony import */ var mattermost_redux_utils_file_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(1611);
/* harmony import */ var mattermost_redux_utils_file_utils__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_utils_file_utils__WEBPACK_IMPORTED_MODULE_12__);









const {
  TabPane
} = antd__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"];
const {
  confirm
} = antd__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"];
const tabs = [{
  type: '',
  name: '全部'
}, {
  type: 'document',
  name: '文件'
}, {
  type: 'image',
  name: '图片'
}, {
  type: 'video',
  name: '视频'
}, {
  type: 'other',
  name: '其他'
}]; // sortType 是默认排序

const menuData = [{
  type: 'CreateAt',
  name: '时间排序',
  sortType: ['DESC', 'ASC']
}, {
  type: 'Name',
  name: '名称排序',
  sortType: ['ASC', 'DESC']
}, {
  type: 'Size',
  name: '大小排序',
  sortType: ['DESC', 'ASC']
}];
class Cloud extends react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      isLoading: true,
      params: {
        channel_id: props.channel.id,
        classification: tabs[0].type,
        page: 0,
        per_page: 100,
        sort_type: menuData[0].sortType[0],
        order_by_field: menuData[0].type
      },
      previewItem: {},
      visible: false
    };
  }

  componentDidMount() {
    this.getCloudList();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (nextProps.searchTerm !== this.props.searchTerm) {
      this.state.params.term = nextProps.searchTerm;
      this.setState({
        params: this.state.params
      });
      this.getCloudList();
    }
  }

  getCloudList() {
    this.setState({
      isLoading: true
    });
    this.props.actions.getCloudData(this.state.params).then(() => {
      this.setState({
        isLoading: false
      });
    });
  }

  tabChange(val) {
    this.state.params.classification = tabs[val].type;
    this.setState({
      params: this.state.params
    });
    this.getCloudList();
  }

  handleClick({
    key
  }) {
    const value = menuData[key]; // 如果再次点击已选中排序，则反序排列

    if (value.type === this.state.params.order_by_field) {
      this.state.params.sort_type = this.state.params.sort_type === value.sortType[0] ? value.sortType[1] : value.sortType[0];
    } else {
      this.state.params.sort_type = value.sortType[0];
    }

    this.state.params.order_by_field = value.type;
    this.setState({
      isLoading: true,
      params: this.state.params
    });
    this.props.actions.getCloudData(this.state.params).then(() => {
      this.setState({
        isLoading: false
      });
    });
  }

  showPreviewModal(e, item) {
    if ($(e.target).hasClass('more-icon') || $(e.target).parents('.ant-dropdown').length > 0) {
      return;
    }

    if (Object(utils_file_utils__WEBPACK_IMPORTED_MODULE_11__[/* canPreview */ "b"])(item.extension)) {
      this.setState({
        visible: true,
        previewItem: item
      });
      return;
    }

    confirm({
      title: '该格式暂不支持预览，您可以下载查看',
      cancelText: '取消',
      okText: '下载',
      icon: react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], {
        type: "exclamation-circle"
      }),

      onOk() {
        const fileUrl = item.link || Object(mattermost_redux_utils_file_utils__WEBPACK_IMPORTED_MODULE_12__["getFileUrl"])(item.id);
        window.open(fileUrl + '?download=1', '_self');
      }

    });
  }

  hidePreviewModal(e) {
    this.setState({
      visible: false
    });
  }

  render() {
    const {
      params,
      isLoading,
      visible,
      previewItem
    } = this.state;
    const {
      cloudList
    } = this.props;
    const menu = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], {
      onClick: val => {
        this.handleClick(val);
      }
    }, menuData.map((item, index) => {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].Item, {
        key: index,
        className: params.order_by_field === item.type ? 'selected' : ''
      }, item.name);
    }));
    let content = null;

    if (isLoading) {
      content = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "loading-cont"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_widgets_loading_loading_wrapper_jsx__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"], {
        text: utils_utils__WEBPACK_IMPORTED_MODULE_9__[/* localizeMessage */ "gb"]("search_header.loading", "Searching")
      }));
    } else if (cloudList.length === 0) {
      content = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "no-data"
      }, "\u6CA1\u6709\u76F8\u5173\u6570\u636E");
    } else {
      content = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "cloud-cont"
      }, cloudList.map((item, index) => {
        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          key: index,
          onClick: e => {
            this.showPreviewModal(e, item);
          }
        }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_ao_cloud_item__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"], {
          file: item,
          key: item.id
        }));
      }));
    }

    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "cloud-wrap"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "cloud-header"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
      defaultActiveKey: "0",
      onChange: val => {
        this.tabChange(val);
      }
    }, tabs.map((item, index) => {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(TabPane, {
        tab: item.name,
        key: index
      });
    })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "sort"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"], {
      overlayClassName: "sort-dropdown",
      overlay: menu,
      placement: "bottomRight"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      className: "sort-icon"
    })))), content, visible && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_view_image__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"], {
      show: visible,
      onModalDismissed: () => {
        this.hidePreviewModal();
      },
      startIndex: 0,
      fileInfos: [previewItem],
      postId: previewItem.post_id ? previewItem.post_id : ''
    }));
  }

}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175)))

/***/ }),

/***/ 2946:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2947:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2948:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2949:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2950:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2951:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2952:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2961:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/bd956aafccffed574da236f21af209ef.gif";

/***/ }),

/***/ 2962:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/8b03642d36741ba3030a9004a1d56bb0.gif";

/***/ }),

/***/ 2963:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	Promise.all(/* require.ensure */[__webpack_require__.e(16), __webpack_require__.e(2), __webpack_require__.e(9)]).then((function(require) {
		cb(__webpack_require__(3429));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 2964:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2965:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/de45d1e5af08c76eb6569318f62b2de8.ico";

/***/ }),

/***/ 2966:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/d18a910a9f6db87364ebe32f8455d17f.png";

/***/ }),

/***/ 2967:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCurrentSearchForCurrentTeam = void 0;

__webpack_require__(420);

var _reselect = __webpack_require__(94);

var _teams = __webpack_require__(32); // Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


var getCurrentSearchForCurrentTeam = (0, _reselect.createSelector)(function (state) {
  return state.entities.search.current;
}, _teams.getCurrentTeamId, function (current, teamId) {
  return current[teamId];
});
exports.getCurrentSearchForCurrentTeam = getCurrentSearchForCurrentTeam;

/***/ }),

/***/ 2969:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./private_00.png": 975,
	"./public_00.png": 976
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 2969;

/***/ }),

/***/ 2970:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./private_00.png": 975,
	"./private_01.png": 994,
	"./private_02.png": 995,
	"./private_03.png": 996,
	"./private_04.png": 997,
	"./private_05.png": 998,
	"./private_06.png": 999,
	"./private_07.png": 1000,
	"./public_00.png": 976,
	"./public_01.png": 1001,
	"./public_02.png": 1002,
	"./public_03.png": 1003,
	"./public_04.png": 1004,
	"./public_05.png": 1005,
	"./public_06.png": 1006,
	"./public_07.png": 1007
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 2970;

/***/ }),

/***/ 2971:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/b249c23fa119c5a95c94bec480b38cc4.png";

/***/ }),

/***/ 2972:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/3f4e1b2d921aeec640252fcb380def02.png";

/***/ }),

/***/ 2973:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/2308935bf5ca4fc49a148074a6c4a3d4.png";

/***/ }),

/***/ 2974:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/9989bde8da3c8c3cce80444e9ff96e79.png";

/***/ }),

/***/ 2975:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/52e04b752df91af05d569c623f6c898a.png";

/***/ }),

/***/ 2976:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/6fae075e4b61bb787a023d42d9cc31f0.png";

/***/ }),

/***/ 2989:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/fbb787c2aff55ad8898f7233a76acb40.png";

/***/ }),

/***/ 2990:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/9eb02c75cfabe48260f4f65025769a80.png";

/***/ }),

/***/ 2991:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/c44312ece2119ca3b0c91ba62cc7c7d9.png";

/***/ }),

/***/ 2992:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2993:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2994:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2995:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2996:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2997:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2998:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2999:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 3011:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {// 1.0.3
/*
The MIT License (MIT)

Copyright (c) 2015 Jan Martin

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
(function ($) {

    $.fn.dragster = function (options) {
        var settings = $.extend({
            enter: $.noop,
            leave: $.noop,
            over: $.noop,
            drop: $.noop
        }, options);

        return this.each(function () {
            var first = false,
                second = false,
                $this = $(this);

            $this.on({
                dragenter: function (event) {
                    if (first) {
                        second = true;
                        return;
                    } else {
                        first = true;
                        $this.trigger('dragster:enter', event);
                    }
                    event.preventDefault();
                },
                dragleave: function (event) {
                    if (second) {
                        second = false;
                    } else if (first) {
                        first = false;
                    }
                    if (!first && !second) {
                        $this.trigger('dragster:leave', event);
                    }
                    event.preventDefault();
                },
                dragover: function (event) {
                    $this.trigger('dragster:over', event);
                    event.preventDefault();
                },
                drop: function (event) {
                    if (second) {
                        second = false;
                    } else if (first) {
                        first = false;
                    }
                    if (!first && !second) {
                        $this.trigger('dragster:drop', event);
                    }
                    event.preventDefault();
                },
                'dragster:enter': settings.enter,
                'dragster:leave': settings.leave,
                'dragster:over': settings.over,
                'dragster:drop': settings.drop
            });
        });
    };

}(jQuery));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175)))

/***/ }),

/***/ 3012:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUsersTyping = exports.makeGetUsersTypingByChannelAndPost = void 0;

__webpack_require__(12);

__webpack_require__(13);

__webpack_require__(18);

var _reselect = __webpack_require__(94);

var _common = __webpack_require__(207);

var _preferences = __webpack_require__(41);

var _user_utils = __webpack_require__(104); // Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow


var getUsersTypingImpl = function getUsersTypingImpl(profiles
/*: IDMappedObjects<UserProfile>*/
, teammateNameDisplay
/*: string*/
, channelId
/*: string*/
, parentPostId
/*: string*/
, typing
/*: Typing*/
)
/*: Array<string>*/
{
  var id = channelId + parentPostId;

  if (typing[id]) {
    var users = Object.keys(typing[id]);

    if (users.length) {
      return users.map(function (userId) {
        return (0, _user_utils.displayUsername)(profiles[userId], teammateNameDisplay);
      });
    }
  }

  return [];
};

var makeGetUsersTypingByChannelAndPost = function makeGetUsersTypingByChannelAndPost() {
  return (0, _reselect.createSelector)(_common.getUsers, _preferences.getTeammateNameDisplaySetting, function (state
  /*: GlobalState*/
  , options
  /*: {channelId: string, postId: string}*/
  ) {
    return (
      /*: string*/
      options.channelId
    );
  }, function (state
  /*: GlobalState*/
  , options
  /*: {channelId: string, postId: string}*/
  ) {
    return (
      /*: string*/
      options.postId
    );
  }, function (state
  /*: GlobalState*/
  ) {
    return (
      /*: Typing*/
      state.entities.typing
    );
  }, getUsersTypingImpl)
  /*: (state: GlobalState, {channelId: string, postId: string}) => Array<string>*/
  ;
};

exports.makeGetUsersTypingByChannelAndPost = makeGetUsersTypingByChannelAndPost;
var getUsersTyping
/*: (state: GlobalState) => Array<string>*/
= (0, _reselect.createSelector)(_common.getUsers, _preferences.getTeammateNameDisplaySetting, _common.getCurrentChannelId, function (state) {
  return state.entities.posts.selectedPostId;
}, function (state) {
  return state.entities.typing;
}, getUsersTypingImpl);
exports.getUsersTyping = getUsersTyping;

/***/ }),

/***/ 3013:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/363416cb963b791aadf6b68f83b9ab76.gif";

/***/ }),

/***/ 3196:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/dada73cb61740b48be647f9e7d7c8605.png";

/***/ }),

/***/ 3197:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 3198:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 3199:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 3200:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/4bc4b39ef702115ae809aa2926144573.png";

/***/ }),

/***/ 3201:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/f23047d2ee7b90b741f565ac4a27c5a3.png";

/***/ }),

/***/ 3202:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/cf7302d2c9fc77a3cb72307e1459c665.png";

/***/ }),

/***/ 3203:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 3204:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/2c70f67ca3eee3ef60540796db6dee8f.png";

/***/ }),

/***/ 3205:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/c221988a32178c25dbaa7e2fa31ae766.png";

/***/ }),

/***/ 3206:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/4aef0707ae8f35b8e0f051d4a00e057a.png";

/***/ }),

/***/ 3207:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/7ea3a510871cd42aeb0e50379acae931.png";

/***/ }),

/***/ 3208:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 3209:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/d50c5deaeda4c69a33adbdc8a4b03476.png";

/***/ }),

/***/ 3210:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/82a1fa0b069e5c01db8322bd1713b967.png";

/***/ }),

/***/ 3211:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	Promise.all(/* require.ensure */[__webpack_require__.e(0), __webpack_require__.e(20)]).then((function(require) {
		cb(__webpack_require__(3440));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3212:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 11).then((function(require) {
		cb(__webpack_require__(3461));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3213:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	Promise.all(/* require.ensure */[__webpack_require__.e(0), __webpack_require__.e(1), __webpack_require__.e(23), __webpack_require__.e(6)]).then((function(require) {
		cb(__webpack_require__(3425));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3214:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 24).then((function(require) {
		cb(__webpack_require__(3463));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3215:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 31).then((function(require) {
		cb(__webpack_require__(3466));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3216:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 19).then((function(require) {
		cb(__webpack_require__(3468));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3217:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 12).then((function(require) {
		cb(__webpack_require__(3469));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3218:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 26).then((function(require) {
		cb(__webpack_require__(3457));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3219:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 25).then((function(require) {
		cb(__webpack_require__(3459));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3220:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 18).then((function(require) {
		cb(__webpack_require__(3460));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3221:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 10).then((function(require) {
		cb(__webpack_require__(3439));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3222:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 30).then((function(require) {
		cb(__webpack_require__(3437));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3223:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 22).then((function(require) {
		cb(__webpack_require__(3464));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3224:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 21).then((function(require) {
		cb(__webpack_require__(3465));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3225:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 15).then((function(require) {
		cb(__webpack_require__(3448));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3226:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 17).then((function(require) {
		cb(__webpack_require__(3470));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3227:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 14).then((function(require) {
		cb(__webpack_require__(3442));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3228:
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(cb) {
	__webpack_require__.e(/* require.ensure */ 13).then((function(require) {
		cb(__webpack_require__(3441));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
}

/***/ }),

/***/ 3229:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(405);
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15);
/* harmony import */ var mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_channels__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var mattermost_redux_selectors_entities_preferences__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(41);
/* harmony import */ var mattermost_redux_selectors_entities_preferences__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_preferences__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_selectors_entities_users__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);
/* harmony import */ var utils_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(22);
/* harmony import */ var actions_views_posts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1618);
/* harmony import */ var _video_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3230);
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function mapStateToProps(state, ownProps) {
  // debugger
  // const getChannel = makeGetChannel();
  // const sidebarPrefs = getSidebarPreferences(ownProps.state);
  // const lastUnreadChannel = ownProps.state.views.channel.keepChannelIdAsUnread;
  // const orderedChannelIds = getOrderedChannelIds(
  //     ownProps.state,
  //     lastUnreadChannel,
  //     sidebarPrefs.grouping,
  //     sidebarPrefs.sorting,
  //     sidebarPrefs.unreads_at_top === "true",
  //     sidebarPrefs.favorite_at_top === "true"
  // );
  let members = []; // Array.isArray(orderedChannelIds)
  //     && orderedChannelIds.map(item => members = [...members, ...item.items]);

  const teamId = ''; //ownProps.state.entities.teams.currentTeamId;

  const currentUserId = state.entities.users.currentUserId;
  const avData = state.views.meeting.invitation.meetingAv || {
    "video_status": "-1",
    "voice_status": "-1"
  }; //初始化为打开
  //console.log("closeMeetingId----------",state.views.meeting.invitation);

  const closeMeetingId = state.views.meeting.invitation.closeMeetingId || ""; //初始化为打开

  return {
    avData,
    teamId,
    members,
    currentUserId,
    closeMeetingId
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux__WEBPACK_IMPORTED_MODULE_1__["bindActionCreators"])({
      setChannelPostSelect: actions_views_posts__WEBPACK_IMPORTED_MODULE_7__[/* setChannelPostSelect */ "c"]
    }, dispatch),
    dispatch
  };
}

/* harmony default export */ __webpack_exports__["a"] = (Object(react_redux__WEBPACK_IMPORTED_MODULE_0__["connect"])(mapStateToProps, mapDispatchToProps)(_video_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"]));

/***/ }),

/***/ 3230:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _js_jquery_2_1_1_min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3231);
/* harmony import */ var _js_jquery_2_1_1_min_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_js_jquery_2_1_1_min_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _js_jquery_json_2_4_min_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3232);
/* harmony import */ var _js_jquery_json_2_4_min_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_js_jquery_json_2_4_min_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _js_jquery_cookie_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3233);
/* harmony import */ var _js_jquery_cookie_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_js_jquery_cookie_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _js_jquery_dataTables_min_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3234);
/* harmony import */ var _js_jquery_dataTables_min_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_js_jquery_dataTables_min_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _js_getScreenId_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3235);
/* harmony import */ var _js_md5_min_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3237);
/* harmony import */ var _js_md5_min_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_js_md5_min_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _js_jquery_hipchat_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3238);
/* harmony import */ var _js_jquery_hipchat_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_js_jquery_hipchat_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _js_verto_min_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3239);
/* harmony import */ var _js_verto_min_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_js_verto_min_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _css_index_scss__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3240);
/* harmony import */ var _css_index_scss__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_css_index_scss__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var api_post_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(67);
/* harmony import */ var images_avatar_female_png__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(3241);
/* harmony import */ var images_avatar_female_png__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(images_avatar_female_png__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _image_members_png__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(3242);
/* harmony import */ var _image_members_png__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_image_members_png__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _image_closeRight_2x_png__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(3243);
/* harmony import */ var _image_closeRight_2x_png__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_image_closeRight_2x_png__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _image_outzoom2x_png__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(3244);
/* harmony import */ var _image_outzoom2x_png__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_image_outzoom2x_png__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _image_loading_share_gif__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(3245);
/* harmony import */ var _image_loading_share_gif__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_image_loading_share_gif__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _image_cpu2x_png__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(3246);
/* harmony import */ var _image_cpu2x_png__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_image_cpu2x_png__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var utils_constants__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(0);
/* harmony import */ var mattermost_redux_client__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(27);
/* harmony import */ var mattermost_redux_client__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(mattermost_redux_client__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var components_channel_new_invite_modal__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(1687);
/* harmony import */ var components_select_member__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(2260);
/* harmony import */ var client_web_websocket_client_jsx__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(1823);
/* harmony import */ var _image_openmic2x_png__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(3247);
/* harmony import */ var _image_openmic2x_png__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_image_openmic2x_png__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var _image_closemic2x_png__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(3248);
/* harmony import */ var _image_closemic2x_png__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_image_closemic2x_png__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var _image_share2x_png__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(3249);
/* harmony import */ var _image_share2x_png__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_image_share2x_png__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var _image_end_share2x_png__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(3250);
/* harmony import */ var _image_end_share2x_png__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_image_end_share2x_png__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var _image_set2x_png__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(3251);
/* harmony import */ var _image_set2x_png__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(_image_set2x_png__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var _image_invite2x_png__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(3252);
/* harmony import */ var _image_invite2x_png__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(_image_invite2x_png__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _image_closeVideo2x_png__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(3253);
/* harmony import */ var _image_closeVideo2x_png__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(_image_closeVideo2x_png__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var _image_openallmic_2x_png__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(3254);
/* harmony import */ var _image_openallmic_2x_png__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(_image_openallmic_2x_png__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var _image_closeallmic2x_png__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(3255);
/* harmony import */ var _image_closeallmic2x_png__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_image_closeallmic2x_png__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var utils_auth_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(428);
/* harmony import */ var utils_utils_jsx__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(22);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(3487);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






















 //左下图
//大图标

 //打开话筒






 //小图标

 //打开话筒








class App extends react__WEBPACK_IMPORTED_MODULE_0___default.a.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "onHide", () => {
      this.setState({
        showAdd: false
      });
    });

    this.state = {
      cur_call: null,
      share_call: null,
      confMan: null,
      ringing: false,
      autocall: true,
      chatting_with: false,
      vid_width: 1280,
      vid_height: 720,
      local_vid_width: 320,
      local_vid_height: 180,
      is_full_screen: false,
      outgoingBandwidth: 0,
      incomingBandwidth: 0,
      vqual: null,
      sessid: null,
      master: null,
      canvas_id: null,
      second_screen: null,
      save_settings: true,
      vertoHandle: null,
      video_screen: "webcam",
      isFirstInit: false,
      isSpeed: false,
      isSearch: true,
      isRight: false,
      //右侧打开
      userList: [],
      myHash: '',
      //我video的hash
      pHash: '',
      //主持人的video的hash
      pWebuid: '',
      //主持人的头像
      timeHandle: -1,
      timeNum: 0,
      //计时器
      myAb: false,
      //我的音效
      allAb: false,
      //所有人的音效
      isShare: false,
      //自己的分享状态
      isShowTip: false,
      //tip状态
      isNPShare: false,
      //主持人的分享状态 true为不显示分享
      meetingNumber: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("meetingNo", this.props.location.search),
      //会议id
      userName: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("userName", this.props.location.search) || "游客",
      //用户名
      userNickName: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("nickName", this.props.location.search) || "游客",
      //用户名
      url: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("url", this.props.location.search),
      //回调地址
      beginUser: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("beginUser", this.props.location.search) || false,
      //是否是发起人
      id: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("id", this.props.location.search),
      //会议id
      role: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("role", this.props.location.search),
      //
      meetingName: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("meetingName", this.props.location.search),
      //
      teamId: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("teamId", this.props.location.search),
      //
      server_host: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("server_host", this.props.location.search),
      //
      showAdd: false,
      //邀请面板
      postData: {},
      //转发消息体
      userIconObject: {},
      //用户头像
      voice_status: Object(utils_auth_js__WEBPACK_IMPORTED_MODULE_31__[/* getUrlTicket */ "b"])("voice_status", this.props.location.search) ///// 会议室音频状态 0 为禁止

    };
    this.lastMeetingCount = 0;
  } //移除调用


  componentWillUnmount() {}

  componentDidMount() {
    const dom = document.getElementsByTagName("body")[0];
    dom.style.background = "#343434";
    const root = document.getElementById("root");
    root.style = "width: 100%;height: 100%;margin: 0;padding: 0;";
    window.addEventListener('resize', () => {
      this.real_size(this);
    }, this);
    window.meeting_id = this.state.id;
    window.userName = this.state.userName;
    window.addEventListener("beforeunload", this.listenClose, false);
    window.video = this;
    window.clickType = 0; // 0 非点击（被踢 点击关闭页签） 1 自己退出 2关闭会议
    //setTimeout(function() {

    $.verto.init({
      skipPermCheck: false
    }, () => {
      this.setState({
        isSpeed: true
      });
      this.init();
    });
    this.real_size(this); //}, 1000);
    //心跳会议计时器

    this.setState({
      timeHandle: setInterval(() => {
        this.setState({
          timeNum: ++this.state.timeNum
        }, () => {// let self = this;
          // if(self.state.timeNum%3 === 0){
          //   //heartMeeting(self.state.id);
          //   WebSocketClient.videoHeartAction(self.state.id);
          // }
        });
      }, 1000, this)
    }); //  searchVideoChannels(this.state.teamId,this.props.currentUserId).then(res => {
    //     console.log('channel res:', res);
    //     debugger
    //     let members = res.data.map(channel => {
    //         const [channelIcon, channelDisplayName] = getChannelIcon(channel);
    //         return {
    //         channelId,
    //         channelIcon,
    //         channelDisplayName,
    //         type: 'lately',
    //         }
    //     });
    //   this.setState({channelList:res.data})
    // }, () => {
    //     console.log("list is worn")
    // });

    Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* getUidList */ "d"])([this.state.userName]).then(res => {
      var userIconObject = JSON.parse(JSON.stringify(this.state.userIconObject));
      userIconObject[this.state.userName] = this.getUserHeaderIcon(res.data[0]);
      this.setState({
        userIconObject: userIconObject
      });
    });
  }

  getUserHeaderIcon(user) {
    return mattermost_redux_client__WEBPACK_IMPORTED_MODULE_18__["Client4"].getUsersRoute() + '/' + user.id + '/image?_=' + (user.last_picture_update || 0);
  }

  real_size(self) {
    /* temasys hack */
    setTimeout(function () {
      $("#" + self.state.video_screen).width("");
      $("#" + self.state.video_screen).height("");
      var w = $("#" + self.state.video_screen).width();
      var h = $("#" + self.state.video_screen).height();
    }, 500);
    console.log("video size changed to fit screen");
  }

  full_screen(name = "webcam") {
    var elem = document.getElementById(name);
    if (!elem) return;

    if (elem.requestFullscreen) {
      elem.requestFullscreen();
    } else if (elem.msRequestFullscreen) {
      elem.msRequestFullscreen();
    } else if (elem.mozRequestFullScreen) {
      elem.mozRequestFullScreen();
    } else if (elem.webkitRequestFullscreen) {
      elem.webkitRequestFullscreen();
    }
  }

  openRihgtList() {
    this.setState({
      isRight: !this.state.isRight
    });
  } //呼叫


  docall() {
    if (this.state.cur_call) {
      return;
    }

    this.check_vid_res();
    let self = this;

    let sharefunc = function (error, sourceId, screen_constraints) {
      let cur_call;

      if (!screen_constraints) {
        cur_call = self.state.vertoHandle.newCall({
          destination_number: self.state.meetingNumber,
          caller_id_name: self.state.userNickName,
          caller_id_number: self.state.userName,
          outgoingBandwidth: "1280x720",
          incomingBandwidth: "1280x720",
          useVideo: true,
          //useStereo: true,
          //useCamera: (self.state.sessid ||self.state.canvas_id) ? "none" : $.verto.videoDevices[0].id,
          //useMic: (self.state.sessid ||self.state.canvas_id) ? "none" : "any",
          //useSpeak: (self.state.sessid ||self.state.canvas_id) ? "none" : "any",
          dedEnc: false,
          mirrorInput: false,
          userVariables: {
            avatar: "",
            email: ""
          }
        });
      } else {
        cur_call = self.state.vertoHandle.newCall({
          destination_number: self.state.meetingNumber,
          caller_id_name: self.state.userNickName + "$share",
          caller_id_number: self.state.userName,
          outgoingBandwidth: "1280x720",
          incomingBandwidth: "1280x720",
          useVideo: true,
          screenShare: true,
          //useStereo: true,高清音频
          //useCamera: (self.state.sessid ||self.state.canvas_id) ? "none" : $.verto.videoDevices[0].id,
          useMic: self.state.sessid || self.state.canvas_id ? "none" : "any",
          useSpeak: self.state.sessid || self.state.canvas_id ? "none" : "any",
          videoParams: screen_constraints.video.mandatory,
          dedEnc: false,
          mirrorInput: false
        });
      }

      self.setState({
        cur_call
      });
      setTimeout(() => {
        self.setState({
          isSpeed: false
        });
      }, 5000);
    };

    getScreenId(sharefunc);
  } // draw video


  clearConfMan() {
    if (this.state.confMan) {
      this.state.confMan.destroy();
      this.setState({
        confMan: null
      });
    } // $("#conf").hide();
    // $("#canvasui").hide();
    // $("#message").hide();


    this.setState({
      chatting_with: null
    });
  }

  display(msg) {//$("#calltitle").html(msg);
  }

  check_vid_res() {}

  on_full(which) {
    is_full = which;

    if (is_full) {
      clearTimeout(rs);
      $("#usr2").hide();
      rs = setTimeout(function () {
        $("#" + video_screen).width($(window).width());
        $("#" + video_screen).height($(window).height());
      }, 1500);
      $("#rows").css("position", "absolute").css("z-index", "2");
      $("#fullbtn").text("Exit Full Screen");
      $("#fullbtn2").text("Exit Full Screen");
      $("#usrctl").show();
    } else {
      $("#usrctl").hide();
      $("#rows").css("position", "static").css("z-index", "2");
      $("#fullbtn").text("Enter Full Screen");
      $("#fullbtn2").text("Enter Full Screen");
      clearTimeout(usrto);
      clearTimeout(rs);
      rs = setTimeout(function () {
        $("#" + video_screen).width("100%");
        $("#" + video_screen).height("100%");
      }, 1500);
    }
  }

  exit_full_screen() {
    if (document.webkitFullscreenEnabled) {
      document.webkitExitFullscreen();
    } else if (document.mozFullScreenEnabled) {
      document.mozCancelFullScreen();
    }
  }

  do_speed_test(fn) {
    if (true) {
      if (fn) {
        fn();
      }

      return;
    } //goto_page("bwtest");


    this.state.vertoHandle.rpcClient.speedTest(1024 * 256, function (e, obj) {
      //console.error("Up: " + obj.upKPS, "Down: ", obj.downKPS);
      var vid = "default"; //if (outgoingBandwidth === "default") {

      outgoingBandwidth = Math.ceil(obj.upKPS * .75).toString();
      $("#vqual_hd").prop("checked", true);
      vid = "1280x720";

      if (outgoingBandwidth < 1024) {
        $("#vqual_vga").prop("checked", true);
        vid = "640x480";
      }

      if (outgoingBandwidth < 512) {
        $("#vqual_qvga").prop("checked", true);
        vid = "320x240";
      }

      if (outgoingBandwidth < 256) {
        $("#vqual_qqvga").prop("checked", true);
        vid = "160x120";
      } //}


      if (incomingBandwidth === "default") {
        incomingBandwidth = Math.ceil(obj.downKPS * .75).toString();
      }

      console.info(outgoingBandwidth, incomingBandwidth); //$("#bwinfo").html("<b>Bandwidth: " + "Up: " + obj.upKPS + " Down: " + obj.downKPS + " Vid: " + vid + "</b>");

      if (fn) {
        fn();
      }
    });
  } //分享


  doshare(on) {
    //$('#ext').trigger('change');
    if (!on) {
      if (share_call) {
        share_call.hangup();
      }

      return;
    }

    if (share_call) {
      return;
    }

    var sharedev = $("#useshare").find(":selected").val();

    if (sharedev !== "screen") {
      share_call = vertoHandle.newCall({
        destination_number: $("#ext").val() + "-screen",
        caller_id_name: $("#cidname").val() + " (Screen)",
        caller_id_number: $("#cid").val() + " (screen)",
        outgoingBandwidth: outgoingBandwidth,
        incomingBandwidth: incomingBandwidth,
        useCamera: sharedev,
        useVideo: true,
        screenShare: true,
        dedEnc: $("#use_dedenc").is(':checked'),
        mirrorInput: $("#mirror_input").is(':checked')
      });
      return;
    }

    console.log("Attempting Screen Capture....");

    var sharefunc = function (error, sourceId, screen_constraints) {
      share_call = vertoHandle.newCall({
        destination_number: $("#ext").val() + "-screen",
        caller_id_name: $("#cidname").val() + " (Screen)",
        caller_id_number: $("#cid").val() + " (screen)",
        outgoingBandwidth: outgoingBandwidth,
        incomingBandwidth: incomingBandwidth,
        videoParams: screen_constraints ? screen_constraints.video.mandatory : {},
        useVideo: true,
        screenShare: true,
        dedEnc: $("#use_dedenc").is(':checked'),
        mirrorInput: $("#mirror_input").is(':checked')
      });
    };

    if (!!navigator.mozGetUserMedia) {
      sharefunc();
    } else {
      getScreenId(sharefunc);
    }
  }

  refresh_devices() {
    $.verto.refreshDevices();
    var x = 0;

    for (var i in $.verto.videoDevices) {
      var source = $.verto.videoDevices[i];
      var o = new Option(source.label, source.id);

      if (!x) {
        o.selected = true;
      } //$("#usecamera").append(o);


      var oo = new Option(source.label, source.id);

      if (!x++) {
        o.selected = true;
      } //$("#useshare").append(oo);

    }

    x = 1;

    for (var i in $.verto.audioInDevices) {
      var source = $.verto.audioInDevices[i];
      var o = new Option(source.label, source.id);

      if (!x++) {
        o.selected = true;
      } //$("#usemic").append(o);

    }

    for (var i in $.verto.audioOutDevices) {
      var source = $.verto.audioOutDevices[i];
      var o = new Option(source.label, source.id);

      if (!x++) {
        o.selected = true;
      } //$("#usespeak").append(o);

    } // var o = new Option("Screen", "screen");
    // o.selected = true;
    // $("#useshare").append(o);
    // $("#usemic").append(new Option("No Microphone", "none"));
    // $("#usecamera").selectmenu('refresh', true);
    // $("#usemic").selectmenu('refresh', true);
    // $("#usespeak").selectmenu('refresh', true);
    // $("#useshare").selectmenu('refresh', true);
    // var tmp;
    // tmp = $.cookie("verto_demo_camera_selected") || "false";
    // if (tmp) {
    //     $('#usecamera option[value=' + tmp + ']').prop('selected', 'selected').change();
    //     pop_select("#usecamera","verto_demo_camera_selected", tmp);
    // }
    // var tmp;
    // tmp = $.cookie("verto_demo_share_selected") || "false";
    // if (tmp) {
    //     $('#useshare option[value=' + tmp + ']').prop('selected', 'selected').change();
    //     pop_select("#useshare","verto_demo_share_selected", tmp);
    // }
    // tmp = $.cookie("verto_demo_mic_selected") || "false";
    // if (tmp) {
    //     $('#usemic option[value=' + tmp + ']').prop('selected', 'selected').change();
    //     pop_select("#usemic","verto_demo_mic_selected", tmp);
    // }
    // tmp = $.cookie("verto_demo_speak_selected") || "false";
    // if (tmp) {
    //     $('#usespeak option[value=' + tmp + ']').prop('selected', 'selected').change();
    //     pop_select("#usespeak","verto_demo_speak_selected", tmp);
    // }

  }

  check_vid() {// var use_vid = $("#use_vid").is(':checked');
    // return use_vid;
  }

  goto_dialog(where) {} //是分享账号


  isShare(name) {
    return name.indexOf("$share") != -1;
  } //获取名字


  getName(name) {
    return name.split("$share").join("");
  } //设置share和video为一个人


  addOnePlay(data) {
    let user = {};
    let found = false;
    const dnKnow = data[0];
    const userData = data[1]; //数据 

    const webuid = userData[1]; ///为za-xxx 唯一id

    const action = JSON.parse(userData[4]); //行为

    const userPostName = userData[2]; //消息用户名

    const userName = this.state.userName; //za-xxxurl传入

    const beginUser = this.state.beginUser == "true"; //开启会议人

    user.icon = data.icon;
    let newList = [];
    this.state.userList.forEach(i => {
      if (i.webuid == webuid) {
        found = true;
        user = i;

        if (this.isShare(userPostName)) {
          //如果过来的是分享
          user.action.video = action.video;
          user.cid = parseInt(userData[0]); //视频操作id

          user.isBuff = user.action.video.reservationID === "presenter"; //是否是主持人

          if (user.isBuff) {
            //设置主持hash 和主持人是否在分享
            this.setState({
              pHash: user.webuid,
              pWebuid: user.webuid,
              isNPShare: user.action.video.muted
            });
          }

          if (webuid == userName) {
            //如果过来的信息是自己
            if (beginUser) {
              //自己是会议开启人 设置自己为主持人并设置 分享打开
              this.onLayer(user); //cid
            } else {
              //不是自己设置 视频关闭
              this.onVMute(user, true);
            }
          }
        } else {
          this.onVMute({
            action: action
          }, true); //设置原视频流的视频关闭

          user.action.audio = action.audio;
          user.acid = parseInt(userData[0]); //音频操作id

          if (webuid == userName) {
            //如果过来的信息是自己
            if (beginUser) {
              //自己是会议开启人 设置自己为主持人并设置 音效打开
              this.onAMute(user, false);
            } else {
              //不是自己设置 设置自己为全频道音效
              const b = !this.isMeetCanSpack();
              this.setState({
                myAb: b
              }, () => {
                this.onAMute(user, b);
              });
            }
          }

          user.isVoice = user.action.audio.talking;
        }

        newList.push(user);
      } else {
        newList.push(i); //不是同一个人直接保存状态
      }
    }); //如果列表中不存在

    if (!found) {
      user.webuid = userData[1]; //登陆id 唯一

      user.name = this.getName(userPostName); //用户名

      user.action = action;

      if (this.isShare(userPostName)) {
        //如果过来的是分享
        user.vdnKnow = dnKnow; //踢人需要

        user.cid = parseInt(userData[0]); //视频操作id

        user.isBuff = user.action.video.reservationID === "presenter"; //是否是主持人

        if (user.isBuff) {
          //设置主持hash 和主持人是否在分享
          this.setState({
            pHash: user.webuid,
            pWebuid: user.webuid,
            isNPShare: user.action.video.muted
          });
        }

        if (webuid == userName) {
          //如果过来的信息是自己
          if (beginUser) {
            //自己是会议开启人 设置自己为主持人并设置 分享打开
            this.onLayer(user); //cid
          } else {
            //不是自己设置 视频关闭
            this.onVMute(user, true);
          }
        }
      } else {
        //非分享
        user.adnKnow = dnKnow; //踢人需要

        user.acid = parseInt(userData[0]); //音频操作id

        const isInElectron = window.navigator.userAgent.indexOf("Electron") !== -1; //是否是端

        if (!isInElectron) {
          //web
          user.cid = parseInt(userData[0]);

          if (webuid == userName) {
            //如果过来的信息是自己
            if (beginUser) {
              //自己是会议开启人 设置自己为主持人并设置 分享打开
              this.onLayer(user); //cid
            } else {
              //不是自己设置 视频关闭
              const b = !this.isMeetCanSpack();
              this.setState({
                myAb: b
              }, () => {
                this.onAMute(user, b);
              });
            }
          }
        } else {
          if (webuid == userName) {
            //如果过来的信息是自己
            const b = !this.isMeetCanSpack();
            this.setState({
              myAb: b
            }, () => {
              this.onAMute(user, b);
            });
          }
        }

        this.onVMute(user, true); //设置视频流为关闭
      }

      newList.push(user);
      this.setState({
        userList: newList
      });
    } else {
      this.setState({
        userList: newList
      });
    }
  } //通过长链接更新状态并返回


  changeOnePlayer(data) {
    let user = {};
    let found = false;
    const userData = data; //数据

    const webuid = userData[1]; ///为za-xxx 唯一id

    const action = JSON.parse(userData[4]); //行为

    const userPostName = userData[2]; //消息用户名
    //console.log(`this.isShare(userPostName)--00000--`);

    let newList = [];
    this.state.userList.forEach(i => {
      if (i.webuid == webuid) {
        found = true;
        user = i;

        if (this.isShare(userPostName)) {
          //如果过来的是分享
          user.action.video = action.video;
          user.isBuff = user.action.video.reservationID === "presenter"; //是否是主持人

          if (user.isBuff) {
            //设置主持hash 和主持人是否在分享
            if (this.state.pHash != user.webuid) //替换主持人
              {
                this.onSetClick(false); //关闭tip

                this.setState({
                  myAb: user.action.audio.muted
                }); //修改音效图标
              }

            this.setState({
              pHash: user.webuid,
              pWebuid: user.webuid,
              isNPShare: user.action.video.muted
            });
          }
        } else {
          const isInElectron = window.navigator.userAgent.indexOf("Electron") !== -1; //是否是端

          if (!isInElectron) {
            //非端判断
            if (!user.isBuff) user.action = action;
            user.action.audio = action.audio;
            user.isBuff = user.action.video.reservationID === "presenter"; //是否是主持人

            if (user.isBuff) {
              //设置主持hash 和主持人是否在分享
              if (this.state.pHash != user.webuid) this.onSetClick(false); //如果主持人切换 关闭tip

              this.setState({
                pHash: user.webuid,
                pWebuid: user.webuid,
                isNPShare: user.action.video.muted
              });
            }
          } else {
            user.action.audio = action.audio;
          }

          user.isVoice = user.action.audio.talking;
        }

        newList.push(user);
      } else {
        newList.push(i);
      }
    });
    this.setState({
      userList: newList
    });
  } //长链接数据转换成显示数据


  socketToListData(data, self) {
    data.length > 1 ? this.addOnePlay(data) : this.changeOnePlayer(data[0]);
  }

  getUserIconObject(webuid) {
    return this.state.userIconObject[webuid] ? this.state.userIconObject[webuid] : images_avatar_female_png__WEBPACK_IMPORTED_MODULE_11___default.a;
  }

  getMyIconObject() {
    return this.state.userIconObject[this.state.userName] ? this.state.userIconObject[this.state.userName] : images_avatar_female_png__WEBPACK_IMPORTED_MODULE_11___default.a;
  } //处理list刷新


  listHandler(args) {
    var packet = args; //console.log("listHandler",packet,packet.action)

    let rlist = [];

    switch (packet.action) {
      case "bootObj":
        //初始化列表
        if (packet.data && packet.data.length > 0) {
          let solist = packet.data;
          solist.forEach(so => {
            this.socketToListData(so, this);
            Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* getUidList */ "d"])([so[1][1]]).then(res => {
              var userIconObject = JSON.parse(JSON.stringify(this.state.userIconObject));
              userIconObject[[so[1][1]]] = this.getUserHeaderIcon(res.data[0]);
              this.setState({
                userIconObject: userIconObject
              });
            });
          });
        } //this.setState({isRight:true,isSearch:false});


        break;

      case "add":
        Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* getUidList */ "d"])([packet.data[1]]).then(res => {
          var userIconObject = JSON.parse(JSON.stringify(this.state.userIconObject));
          userIconObject[[packet.data[1]]] = this.getUserHeaderIcon(res.data[0]);
          this.setState({
            userIconObject: userIconObject
          });
        });
        this.socketToListData([packet.key, packet.data], this); //rlist.push(this.socketToListData(,this));

        break;

      case "modify":
        this.socketToListData([packet.data], this);

        if (!this.state.isFirstInit && this.state.pHash != "") {
          this.setState({
            isFirstInit: true
          }, () => {
            if (this.state.beginUser == "true") Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* meetUpdate */ "l"])({
              meeting_id: this.state.id,
              status: "2"
            }); //主持人初始化完毕

            this.setState({
              isRight: true,
              isSearch: false
            });
          });
        }

        break;

      case "del":
        rlist = JSON.parse(JSON.stringify(this.state.userList));

        for (var i = 0; i < rlist.length; ++i) {
          var data = rlist[i];

          if (data.adnKnow == packet.key || data.vdnKnow == packet.key) {
            if (data.webuid == this.state.userName) {
              //如果是自己被踢出则关闭浏览器
              this.onClose();
            }

            rlist.splice(i, 1);
            break;
          }
        }

        this.setState({
          userList: rlist
        });
        break;

      case "clear":
        this.setState({
          userList: []
        });
        this.onClose();
        break;

      case "reorder":
        break;

      default:
        break;
    }
  }

  //1 e存在是主动退出 2 关闭后被动踢
  onClose(e) {
    window.clickType = 1;

    if (e) {
      if (this.isPresenter()) {
        this.setNextP();
      } else {
        this.closeSelf();
      }
    } else {
      this.closeSelf();
    }
  } //设置下一个主持人


  setNextP() {
    if (this.state.userList.length > 1) {
      for (var i = 0; i < this.state.userList.length; ++i) {
        var user = this.state.userList[i];

        if (user.webuid != this.state.userName) {
          this.onSetMain(user, true);
          break;
        }
      }
    } else {
      this.closeSelf();
    }
  } //设置主屏幕


  onSetMain(item, close = false) {
    if (item.isBuff) return;
    if (!this.isPresenter(true)) return;
    this.onSetSelf();
    this.state.userList.forEach(user => {
      if (this.isMy(user)) {
        //如果是自己
        this.setState({
          myAb: false
        }, () => {
          this.onAMute(user, false);
        });
      }
    });
    this.onAMute(item, false);
    this.onSetAllAmute(false, () => {
      this.onReservation(item);
      if (close) this.closeSelf();
    });
  } //关闭会议室


  onCloseAll() {
    window.clickType = 2;
    Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* meetRemove */ "k"])({
      meeting_id: window.meeting_id + "",
      user_name: window.userName
    }).then(() => {
      Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* endMeeting */ "a"])({
        meeting_id: window.meeting_id + ""
      }).then(() => {
        this.closeWindow();
      });
    });
  } //通知并关闭自己


  closeSelf() {
    Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* meetRemove */ "k"])({
      meeting_id: window.meeting_id + "",
      user_name: window.userName
    }).then(() => {
      this.closeWindow();
    });
  }

  closeWindow() {
    var userAgent = navigator.userAgent;

    if (userAgent.indexOf("Firefox") != -1 || userAgent.indexOf("Presto") != -1) {
      window.location.replace("about:blank");
    } else {
      window.location.href = "about:blank";
      window.close();
    }
  } //浏览器监听关闭


  listenClose(event) {
    if (window.clickType == 0) {
      //点击关闭页签执行
      if (window.video.isPresenter()) {
        //event.returnValue = '请选择一个主持人后退出';
        Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* meetRemove */ "k"])({
          meeting_id: window.meeting_id + "",
          user_name: window.userName
        }); //自己out

        Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* endMeeting */ "a"])({
          meeting_id: window.meeting_id + ""
        }); //关闭会议
      } else {
        if (window.video.state.beginUser == "true") {
          //创建人 没有创建成功的时候就关闭了
          Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* endMeeting */ "a"])({
            meeting_id: window.meeting_id + ""
          }); //关闭会议
        } else Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* meetRemove */ "k"])({
          meeting_id: window.meeting_id + "",
          user_name: window.userName
        });
      }
    }
  } //初始化


  init() {
    this.setState({
      cur_call: null
    });
    this.check_vid_res();
    this.refresh_devices();
    var self = this; //参数

    var callbacks = {
      onMessage: function (verto, dialog, msg, data) {
        switch (msg) {
          case $.verto.enum.message.pvtEvent:
            //      console.error("pvtEvent", data.pvtData);
            if (data.pvtData) {
              switch (data.pvtData.action) {
                case "conference-liveArray-part":
                  self.clearConfMan();

                  if (data.pvtData.secondScreen) {// $("#mainButtons").show();
                    // $("#canvasButtons").hide();
                    // $("#keypad").show();
                  }

                  break;

                case "conference-liveArray-join":
                  self.clearConfMan();

                  if (data.pvtData.secondScreen) {// $("#mainButtons").hide();
                    // $("#canvasButtons").show();
                    // $("#keypad").hide();
                  } else {
                    let confMan = new $.verto.confMan(verto, {
                      tableID: "#conf_list",
                      statusID: "#conf_count",
                      mainModID: "#conf_mod",
                      displayID: "#conf_display",
                      dialog: dialog,
                      hasVid: self.check_vid(),
                      laData: data.pvtData,
                      onLaChange: function (verto, confMan, obj, args) {
                        self.listHandler(args);
                      },
                      chatCallback: function (v, e) {
                        console.log("chatCallback-------", e);
                        var from = e.data.fromDisplay || e.data.from || "Unknown";
                        var message = e.data.message || ""; // $('#chatwin')
                        //  .append($('<span class="chatuid" />').text(from + ':'))
                        //  .append($('<br />'))
                        //  .append(messageTextToJQ(message))
                        //  .append($('<br />'));
                        // $('#chatwin').animate({"scrollTop": $('#chatwin')[0].scrollHeight}, "fast");
                      }
                    });
                    self.setState({
                      confMan
                    });

                    if (!data.pvtData.canvasCount) {
                      data.pvtData.canvasCount = 1;
                    }

                    var canvasCount = data.pvtData.canvasCount + 0;

                    if (canvasCount <= 1) {//$("#canvasui").hide();
                    }

                    if (canvasCount > 1) {
                      // $("#canvasui").show();
                      // $("#canvasid").selectmenu({});
                      // $("#canvasid").selectmenu("enable");
                      // $("#canvasid").empty();
                      var x;

                      for (x = 1; x < canvasCount; x++) {} //$("#canvasid").append(new Option("Canvas " + (x + 1), (x + 1)));
                      // $("#canvasid").append(new Option("Super Canvas", x + 1));
                      // $("#canvasid").selectmenu('refresh', true);
                      // $("#canvasbut").click(function() {
                      //   var canvas_id = $("#canvasid").find(":selected").val();
                      //   var s = window.location.href;
                      //   s = s.replace(/\#.*/,'');
                      //   s += "#sessid=random&master=" + cur_call.callID + 
                      //       "&secondScreen=true&canvas_id=" + canvas_id + "&autocall=" + $("#ext").val() + "-canvas-" + canvas_id;
                      //   console.log("opening new window to " + s);
                      //   window.open(s, "canvas_window_" + canvas_id, "toolbar=0,location=0,menubar=0,directories=0,width=" + ($("#" + video_screen).width() + 50) + ",height=" + ($("#" + video_screen).height() + 400));
                      // });

                    } // $("#conf").show();
                    // $("#chatwin").html("");


                    if (data.pvtData.hipchatURL) {
                      var namex = $("#cidname").val();

                      if (!namex.indexOf(" ") > 0) {
                        namex += " " + $("#cid").val();
                      }

                      var name = namex.replace(/ /i, '%20'); // $('#hcmessage').hipChatPanel({
                      //   url: data.pvtData.hipchatURL + "?name=" + name,
                      //   timezone: "CST"
                      // });
                      // $("#hctop").show().find('.show-hipchat').click();
                    } else {//$("#message").show();
                      }

                    self.setState({
                      chatting_with: data.pvtData.chatChannel
                    });
                  }

                  break;
              }
            }

            break;

          case $.verto.enum.message.clientReady:
            //console.error("clientReady", data);
            break;

          case $.verto.enum.message.info:
            if (data.msg) {
              data = data.msg; //var body = data.body;

              /*
              // This section has been replaced with messageTextToJQ function
               if (body.match(/\.gif|\.jpg|\.jpeg|\.png/)) {
              var mod = "";
              if (body.match(/dropbox.com/)) {
              mod = "?dl=1";
              }
              body = body.replace(/(http[s]{0,1}:\/\/\S+)/g, "<a target='_blank' href='$1'>$1<br><img border='0' class='chatimg' src='$1'" + mod + "><\/a>");
              } else {
              body = body.replace(/(http[s]{0,1}:\/\/\S+)/g, "<a target='_blank' href='$1'>$1<\/a>");
              }
               if (body.slice(-1) !== "\n") {
              body += "\n";
              }
              body = body.replace(/(?:\r\n|\r|\n)/g, '<br />');
              
              var from = data.from_msg_name || data.from;
               $("#chatwin").append("<span class=chatuid>" + from + ":</span><br>" + body);
              $('#chatwin').animate({"scrollTop": $('#chatwin')[0].scrollHeight}, "fast");
              */
              //var from = data.from_msg_name || data.from;
              // $('#chatwin')
              //    .append($('<span class="chatuid" />').text(from + ':'))
              //    .append($('<br />'))
              //    .append(messageTextToJQ(body))
              //    .append($('<br />'));
              // $('#chatwin').animate({"scrollTop": $('#chatwin')[0].scrollHeight}, "fast");
            }

            if (data.txt) {
              console.log(data.txt);

              if (data.txt.chars) {
                var a = [...data.txt.chars]; //console.log(a);

                for (var x in a) {
                  if (a[x] == "\r") {
                    //$("#rtt_in").append("\n");
                    continue;
                  } else if (a[x] == "\b") {
                    //$("#rtt_in").text($("#rtt_in").text().slice(0, -1));
                    continue;
                  }

                  console.log("---------[" + a[x] + "]"); //$("#rtt_in").append(a[x]);
                } //var psconsole = $('#rtt_in');
                //if(psconsole.length)
                //psconsole.scrollTop(psconsole[0].scrollHeight - psconsole.height());

              }
            }

            break;

          case $.verto.enum.message.display:
            var party = dialog.params.remote_caller_id_name + "<" + dialog.params.remote_caller_id_number + ">";
            self.display("Talking to: " + dialog.cidString());
            break;

          default:
            break;
        }
      },
      onDialogState: function (d) {
        //console.error(d, share_call, d == share_call, d.state);
        if (d == self.state.share_call) {
          switch (d.state) {
            case $.verto.enum.state.early:
            case $.verto.enum.state.active:
              if (sessid) {
                this.state.cur_call.setMute("on");
                display("Viewing Canvas: " + canvas_id);
                this.state.vertoHandle.subscribe("presence", {
                  handler: function (v, e) {
                    if (e.data.channelUUID === master && e.data.channelCallState === "HANGUP") {
                      this.state.cur_call.hangup();
                    }
                  }
                });
              } else {
                display("Talking to: " + d.cidString());
              }

              break;

            case $.verto.enum.state.destroy:
              //$("#nosharebtn").hide();
              //$("#sharebtn").show();
              self.setState({
                share_call: null
              });
              break;
          }

          return;
        }

        if (!self.state.cur_call) {
          self.setState({
            cur_call: d
          });
        }

        if (d.state == $.verto.enum.state.ringing) {
          self.setState({
            ringing: true
          });
        } else {
          self.setState({
            ringing: false
          });
        }

        console.log("onDialogState----", d.state);

        switch (d.state) {
          case $.verto.enum.state.ringing:
            self.display("Call From: " + d.cidString());
            self.check_vid_res();
            $("#ansbtn").click(function () {
              console.error("WTF", cur_call, d);
              self.state.cur_call.answer({
                useStereo: $("#use_stereo").is(':checked'),
                callee_id_name: $("#cidname").val(),
                callee_id_number: $("#cid").val(),
                useCamera: $("#usecamera").find(":selected").val(),
                useMic: $("#usemic").find(":selected").val(),
                useSpeak: $("#usespeak").find(":selected").val()
              });
              $('#dialog-incoming-call').dialog('close');
            });
            $("#declinebtn").click(function () {
              cur_call.hangup({
                "cause": "CALL_REJECTED"
              });
              $('#dialog-incoming-call').dialog('close');
            });
            self.goto_dialog("incoming-call"); //$("#dialog-incoming-call-txt").text("Incoming call from: " + d.cidString());

            if (d.params.wantVideo) {
              $("#vansbtn").click(function () {
                $("#use_vid").prop("checked", true);
                cur_call.answer({
                  useVideo: true,
                  useStereo: $("#use_stereo").is(':checked'),
                  useCamera: $("#usecamera").find(":selected").val(),
                  useMic: $("#usemic").find(":selected").val(),
                  useSpeak: $("#usespeak").find(":selected").val()
                });
              }); // the buttons in this jquery mobile wont hide .. gotta wrap them in a div as a workaround

              $("#vansdiv").show();
            } else {
              $("#vansdiv").hide();
            }

            break;

          case $.verto.enum.state.trying:
            self.display("Calling: " + d.cidString()); //self.goto_page("incall");

            break;

          case $.verto.enum.state.early:
          case $.verto.enum.state.active:
            if (self.state.sessid) {
              console.log(`erto.enum.state.active--1111--${self.state.sessid}`);
              self.cur_call.setMute("on");
              self.display("Viewing Canvas: " + canvas_id);
              vertoHandle.subscribe("presence", {
                handler: function (v, e) {
                  if (e.data.channelUUID === master && e.data.channelCallState === "HANGUP") {//cur_call.hangup();
                  }
                }
              });
            } else {
              console.log(`erto.enum.state.active--22222--${d.cidString()}`);
              self.display("Talking to: " + d.cidString());
            } //self.goto_page("incall");
            //self.real_size();


            break;

          case $.verto.enum.state.hangup: //               $("#main_info").html("Call ended with cause: " + d.cause);
          //               self.goto_page("main");
          //               exit_full_screen();
          //                 case $.verto.enum.state.destroy:
          //               $("#hangup_cause").html("");
          //                     clearConfMan();
          //               real_size();
          //               self.setState({cur_call:null});
          //               if (sessid) {
          //                 setTimeout(function() {
          //                     delete $.verto.warnOnUnload;
          //                     window.close();
          //                 }, 500);
          //               }
          //               break;

          case $.verto.enum.state.held:
            break;

          default:
            self.display("");
            break;
        }
      },
      onWSLogin: function (v, success) {
        self.display("");
        self.setState({
          cur_call: null,
          ringing: false
        });

        if (success) {
          self.do_speed_test(function () {
            //self.online(true);
            //self.goto_page("main");
            // $("input[type='radio']").checkboxradio("refresh");
            // $("input[type='checkbox']").checkboxradio("refresh");

            /*
              verto.subscribe("presence", {
              handler: function(v, e) {
              console.error("PRESENCE:", e);
              }
              });
            */
            if (!window.location.hash) {//self.goto_page("main");
            }

            if (self.state.autocall) {
              //self.setState({autocall : false})
              self.docall();
            }
          });
        } else {//self.goto_page("main");
          //self.goto_dialog("login-error");
        }
      },
      onWSClose: function (v, success) {
        self.display(""); //self.online(false);

        var today = new Date(); //$("#errordisplay").html("Connection Error.<br>Last Attempt: " + today);
        //self.goto_page("main");

        if (self.state.sessid) {
          window.close();
        }
      },
      onEvent: function (v, e) {
        console.debug("GOT EVENT", e);
      }
    };
    let vertoHandle = new $.verto({
      login: 1001 + "@" + "za-yuanjing",
      passwd: "1234",
      socketUrl: `wss://${this.state.server_host}:8082`,
      //"wss://zafstest.zhonganinfo.com:8082",
      tag: this.state.video_screen,
      ringFile: "",
      sessid: this.state.sessid,
      videoParams: {
        //           "minWidth": this.state.vid_width,
        //           "minHeight": this.state.vid_height,
        //           "maxWidth": this.state.vid_width,
        //           "maxHeight": this.state.vid_height,
        "minWidth": 1080,
        "minHeight": 720,
        "maxWidth": 1080,
        "maxHeight": 720,
        "minFrameRate": 20,
        "vertoBestFrameRate": 30
      },
      deviceParams: {
        //useCamera: "",//$("#usecamera").find(":selected").val(),                                                                                                            useMic: $("#usemic").find(":selected").val(),
        //useSpeak: ""//$("#usespeak").find(":selected").val()
        useCamera: "none",
        //$.verto.videoDevices[0].id,//"c2a912b38b872c55dfb900c715879e9774db18ec41afc903a8d2fb2d5b388c29",
        useMic: "any",
        useSpeak: "any"
      },
      audioParams: {
        googAutoGainControl: true,
        googNoiseSuppression: true,
        googHighpassFilter: true
      },
      iceServers: true
    }, callbacks);
    self.setState({
      vertoHandle
    });
  } //设置成主持人全屏


  onLayer(item) {
    this.onReservation(item);
    this.state.confMan.modCommand("vid-layout", null, ['presenter-dual-horizontal', 1]);
  } //设置主持人


  onReservation(item) {
    this.state.confMan.modCommand("vid-res-id", item.cid, 'presenter');
    this.onVMute(item, true);
  } //设置右侧


  onMemberClick(boo) {
    this.setState({
      isRight: boo
    });
  } //设置自己关闭屏幕分享 分享设置为不分享


  onSetSelf() {
    this.onShareBtn(true);
  } //关闭声音


  onAMute(item, b) {
    if (b) {
      //true 打开音效
      if (!item.action.audio.muted) this.state.confMan.modCommand("tmute", item.acid, undefined);
    } else {
      //false 关闭音效
      if (item.action.audio.muted) this.state.confMan.modCommand("tmute", item.acid, undefined);
    }
  } //关闭视频


  onVMute(item, b) {
    if (b) {
      //true 打开视频
      if (!item.action.video.muted) this.state.confMan.modCommand("tvmute", item.cid, undefined);
    } else {
      //false 关闭视频
      if (item.action.video.muted) this.state.confMan.modCommand("tvmute", item.cid, undefined);
    }
  } //设置显示


  onSetClick(boo = null) {
    this.setState({
      isShowTip: boo == null ? !this.state.isShowTip : boo
    });
  } //关闭邀请


  //打开邀请
  onInvite() {
    const post = {};
    let message = JSON.stringify({
      id: this.state.id,
      meetId: this.state.meetingNumber,
      meetName: this.state.meetingName,
      from: this.state.userNickName,
      to: [],
      meeting_id: this.state.id,
      channel_id: "",
      time: Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* getFormatDate */ "b"])()
    });
    post.card_type = "5";
    post.channel_id = '';
    post.create_at = utils_utils_jsx__WEBPACK_IMPORTED_MODULE_32__[/* getTimestamp */ "E"]();
    post.file_ids = [];
    post.message = message;
    post.metadata = {};
    post.parent_id = undefined; //post.pending_post_id = `${this.props.currentUserId}:${post.create_at}`;//"d8k8hro3zj853cj7sc1yk8q4sy:1572868598607";//userid+time

    post.user_id = this.props.currentUserId;
    this.setState({
      postData: post
    }, () => {
      this.setState({
        showAdd: true
      });
    }); // this.props.actions.setChannelPostSelect({
    //     type: ChannelPostSelectType.INVITE,
    //     visibleSelectMember: true,
    //     postData: post,
    // });

    this.onSetClick(false);
  } //设置所有成员音效


  onSetAllAmute(boo, callback = null) {
    const value = boo ? "0" : "1";
    Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* updateConfig */ "q"])({
      meeting_id: window.meeting_id,
      "video_status": value,
      "voice_status": value
    }).then(() => {
      if (callback) callback();
    });
    this.onSetClick(false);
  } //频道是否可以说话


  isMeetCanSpack() {
    return this.state.voice_status == "1"; //0全频道静音 1可以说话
  } //设置自己音效


  onSetMyAmute() {
    if (!this.isMeetCanSpack() && !this.isPresenter()) {
      Object(api_post_js__WEBPACK_IMPORTED_MODULE_10__[/* meetingModal */ "m"])("全员静音");
      return;
    }

    this.state.userList.forEach(user => {
      if (this.isMy(user)) {
        //如果是自己
        this.setState({
          myAb: !this.state.myAb
        }, () => {
          this.onAMute(user, this.state.myAb);
        });
      }
    });
    this.onSetClick(false);
  } //长链接收到主持人设置频道音效


  onSocketSetMyAmute() {
    const sb = !this.isMeetCanSpack();
    this.state.userList.forEach(user => {
      if (this.isMy(user)) {
        //如果是自己设置
        this.setState({
          myAb: sb
        }, () => {
          this.onAMute(user, sb);
        });
      }
    }); //this.onSetClick(false);
  } //设置分享


  onShareBtn(b) {
    if (b == this.state.isNPShare) return;
    this.setState({
      isNPShare: !this.state.isNPShare
    }, () => {
      this.state.userList.forEach(user => {
        if (this.isMy(user)) {
          //如果是自己设置
          this.onVMute(user, this.state.isNPShare);
        }
      });
    });
    this.onSetClick(false);
  } //是否是自己


  isMy(user) {
    return user.webuid === this.state.userName;
  } //我是否是主持人


  isPresenter(b) {
    //if(b) console.log(`onSetMain---22222--${this.state.pHash}---${this.state.userName}---${this.state.pHash === this.state.userName}`);
    return this.state.pHash === this.state.userName;
  }

  render() {
    // if(this.props.closeMeetingId == window.meeting_id){
    //   window.clickType = 1;
    //   this.closeSelf();
    //   return;
    // }
    const avData = JSON.parse(localStorage.getItem('meetingAv')); //初始化完成 不是主持人 存在长链接数据 并且数据和之前的不同 则执行全局变更

    const isInElectron = window.navigator.userAgent.indexOf("Electron") !== -1;
    const count = isInElectron ? 2 : 4; //非端判断 web会有5次 端会有3次 不知道为什么 ..

    if (this.state.isFirstInit && !this.isPresenter() && avData && avData.meetingCount - this.lastMeetingCount > count) {
      this.lastMeetingCount = avData.meetingCount;
      this.setState({
        voice_status: avData.voice_status
      }, () => {
        this.onSocketSetMyAmute();
      });
    }

    let title = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "top-title"
    }, this.state.meetingName, " ", Object(utils_utils_jsx__WEBPACK_IMPORTED_MODULE_32__[/* refTimeTxt */ "lb"])(this.state.timeNum));
    let member;

    if (!this.state.isRight) {
      member = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "top-memmber",
        onClick: () => {
          this.onMemberClick(true);
        }
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
        src: _image_members_png__WEBPACK_IMPORTED_MODULE_12___default.a
      }), this.state.userList.length);
    }

    let presenter;
    presenter = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "btn-list-p"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "btn-list-item",
      onClick: () => {
        this.onSetMyAmute();
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: this.state.myAb ? _image_closemic2x_png__WEBPACK_IMPORTED_MODULE_23___default.a : _image_openmic2x_png__WEBPACK_IMPORTED_MODULE_22___default.a
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, this.state.myAb ? "静音" : "开启")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "btn-list-item",
      onClick: () => {
        this.onShareBtn(false);
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_share2x_png__WEBPACK_IMPORTED_MODULE_24___default.a
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, "\u5171\u4EAB")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "btn-list-item",
      onClick: () => {
        this.onSetClick();
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_set2x_png__WEBPACK_IMPORTED_MODULE_26___default.a
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, "\u8BBE\u7F6E")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "btn-list-item",
      onClick: () => {
        this.onInvite();
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_invite2x_png__WEBPACK_IMPORTED_MODULE_27___default.a
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, "\u9080\u8BF7")));
    let listener;
    listener = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "btn-list-s"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "btn-list-item",
      onClick: () => {
        this.onSetMyAmute();
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: this.state.myAb ? _image_closemic2x_png__WEBPACK_IMPORTED_MODULE_23___default.a : _image_openmic2x_png__WEBPACK_IMPORTED_MODULE_22___default.a
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, this.state.myAb ? "静音" : "开启")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "btn-list-item",
      onClick: () => {
        this.onInvite();
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_invite2x_png__WEBPACK_IMPORTED_MODULE_27___default.a
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, "\u9080\u8BF7")));
    let tip;
    tip = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "down-btn-tip"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "down-btn-tip-item",
      onClick: () => {
        this.onSetAllAmute(true);
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_closeallmic2x_png__WEBPACK_IMPORTED_MODULE_30___default.a
    }), "\u5168\u5458\u9759\u97F3"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "down-btn-tip-item",
      onClick: () => {
        this.onSetAllAmute(false);
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_openallmic_2x_png__WEBPACK_IMPORTED_MODULE_29___default.a
    }), "\u53D6\u6D88\u5168\u5458\u9759\u97F3"));
    let downBtn;
    downBtn = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "down-btn"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "down-btn-con"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: this.isPresenter() ? "down-btn-left" : "down-btn-left-s"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "down-btn-left-con"
    }, this.state.isShowTip && tip, this.isPresenter() ? presenter : listener)), !this.state.isNPShare && this.isPresenter() && //this.state.isNPShare &&
    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "down-btn-middle",
      onClick: () => {
        this.onShareBtn(true);
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_end_share2x_png__WEBPACK_IMPORTED_MODULE_25___default.a
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, "\u7ED3\u675F\u5171\u4EAB")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "down-btn-right"
    }, this.isPresenter() && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "down-btn-right-left",
      onClick: () => {
        this.onCloseAll();
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_closeVideo2x_png__WEBPACK_IMPORTED_MODULE_28___default.a
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, "\u7ED3\u675F\u4F1A\u8BAE")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "down-btn-right-right",
      onClick: e => {
        this.onClose(e);
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_outzoom2x_png__WEBPACK_IMPORTED_MODULE_14___default.a
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, "\u9000\u51FA")))));
    let rightList;
    let className = this.state.isRight ? "right-list-right" : "right-list";
    rightList = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: className
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "list-header"
    }, "\u53C2\u4F1A\u4EBA (", this.state.userList.length, "\u4EBA)", react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_closeRight_2x_png__WEBPACK_IMPORTED_MODULE_13___default.a,
      onClick: () => {
        this.onMemberClick(false);
      }
    })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "right-list-right-con"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(antd__WEBPACK_IMPORTED_MODULE_33__[/* default */ "a"], {
      dataSource: this.state.userList,
      renderItem: item => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "listItem",
        onClick: () => {
          this.onSetMain(item);
        }
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "list-inner"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
        src: this.getUserIconObject(item.webuid)
      }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "left"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "user"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        className: "user-name"
      }, item.name), item.isBuff && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        className: "user-buff"
      }, "\u4E3B\u6301\u4EBA")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        className: item.isBuff || !this.isPresenter() ? "user-setbuff-nobuff" : "user-setbuff"
      }, "\u8BBE\u7F6E\u4E3B\u6301\u4EBA")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: item.isVoice ? "right" : "right-close"
      })))
    }))); //const style = (!this.state.isSearch && !this.state.isSpeed) ? 'video-container-content-left-content-block': 'video-container-content-left-content-none';

    const style = !this.state.isSearch ? 'video-container-content-left-content-block' : 'video-container-content-left-content-none';
    const videoStyle = !this.state.isNPShare ? this.isPresenter() ? "video-container-center-no" : "video-container-center" : "video-container-center-no";
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "video-container"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "video-container-content"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "video-container-content-left"
    }, this.state.isSearch && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "search-container"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "search-container-show"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_loading_share_gif__WEBPACK_IMPORTED_MODULE_15___default.a
    }))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: style
    }, this.state.isNPShare && //!this.state.isNPShare &&
    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "search-container"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "search-container-show"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "container"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "pulse-2"
    })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: this.getMyIconObject()
    }))), !this.state.isNPShare && this.isPresenter() && //this.state.isNPShare &&
    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "search-container-cpu"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "search-container-show-cpu"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "search-container-show-cpu-con"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "container"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "pulse-2"
    })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: _image_cpu2x_png__WEBPACK_IMPORTED_MODULE_16___default.a
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "cpu-txt"
    }, "\u6B63\u5728\u5171\u4EAB\u5C4F\u5E55...")))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: videoStyle
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("video", {
      id: "webcam",
      autoplay: "autoplay",
      width: "100%",
      "webkit-controls": true,
      "webkit-playsinline": "true",
      playsinline: "true"
    })), downBtn)), rightList), title, member, this.state.showAdd && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(components_channel_new_invite_modal__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"], {
      onHide: this.onHide,
      channel: {
        id: ""
      },
      otherData: this.state.postData
    }));
  }

}

_defineProperty(App, "propTypes", {
  avData: PropTypes.object,
  //频道设置
  teamId: PropTypes.string,
  closeMeetingId: PropTypes.string,
  actions: PropTypes.shape({
    setChannelPostSelect: PropTypes.func.isRequired
  })
});

/* harmony default export */ __webpack_exports__["a"] = (App);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175)))

/***/ }),

/***/ 3231:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery v2.1.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function (a, b) {
   true && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function (a) {
    if (!a.document) throw new Error("jQuery requires a window with a document");
    return b(a);
  } : b(a);
}("undefined" != typeof window ? window : this, function (a, b) {
  var c = [],
      d = c.slice,
      e = c.concat,
      f = c.push,
      g = c.indexOf,
      h = {},
      i = h.toString,
      j = h.hasOwnProperty,
      k = {},
      l = a.document,
      m = "2.1.1",
      n = function (a, b) {
    return new n.fn.init(a, b);
  },
      o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      p = /^-ms-/,
      q = /-([\da-z])/gi,
      r = function (a, b) {
    return b.toUpperCase();
  };

  n.fn = n.prototype = {
    jquery: m,
    constructor: n,
    selector: "",
    length: 0,
    toArray: function () {
      return d.call(this);
    },
    get: function (a) {
      return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this);
    },
    pushStack: function (a) {
      var b = n.merge(this.constructor(), a);
      return b.prevObject = this, b.context = this.context, b;
    },
    each: function (a, b) {
      return n.each(this, a, b);
    },
    map: function (a) {
      return this.pushStack(n.map(this, function (b, c) {
        return a.call(b, c, b);
      }));
    },
    slice: function () {
      return this.pushStack(d.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (a) {
      var b = this.length,
          c = +a + (0 > a ? b : 0);
      return this.pushStack(c >= 0 && b > c ? [this[c]] : []);
    },
    end: function () {
      return this.prevObject || this.constructor(null);
    },
    push: f,
    sort: c.sort,
    splice: c.splice
  }, n.extend = n.fn.extend = function () {
    var a,
        b,
        c,
        d,
        e,
        f,
        g = arguments[0] || {},
        h = 1,
        i = arguments.length,
        j = !1;

    for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) if (null != (a = arguments[h])) for (b in a) c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));

    return g;
  }, n.extend({
    expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function (a) {
      throw new Error(a);
    },
    noop: function () {},
    isFunction: function (a) {
      return "function" === n.type(a);
    },
    isArray: Array.isArray,
    isWindow: function (a) {
      return null != a && a === a.window;
    },
    isNumeric: function (a) {
      return !n.isArray(a) && a - parseFloat(a) >= 0;
    },
    isPlainObject: function (a) {
      return "object" !== n.type(a) || a.nodeType || n.isWindow(a) ? !1 : a.constructor && !j.call(a.constructor.prototype, "isPrototypeOf") ? !1 : !0;
    },
    isEmptyObject: function (a) {
      var b;

      for (b in a) return !1;

      return !0;
    },
    type: function (a) {
      return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a;
    },
    globalEval: function (a) {
      var b,
          c = eval;
      a = n.trim(a), a && (1 === a.indexOf("use strict") ? (b = l.createElement("script"), b.text = a, l.head.appendChild(b).parentNode.removeChild(b)) : c(a));
    },
    camelCase: function (a) {
      return a.replace(p, "ms-").replace(q, r);
    },
    nodeName: function (a, b) {
      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
    },
    each: function (a, b, c) {
      var d,
          e = 0,
          f = a.length,
          g = s(a);

      if (c) {
        if (g) {
          for (; f > e; e++) if (d = b.apply(a[e], c), d === !1) break;
        } else for (e in a) if (d = b.apply(a[e], c), d === !1) break;
      } else if (g) {
        for (; f > e; e++) if (d = b.call(a[e], e, a[e]), d === !1) break;
      } else for (e in a) if (d = b.call(a[e], e, a[e]), d === !1) break;

      return a;
    },
    trim: function (a) {
      return null == a ? "" : (a + "").replace(o, "");
    },
    makeArray: function (a, b) {
      var c = b || [];
      return null != a && (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c;
    },
    inArray: function (a, b, c) {
      return null == b ? -1 : g.call(b, a, c);
    },
    merge: function (a, b) {
      for (var c = +b.length, d = 0, e = a.length; c > d; d++) a[e++] = b[d];

      return a.length = e, a;
    },
    grep: function (a, b, c) {
      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);

      return e;
    },
    map: function (a, b, c) {
      var d,
          f = 0,
          g = a.length,
          h = s(a),
          i = [];
      if (h) for (; g > f; f++) d = b(a[f], f, c), null != d && i.push(d);else for (f in a) d = b(a[f], f, c), null != d && i.push(d);
      return e.apply([], i);
    },
    guid: 1,
    proxy: function (a, b) {
      var c, e, f;
      return "string" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (e = d.call(arguments, 2), f = function () {
        return a.apply(b || this, e.concat(d.call(arguments)));
      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0;
    },
    now: Date.now,
    support: k
  }), n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (a, b) {
    h["[object " + b + "]"] = b.toLowerCase();
  });

  function s(a) {
    var b = a.length,
        c = n.type(a);
    return "function" === c || n.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a;
  }

  var t = function (a) {
    var b,
        c,
        d,
        e,
        f,
        g,
        h,
        i,
        j,
        k,
        l,
        m,
        n,
        o,
        p,
        q,
        r,
        s,
        t,
        u = "sizzle" + -new Date(),
        v = a.document,
        w = 0,
        x = 0,
        y = gb(),
        z = gb(),
        A = gb(),
        B = function (a, b) {
      return a === b && (l = !0), 0;
    },
        C = "undefined",
        D = 1 << 31,
        E = {}.hasOwnProperty,
        F = [],
        G = F.pop,
        H = F.push,
        I = F.push,
        J = F.slice,
        K = F.indexOf || function (a) {
      for (var b = 0, c = this.length; c > b; b++) if (this[b] === a) return b;

      return -1;
    },
        L = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        M = "[\\x20\\t\\r\\n\\f]",
        N = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        O = N.replace("w", "w#"),
        P = "\\[" + M + "*(" + N + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + O + "))|)" + M + "*\\]",
        Q = ":(" + N + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + P + ")*)|.*)\\)|)",
        R = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
        S = new RegExp("^" + M + "*," + M + "*"),
        T = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
        U = new RegExp("=" + M + "*([^\\]'\"]*?)" + M + "*\\]", "g"),
        V = new RegExp(Q),
        W = new RegExp("^" + O + "$"),
        X = {
      ID: new RegExp("^#(" + N + ")"),
      CLASS: new RegExp("^\\.(" + N + ")"),
      TAG: new RegExp("^(" + N.replace("w", "w*") + ")"),
      ATTR: new RegExp("^" + P),
      PSEUDO: new RegExp("^" + Q),
      CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"),
      bool: new RegExp("^(?:" + L + ")$", "i"),
      needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i")
    },
        Y = /^(?:input|select|textarea|button)$/i,
        Z = /^h\d$/i,
        $ = /^[^{]+\{\s*\[native \w/,
        _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        ab = /[+~]/,
        bb = /'|\\/g,
        cb = new RegExp("\\\\([\\da-f]{1,6}" + M + "?|(" + M + ")|.)", "ig"),
        db = function (a, b, c) {
      var d = "0x" + b - 65536;
      return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);
    };

    try {
      I.apply(F = J.call(v.childNodes), v.childNodes), F[v.childNodes.length].nodeType;
    } catch (eb) {
      I = {
        apply: F.length ? function (a, b) {
          H.apply(a, J.call(b));
        } : function (a, b) {
          var c = a.length,
              d = 0;

          while (a[c++] = b[d++]);

          a.length = c - 1;
        }
      };
    }

    function fb(a, b, d, e) {
      var f, h, j, k, l, o, r, s, w, x;
      if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], !a || "string" != typeof a) return d;
      if (1 !== (k = b.nodeType) && 9 !== k) return [];

      if (p && !e) {
        if (f = _.exec(a)) if (j = f[1]) {
          if (9 === k) {
            if (h = b.getElementById(j), !h || !h.parentNode) return d;
            if (h.id === j) return d.push(h), d;
          } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j) return d.push(h), d;
        } else {
          if (f[2]) return I.apply(d, b.getElementsByTagName(a)), d;
          if ((j = f[3]) && c.getElementsByClassName && b.getElementsByClassName) return I.apply(d, b.getElementsByClassName(j)), d;
        }

        if (c.qsa && (!q || !q.test(a))) {
          if (s = r = u, w = b, x = 9 === k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
            o = g(a), (r = b.getAttribute("id")) ? s = r.replace(bb, "\\$&") : b.setAttribute("id", s), s = "[id='" + s + "'] ", l = o.length;

            while (l--) o[l] = s + qb(o[l]);

            w = ab.test(a) && ob(b.parentNode) || b, x = o.join(",");
          }

          if (x) try {
            return I.apply(d, w.querySelectorAll(x)), d;
          } catch (y) {} finally {
            r || b.removeAttribute("id");
          }
        }
      }

      return i(a.replace(R, "$1"), b, d, e);
    }

    function gb() {
      var a = [];

      function b(c, e) {
        return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e;
      }

      return b;
    }

    function hb(a) {
      return a[u] = !0, a;
    }

    function ib(a) {
      var b = n.createElement("div");

      try {
        return !!a(b);
      } catch (c) {
        return !1;
      } finally {
        b.parentNode && b.parentNode.removeChild(b), b = null;
      }
    }

    function jb(a, b) {
      var c = a.split("|"),
          e = a.length;

      while (e--) d.attrHandle[c[e]] = b;
    }

    function kb(a, b) {
      var c = b && a,
          d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || D) - (~a.sourceIndex || D);
      if (d) return d;
      if (c) while (c = c.nextSibling) if (c === b) return -1;
      return a ? 1 : -1;
    }

    function lb(a) {
      return function (b) {
        var c = b.nodeName.toLowerCase();
        return "input" === c && b.type === a;
      };
    }

    function mb(a) {
      return function (b) {
        var c = b.nodeName.toLowerCase();
        return ("input" === c || "button" === c) && b.type === a;
      };
    }

    function nb(a) {
      return hb(function (b) {
        return b = +b, hb(function (c, d) {
          var e,
              f = a([], c.length, b),
              g = f.length;

          while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e]));
        });
      });
    }

    function ob(a) {
      return a && typeof a.getElementsByTagName !== C && a;
    }

    c = fb.support = {}, f = fb.isXML = function (a) {
      var b = a && (a.ownerDocument || a).documentElement;
      return b ? "HTML" !== b.nodeName : !1;
    }, m = fb.setDocument = function (a) {
      var b,
          e = a ? a.ownerDocument || a : v,
          g = e.defaultView;
      return e !== n && 9 === e.nodeType && e.documentElement ? (n = e, o = e.documentElement, p = !f(e), g && g !== g.top && (g.addEventListener ? g.addEventListener("unload", function () {
        m();
      }, !1) : g.attachEvent && g.attachEvent("onunload", function () {
        m();
      })), c.attributes = ib(function (a) {
        return a.className = "i", !a.getAttribute("className");
      }), c.getElementsByTagName = ib(function (a) {
        return a.appendChild(e.createComment("")), !a.getElementsByTagName("*").length;
      }), c.getElementsByClassName = $.test(e.getElementsByClassName) && ib(function (a) {
        return a.innerHTML = "<div class='a'></div><div class='a i'></div>", a.firstChild.className = "i", 2 === a.getElementsByClassName("i").length;
      }), c.getById = ib(function (a) {
        return o.appendChild(a).id = u, !e.getElementsByName || !e.getElementsByName(u).length;
      }), c.getById ? (d.find.ID = function (a, b) {
        if (typeof b.getElementById !== C && p) {
          var c = b.getElementById(a);
          return c && c.parentNode ? [c] : [];
        }
      }, d.filter.ID = function (a) {
        var b = a.replace(cb, db);
        return function (a) {
          return a.getAttribute("id") === b;
        };
      }) : (delete d.find.ID, d.filter.ID = function (a) {
        var b = a.replace(cb, db);
        return function (a) {
          var c = typeof a.getAttributeNode !== C && a.getAttributeNode("id");
          return c && c.value === b;
        };
      }), d.find.TAG = c.getElementsByTagName ? function (a, b) {
        return typeof b.getElementsByTagName !== C ? b.getElementsByTagName(a) : void 0;
      } : function (a, b) {
        var c,
            d = [],
            e = 0,
            f = b.getElementsByTagName(a);

        if ("*" === a) {
          while (c = f[e++]) 1 === c.nodeType && d.push(c);

          return d;
        }

        return f;
      }, d.find.CLASS = c.getElementsByClassName && function (a, b) {
        return typeof b.getElementsByClassName !== C && p ? b.getElementsByClassName(a) : void 0;
      }, r = [], q = [], (c.qsa = $.test(e.querySelectorAll)) && (ib(function (a) {
        a.innerHTML = "<select msallowclip=''><option selected=''></option></select>", a.querySelectorAll("[msallowclip^='']").length && q.push("[*^$]=" + M + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + M + "*(?:value|" + L + ")"), a.querySelectorAll(":checked").length || q.push(":checked");
      }), ib(function (a) {
        var b = e.createElement("input");
        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + M + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:");
      })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ib(function (a) {
        c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", Q);
      }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function (a, b) {
        var c = 9 === a.nodeType ? a.documentElement : a,
            d = b && b.parentNode;
        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));
      } : function (a, b) {
        if (b) while (b = b.parentNode) if (b === a) return !0;
        return !1;
      }, B = b ? function (a, b) {
        if (a === b) return l = !0, 0;
        var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
        return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === e || a.ownerDocument === v && t(v, a) ? -1 : b === e || b.ownerDocument === v && t(v, b) ? 1 : k ? K.call(k, a) - K.call(k, b) : 0 : 4 & d ? -1 : 1);
      } : function (a, b) {
        if (a === b) return l = !0, 0;
        var c,
            d = 0,
            f = a.parentNode,
            g = b.parentNode,
            h = [a],
            i = [b];
        if (!f || !g) return a === e ? -1 : b === e ? 1 : f ? -1 : g ? 1 : k ? K.call(k, a) - K.call(k, b) : 0;
        if (f === g) return kb(a, b);
        c = a;

        while (c = c.parentNode) h.unshift(c);

        c = b;

        while (c = c.parentNode) i.unshift(c);

        while (h[d] === i[d]) d++;

        return d ? kb(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0;
      }, e) : n;
    }, fb.matches = function (a, b) {
      return fb(a, null, null, b);
    }, fb.matchesSelector = function (a, b) {
      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b))) try {
        var d = s.call(a, b);
        if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
      } catch (e) {}
      return fb(b, n, null, [a]).length > 0;
    }, fb.contains = function (a, b) {
      return (a.ownerDocument || a) !== n && m(a), t(a, b);
    }, fb.attr = function (a, b) {
      (a.ownerDocument || a) !== n && m(a);
      var e = d.attrHandle[b.toLowerCase()],
          f = e && E.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
      return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;
    }, fb.error = function (a) {
      throw new Error("Syntax error, unrecognized expression: " + a);
    }, fb.uniqueSort = function (a) {
      var b,
          d = [],
          e = 0,
          f = 0;

      if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
        while (b = a[f++]) b === a[f] && (e = d.push(f));

        while (e--) a.splice(d[e], 1);
      }

      return k = null, a;
    }, e = fb.getText = function (a) {
      var b,
          c = "",
          d = 0,
          f = a.nodeType;

      if (f) {
        if (1 === f || 9 === f || 11 === f) {
          if ("string" == typeof a.textContent) return a.textContent;

          for (a = a.firstChild; a; a = a.nextSibling) c += e(a);
        } else if (3 === f || 4 === f) return a.nodeValue;
      } else while (b = a[d++]) c += e(b);

      return c;
    }, d = fb.selectors = {
      cacheLength: 50,
      createPseudo: hb,
      match: X,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: !0
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: !0
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        ATTR: function (a) {
          return a[1] = a[1].replace(cb, db), a[3] = (a[3] || a[4] || a[5] || "").replace(cb, db), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4);
        },
        CHILD: function (a) {
          return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || fb.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && fb.error(a[0]), a;
        },
        PSEUDO: function (a) {
          var b,
              c = !a[6] && a[2];
          return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));
        }
      },
      filter: {
        TAG: function (a) {
          var b = a.replace(cb, db).toLowerCase();
          return "*" === a ? function () {
            return !0;
          } : function (a) {
            return a.nodeName && a.nodeName.toLowerCase() === b;
          };
        },
        CLASS: function (a) {
          var b = y[a + " "];
          return b || (b = new RegExp("(^|" + M + ")" + a + "(" + M + "|$)")) && y(a, function (a) {
            return b.test("string" == typeof a.className && a.className || typeof a.getAttribute !== C && a.getAttribute("class") || "");
          });
        },
        ATTR: function (a, b, c) {
          return function (d) {
            var e = fb.attr(d, a);
            return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0;
          };
        },
        CHILD: function (a, b, c, d, e) {
          var f = "nth" !== a.slice(0, 3),
              g = "last" !== a.slice(-4),
              h = "of-type" === b;
          return 1 === d && 0 === e ? function (a) {
            return !!a.parentNode;
          } : function (b, c, i) {
            var j,
                k,
                l,
                m,
                n,
                o,
                p = f !== g ? "nextSibling" : "previousSibling",
                q = b.parentNode,
                r = h && b.nodeName.toLowerCase(),
                s = !i && !h;

            if (q) {
              if (f) {
                while (p) {
                  l = b;

                  while (l = l[p]) if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;

                  o = p = "only" === a && !o && "nextSibling";
                }

                return !0;
              }

              if (o = [g ? q.firstChild : q.lastChild], g && s) {
                k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2], l = n && q.childNodes[n];

                while (l = ++n && l && l[p] || (m = n = 0) || o.pop()) if (1 === l.nodeType && ++m && l === b) {
                  k[a] = [w, n, m];
                  break;
                }
              } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w) m = j[1];else while (l = ++n && l && l[p] || (m = n = 0) || o.pop()) if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (s && ((l[u] || (l[u] = {}))[a] = [w, m]), l === b)) break;

              return m -= e, m === d || m % d === 0 && m / d >= 0;
            }
          };
        },
        PSEUDO: function (a, b) {
          var c,
              e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fb.error("unsupported pseudo: " + a);
          return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? hb(function (a, c) {
            var d,
                f = e(a, b),
                g = f.length;

            while (g--) d = K.call(a, f[g]), a[d] = !(c[d] = f[g]);
          }) : function (a) {
            return e(a, 0, c);
          }) : e;
        }
      },
      pseudos: {
        not: hb(function (a) {
          var b = [],
              c = [],
              d = h(a.replace(R, "$1"));
          return d[u] ? hb(function (a, b, c, e) {
            var f,
                g = d(a, null, e, []),
                h = a.length;

            while (h--) (f = g[h]) && (a[h] = !(b[h] = f));
          }) : function (a, e, f) {
            return b[0] = a, d(b, null, f, c), !c.pop();
          };
        }),
        has: hb(function (a) {
          return function (b) {
            return fb(a, b).length > 0;
          };
        }),
        contains: hb(function (a) {
          return function (b) {
            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;
          };
        }),
        lang: hb(function (a) {
          return W.test(a || "") || fb.error("unsupported lang: " + a), a = a.replace(cb, db).toLowerCase(), function (b) {
            var c;

            do if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);

            return !1;
          };
        }),
        target: function (b) {
          var c = a.location && a.location.hash;
          return c && c.slice(1) === b.id;
        },
        root: function (a) {
          return a === o;
        },
        focus: function (a) {
          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);
        },
        enabled: function (a) {
          return a.disabled === !1;
        },
        disabled: function (a) {
          return a.disabled === !0;
        },
        checked: function (a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b && !!a.checked || "option" === b && !!a.selected;
        },
        selected: function (a) {
          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;
        },
        empty: function (a) {
          for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1;

          return !0;
        },
        parent: function (a) {
          return !d.pseudos.empty(a);
        },
        header: function (a) {
          return Z.test(a.nodeName);
        },
        input: function (a) {
          return Y.test(a.nodeName);
        },
        button: function (a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b && "button" === a.type || "button" === b;
        },
        text: function (a) {
          var b;
          return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase());
        },
        first: nb(function () {
          return [0];
        }),
        last: nb(function (a, b) {
          return [b - 1];
        }),
        eq: nb(function (a, b, c) {
          return [0 > c ? c + b : c];
        }),
        even: nb(function (a, b) {
          for (var c = 0; b > c; c += 2) a.push(c);

          return a;
        }),
        odd: nb(function (a, b) {
          for (var c = 1; b > c; c += 2) a.push(c);

          return a;
        }),
        lt: nb(function (a, b, c) {
          for (var d = 0 > c ? c + b : c; --d >= 0;) a.push(d);

          return a;
        }),
        gt: nb(function (a, b, c) {
          for (var d = 0 > c ? c + b : c; ++d < b;) a.push(d);

          return a;
        })
      }
    }, d.pseudos.nth = d.pseudos.eq;

    for (b in {
      radio: !0,
      checkbox: !0,
      file: !0,
      password: !0,
      image: !0
    }) d.pseudos[b] = lb(b);

    for (b in {
      submit: !0,
      reset: !0
    }) d.pseudos[b] = mb(b);

    function pb() {}

    pb.prototype = d.filters = d.pseudos, d.setFilters = new pb(), g = fb.tokenize = function (a, b) {
      var c,
          e,
          f,
          g,
          h,
          i,
          j,
          k = z[a + " "];
      if (k) return b ? 0 : k.slice(0);
      h = a, i = [], j = d.preFilter;

      while (h) {
        (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({
          value: c,
          type: e[0].replace(R, " ")
        }), h = h.slice(c.length));

        for (g in d.filter) !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({
          value: c,
          type: g,
          matches: e
        }), h = h.slice(c.length));

        if (!c) break;
      }

      return b ? h.length : h ? fb.error(a) : z(a, i).slice(0);
    };

    function qb(a) {
      for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;

      return d;
    }

    function rb(a, b, c) {
      var d = b.dir,
          e = c && "parentNode" === d,
          f = x++;
      return b.first ? function (b, c, f) {
        while (b = b[d]) if (1 === b.nodeType || e) return a(b, c, f);
      } : function (b, c, g) {
        var h,
            i,
            j = [w, f];

        if (g) {
          while (b = b[d]) if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
        } else while (b = b[d]) if (1 === b.nodeType || e) {
          if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f) return j[2] = h[2];
          if (i[d] = j, j[2] = a(b, c, g)) return !0;
        }
      };
    }

    function sb(a) {
      return a.length > 1 ? function (b, c, d) {
        var e = a.length;

        while (e--) if (!a[e](b, c, d)) return !1;

        return !0;
      } : a[0];
    }

    function tb(a, b, c) {
      for (var d = 0, e = b.length; e > d; d++) fb(a, b[d], c);

      return c;
    }

    function ub(a, b, c, d, e) {
      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));

      return g;
    }

    function vb(a, b, c, d, e, f) {
      return d && !d[u] && (d = vb(d)), e && !e[u] && (e = vb(e, f)), hb(function (f, g, h, i) {
        var j,
            k,
            l,
            m = [],
            n = [],
            o = g.length,
            p = f || tb(b || "*", h.nodeType ? [h] : h, []),
            q = !a || !f && b ? p : ub(p, m, a, h, i),
            r = c ? e || (f ? a : o || d) ? [] : g : q;

        if (c && c(q, r, h, i), d) {
          j = ub(r, n), d(j, [], h, i), k = j.length;

          while (k--) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
        }

        if (f) {
          if (e || a) {
            if (e) {
              j = [], k = r.length;

              while (k--) (l = r[k]) && j.push(q[k] = l);

              e(null, r = [], j, i);
            }

            k = r.length;

            while (k--) (l = r[k]) && (j = e ? K.call(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));
          }
        } else r = ub(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : I.apply(g, r);
      });
    }

    function wb(a) {
      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = rb(function (a) {
        return a === b;
      }, h, !0), l = rb(function (a) {
        return K.call(b, a) > -1;
      }, h, !0), m = [function (a, c, d) {
        return !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
      }]; f > i; i++) if (c = d.relative[a[i].type]) m = [rb(sb(m), c)];else {
        if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
          for (e = ++i; f > e; e++) if (d.relative[a[e].type]) break;

          return vb(i > 1 && sb(m), i > 1 && qb(a.slice(0, i - 1).concat({
            value: " " === a[i - 2].type ? "*" : ""
          })).replace(R, "$1"), c, e > i && wb(a.slice(i, e)), f > e && wb(a = a.slice(e)), f > e && qb(a));
        }

        m.push(c);
      }

      return sb(m);
    }

    function xb(a, b) {
      var c = b.length > 0,
          e = a.length > 0,
          f = function (f, g, h, i, k) {
        var l,
            m,
            o,
            p = 0,
            q = "0",
            r = f && [],
            s = [],
            t = j,
            u = f || e && d.find.TAG("*", k),
            v = w += null == t ? 1 : Math.random() || .1,
            x = u.length;

        for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
          if (e && l) {
            m = 0;

            while (o = a[m++]) if (o(l, g, h)) {
              i.push(l);
              break;
            }

            k && (w = v);
          }

          c && ((l = !o && l) && p--, f && r.push(l));
        }

        if (p += q, c && q !== p) {
          m = 0;

          while (o = b[m++]) o(r, s, g, h);

          if (f) {
            if (p > 0) while (q--) r[q] || s[q] || (s[q] = G.call(i));
            s = ub(s);
          }

          I.apply(i, s), k && !f && s.length > 0 && p + b.length > 1 && fb.uniqueSort(i);
        }

        return k && (w = v, j = t), r;
      };

      return c ? hb(f) : f;
    }

    return h = fb.compile = function (a, b) {
      var c,
          d = [],
          e = [],
          f = A[a + " "];

      if (!f) {
        b || (b = g(a)), c = b.length;

        while (c--) f = wb(b[c]), f[u] ? d.push(f) : e.push(f);

        f = A(a, xb(e, d)), f.selector = a;
      }

      return f;
    }, i = fb.select = function (a, b, e, f) {
      var i,
          j,
          k,
          l,
          m,
          n = "function" == typeof a && a,
          o = !f && g(a = n.selector || a);

      if (e = e || [], 1 === o.length) {
        if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
          if (b = (d.find.ID(k.matches[0].replace(cb, db), b) || [])[0], !b) return e;
          n && (b = b.parentNode), a = a.slice(j.shift().value.length);
        }

        i = X.needsContext.test(a) ? 0 : j.length;

        while (i--) {
          if (k = j[i], d.relative[l = k.type]) break;

          if ((m = d.find[l]) && (f = m(k.matches[0].replace(cb, db), ab.test(j[0].type) && ob(b.parentNode) || b))) {
            if (j.splice(i, 1), a = f.length && qb(j), !a) return I.apply(e, f), e;
            break;
          }
        }
      }

      return (n || h(a, o))(f, b, !p, e, ab.test(a) && ob(b.parentNode) || b), e;
    }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ib(function (a) {
      return 1 & a.compareDocumentPosition(n.createElement("div"));
    }), ib(function (a) {
      return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href");
    }) || jb("type|href|height|width", function (a, b, c) {
      return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
    }), c.attributes && ib(function (a) {
      return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value");
    }) || jb("value", function (a, b, c) {
      return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;
    }), ib(function (a) {
      return null == a.getAttribute("disabled");
    }) || jb(L, function (a, b, c) {
      var d;
      return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
    }), fb;
  }(a);

  n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;
  var u = n.expr.match.needsContext,
      v = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
      w = /^.[^:#\[\.,]*$/;

  function x(a, b, c) {
    if (n.isFunction(b)) return n.grep(a, function (a, d) {
      return !!b.call(a, d, a) !== c;
    });
    if (b.nodeType) return n.grep(a, function (a) {
      return a === b !== c;
    });

    if ("string" == typeof b) {
      if (w.test(b)) return n.filter(b, a, c);
      b = n.filter(b, a);
    }

    return n.grep(a, function (a) {
      return g.call(b, a) >= 0 !== c;
    });
  }

  n.filter = function (a, b, c) {
    var d = b[0];
    return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {
      return 1 === a.nodeType;
    }));
  }, n.fn.extend({
    find: function (a) {
      var b,
          c = this.length,
          d = [],
          e = this;
      if ("string" != typeof a) return this.pushStack(n(a).filter(function () {
        for (b = 0; c > b; b++) if (n.contains(e[b], this)) return !0;
      }));

      for (b = 0; c > b; b++) n.find(a, e[b], d);

      return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + " " + a : a, d;
    },
    filter: function (a) {
      return this.pushStack(x(this, a || [], !1));
    },
    not: function (a) {
      return this.pushStack(x(this, a || [], !0));
    },
    is: function (a) {
      return !!x(this, "string" == typeof a && u.test(a) ? n(a) : a || [], !1).length;
    }
  });

  var y,
      z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      A = n.fn.init = function (a, b) {
    var c, d;
    if (!a) return this;

    if ("string" == typeof a) {
      if (c = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : z.exec(a), !c || !c[1] && b) return !b || b.jquery ? (b || y).find(a) : this.constructor(b).find(a);

      if (c[1]) {
        if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : l, !0)), v.test(c[1]) && n.isPlainObject(b)) for (c in b) n.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
        return this;
      }

      return d = l.getElementById(c[2]), d && d.parentNode && (this.length = 1, this[0] = d), this.context = l, this.selector = a, this;
    }

    return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? "undefined" != typeof y.ready ? y.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this));
  };

  A.prototype = n.fn, y = n(l);
  var B = /^(?:parents|prev(?:Until|All))/,
      C = {
    children: !0,
    contents: !0,
    next: !0,
    prev: !0
  };
  n.extend({
    dir: function (a, b, c) {
      var d = [],
          e = void 0 !== c;

      while ((a = a[b]) && 9 !== a.nodeType) if (1 === a.nodeType) {
        if (e && n(a).is(c)) break;
        d.push(a);
      }

      return d;
    },
    sibling: function (a, b) {
      for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);

      return c;
    }
  }), n.fn.extend({
    has: function (a) {
      var b = n(a, this),
          c = b.length;
      return this.filter(function () {
        for (var a = 0; c > a; a++) if (n.contains(this, b[a])) return !0;
      });
    },
    closest: function (a, b) {
      for (var c, d = 0, e = this.length, f = [], g = u.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e > d; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {
        f.push(c);
        break;
      }

      return this.pushStack(f.length > 1 ? n.unique(f) : f);
    },
    index: function (a) {
      return a ? "string" == typeof a ? g.call(n(a), this[0]) : g.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
    },
    add: function (a, b) {
      return this.pushStack(n.unique(n.merge(this.get(), n(a, b))));
    },
    addBack: function (a) {
      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
    }
  });

  function D(a, b) {
    while ((a = a[b]) && 1 !== a.nodeType);

    return a;
  }

  n.each({
    parent: function (a) {
      var b = a.parentNode;
      return b && 11 !== b.nodeType ? b : null;
    },
    parents: function (a) {
      return n.dir(a, "parentNode");
    },
    parentsUntil: function (a, b, c) {
      return n.dir(a, "parentNode", c);
    },
    next: function (a) {
      return D(a, "nextSibling");
    },
    prev: function (a) {
      return D(a, "previousSibling");
    },
    nextAll: function (a) {
      return n.dir(a, "nextSibling");
    },
    prevAll: function (a) {
      return n.dir(a, "previousSibling");
    },
    nextUntil: function (a, b, c) {
      return n.dir(a, "nextSibling", c);
    },
    prevUntil: function (a, b, c) {
      return n.dir(a, "previousSibling", c);
    },
    siblings: function (a) {
      return n.sibling((a.parentNode || {}).firstChild, a);
    },
    children: function (a) {
      return n.sibling(a.firstChild);
    },
    contents: function (a) {
      return a.contentDocument || n.merge([], a.childNodes);
    }
  }, function (a, b) {
    n.fn[a] = function (c, d) {
      var e = n.map(this, b, c);
      return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = n.filter(d, e)), this.length > 1 && (C[a] || n.unique(e), B.test(a) && e.reverse()), this.pushStack(e);
    };
  });
  var E = /\S+/g,
      F = {};

  function G(a) {
    var b = F[a] = {};
    return n.each(a.match(E) || [], function (a, c) {
      b[c] = !0;
    }), b;
  }

  n.Callbacks = function (a) {
    a = "string" == typeof a ? F[a] || G(a) : n.extend({}, a);

    var b,
        c,
        d,
        e,
        f,
        g,
        h = [],
        i = !a.once && [],
        j = function (l) {
      for (b = a.memory && l, c = !0, g = e || 0, e = 0, f = h.length, d = !0; h && f > g; g++) if (h[g].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
        b = !1;
        break;
      }

      d = !1, h && (i ? i.length && j(i.shift()) : b ? h = [] : k.disable());
    },
        k = {
      add: function () {
        if (h) {
          var c = h.length;
          !function g(b) {
            n.each(b, function (b, c) {
              var d = n.type(c);
              "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && g(c);
            });
          }(arguments), d ? f = h.length : b && (e = c, j(b));
        }

        return this;
      },
      remove: function () {
        return h && n.each(arguments, function (a, b) {
          var c;

          while ((c = n.inArray(b, h, c)) > -1) h.splice(c, 1), d && (f >= c && f--, g >= c && g--);
        }), this;
      },
      has: function (a) {
        return a ? n.inArray(a, h) > -1 : !(!h || !h.length);
      },
      empty: function () {
        return h = [], f = 0, this;
      },
      disable: function () {
        return h = i = b = void 0, this;
      },
      disabled: function () {
        return !h;
      },
      lock: function () {
        return i = void 0, b || k.disable(), this;
      },
      locked: function () {
        return !i;
      },
      fireWith: function (a, b) {
        return !h || c && !i || (b = b || [], b = [a, b.slice ? b.slice() : b], d ? i.push(b) : j(b)), this;
      },
      fire: function () {
        return k.fireWith(this, arguments), this;
      },
      fired: function () {
        return !!c;
      }
    };

    return k;
  }, n.extend({
    Deferred: function (a) {
      var b = [["resolve", "done", n.Callbacks("once memory"), "resolved"], ["reject", "fail", n.Callbacks("once memory"), "rejected"], ["notify", "progress", n.Callbacks("memory")]],
          c = "pending",
          d = {
        state: function () {
          return c;
        },
        always: function () {
          return e.done(arguments).fail(arguments), this;
        },
        then: function () {
          var a = arguments;
          return n.Deferred(function (c) {
            n.each(b, function (b, f) {
              var g = n.isFunction(a[b]) && a[b];
              e[f[1]](function () {
                var a = g && g.apply(this, arguments);
                a && n.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments);
              });
            }), a = null;
          }).promise();
        },
        promise: function (a) {
          return null != a ? n.extend(a, d) : d;
        }
      },
          e = {};
      return d.pipe = d.then, n.each(b, function (a, f) {
        var g = f[2],
            h = f[3];
        d[f[1]] = g.add, h && g.add(function () {
          c = h;
        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {
          return e[f[0] + "With"](this === e ? d : this, arguments), this;
        }, e[f[0] + "With"] = g.fireWith;
      }), d.promise(e), a && a.call(e, e), e;
    },
    when: function (a) {
      var b = 0,
          c = d.call(arguments),
          e = c.length,
          f = 1 !== e || a && n.isFunction(a.promise) ? e : 0,
          g = 1 === f ? a : n.Deferred(),
          h = function (a, b, c) {
        return function (e) {
          b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);
        };
      },
          i,
          j,
          k;

      if (e > 1) for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) c[b] && n.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
      return f || g.resolveWith(k, c), g.promise();
    }
  });
  var H;
  n.fn.ready = function (a) {
    return n.ready.promise().done(a), this;
  }, n.extend({
    isReady: !1,
    readyWait: 1,
    holdReady: function (a) {
      a ? n.readyWait++ : n.ready(!0);
    },
    ready: function (a) {
      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (H.resolveWith(l, [n]), n.fn.triggerHandler && (n(l).triggerHandler("ready"), n(l).off("ready"))));
    }
  });

  function I() {
    l.removeEventListener("DOMContentLoaded", I, !1), a.removeEventListener("load", I, !1), n.ready();
  }

  n.ready.promise = function (b) {
    return H || (H = n.Deferred(), "complete" === l.readyState ? setTimeout(n.ready) : (l.addEventListener("DOMContentLoaded", I, !1), a.addEventListener("load", I, !1))), H.promise(b);
  }, n.ready.promise();

  var J = n.access = function (a, b, c, d, e, f, g) {
    var h = 0,
        i = a.length,
        j = null == c;

    if ("object" === n.type(c)) {
      e = !0;

      for (h in c) n.access(a, b, h, c[h], !0, f, g);
    } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function (a, b, c) {
      return j.call(n(a), c);
    })), b)) for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));

    return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
  };

  n.acceptData = function (a) {
    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;
  };

  function K() {
    Object.defineProperty(this.cache = {}, 0, {
      get: function () {
        return {};
      }
    }), this.expando = n.expando + Math.random();
  }

  K.uid = 1, K.accepts = n.acceptData, K.prototype = {
    key: function (a) {
      if (!K.accepts(a)) return 0;
      var b = {},
          c = a[this.expando];

      if (!c) {
        c = K.uid++;

        try {
          b[this.expando] = {
            value: c
          }, Object.defineProperties(a, b);
        } catch (d) {
          b[this.expando] = c, n.extend(a, b);
        }
      }

      return this.cache[c] || (this.cache[c] = {}), c;
    },
    set: function (a, b, c) {
      var d,
          e = this.key(a),
          f = this.cache[e];
      if ("string" == typeof b) f[b] = c;else if (n.isEmptyObject(f)) n.extend(this.cache[e], b);else for (d in b) f[d] = b[d];
      return f;
    },
    get: function (a, b) {
      var c = this.cache[this.key(a)];
      return void 0 === b ? c : c[b];
    },
    access: function (a, b, c) {
      var d;
      return void 0 === b || b && "string" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b);
    },
    remove: function (a, b) {
      var c,
          d,
          e,
          f = this.key(a),
          g = this.cache[f];
      if (void 0 === b) this.cache[f] = {};else {
        n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in g ? d = [b, e] : (d = e, d = d in g ? [d] : d.match(E) || [])), c = d.length;

        while (c--) delete g[d[c]];
      }
    },
    hasData: function (a) {
      return !n.isEmptyObject(this.cache[a[this.expando]] || {});
    },
    discard: function (a) {
      a[this.expando] && delete this.cache[a[this.expando]];
    }
  };
  var L = new K(),
      M = new K(),
      N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      O = /([A-Z])/g;

  function P(a, b, c) {
    var d;
    if (void 0 === c && 1 === a.nodeType) if (d = "data-" + b.replace(O, "-$1").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
      try {
        c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : N.test(c) ? n.parseJSON(c) : c;
      } catch (e) {}

      M.set(a, b, c);
    } else c = void 0;
    return c;
  }

  n.extend({
    hasData: function (a) {
      return M.hasData(a) || L.hasData(a);
    },
    data: function (a, b, c) {
      return M.access(a, b, c);
    },
    removeData: function (a, b) {
      M.remove(a, b);
    },
    _data: function (a, b, c) {
      return L.access(a, b, c);
    },
    _removeData: function (a, b) {
      L.remove(a, b);
    }
  }), n.fn.extend({
    data: function (a, b) {
      var c,
          d,
          e,
          f = this[0],
          g = f && f.attributes;

      if (void 0 === a) {
        if (this.length && (e = M.get(f), 1 === f.nodeType && !L.get(f, "hasDataAttrs"))) {
          c = g.length;

          while (c--) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = n.camelCase(d.slice(5)), P(f, d, e[d])));

          L.set(f, "hasDataAttrs", !0);
        }

        return e;
      }

      return "object" == typeof a ? this.each(function () {
        M.set(this, a);
      }) : J(this, function (b) {
        var c,
            d = n.camelCase(a);

        if (f && void 0 === b) {
          if (c = M.get(f, a), void 0 !== c) return c;
          if (c = M.get(f, d), void 0 !== c) return c;
          if (c = P(f, d, void 0), void 0 !== c) return c;
        } else this.each(function () {
          var c = M.get(this, d);
          M.set(this, d, b), -1 !== a.indexOf("-") && void 0 !== c && M.set(this, a, b);
        });
      }, null, b, arguments.length > 1, null, !0);
    },
    removeData: function (a) {
      return this.each(function () {
        M.remove(this, a);
      });
    }
  }), n.extend({
    queue: function (a, b, c) {
      var d;
      return a ? (b = (b || "fx") + "queue", d = L.get(a, b), c && (!d || n.isArray(c) ? d = L.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0;
    },
    dequeue: function (a, b) {
      b = b || "fx";

      var c = n.queue(a, b),
          d = c.length,
          e = c.shift(),
          f = n._queueHooks(a, b),
          g = function () {
        n.dequeue(a, b);
      };

      "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();
    },
    _queueHooks: function (a, b) {
      var c = b + "queueHooks";
      return L.get(a, c) || L.access(a, c, {
        empty: n.Callbacks("once memory").add(function () {
          L.remove(a, [b + "queue", c]);
        })
      });
    }
  }), n.fn.extend({
    queue: function (a, b) {
      var c = 2;
      return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {
        var c = n.queue(this, a, b);
        n._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a);
      });
    },
    dequeue: function (a) {
      return this.each(function () {
        n.dequeue(this, a);
      });
    },
    clearQueue: function (a) {
      return this.queue(a || "fx", []);
    },
    promise: function (a, b) {
      var c,
          d = 1,
          e = n.Deferred(),
          f = this,
          g = this.length,
          h = function () {
        --d || e.resolveWith(f, [f]);
      };

      "string" != typeof a && (b = a, a = void 0), a = a || "fx";

      while (g--) c = L.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));

      return h(), e.promise(b);
    }
  });

  var Q = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
      R = ["Top", "Right", "Bottom", "Left"],
      S = function (a, b) {
    return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a);
  },
      T = /^(?:checkbox|radio)$/i;

  !function () {
    var a = l.createDocumentFragment(),
        b = a.appendChild(l.createElement("div")),
        c = l.createElement("input");
    c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;
  }();
  var U = "undefined";
  k.focusinBubbles = "onfocusin" in a;
  var V = /^key/,
      W = /^(?:mouse|pointer|contextmenu)|click/,
      X = /^(?:focusinfocus|focusoutblur)$/,
      Y = /^([^.]*)(?:\.(.+)|)$/;

  function Z() {
    return !0;
  }

  function $() {
    return !1;
  }

  function _() {
    try {
      return l.activeElement;
    } catch (a) {}
  }

  n.event = {
    global: {},
    add: function (a, b, c, d, e) {
      var f,
          g,
          h,
          i,
          j,
          k,
          l,
          m,
          o,
          p,
          q,
          r = L.get(a);

      if (r) {
        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) {
          return typeof n !== U && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0;
        }), b = (b || "").match(E) || [""], j = b.length;

        while (j--) h = Y.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({
          type: o,
          origType: q,
          data: d,
          handler: c,
          guid: c.guid,
          selector: e,
          needsContext: e && n.expr.match.needsContext.test(e),
          namespace: p.join(".")
        }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g, !1)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0);
      }
    },
    remove: function (a, b, c, d, e) {
      var f,
          g,
          h,
          i,
          j,
          k,
          l,
          m,
          o,
          p,
          q,
          r = L.hasData(a) && L.get(a);

      if (r && (i = r.events)) {
        b = (b || "").match(E) || [""], j = b.length;

        while (j--) if (h = Y.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
          l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length;

          while (f--) k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));

          g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]);
        } else for (o in i) n.event.remove(a, o + b[j], c, d, !0);

        n.isEmptyObject(i) && (delete r.handle, L.remove(a, "events"));
      }
    },
    trigger: function (b, c, d, e) {
      var f,
          g,
          h,
          i,
          k,
          m,
          o,
          p = [d || l],
          q = j.call(b, "type") ? b.type : b,
          r = j.call(b, "namespace") ? b.namespace.split(".") : [];

      if (g = h = d = d || l, 3 !== d.nodeType && 8 !== d.nodeType && !X.test(q + n.event.triggered) && (q.indexOf(".") >= 0 && (r = q.split("."), q = r.shift(), r.sort()), k = q.indexOf(":") < 0 && "on" + q, b = b[n.expando] ? b : new n.Event(q, "object" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = r.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + r.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, e || !o.trigger || o.trigger.apply(d, c) !== !1)) {
        if (!e && !o.noBubble && !n.isWindow(d)) {
          for (i = o.delegateType || q, X.test(i + q) || (g = g.parentNode); g; g = g.parentNode) p.push(g), h = g;

          h === (d.ownerDocument || l) && p.push(h.defaultView || h.parentWindow || a);
        }

        f = 0;

        while ((g = p[f++]) && !b.isPropagationStopped()) b.type = f > 1 ? i : o.bindType || q, m = (L.get(g, "events") || {})[b.type] && L.get(g, "handle"), m && m.apply(g, c), m = k && g[k], m && m.apply && n.acceptData(g) && (b.result = m.apply(g, c), b.result === !1 && b.preventDefault());

        return b.type = q, e || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !n.acceptData(d) || k && n.isFunction(d[q]) && !n.isWindow(d) && (h = d[k], h && (d[k] = null), n.event.triggered = q, d[q](), n.event.triggered = void 0, h && (d[k] = h)), b.result;
      }
    },
    dispatch: function (a) {
      a = n.event.fix(a);
      var b,
          c,
          e,
          f,
          g,
          h = [],
          i = d.call(arguments),
          j = (L.get(this, "events") || {})[a.type] || [],
          k = n.event.special[a.type] || {};

      if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
        h = n.event.handlers.call(this, a, j), b = 0;

        while ((f = h[b++]) && !a.isPropagationStopped()) {
          a.currentTarget = f.elem, c = 0;

          while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) (!a.namespace_re || a.namespace_re.test(g.namespace)) && (a.handleObj = g, a.data = g.data, e = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (a.result = e) === !1 && (a.preventDefault(), a.stopPropagation()));
        }

        return k.postDispatch && k.postDispatch.call(this, a), a.result;
      }
    },
    handlers: function (a, b) {
      var c,
          d,
          e,
          f,
          g = [],
          h = b.delegateCount,
          i = a.target;
      if (h && i.nodeType && (!a.button || "click" !== a.type)) for (; i !== this; i = i.parentNode || this) if (i.disabled !== !0 || "click" !== a.type) {
        for (d = [], c = 0; h > c; c++) f = b[c], e = f.selector + " ", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) >= 0 : n.find(e, this, null, [i]).length), d[e] && d.push(f);

        d.length && g.push({
          elem: i,
          handlers: d
        });
      }
      return h < b.length && g.push({
        elem: this,
        handlers: b.slice(h)
      }), g;
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function (a, b) {
        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function (a, b) {
        var c,
            d,
            e,
            f = b.button;
        return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || l, d = c.documentElement, e = c.body, a.pageX = b.clientX + (d && d.scrollLeft || e && e.scrollLeft || 0) - (d && d.clientLeft || e && e.clientLeft || 0), a.pageY = b.clientY + (d && d.scrollTop || e && e.scrollTop || 0) - (d && d.clientTop || e && e.clientTop || 0)), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a;
      }
    },
    fix: function (a) {
      if (a[n.expando]) return a;
      var b,
          c,
          d,
          e = a.type,
          f = a,
          g = this.fixHooks[e];
      g || (this.fixHooks[e] = g = W.test(e) ? this.mouseHooks : V.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new n.Event(f), b = d.length;

      while (b--) c = d[b], a[c] = f[c];

      return a.target || (a.target = l), 3 === a.target.nodeType && (a.target = a.target.parentNode), g.filter ? g.filter(a, f) : a;
    },
    special: {
      load: {
        noBubble: !0
      },
      focus: {
        trigger: function () {
          return this !== _() && this.focus ? (this.focus(), !1) : void 0;
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function () {
          return this === _() && this.blur ? (this.blur(), !1) : void 0;
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function () {
          return "checkbox" === this.type && this.click && n.nodeName(this, "input") ? (this.click(), !1) : void 0;
        },
        _default: function (a) {
          return n.nodeName(a.target, "a");
        }
      },
      beforeunload: {
        postDispatch: function (a) {
          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);
        }
      }
    },
    simulate: function (a, b, c, d) {
      var e = n.extend(new n.Event(), c, {
        type: a,
        isSimulated: !0,
        originalEvent: {}
      });
      d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault();
    }
  }, n.removeEvent = function (a, b, c) {
    a.removeEventListener && a.removeEventListener(b, c, !1);
  }, n.Event = function (a, b) {
    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? Z : $) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b);
  }, n.Event.prototype = {
    isDefaultPrevented: $,
    isPropagationStopped: $,
    isImmediatePropagationStopped: $,
    preventDefault: function () {
      var a = this.originalEvent;
      this.isDefaultPrevented = Z, a && a.preventDefault && a.preventDefault();
    },
    stopPropagation: function () {
      var a = this.originalEvent;
      this.isPropagationStopped = Z, a && a.stopPropagation && a.stopPropagation();
    },
    stopImmediatePropagation: function () {
      var a = this.originalEvent;
      this.isImmediatePropagationStopped = Z, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), this.stopPropagation();
    }
  }, n.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (a, b) {
    n.event.special[a] = {
      delegateType: b,
      bindType: b,
      handle: function (a) {
        var c,
            d = this,
            e = a.relatedTarget,
            f = a.handleObj;
        return (!e || e !== d && !n.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;
      }
    };
  }), k.focusinBubbles || n.each({
    focus: "focusin",
    blur: "focusout"
  }, function (a, b) {
    var c = function (a) {
      n.event.simulate(b, a.target, n.event.fix(a), !0);
    };

    n.event.special[b] = {
      setup: function () {
        var d = this.ownerDocument || this,
            e = L.access(d, b);
        e || d.addEventListener(a, c, !0), L.access(d, b, (e || 0) + 1);
      },
      teardown: function () {
        var d = this.ownerDocument || this,
            e = L.access(d, b) - 1;
        e ? L.access(d, b, e) : (d.removeEventListener(a, c, !0), L.remove(d, b));
      }
    };
  }), n.fn.extend({
    on: function (a, b, c, d, e) {
      var f, g;

      if ("object" == typeof a) {
        "string" != typeof b && (c = c || b, b = void 0);

        for (g in a) this.on(g, b, c, a[g], e);

        return this;
      }

      if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = $;else if (!d) return this;
      return 1 === e && (f = d, d = function (a) {
        return n().off(a), f.apply(this, arguments);
      }, d.guid = f.guid || (f.guid = n.guid++)), this.each(function () {
        n.event.add(this, a, d, c, b);
      });
    },
    one: function (a, b, c, d) {
      return this.on(a, b, c, d, 1);
    },
    off: function (a, b, c) {
      var d, e;
      if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;

      if ("object" == typeof a) {
        for (e in a) this.off(e, b, a[e]);

        return this;
      }

      return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = $), this.each(function () {
        n.event.remove(this, a, c, b);
      });
    },
    trigger: function (a, b) {
      return this.each(function () {
        n.event.trigger(a, b, this);
      });
    },
    triggerHandler: function (a, b) {
      var c = this[0];
      return c ? n.event.trigger(a, b, c, !0) : void 0;
    }
  });
  var ab = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      bb = /<([\w:]+)/,
      cb = /<|&#?\w+;/,
      db = /<(?:script|style|link)/i,
      eb = /checked\s*(?:[^=]|=\s*.checked.)/i,
      fb = /^$|\/(?:java|ecma)script/i,
      gb = /^true\/(.*)/,
      hb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
      ib = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  ib.optgroup = ib.option, ib.tbody = ib.tfoot = ib.colgroup = ib.caption = ib.thead, ib.th = ib.td;

  function jb(a, b) {
    return n.nodeName(a, "table") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
  }

  function kb(a) {
    return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a;
  }

  function lb(a) {
    var b = gb.exec(a.type);
    return b ? a.type = b[1] : a.removeAttribute("type"), a;
  }

  function mb(a, b) {
    for (var c = 0, d = a.length; d > c; c++) L.set(a[c], "globalEval", !b || L.get(b[c], "globalEval"));
  }

  function nb(a, b) {
    var c, d, e, f, g, h, i, j;

    if (1 === b.nodeType) {
      if (L.hasData(a) && (f = L.access(a), g = L.set(b, f), j = f.events)) {
        delete g.handle, g.events = {};

        for (e in j) for (c = 0, d = j[e].length; d > c; c++) n.event.add(b, e, j[e][c]);
      }

      M.hasData(a) && (h = M.access(a), i = n.extend({}, h), M.set(b, i));
    }
  }

  function ob(a, b) {
    var c = a.getElementsByTagName ? a.getElementsByTagName(b || "*") : a.querySelectorAll ? a.querySelectorAll(b || "*") : [];
    return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c;
  }

  function pb(a, b) {
    var c = b.nodeName.toLowerCase();
    "input" === c && T.test(a.type) ? b.checked = a.checked : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue);
  }

  n.extend({
    clone: function (a, b, c) {
      var d,
          e,
          f,
          g,
          h = a.cloneNode(!0),
          i = n.contains(a.ownerDocument, a);
      if (!(k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (g = ob(h), f = ob(a), d = 0, e = f.length; e > d; d++) pb(f[d], g[d]);
      if (b) if (c) for (f = f || ob(a), g = g || ob(h), d = 0, e = f.length; e > d; d++) nb(f[d], g[d]);else nb(a, h);
      return g = ob(h, "script"), g.length > 0 && mb(g, !i && ob(a, "script")), h;
    },
    buildFragment: function (a, b, c, d) {
      for (var e, f, g, h, i, j, k = b.createDocumentFragment(), l = [], m = 0, o = a.length; o > m; m++) if (e = a[m], e || 0 === e) if ("object" === n.type(e)) n.merge(l, e.nodeType ? [e] : e);else if (cb.test(e)) {
        f = f || k.appendChild(b.createElement("div")), g = (bb.exec(e) || ["", ""])[1].toLowerCase(), h = ib[g] || ib._default, f.innerHTML = h[1] + e.replace(ab, "<$1></$2>") + h[2], j = h[0];

        while (j--) f = f.lastChild;

        n.merge(l, f.childNodes), f = k.firstChild, f.textContent = "";
      } else l.push(b.createTextNode(e));

      k.textContent = "", m = 0;

      while (e = l[m++]) if ((!d || -1 === n.inArray(e, d)) && (i = n.contains(e.ownerDocument, e), f = ob(k.appendChild(e), "script"), i && mb(f), c)) {
        j = 0;

        while (e = f[j++]) fb.test(e.type || "") && c.push(e);
      }

      return k;
    },
    cleanData: function (a) {
      for (var b, c, d, e, f = n.event.special, g = 0; void 0 !== (c = a[g]); g++) {
        if (n.acceptData(c) && (e = c[L.expando], e && (b = L.cache[e]))) {
          if (b.events) for (d in b.events) f[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);
          L.cache[e] && delete L.cache[e];
        }

        delete M.cache[c[M.expando]];
      }
    }
  }), n.fn.extend({
    text: function (a) {
      return J(this, function (a) {
        return void 0 === a ? n.text(this) : this.empty().each(function () {
          (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a);
        });
      }, null, a, arguments.length);
    },
    append: function () {
      return this.domManip(arguments, function (a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = jb(this, a);
          b.appendChild(a);
        }
      });
    },
    prepend: function () {
      return this.domManip(arguments, function (a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = jb(this, a);
          b.insertBefore(a, b.firstChild);
        }
      });
    },
    before: function () {
      return this.domManip(arguments, function (a) {
        this.parentNode && this.parentNode.insertBefore(a, this);
      });
    },
    after: function () {
      return this.domManip(arguments, function (a) {
        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
      });
    },
    remove: function (a, b) {
      for (var c, d = a ? n.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || n.cleanData(ob(c)), c.parentNode && (b && n.contains(c.ownerDocument, c) && mb(ob(c, "script")), c.parentNode.removeChild(c));

      return this;
    },
    empty: function () {
      for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (n.cleanData(ob(a, !1)), a.textContent = "");

      return this;
    },
    clone: function (a, b) {
      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {
        return n.clone(this, a, b);
      });
    },
    html: function (a) {
      return J(this, function (a) {
        var b = this[0] || {},
            c = 0,
            d = this.length;
        if (void 0 === a && 1 === b.nodeType) return b.innerHTML;

        if ("string" == typeof a && !db.test(a) && !ib[(bb.exec(a) || ["", ""])[1].toLowerCase()]) {
          a = a.replace(ab, "<$1></$2>");

          try {
            for (; d > c; c++) b = this[c] || {}, 1 === b.nodeType && (n.cleanData(ob(b, !1)), b.innerHTML = a);

            b = 0;
          } catch (e) {}
        }

        b && this.empty().append(a);
      }, null, a, arguments.length);
    },
    replaceWith: function () {
      var a = arguments[0];
      return this.domManip(arguments, function (b) {
        a = this.parentNode, n.cleanData(ob(this)), a && a.replaceChild(b, this);
      }), a && (a.length || a.nodeType) ? this : this.remove();
    },
    detach: function (a) {
      return this.remove(a, !0);
    },
    domManip: function (a, b) {
      a = e.apply([], a);
      var c,
          d,
          f,
          g,
          h,
          i,
          j = 0,
          l = this.length,
          m = this,
          o = l - 1,
          p = a[0],
          q = n.isFunction(p);
      if (q || l > 1 && "string" == typeof p && !k.checkClone && eb.test(p)) return this.each(function (c) {
        var d = m.eq(c);
        q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);
      });

      if (l && (c = n.buildFragment(a, this[0].ownerDocument, !1, this), d = c.firstChild, 1 === c.childNodes.length && (c = d), d)) {
        for (f = n.map(ob(c, "script"), kb), g = f.length; l > j; j++) h = c, j !== o && (h = n.clone(h, !0, !0), g && n.merge(f, ob(h, "script"))), b.call(this[j], h, j);

        if (g) for (i = f[f.length - 1].ownerDocument, n.map(f, lb), j = 0; g > j; j++) h = f[j], fb.test(h.type || "") && !L.access(h, "globalEval") && n.contains(i, h) && (h.src ? n._evalUrl && n._evalUrl(h.src) : n.globalEval(h.textContent.replace(hb, "")));
      }

      return this;
    }
  }), n.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (a, b) {
    n.fn[a] = function (a) {
      for (var c, d = [], e = n(a), g = e.length - 1, h = 0; g >= h; h++) c = h === g ? this : this.clone(!0), n(e[h])[b](c), f.apply(d, c.get());

      return this.pushStack(d);
    };
  });
  var qb,
      rb = {};

  function sb(b, c) {
    var d,
        e = n(c.createElement(b)).appendTo(c.body),
        f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : n.css(e[0], "display");
    return e.detach(), f;
  }

  function tb(a) {
    var b = l,
        c = rb[a];
    return c || (c = sb(a, b), "none" !== c && c || (qb = (qb || n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = qb[0].contentDocument, b.write(), b.close(), c = sb(a, b), qb.detach()), rb[a] = c), c;
  }

  var ub = /^margin/,
      vb = new RegExp("^(" + Q + ")(?!px)[a-z%]+$", "i"),
      wb = function (a) {
    return a.ownerDocument.defaultView.getComputedStyle(a, null);
  };

  function xb(a, b, c) {
    var d,
        e,
        f,
        g,
        h = a.style;
    return c = c || wb(a), c && (g = c.getPropertyValue(b) || c[b]), c && ("" !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), vb.test(g) && ub.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + "" : g;
  }

  function yb(a, b) {
    return {
      get: function () {
        return a() ? void delete this.get : (this.get = b).apply(this, arguments);
      }
    };
  }

  !function () {
    var b,
        c,
        d = l.documentElement,
        e = l.createElement("div"),
        f = l.createElement("div");

    if (f.style) {
      f.style.backgroundClip = "content-box", f.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === f.style.backgroundClip, e.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", e.appendChild(f);

      function g() {
        f.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", f.innerHTML = "", d.appendChild(e);
        var g = a.getComputedStyle(f, null);
        b = "1%" !== g.top, c = "4px" === g.width, d.removeChild(e);
      }

      a.getComputedStyle && n.extend(k, {
        pixelPosition: function () {
          return g(), b;
        },
        boxSizingReliable: function () {
          return null == c && g(), c;
        },
        reliableMarginRight: function () {
          var b,
              c = f.appendChild(l.createElement("div"));
          return c.style.cssText = f.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", c.style.marginRight = c.style.width = "0", f.style.width = "1px", d.appendChild(e), b = !parseFloat(a.getComputedStyle(c, null).marginRight), d.removeChild(e), b;
        }
      });
    }
  }(), n.swap = function (a, b, c, d) {
    var e,
        f,
        g = {};

    for (f in b) g[f] = a.style[f], a.style[f] = b[f];

    e = c.apply(a, d || []);

    for (f in b) a.style[f] = g[f];

    return e;
  };
  var zb = /^(none|table(?!-c[ea]).+)/,
      Ab = new RegExp("^(" + Q + ")(.*)$", "i"),
      Bb = new RegExp("^([+-])=(" + Q + ")", "i"),
      Cb = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      Db = {
    letterSpacing: "0",
    fontWeight: "400"
  },
      Eb = ["Webkit", "O", "Moz", "ms"];

  function Fb(a, b) {
    if (b in a) return b;
    var c = b[0].toUpperCase() + b.slice(1),
        d = b,
        e = Eb.length;

    while (e--) if (b = Eb[e] + c, b in a) return b;

    return d;
  }

  function Gb(a, b, c) {
    var d = Ab.exec(b);
    return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
  }

  function Hb(a, b, c, d, e) {
    for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += n.css(a, c + R[f], !0, e)), d ? ("content" === c && (g -= n.css(a, "padding" + R[f], !0, e)), "margin" !== c && (g -= n.css(a, "border" + R[f] + "Width", !0, e))) : (g += n.css(a, "padding" + R[f], !0, e), "padding" !== c && (g += n.css(a, "border" + R[f] + "Width", !0, e)));

    return g;
  }

  function Ib(a, b, c) {
    var d = !0,
        e = "width" === b ? a.offsetWidth : a.offsetHeight,
        f = wb(a),
        g = "border-box" === n.css(a, "boxSizing", !1, f);

    if (0 >= e || null == e) {
      if (e = xb(a, b, f), (0 > e || null == e) && (e = a.style[b]), vb.test(e)) return e;
      d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
    }

    return e + Hb(a, b, c || (g ? "border" : "content"), d, f) + "px";
  }

  function Jb(a, b) {
    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = L.get(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && S(d) && (f[g] = L.access(d, "olddisplay", tb(d.nodeName)))) : (e = S(d), "none" === c && e || L.set(d, "olddisplay", e ? c : n.css(d, "display"))));

    for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));

    return a;
  }

  n.extend({
    cssHooks: {
      opacity: {
        get: function (a, b) {
          if (b) {
            var c = xb(a, "opacity");
            return "" === c ? "1" : c;
          }
        }
      }
    },
    cssNumber: {
      columnCount: !0,
      fillOpacity: !0,
      flexGrow: !0,
      flexShrink: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {
      "float": "cssFloat"
    },
    style: function (a, b, c, d) {
      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
        var e,
            f,
            g,
            h = n.camelCase(b),
            i = a.style;
        return b = n.cssProps[h] || (n.cssProps[h] = Fb(i, h)), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, "string" === f && (e = Bb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b)), f = "number"), null != c && c === c && ("number" !== f || n.cssNumber[h] || (c += "px"), k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);
      }
    },
    css: function (a, b, c, d) {
      var e,
          f,
          g,
          h = n.camelCase(b);
      return b = n.cssProps[h] || (n.cssProps[h] = Fb(a.style, h)), g = n.cssHooks[b] || n.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = xb(a, b, d)), "normal" === e && b in Db && (e = Db[b]), "" === c || c ? (f = parseFloat(e), c === !0 || n.isNumeric(f) ? f || 0 : e) : e;
    }
  }), n.each(["height", "width"], function (a, b) {
    n.cssHooks[b] = {
      get: function (a, c, d) {
        return c ? zb.test(n.css(a, "display")) && 0 === a.offsetWidth ? n.swap(a, Cb, function () {
          return Ib(a, b, d);
        }) : Ib(a, b, d) : void 0;
      },
      set: function (a, c, d) {
        var e = d && wb(a);
        return Gb(a, c, d ? Hb(a, b, d, "border-box" === n.css(a, "boxSizing", !1, e), e) : 0);
      }
    };
  }), n.cssHooks.marginRight = yb(k.reliableMarginRight, function (a, b) {
    return b ? n.swap(a, {
      display: "inline-block"
    }, xb, [a, "marginRight"]) : void 0;
  }), n.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (a, b) {
    n.cssHooks[a + b] = {
      expand: function (c) {
        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++) e[a + R[d] + b] = f[d] || f[d - 2] || f[0];

        return e;
      }
    }, ub.test(a) || (n.cssHooks[a + b].set = Gb);
  }), n.fn.extend({
    css: function (a, b) {
      return J(this, function (a, b, c) {
        var d,
            e,
            f = {},
            g = 0;

        if (n.isArray(b)) {
          for (d = wb(a), e = b.length; e > g; g++) f[b[g]] = n.css(a, b[g], !1, d);

          return f;
        }

        return void 0 !== c ? n.style(a, b, c) : n.css(a, b);
      }, a, b, arguments.length > 1);
    },
    show: function () {
      return Jb(this, !0);
    },
    hide: function () {
      return Jb(this);
    },
    toggle: function (a) {
      return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function () {
        S(this) ? n(this).show() : n(this).hide();
      });
    }
  });

  function Kb(a, b, c, d, e) {
    return new Kb.prototype.init(a, b, c, d, e);
  }

  n.Tween = Kb, Kb.prototype = {
    constructor: Kb,
    init: function (a, b, c, d, e, f) {
      this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px");
    },
    cur: function () {
      var a = Kb.propHooks[this.prop];
      return a && a.get ? a.get(this) : Kb.propHooks._default.get(this);
    },
    run: function (a) {
      var b,
          c = Kb.propHooks[this.prop];
      return this.pos = b = this.options.duration ? n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Kb.propHooks._default.set(this), this;
    }
  }, Kb.prototype.init.prototype = Kb.prototype, Kb.propHooks = {
    _default: {
      get: function (a) {
        var b;
        return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = n.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0) : a.elem[a.prop];
      },
      set: function (a) {
        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[n.cssProps[a.prop]] || n.cssHooks[a.prop]) ? n.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now;
      }
    }
  }, Kb.propHooks.scrollTop = Kb.propHooks.scrollLeft = {
    set: function (a) {
      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
    }
  }, n.easing = {
    linear: function (a) {
      return a;
    },
    swing: function (a) {
      return .5 - Math.cos(a * Math.PI) / 2;
    }
  }, n.fx = Kb.prototype.init, n.fx.step = {};
  var Lb,
      Mb,
      Nb = /^(?:toggle|show|hide)$/,
      Ob = new RegExp("^(?:([+-])=|)(" + Q + ")([a-z%]*)$", "i"),
      Pb = /queueHooks$/,
      Qb = [Vb],
      Rb = {
    "*": [function (a, b) {
      var c = this.createTween(a, b),
          d = c.cur(),
          e = Ob.exec(b),
          f = e && e[3] || (n.cssNumber[a] ? "" : "px"),
          g = (n.cssNumber[a] || "px" !== f && +d) && Ob.exec(n.css(c.elem, a)),
          h = 1,
          i = 20;

      if (g && g[3] !== f) {
        f = f || g[3], e = e || [], g = +d || 1;

        do h = h || ".5", g /= h, n.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i);
      }

      return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c;
    }]
  };

  function Sb() {
    return setTimeout(function () {
      Lb = void 0;
    }), Lb = n.now();
  }

  function Tb(a, b) {
    var c,
        d = 0,
        e = {
      height: a
    };

    for (b = b ? 1 : 0; 4 > d; d += 2 - b) c = R[d], e["margin" + c] = e["padding" + c] = a;

    return b && (e.opacity = e.width = a), e;
  }

  function Ub(a, b, c) {
    for (var d, e = (Rb[b] || []).concat(Rb["*"]), f = 0, g = e.length; g > f; f++) if (d = e[f].call(c, b, a)) return d;
  }

  function Vb(a, b, c) {
    var d,
        e,
        f,
        g,
        h,
        i,
        j,
        k,
        l = this,
        m = {},
        o = a.style,
        p = a.nodeType && S(a),
        q = L.get(a, "fxshow");
    c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {
      h.unqueued || i();
    }), h.unqueued++, l.always(function () {
      l.always(function () {
        h.unqueued--, n.queue(a, "fx").length || h.empty.fire();
      });
    })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, "display"), k = "none" === j ? L.get(a, "olddisplay") || tb(a.nodeName) : j, "inline" === k && "none" === n.css(a, "float") && (o.display = "inline-block")), c.overflow && (o.overflow = "hidden", l.always(function () {
      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];
    }));

    for (d in b) if (e = b[d], Nb.exec(e)) {
      if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {
        if ("show" !== e || !q || void 0 === q[d]) continue;
        p = !0;
      }

      m[d] = q && q[d] || n.style(a, d);
    } else j = void 0;

    if (n.isEmptyObject(m)) "inline" === ("none" === j ? tb(a.nodeName) : j) && (o.display = j);else {
      q ? "hidden" in q && (p = q.hidden) : q = L.access(a, "fxshow", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function () {
        n(a).hide();
      }), l.done(function () {
        var b;
        L.remove(a, "fxshow");

        for (b in m) n.style(a, b, m[b]);
      });

      for (d in m) g = Ub(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0));
    }
  }

  function Wb(a, b) {
    var c, d, e, f, g;

    for (c in a) if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && "expand" in g) {
      f = g.expand(f), delete a[d];

      for (c in f) c in a || (a[c] = f[c], b[c] = e);
    } else b[d] = e;
  }

  function Xb(a, b, c) {
    var d,
        e,
        f = 0,
        g = Qb.length,
        h = n.Deferred().always(function () {
      delete i.elem;
    }),
        i = function () {
      if (e) return !1;

      for (var b = Lb || Sb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);

      return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);
    },
        j = h.promise({
      elem: a,
      props: n.extend({}, b),
      opts: n.extend(!0, {
        specialEasing: {}
      }, c),
      originalProperties: b,
      originalOptions: c,
      startTime: Lb || Sb(),
      duration: c.duration,
      tweens: [],
      createTween: function (b, c) {
        var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
        return j.tweens.push(d), d;
      },
      stop: function (b) {
        var c = 0,
            d = b ? j.tweens.length : 0;
        if (e) return this;

        for (e = !0; d > c; c++) j.tweens[c].run(1);

        return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this;
      }
    }),
        k = j.props;

    for (Wb(k, j.opts.specialEasing); g > f; f++) if (d = Qb[f].call(j, a, k, j.opts)) return d;

    return n.map(k, Ub, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, {
      elem: a,
      anim: j,
      queue: j.opts.queue
    })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
  }

  n.Animation = n.extend(Xb, {
    tweener: function (a, b) {
      n.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" ");

      for (var c, d = 0, e = a.length; e > d; d++) c = a[d], Rb[c] = Rb[c] || [], Rb[c].unshift(b);
    },
    prefilter: function (a, b) {
      b ? Qb.unshift(a) : Qb.push(a);
    }
  }), n.speed = function (a, b, c) {
    var d = a && "object" == typeof a ? n.extend({}, a) : {
      complete: c || !c && b || n.isFunction(a) && a,
      duration: a,
      easing: c && b || b && !n.isFunction(b) && b
    };
    return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function () {
      n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue);
    }, d;
  }, n.fn.extend({
    fadeTo: function (a, b, c, d) {
      return this.filter(S).css("opacity", 0).show().end().animate({
        opacity: b
      }, a, c, d);
    },
    animate: function (a, b, c, d) {
      var e = n.isEmptyObject(a),
          f = n.speed(b, c, d),
          g = function () {
        var b = Xb(this, n.extend({}, a), f);
        (e || L.get(this, "finish")) && b.stop(!0);
      };

      return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);
    },
    stop: function (a, b, c) {
      var d = function (a) {
        var b = a.stop;
        delete a.stop, b(c);
      };

      return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function () {
        var b = !0,
            e = null != a && a + "queueHooks",
            f = n.timers,
            g = L.get(this);
        if (e) g[e] && g[e].stop && d(g[e]);else for (e in g) g[e] && g[e].stop && Pb.test(e) && d(g[e]);

        for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));

        (b || !c) && n.dequeue(this, a);
      });
    },
    finish: function (a) {
      return a !== !1 && (a = a || "fx"), this.each(function () {
        var b,
            c = L.get(this),
            d = c[a + "queue"],
            e = c[a + "queueHooks"],
            f = n.timers,
            g = d ? d.length : 0;

        for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));

        for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);

        delete c.finish;
      });
    }
  }), n.each(["toggle", "show", "hide"], function (a, b) {
    var c = n.fn[b];

    n.fn[b] = function (a, d, e) {
      return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(Tb(b, !0), a, d, e);
    };
  }), n.each({
    slideDown: Tb("show"),
    slideUp: Tb("hide"),
    slideToggle: Tb("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (a, b) {
    n.fn[a] = function (a, c, d) {
      return this.animate(b, a, c, d);
    };
  }), n.timers = [], n.fx.tick = function () {
    var a,
        b = 0,
        c = n.timers;

    for (Lb = n.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);

    c.length || n.fx.stop(), Lb = void 0;
  }, n.fx.timer = function (a) {
    n.timers.push(a), a() ? n.fx.start() : n.timers.pop();
  }, n.fx.interval = 13, n.fx.start = function () {
    Mb || (Mb = setInterval(n.fx.tick, n.fx.interval));
  }, n.fx.stop = function () {
    clearInterval(Mb), Mb = null;
  }, n.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  }, n.fn.delay = function (a, b) {
    return a = n.fx ? n.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function (b, c) {
      var d = setTimeout(b, a);

      c.stop = function () {
        clearTimeout(d);
      };
    });
  }, function () {
    var a = l.createElement("input"),
        b = l.createElement("select"),
        c = b.appendChild(l.createElement("option"));
    a.type = "checkbox", k.checkOn = "" !== a.value, k.optSelected = c.selected, b.disabled = !0, k.optDisabled = !c.disabled, a = l.createElement("input"), a.value = "t", a.type = "radio", k.radioValue = "t" === a.value;
  }();
  var Yb,
      Zb,
      $b = n.expr.attrHandle;
  n.fn.extend({
    attr: function (a, b) {
      return J(this, n.attr, a, b, arguments.length > 1);
    },
    removeAttr: function (a) {
      return this.each(function () {
        n.removeAttr(this, a);
      });
    }
  }), n.extend({
    attr: function (a, b, c) {
      var d,
          e,
          f = a.nodeType;
      if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === U ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), d = n.attrHooks[b] || (n.expr.match.bool.test(b) ? Zb : Yb)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = n.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void n.removeAttr(a, b));
    },
    removeAttr: function (a, b) {
      var c,
          d,
          e = 0,
          f = b && b.match(E);
      if (f && 1 === a.nodeType) while (c = f[e++]) d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c);
    },
    attrHooks: {
      type: {
        set: function (a, b) {
          if (!k.radioValue && "radio" === b && n.nodeName(a, "input")) {
            var c = a.value;
            return a.setAttribute("type", b), c && (a.value = c), b;
          }
        }
      }
    }
  }), Zb = {
    set: function (a, b, c) {
      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;
    }
  }, n.each(n.expr.match.bool.source.match(/\w+/g), function (a, b) {
    var c = $b[b] || n.find.attr;

    $b[b] = function (a, b, d) {
      var e, f;
      return d || (f = $b[b], $b[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, $b[b] = f), e;
    };
  });
  var _b = /^(?:input|select|textarea|button)$/i;
  n.fn.extend({
    prop: function (a, b) {
      return J(this, n.prop, a, b, arguments.length > 1);
    },
    removeProp: function (a) {
      return this.each(function () {
        delete this[n.propFix[a] || a];
      });
    }
  }), n.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function (a, b, c) {
      var d,
          e,
          f,
          g = a.nodeType;
      if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !n.isXMLDoc(a), f && (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b];
    },
    propHooks: {
      tabIndex: {
        get: function (a) {
          return a.hasAttribute("tabindex") || _b.test(a.nodeName) || a.href ? a.tabIndex : -1;
        }
      }
    }
  }), k.optSelected || (n.propHooks.selected = {
    get: function (a) {
      var b = a.parentNode;
      return b && b.parentNode && b.parentNode.selectedIndex, null;
    }
  }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    n.propFix[this.toLowerCase()] = this;
  });
  var ac = /[\t\r\n\f]/g;
  n.fn.extend({
    addClass: function (a) {
      var b,
          c,
          d,
          e,
          f,
          g,
          h = "string" == typeof a && a,
          i = 0,
          j = this.length;
      if (n.isFunction(a)) return this.each(function (b) {
        n(this).addClass(a.call(this, b, this.className));
      });
      if (h) for (b = (a || "").match(E) || []; j > i; i++) if (c = this[i], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ac, " ") : " ")) {
        f = 0;

        while (e = b[f++]) d.indexOf(" " + e + " ") < 0 && (d += e + " ");

        g = n.trim(d), c.className !== g && (c.className = g);
      }
      return this;
    },
    removeClass: function (a) {
      var b,
          c,
          d,
          e,
          f,
          g,
          h = 0 === arguments.length || "string" == typeof a && a,
          i = 0,
          j = this.length;
      if (n.isFunction(a)) return this.each(function (b) {
        n(this).removeClass(a.call(this, b, this.className));
      });
      if (h) for (b = (a || "").match(E) || []; j > i; i++) if (c = this[i], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ac, " ") : "")) {
        f = 0;

        while (e = b[f++]) while (d.indexOf(" " + e + " ") >= 0) d = d.replace(" " + e + " ", " ");

        g = a ? n.trim(d) : "", c.className !== g && (c.className = g);
      }
      return this;
    },
    toggleClass: function (a, b) {
      var c = typeof a;
      return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(n.isFunction(a) ? function (c) {
        n(this).toggleClass(a.call(this, c, this.className, b), b);
      } : function () {
        if ("string" === c) {
          var b,
              d = 0,
              e = n(this),
              f = a.match(E) || [];

          while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b);
        } else (c === U || "boolean" === c) && (this.className && L.set(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : L.get(this, "__className__") || "");
      });
    },
    hasClass: function (a) {
      for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++) if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(ac, " ").indexOf(b) >= 0) return !0;

      return !1;
    }
  });
  var bc = /\r/g;
  n.fn.extend({
    val: function (a) {
      var b,
          c,
          d,
          e = this[0];
      {
        if (arguments.length) return d = n.isFunction(a), this.each(function (c) {
          var e;
          1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) && (e = n.map(e, function (a) {
            return null == a ? "" : a + "";
          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e));
        });
        if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(bc, "") : null == c ? "" : c);
      }
    }
  }), n.extend({
    valHooks: {
      option: {
        get: function (a) {
          var b = n.find.attr(a, "value");
          return null != b ? b : n.trim(n.text(a));
        }
      },
      select: {
        get: function (a) {
          for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) if (c = d[i], !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && n.nodeName(c.parentNode, "optgroup"))) {
            if (b = n(c).val(), f) return b;
            g.push(b);
          }

          return g;
        },
        set: function (a, b) {
          var c,
              d,
              e = a.options,
              f = n.makeArray(b),
              g = e.length;

          while (g--) d = e[g], (d.selected = n.inArray(d.value, f) >= 0) && (c = !0);

          return c || (a.selectedIndex = -1), f;
        }
      }
    }
  }), n.each(["radio", "checkbox"], function () {
    n.valHooks[this] = {
      set: function (a, b) {
        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) >= 0 : void 0;
      }
    }, k.checkOn || (n.valHooks[this].get = function (a) {
      return null === a.getAttribute("value") ? "on" : a.value;
    });
  }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (a, b) {
    n.fn[b] = function (a, c) {
      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);
    };
  }), n.fn.extend({
    hover: function (a, b) {
      return this.mouseenter(a).mouseleave(b || a);
    },
    bind: function (a, b, c) {
      return this.on(a, null, b, c);
    },
    unbind: function (a, b) {
      return this.off(a, null, b);
    },
    delegate: function (a, b, c, d) {
      return this.on(b, a, c, d);
    },
    undelegate: function (a, b, c) {
      return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);
    }
  });
  var cc = n.now(),
      dc = /\?/;
  n.parseJSON = function (a) {
    return JSON.parse(a + "");
  }, n.parseXML = function (a) {
    var b, c;
    if (!a || "string" != typeof a) return null;

    try {
      c = new DOMParser(), b = c.parseFromString(a, "text/xml");
    } catch (d) {
      b = void 0;
    }

    return (!b || b.getElementsByTagName("parsererror").length) && n.error("Invalid XML: " + a), b;
  };
  var ec,
      fc,
      gc = /#.*$/,
      hc = /([?&])_=[^&]*/,
      ic = /^(.*?):[ \t]*([^\r\n]*)$/gm,
      jc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      kc = /^(?:GET|HEAD)$/,
      lc = /^\/\//,
      mc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
      nc = {},
      oc = {},
      pc = "*/".concat("*");

  try {
    fc = location.href;
  } catch (qc) {
    fc = l.createElement("a"), fc.href = "", fc = fc.href;
  }

  ec = mc.exec(fc.toLowerCase()) || [];

  function rc(a) {
    return function (b, c) {
      "string" != typeof b && (c = b, b = "*");
      var d,
          e = 0,
          f = b.toLowerCase().match(E) || [];
      if (n.isFunction(c)) while (d = f[e++]) "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
    };
  }

  function sc(a, b, c, d) {
    var e = {},
        f = a === oc;

    function g(h) {
      var i;
      return e[h] = !0, n.each(a[h] || [], function (a, h) {
        var j = h(b, c, d);
        return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);
      }), i;
    }

    return g(b.dataTypes[0]) || !e["*"] && g("*");
  }

  function tc(a, b) {
    var c,
        d,
        e = n.ajaxSettings.flatOptions || {};

    for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);

    return d && n.extend(!0, a, d), a;
  }

  function uc(a, b, c) {
    var d,
        e,
        f,
        g,
        h = a.contents,
        i = a.dataTypes;

    while ("*" === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));

    if (d) for (e in h) if (h[e] && h[e].test(d)) {
      i.unshift(e);
      break;
    }
    if (i[0] in c) f = i[0];else {
      for (e in c) {
        if (!i[0] || a.converters[e + " " + i[0]]) {
          f = e;
          break;
        }

        g || (g = e);
      }

      f = f || g;
    }
    return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
  }

  function vc(a, b, c, d) {
    var e,
        f,
        g,
        h,
        i,
        j = {},
        k = a.dataTypes.slice();
    if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
    f = k.shift();

    while (f) if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i;else if ("*" !== i && i !== f) {
      if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
        g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
        break;
      }
      if (g !== !0) if (g && a["throws"]) b = g(b);else try {
        b = g(b);
      } catch (l) {
        return {
          state: "parsererror",
          error: g ? l : "No conversion from " + i + " to " + f
        };
      }
    }

    return {
      state: "success",
      data: b
    };
  }

  n.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: fc,
      type: "GET",
      isLocal: jc.test(ec[1]),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": pc,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": n.parseJSON,
        "text xml": n.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function (a, b) {
      return b ? tc(tc(a, n.ajaxSettings), b) : tc(n.ajaxSettings, a);
    },
    ajaxPrefilter: rc(nc),
    ajaxTransport: rc(oc),
    ajax: function (a, b) {
      "object" == typeof a && (b = a, a = void 0), b = b || {};
      var c,
          d,
          e,
          f,
          g,
          h,
          i,
          j,
          k = n.ajaxSetup({}, b),
          l = k.context || k,
          m = k.context && (l.nodeType || l.jquery) ? n(l) : n.event,
          o = n.Deferred(),
          p = n.Callbacks("once memory"),
          q = k.statusCode || {},
          r = {},
          s = {},
          t = 0,
          u = "canceled",
          v = {
        readyState: 0,
        getResponseHeader: function (a) {
          var b;

          if (2 === t) {
            if (!f) {
              f = {};

              while (b = ic.exec(e)) f[b[1].toLowerCase()] = b[2];
            }

            b = f[a.toLowerCase()];
          }

          return null == b ? null : b;
        },
        getAllResponseHeaders: function () {
          return 2 === t ? e : null;
        },
        setRequestHeader: function (a, b) {
          var c = a.toLowerCase();
          return t || (a = s[c] = s[c] || a, r[a] = b), this;
        },
        overrideMimeType: function (a) {
          return t || (k.mimeType = a), this;
        },
        statusCode: function (a) {
          var b;
          if (a) if (2 > t) for (b in a) q[b] = [q[b], a[b]];else v.always(a[v.status]);
          return this;
        },
        abort: function (a) {
          var b = a || u;
          return c && c.abort(b), x(0, b), this;
        }
      };
      if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || fc) + "").replace(gc, "").replace(lc, ec[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = n.trim(k.dataType || "*").toLowerCase().match(E) || [""], null == k.crossDomain && (h = mc.exec(k.url.toLowerCase()), k.crossDomain = !(!h || h[1] === ec[1] && h[2] === ec[2] && (h[3] || ("http:" === h[1] ? "80" : "443")) === (ec[3] || ("http:" === ec[1] ? "80" : "443")))), k.data && k.processData && "string" != typeof k.data && (k.data = n.param(k.data, k.traditional)), sc(nc, k, b, v), 2 === t) return v;
      i = k.global, i && 0 === n.active++ && n.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !kc.test(k.type), d = k.url, k.hasContent || (k.data && (d = k.url += (dc.test(d) ? "&" : "?") + k.data, delete k.data), k.cache === !1 && (k.url = hc.test(d) ? d.replace(hc, "$1_=" + cc++) : d + (dc.test(d) ? "&" : "?") + "_=" + cc++)), k.ifModified && (n.lastModified[d] && v.setRequestHeader("If-Modified-Since", n.lastModified[d]), n.etag[d] && v.setRequestHeader("If-None-Match", n.etag[d])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + pc + "; q=0.01" : "") : k.accepts["*"]);

      for (j in k.headers) v.setRequestHeader(j, k.headers[j]);

      if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();
      u = "abort";

      for (j in {
        success: 1,
        error: 1,
        complete: 1
      }) v[j](k[j]);

      if (c = sc(oc, k, b, v)) {
        v.readyState = 1, i && m.trigger("ajaxSend", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function () {
          v.abort("timeout");
        }, k.timeout));

        try {
          t = 1, c.send(r, x);
        } catch (w) {
          if (!(2 > t)) throw w;
          x(-1, w);
        }
      } else x(-1, "No Transport");

      function x(a, b, f, h) {
        var j,
            r,
            s,
            u,
            w,
            x = b;
        2 !== t && (t = 2, g && clearTimeout(g), c = void 0, e = h || "", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, f && (u = uc(k, v, f)), u = vc(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (n.lastModified[d] = w), w = v.getResponseHeader("etag"), w && (n.etag[d] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, i && m.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), i && (m.trigger("ajaxComplete", [v, k]), --n.active || n.event.trigger("ajaxStop")));
      }

      return v;
    },
    getJSON: function (a, b, c) {
      return n.get(a, b, c, "json");
    },
    getScript: function (a, b) {
      return n.get(a, void 0, b, "script");
    }
  }), n.each(["get", "post"], function (a, b) {
    n[b] = function (a, c, d, e) {
      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax({
        url: a,
        type: b,
        dataType: e,
        data: c,
        success: d
      });
    };
  }), n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (a, b) {
    n.fn[b] = function (a) {
      return this.on(b, a);
    };
  }), n._evalUrl = function (a) {
    return n.ajax({
      url: a,
      type: "GET",
      dataType: "script",
      async: !1,
      global: !1,
      "throws": !0
    });
  }, n.fn.extend({
    wrapAll: function (a) {
      var b;
      return n.isFunction(a) ? this.each(function (b) {
        n(this).wrapAll(a.call(this, b));
      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {
        var a = this;

        while (a.firstElementChild) a = a.firstElementChild;

        return a;
      }).append(this)), this);
    },
    wrapInner: function (a) {
      return this.each(n.isFunction(a) ? function (b) {
        n(this).wrapInner(a.call(this, b));
      } : function () {
        var b = n(this),
            c = b.contents();
        c.length ? c.wrapAll(a) : b.append(a);
      });
    },
    wrap: function (a) {
      var b = n.isFunction(a);
      return this.each(function (c) {
        n(this).wrapAll(b ? a.call(this, c) : a);
      });
    },
    unwrap: function () {
      return this.parent().each(function () {
        n.nodeName(this, "body") || n(this).replaceWith(this.childNodes);
      }).end();
    }
  }), n.expr.filters.hidden = function (a) {
    return a.offsetWidth <= 0 && a.offsetHeight <= 0;
  }, n.expr.filters.visible = function (a) {
    return !n.expr.filters.hidden(a);
  };
  var wc = /%20/g,
      xc = /\[\]$/,
      yc = /\r?\n/g,
      zc = /^(?:submit|button|image|reset|file)$/i,
      Ac = /^(?:input|select|textarea|keygen)/i;

  function Bc(a, b, c, d) {
    var e;
    if (n.isArray(b)) n.each(b, function (b, e) {
      c || xc.test(a) ? d(a, e) : Bc(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
    });else if (c || "object" !== n.type(b)) d(a, b);else for (e in b) Bc(a + "[" + e + "]", b[e], c, d);
  }

  n.param = function (a, b) {
    var c,
        d = [],
        e = function (a, b) {
      b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);
    };

    if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () {
      e(this.name, this.value);
    });else for (c in a) Bc(c, a[c], b, e);
    return d.join("&").replace(wc, "+");
  }, n.fn.extend({
    serialize: function () {
      return n.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        var a = n.prop(this, "elements");
        return a ? n.makeArray(a) : this;
      }).filter(function () {
        var a = this.type;
        return this.name && !n(this).is(":disabled") && Ac.test(this.nodeName) && !zc.test(a) && (this.checked || !T.test(a));
      }).map(function (a, b) {
        var c = n(this).val();
        return null == c ? null : n.isArray(c) ? n.map(c, function (a) {
          return {
            name: b.name,
            value: a.replace(yc, "\r\n")
          };
        }) : {
          name: b.name,
          value: c.replace(yc, "\r\n")
        };
      }).get();
    }
  }), n.ajaxSettings.xhr = function () {
    try {
      return new XMLHttpRequest();
    } catch (a) {}
  };
  var Cc = 0,
      Dc = {},
      Ec = {
    0: 200,
    1223: 204
  },
      Fc = n.ajaxSettings.xhr();
  a.ActiveXObject && n(a).on("unload", function () {
    for (var a in Dc) Dc[a]();
  }), k.cors = !!Fc && "withCredentials" in Fc, k.ajax = Fc = !!Fc, n.ajaxTransport(function (a) {
    var b;
    return k.cors || Fc && !a.crossDomain ? {
      send: function (c, d) {
        var e,
            f = a.xhr(),
            g = ++Cc;
        if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) f[e] = a.xhrFields[e];
        a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");

        for (e in c) f.setRequestHeader(e, c[e]);

        b = function (a) {
          return function () {
            b && (delete Dc[g], b = f.onload = f.onerror = null, "abort" === a ? f.abort() : "error" === a ? d(f.status, f.statusText) : d(Ec[f.status] || f.status, f.statusText, "string" == typeof f.responseText ? {
              text: f.responseText
            } : void 0, f.getAllResponseHeaders()));
          };
        }, f.onload = b(), f.onerror = b("error"), b = Dc[g] = b("abort");

        try {
          f.send(a.hasContent && a.data || null);
        } catch (h) {
          if (b) throw h;
        }
      },
      abort: function () {
        b && b();
      }
    } : void 0;
  }), n.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /(?:java|ecma)script/
    },
    converters: {
      "text script": function (a) {
        return n.globalEval(a), a;
      }
    }
  }), n.ajaxPrefilter("script", function (a) {
    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET");
  }), n.ajaxTransport("script", function (a) {
    if (a.crossDomain) {
      var b, c;
      return {
        send: function (d, e) {
          b = n("<script>").prop({
            async: !0,
            charset: a.scriptCharset,
            src: a.url
          }).on("load error", c = function (a) {
            b.remove(), c = null, a && e("error" === a.type ? 404 : 200, a.type);
          }), l.head.appendChild(b[0]);
        },
        abort: function () {
          c && c();
        }
      };
    }
  });
  var Gc = [],
      Hc = /(=)\?(?=&|$)|\?\?/;
  n.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var a = Gc.pop() || n.expando + "_" + cc++;
      return this[a] = !0, a;
    }
  }), n.ajaxPrefilter("json jsonp", function (b, c, d) {
    var e,
        f,
        g,
        h = b.jsonp !== !1 && (Hc.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && Hc.test(b.data) && "data");
    return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Hc, "$1" + e) : b.jsonp !== !1 && (b.url += (dc.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function () {
      return g || n.error(e + " was not called"), g[0];
    }, b.dataTypes[0] = "json", f = a[e], a[e] = function () {
      g = arguments;
    }, d.always(function () {
      a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Gc.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0;
    }), "script") : void 0;
  }), n.parseHTML = function (a, b, c) {
    if (!a || "string" != typeof a) return null;
    "boolean" == typeof b && (c = b, b = !1), b = b || l;
    var d = v.exec(a),
        e = !c && [];
    return d ? [b.createElement(d[1])] : (d = n.buildFragment([a], b, e), e && e.length && n(e).remove(), n.merge([], d.childNodes));
  };
  var Ic = n.fn.load;
  n.fn.load = function (a, b, c) {
    if ("string" != typeof a && Ic) return Ic.apply(this, arguments);
    var d,
        e,
        f,
        g = this,
        h = a.indexOf(" ");
    return h >= 0 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && n.ajax({
      url: a,
      type: e,
      dataType: "html",
      data: b
    }).done(function (a) {
      f = arguments, g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a);
    }).complete(c && function (a, b) {
      g.each(c, f || [a.responseText, b, a]);
    }), this;
  }, n.expr.filters.animated = function (a) {
    return n.grep(n.timers, function (b) {
      return a === b.elem;
    }).length;
  };
  var Jc = a.document.documentElement;

  function Kc(a) {
    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;
  }

  n.offset = {
    setOffset: function (a, b, c) {
      var d,
          e,
          f,
          g,
          h,
          i,
          j,
          k = n.css(a, "position"),
          l = n(a),
          m = {};
      "static" === k && (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m);
    }
  }, n.fn.extend({
    offset: function (a) {
      if (arguments.length) return void 0 === a ? this : this.each(function (b) {
        n.offset.setOffset(this, a, b);
      });
      var b,
          c,
          d = this[0],
          e = {
        top: 0,
        left: 0
      },
          f = d && d.ownerDocument;
      if (f) return b = f.documentElement, n.contains(b, d) ? (typeof d.getBoundingClientRect !== U && (e = d.getBoundingClientRect()), c = Kc(f), {
        top: e.top + c.pageYOffset - b.clientTop,
        left: e.left + c.pageXOffset - b.clientLeft
      }) : e;
    },
    position: function () {
      if (this[0]) {
        var a,
            b,
            c = this[0],
            d = {
          top: 0,
          left: 0
        };
        return "fixed" === n.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (d = a.offset()), d.top += n.css(a[0], "borderTopWidth", !0), d.left += n.css(a[0], "borderLeftWidth", !0)), {
          top: b.top - d.top - n.css(c, "marginTop", !0),
          left: b.left - d.left - n.css(c, "marginLeft", !0)
        };
      }
    },
    offsetParent: function () {
      return this.map(function () {
        var a = this.offsetParent || Jc;

        while (a && !n.nodeName(a, "html") && "static" === n.css(a, "position")) a = a.offsetParent;

        return a || Jc;
      });
    }
  }), n.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (b, c) {
    var d = "pageYOffset" === c;

    n.fn[b] = function (e) {
      return J(this, function (b, e, f) {
        var g = Kc(b);
        return void 0 === f ? g ? g[c] : b[e] : void (g ? g.scrollTo(d ? a.pageXOffset : f, d ? f : a.pageYOffset) : b[e] = f);
      }, b, e, arguments.length, null);
    };
  }), n.each(["top", "left"], function (a, b) {
    n.cssHooks[b] = yb(k.pixelPosition, function (a, c) {
      return c ? (c = xb(a, b), vb.test(c) ? n(a).position()[b] + "px" : c) : void 0;
    });
  }), n.each({
    Height: "height",
    Width: "width"
  }, function (a, b) {
    n.each({
      padding: "inner" + a,
      content: b,
      "": "outer" + a
    }, function (c, d) {
      n.fn[d] = function (d, e) {
        var f = arguments.length && (c || "boolean" != typeof d),
            g = c || (d === !0 || e === !0 ? "margin" : "border");
        return J(this, function (b, c, d) {
          var e;
          return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g);
        }, b, f ? d : void 0, f, null);
      };
    });
  }), n.fn.size = function () {
    return this.length;
  }, n.fn.andSelf = n.fn.addBack,  true && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return n;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  var Lc = a.jQuery,
      Mc = a.$;
  return n.noConflict = function (b) {
    return a.$ === n && (a.$ = Mc), b && a.jQuery === n && (a.jQuery = Lc), n;
  }, typeof b === U && (a.jQuery = a.$ = n), n;
});

/***/ }),

/***/ 3232:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/*! jQuery JSON plugin 2.4.0 | code.google.com/p/jquery-json */
(function ($) {
  'use strict';

  var escape = /["\\\x00-\x1f\x7f-\x9f]/g,
      meta = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '"': '\\"',
    '\\': '\\\\'
  },
      hasOwn = Object.prototype.hasOwnProperty;
  $.toJSON = typeof JSON === 'object' && JSON.stringify ? JSON.stringify : function (o) {
    if (o === null) {
      return 'null';
    }

    var pairs,
        k,
        name,
        val,
        type = $.type(o);

    if (type === 'undefined') {
      return undefined;
    }

    if (type === 'number' || type === 'boolean') {
      return String(o);
    }

    if (type === 'string') {
      return $.quoteString(o);
    }

    if (typeof o.toJSON === 'function') {
      return $.toJSON(o.toJSON());
    }

    if (type === 'date') {
      var month = o.getUTCMonth() + 1,
          day = o.getUTCDate(),
          year = o.getUTCFullYear(),
          hours = o.getUTCHours(),
          minutes = o.getUTCMinutes(),
          seconds = o.getUTCSeconds(),
          milli = o.getUTCMilliseconds();

      if (month < 10) {
        month = '0' + month;
      }

      if (day < 10) {
        day = '0' + day;
      }

      if (hours < 10) {
        hours = '0' + hours;
      }

      if (minutes < 10) {
        minutes = '0' + minutes;
      }

      if (seconds < 10) {
        seconds = '0' + seconds;
      }

      if (milli < 100) {
        milli = '0' + milli;
      }

      if (milli < 10) {
        milli = '0' + milli;
      }

      return '"' + year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds + '.' + milli + 'Z"';
    }

    pairs = [];

    if ($.isArray(o)) {
      for (k = 0; k < o.length; k++) {
        pairs.push($.toJSON(o[k]) || 'null');
      }

      return '[' + pairs.join(',') + ']';
    }

    if (typeof o === 'object') {
      for (k in o) {
        if (hasOwn.call(o, k)) {
          type = typeof k;

          if (type === 'number') {
            name = '"' + k + '"';
          } else if (type === 'string') {
            name = $.quoteString(k);
          } else {
            continue;
          }

          type = typeof o[k];

          if (type !== 'function' && type !== 'undefined') {
            val = $.toJSON(o[k]);
            pairs.push(name + ':' + val);
          }
        }
      }

      return '{' + pairs.join(',') + '}';
    }
  };
  $.evalJSON = typeof JSON === 'object' && JSON.parse ? JSON.parse : function (str) {
    return eval('(' + str + ')');
  };
  $.secureEvalJSON = typeof JSON === 'object' && JSON.parse ? JSON.parse : function (str) {
    var filtered = str.replace(/\\["\\\/bfnrtu]/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(/(?:^|:|,)(?:\s*\[)+/g, '');

    if (/^[\],:{}\s]*$/.test(filtered)) {
      return eval('(' + str + ')');
    }

    throw new SyntaxError('Error parsing JSON, source is not valid.');
  };

  $.quoteString = function (str) {
    if (str.match(escape)) {
      return '"' + str.replace(escape, function (a) {
        var c = meta[a];

        if (typeof c === 'string') {
          return c;
        }

        c = a.charCodeAt();
        return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
      }) + '"';
    }

    return '"' + str + '"';
  };
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175)))

/***/ }),

/***/ 3233:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
 * jQuery Cookie Plugin v1.3.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function ($, document, undefined) {
  var pluses = /\+/g;

  function raw(s) {
    return s;
  }

  function decoded(s) {
    return unRfc2068(decodeURIComponent(s.replace(pluses, ' ')));
  }

  function unRfc2068(value) {
    if (value.indexOf('"') === 0) {
      // This is a quoted cookie as according to RFC2068, unescape
      value = value.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
    }

    return value;
  }

  function fromJSON(value) {
    return config.json ? JSON.parse(value) : value;
  }

  var config = $.cookie = function (key, value, options) {
    // write
    if (value !== undefined) {
      options = $.extend({}, config.defaults, options);

      if (value === null) {
        options.expires = -1;
      }

      if (typeof options.expires === 'number') {
        var days = options.expires,
            t = options.expires = new Date();
        t.setDate(t.getDate() + days);
      }

      value = config.json ? JSON.stringify(value) : String(value);
      return document.cookie = [encodeURIComponent(key), '=', config.raw ? value : encodeURIComponent(value), options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
      options.path ? '; path=' + options.path : '', options.domain ? '; domain=' + options.domain : '', options.secure ? '; secure' : ''].join('');
    } // read


    var decode = config.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    var result = key ? null : {};

    for (var i = 0, l = cookies.length; i < l; i++) {
      var parts = cookies[i].split('=');
      var name = decode(parts.shift());
      var cookie = decode(parts.join('='));

      if (key && key === name) {
        result = fromJSON(cookie);
        break;
      }

      if (!key) {
        result[name] = fromJSON(cookie);
      }
    }

    return result;
  };

  config.defaults = {};

  $.removeCookie = function (key, options) {
    if ($.cookie(key) !== null) {
      $.cookie(key, null, options);
      return true;
    }

    return false;
  };
})(jQuery, document);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175)))

/***/ }),

/***/ 3234:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.1
 * ©2008-2014 SpryMedia Ltd - datatables.net/license
 */
(function (za, O, l) {
  var N = function (h) {
    function T(a) {
      var b,
          c,
          d = {};
      h.each(a, function (e) {
        if ((b = e.match(/^([^A-Z]+?)([A-Z])/)) && -1 !== "a aa ai ao as b fn i m o s ".indexOf(b[1] + " ")) c = e.replace(b[0], b[2].toLowerCase()), d[c] = e, "o" === b[1] && T(a[e]);
      });
      a._hungarianMap = d;
    }

    function G(a, b, c) {
      a._hungarianMap || T(a);
      var d;
      h.each(b, function (e) {
        d = a._hungarianMap[e];
        if (d !== l && (c || b[d] === l)) "o" === d.charAt(0) ? (b[d] || (b[d] = {}), h.extend(!0, b[d], b[e]), G(a[d], b[d], c)) : b[d] = b[e];
      });
    }

    function N(a) {
      var b = p.defaults.oLanguage,
          c = a.sZeroRecords;
      !a.sEmptyTable && c && "No data available in table" === b.sEmptyTable && D(a, a, "sZeroRecords", "sEmptyTable");
      !a.sLoadingRecords && c && "Loading..." === b.sLoadingRecords && D(a, a, "sZeroRecords", "sLoadingRecords");
      a.sInfoThousands && (a.sThousands = a.sInfoThousands);
      (a = a.sDecimal) && cb(a);
    }

    function db(a) {
      w(a, "ordering", "bSort");
      w(a, "orderMulti", "bSortMulti");
      w(a, "orderClasses", "bSortClasses");
      w(a, "orderCellsTop", "bSortCellsTop");
      w(a, "order", "aaSorting");
      w(a, "orderFixed", "aaSortingFixed");
      w(a, "paging", "bPaginate");
      w(a, "pagingType", "sPaginationType");
      w(a, "pageLength", "iDisplayLength");
      w(a, "searching", "bFilter");
      if (a = a.aoSearchCols) for (var b = 0, c = a.length; b < c; b++) a[b] && G(p.models.oSearch, a[b]);
    }

    function eb(a) {
      w(a, "orderable", "bSortable");
      w(a, "orderData", "aDataSort");
      w(a, "orderSequence", "asSorting");
      w(a, "orderDataType", "sortDataType");
    }

    function fb(a) {
      var a = a.oBrowser,
          b = h("<div/>").css({
        position: "absolute",
        top: 0,
        left: 0,
        height: 1,
        width: 1,
        overflow: "hidden"
      }).append(h("<div/>").css({
        position: "absolute",
        top: 1,
        left: 1,
        width: 100,
        overflow: "scroll"
      }).append(h('<div class="test"/>').css({
        width: "100%",
        height: 10
      }))).appendTo("body"),
          c = b.find(".test");
      a.bScrollOversize = 100 === c[0].offsetWidth;
      a.bScrollbarLeft = 1 !== c.offset().left;
      b.remove();
    }

    function gb(a, b, c, d, e, f) {
      var g,
          j = !1;
      c !== l && (g = c, j = !0);

      for (; d !== e;) a.hasOwnProperty(d) && (g = j ? b(g, a[d], d, a) : a[d], j = !0, d += f);

      return g;
    }

    function Aa(a, b) {
      var c = p.defaults.column,
          d = a.aoColumns.length,
          c = h.extend({}, p.models.oColumn, c, {
        nTh: b ? b : O.createElement("th"),
        sTitle: c.sTitle ? c.sTitle : b ? b.innerHTML : "",
        aDataSort: c.aDataSort ? c.aDataSort : [d],
        mData: c.mData ? c.mData : d,
        idx: d
      });
      a.aoColumns.push(c);
      c = a.aoPreSearchCols;
      c[d] = h.extend({}, p.models.oSearch, c[d]);
      fa(a, d, null);
    }

    function fa(a, b, c) {
      var b = a.aoColumns[b],
          d = a.oClasses,
          e = h(b.nTh);

      if (!b.sWidthOrig) {
        b.sWidthOrig = e.attr("width") || null;
        var f = (e.attr("style") || "").match(/width:\s*(\d+[pxem%]+)/);
        f && (b.sWidthOrig = f[1]);
      }

      c !== l && null !== c && (eb(c), G(p.defaults.column, c), c.mDataProp !== l && !c.mData && (c.mData = c.mDataProp), c.sType && (b._sManualType = c.sType), c.className && !c.sClass && (c.sClass = c.className), h.extend(b, c), D(b, c, "sWidth", "sWidthOrig"), "number" === typeof c.iDataSort && (b.aDataSort = [c.iDataSort]), D(b, c, "aDataSort"));

      var g = b.mData,
          j = U(g),
          i = b.mRender ? U(b.mRender) : null,
          c = function (a) {
        return "string" === typeof a && -1 !== a.indexOf("@");
      };

      b._bAttrSrc = h.isPlainObject(g) && (c(g.sort) || c(g.type) || c(g.filter));

      b.fnGetData = function (a, b, c) {
        var d = j(a, b, l, c);
        return i && b ? i(d, b, a, c) : d;
      };

      b.fnSetData = function (a, b, c) {
        return Ba(g)(a, b, c);
      };

      a.oFeatures.bSort || (b.bSortable = !1, e.addClass(d.sSortableNone));
      a = -1 !== h.inArray("asc", b.asSorting);
      c = -1 !== h.inArray("desc", b.asSorting);
      !b.bSortable || !a && !c ? (b.sSortingClass = d.sSortableNone, b.sSortingClassJUI = "") : a && !c ? (b.sSortingClass = d.sSortableAsc, b.sSortingClassJUI = d.sSortJUIAscAllowed) : !a && c ? (b.sSortingClass = d.sSortableDesc, b.sSortingClassJUI = d.sSortJUIDescAllowed) : (b.sSortingClass = d.sSortable, b.sSortingClassJUI = d.sSortJUI);
    }

    function V(a) {
      if (!1 !== a.oFeatures.bAutoWidth) {
        var b = a.aoColumns;
        Ca(a);

        for (var c = 0, d = b.length; c < d; c++) b[c].nTh.style.width = b[c].sWidth;
      }

      b = a.oScroll;
      ("" !== b.sY || "" !== b.sX) && W(a);
      u(a, null, "column-sizing", [a]);
    }

    function ga(a, b) {
      var c = X(a, "bVisible");
      return "number" === typeof c[b] ? c[b] : null;
    }

    function Y(a, b) {
      var c = X(a, "bVisible"),
          c = h.inArray(b, c);
      return -1 !== c ? c : null;
    }

    function Z(a) {
      return X(a, "bVisible").length;
    }

    function X(a, b) {
      var c = [];
      h.map(a.aoColumns, function (a, e) {
        a[b] && c.push(e);
      });
      return c;
    }

    function Da(a) {
      var b = a.aoColumns,
          c = a.aoData,
          d = p.ext.type.detect,
          e,
          f,
          g,
          j,
          i,
          h,
          m,
          n,
          k;
      e = 0;

      for (f = b.length; e < f; e++) if (m = b[e], k = [], !m.sType && m._sManualType) m.sType = m._sManualType;else if (!m.sType) {
        g = 0;

        for (j = d.length; g < j; g++) {
          i = 0;

          for (h = c.length; i < h && !(k[i] === l && (k[i] = A(a, i, e, "type")), n = d[g](k[i], a), !n || "html" === n); i++);

          if (n) {
            m.sType = n;
            break;
          }
        }

        m.sType || (m.sType = "string");
      }
    }

    function hb(a, b, c, d) {
      var e,
          f,
          g,
          j,
          i,
          o,
          m = a.aoColumns;
      if (b) for (e = b.length - 1; 0 <= e; e--) {
        o = b[e];
        var n = o.targets !== l ? o.targets : o.aTargets;
        h.isArray(n) || (n = [n]);
        f = 0;

        for (g = n.length; f < g; f++) if ("number" === typeof n[f] && 0 <= n[f]) {
          for (; m.length <= n[f];) Aa(a);

          d(n[f], o);
        } else if ("number" === typeof n[f] && 0 > n[f]) d(m.length + n[f], o);else if ("string" === typeof n[f]) {
          j = 0;

          for (i = m.length; j < i; j++) ("_all" == n[f] || h(m[j].nTh).hasClass(n[f])) && d(j, o);
        }
      }

      if (c) {
        e = 0;

        for (a = c.length; e < a; e++) d(e, c[e]);
      }
    }

    function I(a, b, c, d) {
      var e = a.aoData.length,
          f = h.extend(!0, {}, p.models.oRow, {
        src: c ? "dom" : "data"
      });
      f._aData = b;
      a.aoData.push(f);

      for (var b = a.aoColumns, f = 0, g = b.length; f < g; f++) c && Ea(a, e, f, A(a, e, f)), b[f].sType = null;

      a.aiDisplayMaster.push(e);
      (c || !a.oFeatures.bDeferRender) && Fa(a, e, c, d);
      return e;
    }

    function ha(a, b) {
      var c;
      b instanceof h || (b = h(b));
      return b.map(function (b, e) {
        c = ia(a, e);
        return I(a, c.data, e, c.cells);
      });
    }

    function A(a, b, c, d) {
      var e = a.iDraw,
          f = a.aoColumns[c],
          g = a.aoData[b]._aData,
          j = f.sDefaultContent,
          c = f.fnGetData(g, d, {
        settings: a,
        row: b,
        col: c
      });
      if (c === l) return a.iDrawError != e && null === j && (P(a, 0, "Requested unknown parameter " + ("function" == typeof f.mData ? "{function}" : "'" + f.mData + "'") + " for row " + b, 4), a.iDrawError = e), j;
      if ((c === g || null === c) && null !== j) c = j;else if ("function" === typeof c) return c.call(g);
      return null === c && "display" == d ? "" : c;
    }

    function Ea(a, b, c, d) {
      a.aoColumns[c].fnSetData(a.aoData[b]._aData, d, {
        settings: a,
        row: b,
        col: c
      });
    }

    function Ga(a) {
      return h.map(a.match(/(\\.|[^\.])+/g), function (a) {
        return a.replace(/\\./g, ".");
      });
    }

    function U(a) {
      if (h.isPlainObject(a)) {
        var b = {};
        h.each(a, function (a, c) {
          c && (b[a] = U(c));
        });
        return function (a, c, f, g) {
          var j = b[c] || b._;
          return j !== l ? j(a, c, f, g) : a;
        };
      }

      if (null === a) return function (a) {
        return a;
      };
      if ("function" === typeof a) return function (b, c, f, g) {
        return a(b, c, f, g);
      };

      if ("string" === typeof a && (-1 !== a.indexOf(".") || -1 !== a.indexOf("[") || -1 !== a.indexOf("("))) {
        var c = function (a, b, f) {
          var g, j;

          if ("" !== f) {
            j = Ga(f);

            for (var i = 0, h = j.length; i < h; i++) {
              f = j[i].match($);
              g = j[i].match(Q);

              if (f) {
                j[i] = j[i].replace($, "");
                "" !== j[i] && (a = a[j[i]]);
                g = [];
                j.splice(0, i + 1);
                j = j.join(".");
                i = 0;

                for (h = a.length; i < h; i++) g.push(c(a[i], b, j));

                a = f[0].substring(1, f[0].length - 1);
                a = "" === a ? g : g.join(a);
                break;
              } else if (g) {
                j[i] = j[i].replace(Q, "");
                a = a[j[i]]();
                continue;
              }

              if (null === a || a[j[i]] === l) return l;
              a = a[j[i]];
            }
          }

          return a;
        };

        return function (b, e) {
          return c(b, e, a);
        };
      }

      return function (b) {
        return b[a];
      };
    }

    function Ba(a) {
      if (h.isPlainObject(a)) return Ba(a._);
      if (null === a) return function () {};
      if ("function" === typeof a) return function (b, d, e) {
        a(b, "set", d, e);
      };

      if ("string" === typeof a && (-1 !== a.indexOf(".") || -1 !== a.indexOf("[") || -1 !== a.indexOf("("))) {
        var b = function (a, d, e) {
          var e = Ga(e),
              f;
          f = e[e.length - 1];

          for (var g, j, i = 0, h = e.length - 1; i < h; i++) {
            g = e[i].match($);
            j = e[i].match(Q);

            if (g) {
              e[i] = e[i].replace($, "");
              a[e[i]] = [];
              f = e.slice();
              f.splice(0, i + 1);
              g = f.join(".");
              j = 0;

              for (h = d.length; j < h; j++) f = {}, b(f, d[j], g), a[e[i]].push(f);

              return;
            }

            j && (e[i] = e[i].replace(Q, ""), a = a[e[i]](d));
            if (null === a[e[i]] || a[e[i]] === l) a[e[i]] = {};
            a = a[e[i]];
          }

          if (f.match(Q)) a[f.replace(Q, "")](d);else a[f.replace($, "")] = d;
        };

        return function (c, d) {
          return b(c, d, a);
        };
      }

      return function (b, d) {
        b[a] = d;
      };
    }

    function Ha(a) {
      return C(a.aoData, "_aData");
    }

    function ja(a) {
      a.aoData.length = 0;
      a.aiDisplayMaster.length = 0;
      a.aiDisplay.length = 0;
    }

    function ka(a, b, c) {
      for (var d = -1, e = 0, f = a.length; e < f; e++) a[e] == b ? d = e : a[e] > b && a[e]--;

      -1 != d && c === l && a.splice(d, 1);
    }

    function la(a, b, c, d) {
      var e = a.aoData[b],
          f;
      if ("dom" === c || (!c || "auto" === c) && "dom" === e.src) e._aData = ia(a, e).data;else {
        var g = e.anCells,
            j;

        if (g) {
          c = 0;

          for (f = g.length; c < f; c++) {
            for (j = g[c]; j.childNodes.length;) j.removeChild(j.firstChild);

            g[c].innerHTML = A(a, b, c, "display");
          }
        }
      }
      e._aSortData = null;
      e._aFilterData = null;
      a = a.aoColumns;
      if (d !== l) a[d].sType = null;else {
        c = 0;

        for (f = a.length; c < f; c++) a[c].sType = null;
      }
      Ia(e);
    }

    function ia(a, b) {
      var c = [],
          d = [],
          e = b.firstChild,
          f,
          g,
          j,
          i = 0,
          o,
          m = a.aoColumns,
          n = function (a, b, c) {
        "string" === typeof a && (b = a.indexOf("@"), -1 !== b && (a = a.substring(b + 1), j["@" + a] = c.getAttribute(a)));
      },
          k = function (a) {
        g = m[i];
        o = h.trim(a.innerHTML);
        g && g._bAttrSrc ? (j = {
          display: o
        }, n(g.mData.sort, j, a), n(g.mData.type, j, a), n(g.mData.filter, j, a), c.push(j)) : c.push(o);
        i++;
      };

      if (e) for (; e;) {
        f = e.nodeName.toUpperCase();
        if ("TD" == f || "TH" == f) k(e), d.push(e);
        e = e.nextSibling;
      } else {
        d = b.anCells;
        e = 0;

        for (f = d.length; e < f; e++) k(d[e]);
      }
      return {
        data: c,
        cells: d
      };
    }

    function Fa(a, b, c, d) {
      var e = a.aoData[b],
          f = e._aData,
          g = [],
          j,
          i,
          h,
          m,
          n;

      if (null === e.nTr) {
        j = c || O.createElement("tr");
        e.nTr = j;
        e.anCells = g;
        j._DT_RowIndex = b;
        Ia(e);
        m = 0;

        for (n = a.aoColumns.length; m < n; m++) {
          h = a.aoColumns[m];
          i = c ? d[m] : O.createElement(h.sCellType);
          g.push(i);
          if (!c || h.mRender || h.mData !== m) i.innerHTML = A(a, b, m, "display");
          h.sClass && (i.className += " " + h.sClass);
          h.bVisible && !c ? j.appendChild(i) : !h.bVisible && c && i.parentNode.removeChild(i);
          h.fnCreatedCell && h.fnCreatedCell.call(a.oInstance, i, A(a, b, m), f, b, m);
        }

        u(a, "aoRowCreatedCallback", null, [j, f, b]);
      }

      e.nTr.setAttribute("role", "row");
    }

    function Ia(a) {
      var b = a.nTr,
          c = a._aData;

      if (b) {
        c.DT_RowId && (b.id = c.DT_RowId);

        if (c.DT_RowClass) {
          var d = c.DT_RowClass.split(" ");
          a.__rowc = a.__rowc ? Ja(a.__rowc.concat(d)) : d;
          h(b).removeClass(a.__rowc.join(" ")).addClass(c.DT_RowClass);
        }

        c.DT_RowData && h(b).data(c.DT_RowData);
      }
    }

    function ib(a) {
      var b,
          c,
          d,
          e,
          f,
          g = a.nTHead,
          j = a.nTFoot,
          i = 0 === h("th, td", g).length,
          o = a.oClasses,
          m = a.aoColumns;
      i && (e = h("<tr/>").appendTo(g));
      b = 0;

      for (c = m.length; b < c; b++) f = m[b], d = h(f.nTh).addClass(f.sClass), i && d.appendTo(e), a.oFeatures.bSort && (d.addClass(f.sSortingClass), !1 !== f.bSortable && (d.attr("tabindex", a.iTabIndex).attr("aria-controls", a.sTableId), Ka(a, f.nTh, b))), f.sTitle != d.html() && d.html(f.sTitle), La(a, "header")(a, d, f, o);

      i && aa(a.aoHeader, g);
      h(g).find(">tr").attr("role", "row");
      h(g).find(">tr>th, >tr>td").addClass(o.sHeaderTH);
      h(j).find(">tr>th, >tr>td").addClass(o.sFooterTH);

      if (null !== j) {
        a = a.aoFooter[0];
        b = 0;

        for (c = a.length; b < c; b++) f = m[b], f.nTf = a[b].cell, f.sClass && h(f.nTf).addClass(f.sClass);
      }
    }

    function ba(a, b, c) {
      var d,
          e,
          f,
          g = [],
          j = [],
          i = a.aoColumns.length,
          o;

      if (b) {
        c === l && (c = !1);
        d = 0;

        for (e = b.length; d < e; d++) {
          g[d] = b[d].slice();
          g[d].nTr = b[d].nTr;

          for (f = i - 1; 0 <= f; f--) !a.aoColumns[f].bVisible && !c && g[d].splice(f, 1);

          j.push([]);
        }

        d = 0;

        for (e = g.length; d < e; d++) {
          if (a = g[d].nTr) for (; f = a.firstChild;) a.removeChild(f);
          f = 0;

          for (b = g[d].length; f < b; f++) if (o = i = 1, j[d][f] === l) {
            a.appendChild(g[d][f].cell);

            for (j[d][f] = 1; g[d + i] !== l && g[d][f].cell == g[d + i][f].cell;) j[d + i][f] = 1, i++;

            for (; g[d][f + o] !== l && g[d][f].cell == g[d][f + o].cell;) {
              for (c = 0; c < i; c++) j[d + c][f + o] = 1;

              o++;
            }

            h(g[d][f].cell).attr("rowspan", i).attr("colspan", o);
          }
        }
      }
    }

    function K(a) {
      var b = u(a, "aoPreDrawCallback", "preDraw", [a]);
      if (-1 !== h.inArray(!1, b)) B(a, !1);else {
        var b = [],
            c = 0,
            d = a.asStripeClasses,
            e = d.length,
            f = a.oLanguage,
            g = a.iInitDisplayStart,
            j = "ssp" == z(a),
            i = a.aiDisplay;
        a.bDrawing = !0;
        g !== l && -1 !== g && (a._iDisplayStart = j ? g : g >= a.fnRecordsDisplay() ? 0 : g, a.iInitDisplayStart = -1);
        var g = a._iDisplayStart,
            o = a.fnDisplayEnd();
        if (a.bDeferLoading) a.bDeferLoading = !1, a.iDraw++, B(a, !1);else if (j) {
          if (!a.bDestroying && !jb(a)) return;
        } else a.iDraw++;

        if (0 !== i.length) {
          f = j ? a.aoData.length : o;

          for (j = j ? 0 : g; j < f; j++) {
            var m = i[j],
                n = a.aoData[m];
            null === n.nTr && Fa(a, m);
            m = n.nTr;

            if (0 !== e) {
              var k = d[c % e];
              n._sRowStripe != k && (h(m).removeClass(n._sRowStripe).addClass(k), n._sRowStripe = k);
            }

            u(a, "aoRowCallback", null, [m, n._aData, c, j]);
            b.push(m);
            c++;
          }
        } else c = f.sZeroRecords, 1 == a.iDraw && "ajax" == z(a) ? c = f.sLoadingRecords : f.sEmptyTable && 0 === a.fnRecordsTotal() && (c = f.sEmptyTable), b[0] = h("<tr/>", {
          "class": e ? d[0] : ""
        }).append(h("<td />", {
          valign: "top",
          colSpan: Z(a),
          "class": a.oClasses.sRowEmpty
        }).html(c))[0];

        u(a, "aoHeaderCallback", "header", [h(a.nTHead).children("tr")[0], Ha(a), g, o, i]);
        u(a, "aoFooterCallback", "footer", [h(a.nTFoot).children("tr")[0], Ha(a), g, o, i]);
        d = h(a.nTBody);
        d.children().detach();
        d.append(h(b));
        u(a, "aoDrawCallback", "draw", [a]);
        a.bSorted = !1;
        a.bFiltered = !1;
        a.bDrawing = !1;
      }
    }

    function L(a, b) {
      var c = a.oFeatures,
          d = c.bFilter;
      c.bSort && kb(a);
      d ? ca(a, a.oPreviousSearch) : a.aiDisplay = a.aiDisplayMaster.slice();
      !0 !== b && (a._iDisplayStart = 0);
      a._drawHold = b;
      K(a);
      a._drawHold = !1;
    }

    function lb(a) {
      var b = a.oClasses,
          c = h(a.nTable),
          c = h("<div/>").insertBefore(c),
          d = a.oFeatures,
          e = h("<div/>", {
        id: a.sTableId + "_wrapper",
        "class": b.sWrapper + (a.nTFoot ? "" : " " + b.sNoFooter)
      });
      a.nHolding = c[0];
      a.nTableWrapper = e[0];
      a.nTableReinsertBefore = a.nTable.nextSibling;

      for (var f = a.sDom.split(""), g, j, i, o, m, n, k = 0; k < f.length; k++) {
        g = null;
        j = f[k];

        if ("<" == j) {
          i = h("<div/>")[0];
          o = f[k + 1];

          if ("'" == o || '"' == o) {
            m = "";

            for (n = 2; f[k + n] != o;) m += f[k + n], n++;

            "H" == m ? m = b.sJUIHeader : "F" == m && (m = b.sJUIFooter);
            -1 != m.indexOf(".") ? (o = m.split("."), i.id = o[0].substr(1, o[0].length - 1), i.className = o[1]) : "#" == m.charAt(0) ? i.id = m.substr(1, m.length - 1) : i.className = m;
            k += n;
          }

          e.append(i);
          e = h(i);
        } else if (">" == j) e = e.parent();else if ("l" == j && d.bPaginate && d.bLengthChange) g = mb(a);else if ("f" == j && d.bFilter) g = nb(a);else if ("r" == j && d.bProcessing) g = ob(a);else if ("t" == j) g = pb(a);else if ("i" == j && d.bInfo) g = qb(a);else if ("p" == j && d.bPaginate) g = rb(a);else if (0 !== p.ext.feature.length) {
          i = p.ext.feature;
          n = 0;

          for (o = i.length; n < o; n++) if (j == i[n].cFeature) {
            g = i[n].fnInit(a);
            break;
          }
        }

        g && (i = a.aanFeatures, i[j] || (i[j] = []), i[j].push(g), e.append(g));
      }

      c.replaceWith(e);
    }

    function aa(a, b) {
      var c = h(b).children("tr"),
          d,
          e,
          f,
          g,
          j,
          i,
          o,
          m,
          n,
          k;
      a.splice(0, a.length);
      f = 0;

      for (i = c.length; f < i; f++) a.push([]);

      f = 0;

      for (i = c.length; f < i; f++) {
        d = c[f];

        for (e = d.firstChild; e;) {
          if ("TD" == e.nodeName.toUpperCase() || "TH" == e.nodeName.toUpperCase()) {
            m = 1 * e.getAttribute("colspan");
            n = 1 * e.getAttribute("rowspan");
            m = !m || 0 === m || 1 === m ? 1 : m;
            n = !n || 0 === n || 1 === n ? 1 : n;
            g = 0;

            for (j = a[f]; j[g];) g++;

            o = g;
            k = 1 === m ? !0 : !1;

            for (j = 0; j < m; j++) for (g = 0; g < n; g++) a[f + g][o + j] = {
              cell: e,
              unique: k
            }, a[f + g].nTr = d;
          }

          e = e.nextSibling;
        }
      }
    }

    function ma(a, b, c) {
      var d = [];
      c || (c = a.aoHeader, b && (c = [], aa(c, b)));

      for (var b = 0, e = c.length; b < e; b++) for (var f = 0, g = c[b].length; f < g; f++) if (c[b][f].unique && (!d[f] || !a.bSortCellsTop)) d[f] = c[b][f].cell;

      return d;
    }

    function na(a, b, c) {
      u(a, "aoServerParams", "serverParams", [b]);

      if (b && h.isArray(b)) {
        var d = {},
            e = /(.*?)\[\]$/;
        h.each(b, function (a, b) {
          var c = b.name.match(e);
          c ? (c = c[0], d[c] || (d[c] = []), d[c].push(b.value)) : d[b.name] = b.value;
        });
        b = d;
      }

      var f,
          g = a.ajax,
          j = a.oInstance;

      if (h.isPlainObject(g) && g.data) {
        f = g.data;
        var i = h.isFunction(f) ? f(b) : f,
            b = h.isFunction(f) && i ? i : h.extend(!0, b, i);
        delete g.data;
      }

      i = {
        data: b,
        success: function (b) {
          var d = b.error || b.sError;
          d && a.oApi._fnLog(a, 0, d);
          a.json = b;
          u(a, null, "xhr", [a, b]);
          c(b);
        },
        dataType: "json",
        cache: !1,
        type: a.sServerMethod,
        error: function (b, c) {
          var d = a.oApi._fnLog;
          "parsererror" == c ? d(a, 0, "Invalid JSON response", 1) : 4 === b.readyState && d(a, 0, "Ajax error", 7);
          B(a, !1);
        }
      };
      a.oAjaxData = b;
      u(a, null, "preXhr", [a, b]);
      a.fnServerData ? a.fnServerData.call(j, a.sAjaxSource, h.map(b, function (a, b) {
        return {
          name: b,
          value: a
        };
      }), c, a) : a.sAjaxSource || "string" === typeof g ? a.jqXHR = h.ajax(h.extend(i, {
        url: g || a.sAjaxSource
      })) : h.isFunction(g) ? a.jqXHR = g.call(j, b, c, a) : (a.jqXHR = h.ajax(h.extend(i, g)), g.data = f);
    }

    function jb(a) {
      return a.bAjaxDataGet ? (a.iDraw++, B(a, !0), na(a, sb(a), function (b) {
        tb(a, b);
      }), !1) : !0;
    }

    function sb(a) {
      var b = a.aoColumns,
          c = b.length,
          d = a.oFeatures,
          e = a.oPreviousSearch,
          f = a.aoPreSearchCols,
          g,
          j = [],
          i,
          o,
          m,
          n = R(a);
      g = a._iDisplayStart;
      i = !1 !== d.bPaginate ? a._iDisplayLength : -1;

      var k = function (a, b) {
        j.push({
          name: a,
          value: b
        });
      };

      k("sEcho", a.iDraw);
      k("iColumns", c);
      k("sColumns", C(b, "sName").join(","));
      k("iDisplayStart", g);
      k("iDisplayLength", i);
      var l = {
        draw: a.iDraw,
        columns: [],
        order: [],
        start: g,
        length: i,
        search: {
          value: e.sSearch,
          regex: e.bRegex
        }
      };

      for (g = 0; g < c; g++) o = b[g], m = f[g], i = "function" == typeof o.mData ? "function" : o.mData, l.columns.push({
        data: i,
        name: o.sName,
        searchable: o.bSearchable,
        orderable: o.bSortable,
        search: {
          value: m.sSearch,
          regex: m.bRegex
        }
      }), k("mDataProp_" + g, i), d.bFilter && (k("sSearch_" + g, m.sSearch), k("bRegex_" + g, m.bRegex), k("bSearchable_" + g, o.bSearchable)), d.bSort && k("bSortable_" + g, o.bSortable);

      d.bFilter && (k("sSearch", e.sSearch), k("bRegex", e.bRegex));
      d.bSort && (h.each(n, function (a, b) {
        l.order.push({
          column: b.col,
          dir: b.dir
        });
        k("iSortCol_" + a, b.col);
        k("sSortDir_" + a, b.dir);
      }), k("iSortingCols", n.length));
      b = p.ext.legacy.ajax;
      return null === b ? a.sAjaxSource ? j : l : b ? j : l;
    }

    function tb(a, b) {
      var c = b.sEcho !== l ? b.sEcho : b.draw,
          d = b.iTotalRecords !== l ? b.iTotalRecords : b.recordsTotal,
          e = b.iTotalDisplayRecords !== l ? b.iTotalDisplayRecords : b.recordsFiltered;

      if (c) {
        if (1 * c < a.iDraw) return;
        a.iDraw = 1 * c;
      }

      ja(a);
      a._iRecordsTotal = parseInt(d, 10);
      a._iRecordsDisplay = parseInt(e, 10);
      c = oa(a, b);
      d = 0;

      for (e = c.length; d < e; d++) I(a, c[d]);

      a.aiDisplay = a.aiDisplayMaster.slice();
      a.bAjaxDataGet = !1;
      K(a);
      a._bInitComplete || pa(a, b);
      a.bAjaxDataGet = !0;
      B(a, !1);
    }

    function oa(a, b) {
      var c = h.isPlainObject(a.ajax) && a.ajax.dataSrc !== l ? a.ajax.dataSrc : a.sAjaxDataProp;
      return "data" === c ? b.aaData || b[c] : "" !== c ? U(c)(b) : b;
    }

    function nb(a) {
      var b = a.oClasses,
          c = a.sTableId,
          d = a.oLanguage,
          e = a.oPreviousSearch,
          f = a.aanFeatures,
          g = '<input type="search" class="' + b.sFilterInput + '"/>',
          j = d.sSearch,
          j = j.match(/_INPUT_/) ? j.replace("_INPUT_", g) : j + g,
          b = h("<div/>", {
        id: !f.f ? c + "_filter" : null,
        "class": b.sFilter
      }).append(h("<label/>").append(j)),
          f = function () {
        var b = !this.value ? "" : this.value;
        b != e.sSearch && (ca(a, {
          sSearch: b,
          bRegex: e.bRegex,
          bSmart: e.bSmart,
          bCaseInsensitive: e.bCaseInsensitive
        }), a._iDisplayStart = 0, K(a));
      },
          i = h("input", b).val(e.sSearch).attr("placeholder", d.sSearchPlaceholder).bind("keyup.DT search.DT input.DT paste.DT cut.DT", "ssp" === z(a) ? Ma(f, 400) : f).bind("keypress.DT", function (a) {
        if (13 == a.keyCode) return !1;
      }).attr("aria-controls", c);

      h(a.nTable).on("search.dt.DT", function (b, c) {
        if (a === c) try {
          i[0] !== O.activeElement && i.val(e.sSearch);
        } catch (d) {}
      });
      return b[0];
    }

    function ca(a, b, c) {
      var d = a.oPreviousSearch,
          e = a.aoPreSearchCols,
          f = function (a) {
        d.sSearch = a.sSearch;
        d.bRegex = a.bRegex;
        d.bSmart = a.bSmart;
        d.bCaseInsensitive = a.bCaseInsensitive;
      };

      Da(a);

      if ("ssp" != z(a)) {
        ub(a, b.sSearch, c, b.bEscapeRegex !== l ? !b.bEscapeRegex : b.bRegex, b.bSmart, b.bCaseInsensitive);
        f(b);

        for (b = 0; b < e.length; b++) vb(a, e[b].sSearch, b, e[b].bEscapeRegex !== l ? !e[b].bEscapeRegex : e[b].bRegex, e[b].bSmart, e[b].bCaseInsensitive);

        wb(a);
      } else f(b);

      a.bFiltered = !0;
      u(a, null, "search", [a]);
    }

    function wb(a) {
      for (var b = p.ext.search, c = a.aiDisplay, d, e, f = 0, g = b.length; f < g; f++) {
        for (var j = [], i = 0, h = c.length; i < h; i++) e = c[i], d = a.aoData[e], b[f](a, d._aFilterData, e, d._aData, i) && j.push(e);

        c.length = 0;
        c.push.apply(c, j);
      }
    }

    function vb(a, b, c, d, e, f) {
      if ("" !== b) for (var g = a.aiDisplay, d = Na(b, d, e, f), e = g.length - 1; 0 <= e; e--) b = a.aoData[g[e]]._aFilterData[c], d.test(b) || g.splice(e, 1);
    }

    function ub(a, b, c, d, e, f) {
      var d = Na(b, d, e, f),
          e = a.oPreviousSearch.sSearch,
          f = a.aiDisplayMaster,
          g;
      0 !== p.ext.search.length && (c = !0);
      g = xb(a);
      if (0 >= b.length) a.aiDisplay = f.slice();else {
        if (g || c || e.length > b.length || 0 !== b.indexOf(e) || a.bSorted) a.aiDisplay = f.slice();
        b = a.aiDisplay;

        for (c = b.length - 1; 0 <= c; c--) d.test(a.aoData[b[c]]._sFilterRow) || b.splice(c, 1);
      }
    }

    function Na(a, b, c, d) {
      a = b ? a : Oa(a);
      c && (a = "^(?=.*?" + h.map(a.match(/"[^"]+"|[^ ]+/g) || "", function (a) {
        return '"' === a.charAt(0) ? a.match(/^"(.*)"$/)[1] : a;
      }).join(")(?=.*?") + ").*$");
      return RegExp(a, d ? "i" : "");
    }

    function Oa(a) {
      return a.replace(Vb, "\\$1");
    }

    function xb(a) {
      var b = a.aoColumns,
          c,
          d,
          e,
          f,
          g,
          j,
          i,
          h,
          m = p.ext.type.search;
      c = !1;
      d = 0;

      for (f = a.aoData.length; d < f; d++) if (h = a.aoData[d], !h._aFilterData) {
        j = [];
        e = 0;

        for (g = b.length; e < g; e++) if (c = b[e], c.bSearchable ? (i = A(a, d, e, "filter"), i = m[c.sType] ? m[c.sType](i) : null !== i ? i : "") : i = "", i) i.indexOf && -1 !== i.indexOf("&") && (qa.innerHTML = i, i = Wb ? qa.textContent : qa.innerText), i.replace && (i = i.replace(/[\r\n]/g, "")), j.push(i);

        h._aFilterData = j;
        h._sFilterRow = j.join("  ");
        c = !0;
      }

      return c;
    }

    function yb(a) {
      return {
        search: a.sSearch,
        smart: a.bSmart,
        regex: a.bRegex,
        caseInsensitive: a.bCaseInsensitive
      };
    }

    function zb(a) {
      return {
        sSearch: a.search,
        bSmart: a.smart,
        bRegex: a.regex,
        bCaseInsensitive: a.caseInsensitive
      };
    }

    function qb(a) {
      var b = a.sTableId,
          c = a.aanFeatures.i,
          d = h("<div/>", {
        "class": a.oClasses.sInfo,
        id: !c ? b + "_info" : null
      });
      c || (a.aoDrawCallback.push({
        fn: Ab,
        sName: "information"
      }), d.attr("role", "status").attr("aria-live", "polite"), h(a.nTable).attr("aria-describedby", b + "_info"));
      return d[0];
    }

    function Ab(a) {
      var b = a.aanFeatures.i;

      if (0 !== b.length) {
        var c = a.oLanguage,
            d = a._iDisplayStart + 1,
            e = a.fnDisplayEnd(),
            f = a.fnRecordsTotal(),
            g = a.fnRecordsDisplay(),
            j = g ? c.sInfo : c.sInfoEmpty;
        g !== f && (j += " " + c.sInfoFiltered);
        j += c.sInfoPostFix;
        j = Bb(a, j);
        c = c.fnInfoCallback;
        null !== c && (j = c.call(a.oInstance, a, d, e, f, g, j));
        h(b).html(j);
      }
    }

    function Bb(a, b) {
      var c = a.fnFormatNumber,
          d = a._iDisplayStart + 1,
          e = a._iDisplayLength,
          f = a.fnRecordsDisplay(),
          g = -1 === e;
      return b.replace(/_START_/g, c.call(a, d)).replace(/_END_/g, c.call(a, a.fnDisplayEnd())).replace(/_MAX_/g, c.call(a, a.fnRecordsTotal())).replace(/_TOTAL_/g, c.call(a, f)).replace(/_PAGE_/g, c.call(a, g ? 1 : Math.ceil(d / e))).replace(/_PAGES_/g, c.call(a, g ? 1 : Math.ceil(f / e)));
    }

    function ra(a) {
      var b,
          c,
          d = a.iInitDisplayStart,
          e = a.aoColumns,
          f;
      c = a.oFeatures;

      if (a.bInitialised) {
        lb(a);
        ib(a);
        ba(a, a.aoHeader);
        ba(a, a.aoFooter);
        B(a, !0);
        c.bAutoWidth && Ca(a);
        b = 0;

        for (c = e.length; b < c; b++) f = e[b], f.sWidth && (f.nTh.style.width = s(f.sWidth));

        L(a);
        e = z(a);
        "ssp" != e && ("ajax" == e ? na(a, [], function (c) {
          var f = oa(a, c);

          for (b = 0; b < f.length; b++) I(a, f[b]);

          a.iInitDisplayStart = d;
          L(a);
          B(a, !1);
          pa(a, c);
        }, a) : (B(a, !1), pa(a)));
      } else setTimeout(function () {
        ra(a);
      }, 200);
    }

    function pa(a, b) {
      a._bInitComplete = !0;
      b && V(a);
      u(a, "aoInitComplete", "init", [a, b]);
    }

    function Pa(a, b) {
      var c = parseInt(b, 10);
      a._iDisplayLength = c;
      Qa(a);
      u(a, null, "length", [a, c]);
    }

    function mb(a) {
      for (var b = a.oClasses, c = a.sTableId, d = a.aLengthMenu, e = h.isArray(d[0]), f = e ? d[0] : d, d = e ? d[1] : d, e = h("<select/>", {
        name: c + "_length",
        "aria-controls": c,
        "class": b.sLengthSelect
      }), g = 0, j = f.length; g < j; g++) e[0][g] = new Option(d[g], f[g]);

      var i = h("<div><label/></div>").addClass(b.sLength);
      a.aanFeatures.l || (i[0].id = c + "_length");
      i.children().append(a.oLanguage.sLengthMenu.replace("_MENU_", e[0].outerHTML));
      h("select", i).val(a._iDisplayLength).bind("change.DT", function () {
        Pa(a, h(this).val());
        K(a);
      });
      h(a.nTable).bind("length.dt.DT", function (b, c, d) {
        a === c && h("select", i).val(d);
      });
      return i[0];
    }

    function rb(a) {
      var b = a.sPaginationType,
          c = p.ext.pager[b],
          d = "function" === typeof c,
          e = function (a) {
        K(a);
      },
          b = h("<div/>").addClass(a.oClasses.sPaging + b)[0],
          f = a.aanFeatures;

      d || c.fnInit(a, b, e);
      f.p || (b.id = a.sTableId + "_paginate", a.aoDrawCallback.push({
        fn: function (a) {
          if (d) {
            var b = a._iDisplayStart,
                i = a._iDisplayLength,
                h = a.fnRecordsDisplay(),
                m = -1 === i,
                b = m ? 0 : Math.ceil(b / i),
                i = m ? 1 : Math.ceil(h / i),
                h = c(b, i),
                n,
                m = 0;

            for (n = f.p.length; m < n; m++) La(a, "pageButton")(a, f.p[m], m, h, b, i);
          } else c.fnUpdate(a, e);
        },
        sName: "pagination"
      }));
      return b;
    }

    function Ra(a, b, c) {
      var d = a._iDisplayStart,
          e = a._iDisplayLength,
          f = a.fnRecordsDisplay();
      0 === f || -1 === e ? d = 0 : "number" === typeof b ? (d = b * e, d > f && (d = 0)) : "first" == b ? d = 0 : "previous" == b ? (d = 0 <= e ? d - e : 0, 0 > d && (d = 0)) : "next" == b ? d + e < f && (d += e) : "last" == b ? d = Math.floor((f - 1) / e) * e : P(a, 0, "Unknown paging action: " + b, 5);
      b = a._iDisplayStart !== d;
      a._iDisplayStart = d;
      b && (u(a, null, "page", [a]), c && K(a));
      return b;
    }

    function ob(a) {
      return h("<div/>", {
        id: !a.aanFeatures.r ? a.sTableId + "_processing" : null,
        "class": a.oClasses.sProcessing
      }).html(a.oLanguage.sProcessing).insertBefore(a.nTable)[0];
    }

    function B(a, b) {
      a.oFeatures.bProcessing && h(a.aanFeatures.r).css("display", b ? "block" : "none");
      u(a, null, "processing", [a, b]);
    }

    function pb(a) {
      var b = h(a.nTable);
      b.attr("role", "grid");
      var c = a.oScroll;
      if ("" === c.sX && "" === c.sY) return a.nTable;
      var d = c.sX,
          e = c.sY,
          f = a.oClasses,
          g = b.children("caption"),
          j = g.length ? g[0]._captionSide : null,
          i = h(b[0].cloneNode(!1)),
          o = h(b[0].cloneNode(!1)),
          m = b.children("tfoot");
      c.sX && "100%" === b.attr("width") && b.removeAttr("width");
      m.length || (m = null);
      c = h("<div/>", {
        "class": f.sScrollWrapper
      }).append(h("<div/>", {
        "class": f.sScrollHead
      }).css({
        overflow: "hidden",
        position: "relative",
        border: 0,
        width: d ? !d ? null : s(d) : "100%"
      }).append(h("<div/>", {
        "class": f.sScrollHeadInner
      }).css({
        "box-sizing": "content-box",
        width: c.sXInner || "100%"
      }).append(i.removeAttr("id").css("margin-left", 0).append(b.children("thead")))).append("top" === j ? g : null)).append(h("<div/>", {
        "class": f.sScrollBody
      }).css({
        overflow: "auto",
        height: !e ? null : s(e),
        width: !d ? null : s(d)
      }).append(b));
      m && c.append(h("<div/>", {
        "class": f.sScrollFoot
      }).css({
        overflow: "hidden",
        border: 0,
        width: d ? !d ? null : s(d) : "100%"
      }).append(h("<div/>", {
        "class": f.sScrollFootInner
      }).append(o.removeAttr("id").css("margin-left", 0).append(b.children("tfoot")))).append("bottom" === j ? g : null));
      var b = c.children(),
          n = b[0],
          f = b[1],
          k = m ? b[2] : null;
      d && h(f).scroll(function () {
        var a = this.scrollLeft;
        n.scrollLeft = a;
        m && (k.scrollLeft = a);
      });
      a.nScrollHead = n;
      a.nScrollBody = f;
      a.nScrollFoot = k;
      a.aoDrawCallback.push({
        fn: W,
        sName: "scrolling"
      });
      return c[0];
    }

    function W(a) {
      var b = a.oScroll,
          c = b.sX,
          d = b.sXInner,
          e = b.sY,
          f = b.iBarWidth,
          g = h(a.nScrollHead),
          j = g[0].style,
          i = g.children("div"),
          o = i[0].style,
          m = i.children("table"),
          i = a.nScrollBody,
          n = h(i),
          k = i.style,
          l = h(a.nScrollFoot).children("div"),
          p = l.children("table"),
          r = h(a.nTHead),
          q = h(a.nTable),
          da = q[0],
          M = da.style,
          J = a.nTFoot ? h(a.nTFoot) : null,
          u = a.oBrowser,
          v = u.bScrollOversize,
          y,
          t,
          x,
          w,
          z,
          A = [],
          B = [],
          C = [],
          D,
          E = function (a) {
        a = a.style;
        a.paddingTop = "0";
        a.paddingBottom = "0";
        a.borderTopWidth = "0";
        a.borderBottomWidth = "0";
        a.height = 0;
      };

      q.children("thead, tfoot").remove();
      z = r.clone().prependTo(q);
      y = r.find("tr");
      x = z.find("tr");
      z.find("th, td").removeAttr("tabindex");
      J && (w = J.clone().prependTo(q), t = J.find("tr"), w = w.find("tr"));
      c || (k.width = "100%", g[0].style.width = "100%");
      h.each(ma(a, z), function (b, c) {
        D = ga(a, b);
        c.style.width = a.aoColumns[D].sWidth;
      });
      J && F(function (a) {
        a.style.width = "";
      }, w);
      b.bCollapse && "" !== e && (k.height = n[0].offsetHeight + r[0].offsetHeight + "px");
      g = q.outerWidth();

      if ("" === c) {
        if (M.width = "100%", v && (q.find("tbody").height() > i.offsetHeight || "scroll" == n.css("overflow-y"))) M.width = s(q.outerWidth() - f);
      } else "" !== d ? M.width = s(d) : g == n.width() && n.height() < q.height() ? (M.width = s(g - f), q.outerWidth() > g - f && (M.width = s(g))) : M.width = s(g);

      g = q.outerWidth();
      F(E, x);
      F(function (a) {
        C.push(a.innerHTML);
        A.push(s(h(a).css("width")));
      }, x);
      F(function (a, b) {
        a.style.width = A[b];
      }, y);
      h(x).height(0);
      J && (F(E, w), F(function (a) {
        B.push(s(h(a).css("width")));
      }, w), F(function (a, b) {
        a.style.width = B[b];
      }, t), h(w).height(0));
      F(function (a, b) {
        a.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + C[b] + "</div>";
        a.style.width = A[b];
      }, x);
      J && F(function (a, b) {
        a.innerHTML = "";
        a.style.width = B[b];
      }, w);

      if (q.outerWidth() < g) {
        t = i.scrollHeight > i.offsetHeight || "scroll" == n.css("overflow-y") ? g + f : g;
        if (v && (i.scrollHeight > i.offsetHeight || "scroll" == n.css("overflow-y"))) M.width = s(t - f);
        ("" === c || "" !== d) && P(a, 1, "Possible column misalignment", 6);
      } else t = "100%";

      k.width = s(t);
      j.width = s(t);
      J && (a.nScrollFoot.style.width = s(t));
      !e && v && (k.height = s(da.offsetHeight + f));
      e && b.bCollapse && (k.height = s(e), b = c && da.offsetWidth > i.offsetWidth ? f : 0, da.offsetHeight < i.offsetHeight && (k.height = s(da.offsetHeight + b)));
      b = q.outerWidth();
      m[0].style.width = s(b);
      o.width = s(b);
      m = q.height() > i.clientHeight || "scroll" == n.css("overflow-y");
      u = "padding" + (u.bScrollbarLeft ? "Left" : "Right");
      o[u] = m ? f + "px" : "0px";
      J && (p[0].style.width = s(b), l[0].style.width = s(b), l[0].style[u] = m ? f + "px" : "0px");
      n.scroll();
      if ((a.bSorted || a.bFiltered) && !a._drawHold) i.scrollTop = 0;
    }

    function F(a, b, c) {
      for (var d = 0, e = 0, f = b.length, g, j; e < f;) {
        g = b[e].firstChild;

        for (j = c ? c[e].firstChild : null; g;) 1 === g.nodeType && (c ? a(g, j, d) : a(g, d), d++), g = g.nextSibling, j = c ? j.nextSibling : null;

        e++;
      }
    }

    function Ca(a) {
      var b = a.nTable,
          c = a.aoColumns,
          d = a.oScroll,
          e = d.sY,
          f = d.sX,
          g = d.sXInner,
          j = c.length,
          d = X(a, "bVisible"),
          i = h("th", a.nTHead),
          o = b.getAttribute("width"),
          m = b.parentNode,
          n = !1,
          k,
          l;

      for (k = 0; k < d.length; k++) l = c[d[k]], null !== l.sWidth && (l.sWidth = Cb(l.sWidthOrig, m), n = !0);

      if (!n && !f && !e && j == Z(a) && j == i.length) for (k = 0; k < j; k++) c[k].sWidth = s(i.eq(k).width());else {
        j = h(b).clone().empty().css("visibility", "hidden").removeAttr("id").append(h(a.nTHead).clone(!1)).append(h(a.nTFoot).clone(!1)).append(h("<tbody><tr/></tbody>"));
        j.find("tfoot th, tfoot td").css("width", "");
        var p = j.find("tbody tr"),
            i = ma(a, j.find("thead")[0]);

        for (k = 0; k < d.length; k++) l = c[d[k]], i[k].style.width = null !== l.sWidthOrig && "" !== l.sWidthOrig ? s(l.sWidthOrig) : "";

        if (a.aoData.length) for (k = 0; k < d.length; k++) n = d[k], l = c[n], h(Db(a, n)).clone(!1).append(l.sContentPadding).appendTo(p);
        j.appendTo(m);
        f && g ? j.width(g) : f ? (j.css("width", "auto"), j.width() < m.offsetWidth && j.width(m.offsetWidth)) : e ? j.width(m.offsetWidth) : o && j.width(o);
        Eb(a, j[0]);

        if (f) {
          for (k = g = 0; k < d.length; k++) l = c[d[k]], e = h(i[k]).outerWidth(), g += null === l.sWidthOrig ? e : parseInt(l.sWidth, 10) + e - h(i[k]).width();

          j.width(s(g));
          b.style.width = s(g);
        }

        for (k = 0; k < d.length; k++) if (l = c[d[k]], e = h(i[k]).width()) l.sWidth = s(e);

        b.style.width = s(j.css("width"));
        j.remove();
      }
      o && (b.style.width = s(o));
      if ((o || f) && !a._reszEvt) h(za).bind("resize.DT-" + a.sInstance, Ma(function () {
        V(a);
      })), a._reszEvt = !0;
    }

    function Ma(a, b) {
      var c = b || 200,
          d,
          e;
      return function () {
        var b = this,
            g = +new Date(),
            j = arguments;
        d && g < d + c ? (clearTimeout(e), e = setTimeout(function () {
          d = l;
          a.apply(b, j);
        }, c)) : d ? (d = g, a.apply(b, j)) : d = g;
      };
    }

    function Cb(a, b) {
      if (!a) return 0;
      var c = h("<div/>").css("width", s(a)).appendTo(b || O.body),
          d = c[0].offsetWidth;
      c.remove();
      return d;
    }

    function Eb(a, b) {
      var c = a.oScroll;
      if (c.sX || c.sY) c = !c.sX ? c.iBarWidth : 0, b.style.width = s(h(b).outerWidth() - c);
    }

    function Db(a, b) {
      var c = Fb(a, b);
      if (0 > c) return null;
      var d = a.aoData[c];
      return !d.nTr ? h("<td/>").html(A(a, c, b, "display"))[0] : d.anCells[b];
    }

    function Fb(a, b) {
      for (var c, d = -1, e = -1, f = 0, g = a.aoData.length; f < g; f++) c = A(a, f, b, "display") + "", c = c.replace(Xb, ""), c.length > d && (d = c.length, e = f);

      return e;
    }

    function s(a) {
      return null === a ? "0px" : "number" == typeof a ? 0 > a ? "0px" : a + "px" : a.match(/\d$/) ? a + "px" : a;
    }

    function Gb() {
      if (!p.__scrollbarWidth) {
        var a = h("<p/>").css({
          width: "100%",
          height: 200,
          padding: 0
        })[0],
            b = h("<div/>").css({
          position: "absolute",
          top: 0,
          left: 0,
          width: 200,
          height: 150,
          padding: 0,
          overflow: "hidden",
          visibility: "hidden"
        }).append(a).appendTo("body"),
            c = a.offsetWidth;
        b.css("overflow", "scroll");
        a = a.offsetWidth;
        c === a && (a = b[0].clientWidth);
        b.remove();
        p.__scrollbarWidth = c - a;
      }

      return p.__scrollbarWidth;
    }

    function R(a) {
      var b,
          c,
          d = [],
          e = a.aoColumns,
          f,
          g,
          j,
          i;
      b = a.aaSortingFixed;
      c = h.isPlainObject(b);
      var o = [];

      f = function (a) {
        a.length && !h.isArray(a[0]) ? o.push(a) : o.push.apply(o, a);
      };

      h.isArray(b) && f(b);
      c && b.pre && f(b.pre);
      f(a.aaSorting);
      c && b.post && f(b.post);

      for (a = 0; a < o.length; a++) {
        i = o[a][0];
        f = e[i].aDataSort;
        b = 0;

        for (c = f.length; b < c; b++) g = f[b], j = e[g].sType || "string", d.push({
          src: i,
          col: g,
          dir: o[a][1],
          index: o[a][2],
          type: j,
          formatter: p.ext.type.order[j + "-pre"]
        });
      }

      return d;
    }

    function kb(a) {
      var b,
          c,
          d = [],
          e = p.ext.type.order,
          f = a.aoData,
          g = 0,
          j,
          i = a.aiDisplayMaster,
          h;
      Da(a);
      h = R(a);
      b = 0;

      for (c = h.length; b < c; b++) j = h[b], j.formatter && g++, Hb(a, j.col);

      if ("ssp" != z(a) && 0 !== h.length) {
        b = 0;

        for (c = i.length; b < c; b++) d[i[b]] = b;

        g === h.length ? i.sort(function (a, b) {
          var c,
              e,
              g,
              j,
              i = h.length,
              l = f[a]._aSortData,
              p = f[b]._aSortData;

          for (g = 0; g < i; g++) if (j = h[g], c = l[j.col], e = p[j.col], c = c < e ? -1 : c > e ? 1 : 0, 0 !== c) return "asc" === j.dir ? c : -c;

          c = d[a];
          e = d[b];
          return c < e ? -1 : c > e ? 1 : 0;
        }) : i.sort(function (a, b) {
          var c,
              g,
              j,
              i,
              l = h.length,
              p = f[a]._aSortData,
              r = f[b]._aSortData;

          for (j = 0; j < l; j++) if (i = h[j], c = p[i.col], g = r[i.col], i = e[i.type + "-" + i.dir] || e["string-" + i.dir], c = i(c, g), 0 !== c) return c;

          c = d[a];
          g = d[b];
          return c < g ? -1 : c > g ? 1 : 0;
        });
      }

      a.bSorted = !0;
    }

    function Ib(a) {
      for (var b, c, d = a.aoColumns, e = R(a), a = a.oLanguage.oAria, f = 0, g = d.length; f < g; f++) {
        c = d[f];
        var j = c.asSorting;
        b = c.sTitle.replace(/<.*?>/g, "");
        var i = c.nTh;
        i.removeAttribute("aria-sort");
        c.bSortable && (0 < e.length && e[0].col == f ? (i.setAttribute("aria-sort", "asc" == e[0].dir ? "ascending" : "descending"), c = j[e[0].index + 1] || j[0]) : c = j[0], b += "asc" === c ? a.sSortAscending : a.sSortDescending);
        i.setAttribute("aria-label", b);
      }
    }

    function Sa(a, b, c, d) {
      var e = a.aaSorting,
          f = a.aoColumns[b].asSorting,
          g = function (a) {
        var b = a._idx;
        b === l && (b = h.inArray(a[1], f));
        return b + 1 >= f.length ? 0 : b + 1;
      };

      "number" === typeof e[0] && (e = a.aaSorting = [e]);
      c && a.oFeatures.bSortMulti ? (c = h.inArray(b, C(e, "0")), -1 !== c ? (b = g(e[c]), e[c][1] = f[b], e[c]._idx = b) : (e.push([b, f[0], 0]), e[e.length - 1]._idx = 0)) : e.length && e[0][0] == b ? (b = g(e[0]), e.length = 1, e[0][1] = f[b], e[0]._idx = b) : (e.length = 0, e.push([b, f[0]]), e[0]._idx = 0);
      L(a);
      "function" == typeof d && d(a);
    }

    function Ka(a, b, c, d) {
      var e = a.aoColumns[c];
      Ta(b, {}, function (b) {
        !1 !== e.bSortable && (a.oFeatures.bProcessing ? (B(a, !0), setTimeout(function () {
          Sa(a, c, b.shiftKey, d);
          "ssp" !== z(a) && B(a, !1);
        }, 0)) : Sa(a, c, b.shiftKey, d));
      });
    }

    function sa(a) {
      var b = a.aLastSort,
          c = a.oClasses.sSortColumn,
          d = R(a),
          e = a.oFeatures,
          f,
          g;

      if (e.bSort && e.bSortClasses) {
        e = 0;

        for (f = b.length; e < f; e++) g = b[e].src, h(C(a.aoData, "anCells", g)).removeClass(c + (2 > e ? e + 1 : 3));

        e = 0;

        for (f = d.length; e < f; e++) g = d[e].src, h(C(a.aoData, "anCells", g)).addClass(c + (2 > e ? e + 1 : 3));
      }

      a.aLastSort = d;
    }

    function Hb(a, b) {
      var c = a.aoColumns[b],
          d = p.ext.order[c.sSortDataType],
          e;
      d && (e = d.call(a.oInstance, a, b, Y(a, b)));

      for (var f, g = p.ext.type.order[c.sType + "-pre"], j = 0, i = a.aoData.length; j < i; j++) if (c = a.aoData[j], c._aSortData || (c._aSortData = []), !c._aSortData[b] || d) f = d ? e[j] : A(a, j, b, "sort"), c._aSortData[b] = g ? g(f) : f;
    }

    function ta(a) {
      if (a.oFeatures.bStateSave && !a.bDestroying) {
        var b = {
          time: +new Date(),
          start: a._iDisplayStart,
          length: a._iDisplayLength,
          order: h.extend(!0, [], a.aaSorting),
          search: yb(a.oPreviousSearch),
          columns: h.map(a.aoColumns, function (b, d) {
            return {
              visible: b.bVisible,
              search: yb(a.aoPreSearchCols[d])
            };
          })
        };
        u(a, "aoStateSaveParams", "stateSaveParams", [a, b]);
        a.oSavedState = b;
        a.fnStateSaveCallback.call(a.oInstance, a, b);
      }
    }

    function Jb(a) {
      var b,
          c,
          d = a.aoColumns;

      if (a.oFeatures.bStateSave) {
        var e = a.fnStateLoadCallback.call(a.oInstance, a);

        if (e && e.time && (b = u(a, "aoStateLoadParams", "stateLoadParams", [a, e]), -1 === h.inArray(!1, b) && (b = a.iStateDuration, !(0 < b && e.time < +new Date() - 1E3 * b) && d.length === e.columns.length))) {
          a.oLoadedState = h.extend(!0, {}, e);
          a._iDisplayStart = e.start;
          a.iInitDisplayStart = e.start;
          a._iDisplayLength = e.length;
          a.aaSorting = [];
          h.each(e.order, function (b, c) {
            a.aaSorting.push(c[0] >= d.length ? [0, c[1]] : c);
          });
          h.extend(a.oPreviousSearch, zb(e.search));
          b = 0;

          for (c = e.columns.length; b < c; b++) {
            var f = e.columns[b];
            d[b].bVisible = f.visible;
            h.extend(a.aoPreSearchCols[b], zb(f.search));
          }

          u(a, "aoStateLoaded", "stateLoaded", [a, e]);
        }
      }
    }

    function ua(a) {
      var b = p.settings,
          a = h.inArray(a, C(b, "nTable"));
      return -1 !== a ? b[a] : null;
    }

    function P(a, b, c, d) {
      c = "DataTables warning: " + (null !== a ? "table id=" + a.sTableId + " - " : "") + c;
      d && (c += ". For more information about this error, please see http://datatables.net/tn/" + d);
      if (b) za.console && console.log && console.log(c);else if (a = p.ext, "alert" == (a.sErrMode || a.errMode)) alert(c);else throw Error(c);
    }

    function D(a, b, c, d) {
      h.isArray(c) ? h.each(c, function (c, d) {
        h.isArray(d) ? D(a, b, d[0], d[1]) : D(a, b, d);
      }) : (d === l && (d = c), b[c] !== l && (a[d] = b[c]));
    }

    function Kb(a, b, c) {
      var d, e;

      for (e in b) b.hasOwnProperty(e) && (d = b[e], h.isPlainObject(d) ? (h.isPlainObject(a[e]) || (a[e] = {}), h.extend(!0, a[e], d)) : a[e] = c && "data" !== e && "aaData" !== e && h.isArray(d) ? d.slice() : d);

      return a;
    }

    function Ta(a, b, c) {
      h(a).bind("click.DT", b, function (b) {
        a.blur();
        c(b);
      }).bind("keypress.DT", b, function (a) {
        13 === a.which && (a.preventDefault(), c(a));
      }).bind("selectstart.DT", function () {
        return !1;
      });
    }

    function x(a, b, c, d) {
      c && a[b].push({
        fn: c,
        sName: d
      });
    }

    function u(a, b, c, d) {
      var e = [];
      b && (e = h.map(a[b].slice().reverse(), function (b) {
        return b.fn.apply(a.oInstance, d);
      }));
      null !== c && h(a.nTable).trigger(c + ".dt", d);
      return e;
    }

    function Qa(a) {
      var b = a._iDisplayStart,
          c = a.fnDisplayEnd(),
          d = a._iDisplayLength;
      c === a.fnRecordsDisplay() && (b = c - d);
      if (-1 === d || 0 > b) b = 0;
      a._iDisplayStart = b;
    }

    function La(a, b) {
      var c = a.renderer,
          d = p.ext.renderer[b];
      return h.isPlainObject(c) && c[b] ? d[c[b]] || d._ : "string" === typeof c ? d[c] || d._ : d._;
    }

    function z(a) {
      return a.oFeatures.bServerSide ? "ssp" : a.ajax || a.sAjaxSource ? "ajax" : "dom";
    }

    function Ua(a, b) {
      var c = [],
          c = Lb.numbers_length,
          d = Math.floor(c / 2);
      b <= c ? c = S(0, b) : a <= d ? (c = S(0, c - 2), c.push("ellipsis"), c.push(b - 1)) : (a >= b - 1 - d ? c = S(b - (c - 2), b) : (c = S(a - 1, a + 2), c.push("ellipsis"), c.push(b - 1)), c.splice(0, 0, "ellipsis"), c.splice(0, 0, 0));
      c.DT_el = "span";
      return c;
    }

    function cb(a) {
      h.each({
        num: function (b) {
          return va(b, a);
        },
        "num-fmt": function (b) {
          return va(b, a, Va);
        },
        "html-num": function (b) {
          return va(b, a, wa);
        },
        "html-num-fmt": function (b) {
          return va(b, a, wa, Va);
        }
      }, function (b, c) {
        t.type.order[b + a + "-pre"] = c;
      });
    }

    function Mb(a) {
      return function () {
        var b = [ua(this[p.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
        return p.ext.internal[a].apply(this, b);
      };
    }

    var p,
        t,
        q,
        r,
        v,
        Wa = {},
        Nb = /[\r\n]/g,
        wa = /<.*?>/g,
        Yb = /^[\w\+\-]/,
        Zb = /[\w\+\-]$/,
        Vb = RegExp("(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\|\\$|\\^|\\-)", "g"),
        Va = /[',$\u00a3\u20ac\u00a5%\u2009\u202F]/g,
        H = function (a) {
      return !a || !0 === a || "-" === a ? !0 : !1;
    },
        Ob = function (a) {
      var b = parseInt(a, 10);
      return !isNaN(b) && isFinite(a) ? b : null;
    },
        Pb = function (a, b) {
      Wa[b] || (Wa[b] = RegExp(Oa(b), "g"));
      return "string" === typeof a ? a.replace(/\./g, "").replace(Wa[b], ".") : a;
    },
        Xa = function (a, b, c) {
      var d = "string" === typeof a;
      b && d && (a = Pb(a, b));
      c && d && (a = a.replace(Va, ""));
      return H(a) || !isNaN(parseFloat(a)) && isFinite(a);
    },
        Qb = function (a, b, c) {
      return H(a) ? !0 : !(H(a) || "string" === typeof a) ? null : Xa(a.replace(wa, ""), b, c) ? !0 : null;
    },
        C = function (a, b, c) {
      var d = [],
          e = 0,
          f = a.length;
      if (c !== l) for (; e < f; e++) a[e] && a[e][b] && d.push(a[e][b][c]);else for (; e < f; e++) a[e] && d.push(a[e][b]);
      return d;
    },
        xa = function (a, b, c, d) {
      var e = [],
          f = 0,
          g = b.length;
      if (d !== l) for (; f < g; f++) e.push(a[b[f]][c][d]);else for (; f < g; f++) e.push(a[b[f]][c]);
      return e;
    },
        S = function (a, b) {
      var c = [],
          d;
      b === l ? (b = 0, d = a) : (d = b, b = a);

      for (var e = b; e < d; e++) c.push(e);

      return c;
    },
        Ja = function (a) {
      var b = [],
          c,
          d,
          e = a.length,
          f,
          g = 0;
      d = 0;

      a: for (; d < e; d++) {
        c = a[d];

        for (f = 0; f < g; f++) if (b[f] === c) continue a;

        b.push(c);
        g++;
      }

      return b;
    },
        w = function (a, b, c) {
      a[b] !== l && (a[c] = a[b]);
    },
        $ = /\[.*?\]$/,
        Q = /\(\)$/,
        qa = h("<div>")[0],
        Wb = qa.textContent !== l,
        Xb = /<.*?>/g;

    p = function (a) {
      this.$ = function (a, b) {
        return this.api(!0).$(a, b);
      };

      this._ = function (a, b) {
        return this.api(!0).rows(a, b).data();
      };

      this.api = function (a) {
        return a ? new q(ua(this[t.iApiIndex])) : new q(this);
      };

      this.fnAddData = function (a, b) {
        var c = this.api(!0),
            d = h.isArray(a) && (h.isArray(a[0]) || h.isPlainObject(a[0])) ? c.rows.add(a) : c.row.add(a);
        (b === l || b) && c.draw();
        return d.flatten().toArray();
      };

      this.fnAdjustColumnSizing = function (a) {
        var b = this.api(!0).columns.adjust(),
            c = b.settings()[0],
            d = c.oScroll;
        a === l || a ? b.draw(!1) : ("" !== d.sX || "" !== d.sY) && W(c);
      };

      this.fnClearTable = function (a) {
        var b = this.api(!0).clear();
        (a === l || a) && b.draw();
      };

      this.fnClose = function (a) {
        this.api(!0).row(a).child.hide();
      };

      this.fnDeleteRow = function (a, b, c) {
        var d = this.api(!0),
            a = d.rows(a),
            e = a.settings()[0],
            h = e.aoData[a[0][0]];
        a.remove();
        b && b.call(this, e, h);
        (c === l || c) && d.draw();
        return h;
      };

      this.fnDestroy = function (a) {
        this.api(!0).destroy(a);
      };

      this.fnDraw = function (a) {
        this.api(!0).draw(!a);
      };

      this.fnFilter = function (a, b, c, d, e, h) {
        e = this.api(!0);
        null === b || b === l ? e.search(a, c, d, h) : e.column(b).search(a, c, d, h);
        e.draw();
      };

      this.fnGetData = function (a, b) {
        var c = this.api(!0);

        if (a !== l) {
          var d = a.nodeName ? a.nodeName.toLowerCase() : "";
          return b !== l || "td" == d || "th" == d ? c.cell(a, b).data() : c.row(a).data() || null;
        }

        return c.data().toArray();
      };

      this.fnGetNodes = function (a) {
        var b = this.api(!0);
        return a !== l ? b.row(a).node() : b.rows().nodes().flatten().toArray();
      };

      this.fnGetPosition = function (a) {
        var b = this.api(!0),
            c = a.nodeName.toUpperCase();
        return "TR" == c ? b.row(a).index() : "TD" == c || "TH" == c ? (a = b.cell(a).index(), [a.row, a.columnVisible, a.column]) : null;
      };

      this.fnIsOpen = function (a) {
        return this.api(!0).row(a).child.isShown();
      };

      this.fnOpen = function (a, b, c) {
        return this.api(!0).row(a).child(b, c).show().child()[0];
      };

      this.fnPageChange = function (a, b) {
        var c = this.api(!0).page(a);
        (b === l || b) && c.draw(!1);
      };

      this.fnSetColumnVis = function (a, b, c) {
        a = this.api(!0).column(a).visible(b);
        (c === l || c) && a.columns.adjust().draw();
      };

      this.fnSettings = function () {
        return ua(this[t.iApiIndex]);
      };

      this.fnSort = function (a) {
        this.api(!0).order(a).draw();
      };

      this.fnSortListener = function (a, b, c) {
        this.api(!0).order.listener(a, b, c);
      };

      this.fnUpdate = function (a, b, c, d, e) {
        var h = this.api(!0);
        c === l || null === c ? h.row(b).data(a) : h.cell(b, c).data(a);
        (e === l || e) && h.columns.adjust();
        (d === l || d) && h.draw();
        return 0;
      };

      this.fnVersionCheck = t.fnVersionCheck;
      var b = this,
          c = a === l,
          d = this.length;
      c && (a = {});
      this.oApi = this.internal = t.internal;

      for (var e in p.ext.internal) e && (this[e] = Mb(e));

      this.each(function () {
        var e = {},
            g = 1 < d ? Kb(e, a, !0) : a,
            j = 0,
            i,
            o = this.getAttribute("id"),
            e = !1,
            m = p.defaults;
        if ("table" != this.nodeName.toLowerCase()) P(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);else {
          db(m);
          eb(m.column);
          G(m, m, !0);
          G(m.column, m.column, !0);
          G(m, g);
          var n = p.settings,
              j = 0;

          for (i = n.length; j < i; j++) {
            if (n[j].nTable == this) {
              i = g.bRetrieve !== l ? g.bRetrieve : m.bRetrieve;
              if (c || i) return n[j].oInstance;

              if (g.bDestroy !== l ? g.bDestroy : m.bDestroy) {
                n[j].oInstance.fnDestroy();
                break;
              } else {
                P(n[j], 0, "Cannot reinitialise DataTable", 3);
                return;
              }
            }

            if (n[j].sTableId == this.id) {
              n.splice(j, 1);
              break;
            }
          }

          if (null === o || "" === o) this.id = o = "DataTables_Table_" + p.ext._unique++;
          var k = h.extend(!0, {}, p.models.oSettings, {
            nTable: this,
            oApi: b.internal,
            oInit: g,
            sDestroyWidth: h(this)[0].style.width,
            sInstance: o,
            sTableId: o
          });
          n.push(k);
          k.oInstance = 1 === b.length ? b : h(this).dataTable();
          db(g);
          g.oLanguage && N(g.oLanguage);
          g.aLengthMenu && !g.iDisplayLength && (g.iDisplayLength = h.isArray(g.aLengthMenu[0]) ? g.aLengthMenu[0][0] : g.aLengthMenu[0]);
          g = Kb(h.extend(!0, {}, m), g);
          D(k.oFeatures, g, "bPaginate bLengthChange bFilter bSort bSortMulti bInfo bProcessing bAutoWidth bSortClasses bServerSide bDeferRender".split(" "));
          D(k, g, ["asStripeClasses", "ajax", "fnServerData", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "sAjaxSource", "sAjaxDataProp", "iStateDuration", "sDom", "bSortCellsTop", "iTabIndex", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", ["iCookieDuration", "iStateDuration"], ["oSearch", "oPreviousSearch"], ["aoSearchCols", "aoPreSearchCols"], ["iDisplayLength", "_iDisplayLength"], ["bJQueryUI", "bJUI"]]);
          D(k.oScroll, g, [["sScrollX", "sX"], ["sScrollXInner", "sXInner"], ["sScrollY", "sY"], ["bScrollCollapse", "bCollapse"]]);
          D(k.oLanguage, g, "fnInfoCallback");
          x(k, "aoDrawCallback", g.fnDrawCallback, "user");
          x(k, "aoServerParams", g.fnServerParams, "user");
          x(k, "aoStateSaveParams", g.fnStateSaveParams, "user");
          x(k, "aoStateLoadParams", g.fnStateLoadParams, "user");
          x(k, "aoStateLoaded", g.fnStateLoaded, "user");
          x(k, "aoRowCallback", g.fnRowCallback, "user");
          x(k, "aoRowCreatedCallback", g.fnCreatedRow, "user");
          x(k, "aoHeaderCallback", g.fnHeaderCallback, "user");
          x(k, "aoFooterCallback", g.fnFooterCallback, "user");
          x(k, "aoInitComplete", g.fnInitComplete, "user");
          x(k, "aoPreDrawCallback", g.fnPreDrawCallback, "user");
          o = k.oClasses;
          g.bJQueryUI ? (h.extend(o, p.ext.oJUIClasses, g.oClasses), g.sDom === m.sDom && "lfrtip" === m.sDom && (k.sDom = '<"H"lfr>t<"F"ip>'), k.renderer) ? h.isPlainObject(k.renderer) && !k.renderer.header && (k.renderer.header = "jqueryui") : k.renderer = "jqueryui" : h.extend(o, p.ext.classes, g.oClasses);
          h(this).addClass(o.sTable);
          if ("" !== k.oScroll.sX || "" !== k.oScroll.sY) k.oScroll.iBarWidth = Gb();
          !0 === k.oScroll.sX && (k.oScroll.sX = "100%");
          k.iInitDisplayStart === l && (k.iInitDisplayStart = g.iDisplayStart, k._iDisplayStart = g.iDisplayStart);
          null !== g.iDeferLoading && (k.bDeferLoading = !0, j = h.isArray(g.iDeferLoading), k._iRecordsDisplay = j ? g.iDeferLoading[0] : g.iDeferLoading, k._iRecordsTotal = j ? g.iDeferLoading[1] : g.iDeferLoading);
          "" !== g.oLanguage.sUrl ? (k.oLanguage.sUrl = g.oLanguage.sUrl, h.getJSON(k.oLanguage.sUrl, null, function (a) {
            N(a);
            G(m.oLanguage, a);
            h.extend(true, k.oLanguage, g.oLanguage, a);
            ra(k);
          }), e = !0) : h.extend(!0, k.oLanguage, g.oLanguage);
          null === g.asStripeClasses && (k.asStripeClasses = [o.sStripeOdd, o.sStripeEven]);
          var j = k.asStripeClasses,
              r = h("tbody tr:eq(0)", this);
          -1 !== h.inArray(!0, h.map(j, function (a) {
            return r.hasClass(a);
          })) && (h("tbody tr", this).removeClass(j.join(" ")), k.asDestroyStripes = j.slice());
          var n = [],
              q,
              j = this.getElementsByTagName("thead");
          0 !== j.length && (aa(k.aoHeader, j[0]), n = ma(k));

          if (null === g.aoColumns) {
            q = [];
            j = 0;

            for (i = n.length; j < i; j++) q.push(null);
          } else q = g.aoColumns;

          j = 0;

          for (i = q.length; j < i; j++) Aa(k, n ? n[j] : null);

          hb(k, g.aoColumnDefs, q, function (a, b) {
            fa(k, a, b);
          });

          if (r.length) {
            var s = function (a, b) {
              return a.getAttribute("data-" + b) ? b : null;
            };

            h.each(ia(k, r[0]).cells, function (a, b) {
              var c = k.aoColumns[a];

              if (c.mData === a) {
                var d = s(b, "sort") || s(b, "order"),
                    e = s(b, "filter") || s(b, "search");

                if (d !== null || e !== null) {
                  c.mData = {
                    _: a + ".display",
                    sort: d !== null ? a + ".@data-" + d : l,
                    type: d !== null ? a + ".@data-" + d : l,
                    filter: e !== null ? a + ".@data-" + e : l
                  };
                  fa(k, a);
                }
              }
            });
          }

          var t = k.oFeatures;
          g.bStateSave && (t.bStateSave = !0, Jb(k, g), x(k, "aoDrawCallback", ta, "state_save"));

          if (g.aaSorting === l) {
            n = k.aaSorting;
            j = 0;

            for (i = n.length; j < i; j++) n[j][1] = k.aoColumns[j].asSorting[0];
          }

          sa(k);
          t.bSort && x(k, "aoDrawCallback", function () {
            if (k.bSorted) {
              var a = R(k),
                  b = {};
              h.each(a, function (a, c) {
                b[c.src] = c.dir;
              });
              u(k, null, "order", [k, a, b]);
              Ib(k);
            }
          });
          x(k, "aoDrawCallback", function () {
            (k.bSorted || z(k) === "ssp" || t.bDeferRender) && sa(k);
          }, "sc");
          fb(k);
          j = h(this).children("caption").each(function () {
            this._captionSide = h(this).css("caption-side");
          });
          i = h(this).children("thead");
          0 === i.length && (i = h("<thead/>").appendTo(this));
          k.nTHead = i[0];
          i = h(this).children("tbody");
          0 === i.length && (i = h("<tbody/>").appendTo(this));
          k.nTBody = i[0];
          i = h(this).children("tfoot");
          if (0 === i.length && 0 < j.length && ("" !== k.oScroll.sX || "" !== k.oScroll.sY)) i = h("<tfoot/>").appendTo(this);
          0 === i.length || 0 === i.children().length ? h(this).addClass(o.sNoFooter) : 0 < i.length && (k.nTFoot = i[0], aa(k.aoFooter, k.nTFoot));
          if (g.aaData) for (j = 0; j < g.aaData.length; j++) I(k, g.aaData[j]);else (k.bDeferLoading || "dom" == z(k)) && ha(k, h(k.nTBody).children("tr"));
          k.aiDisplay = k.aiDisplayMaster.slice();
          k.bInitialised = !0;
          !1 === e && ra(k);
        }
      });
      b = null;
      return this;
    };

    var Rb = [],
        y = Array.prototype,
        $b = function (a) {
      var b,
          c,
          d = p.settings,
          e = h.map(d, function (a) {
        return a.nTable;
      });

      if (a) {
        if (a.nTable && a.oApi) return [a];
        if (a.nodeName && "table" === a.nodeName.toLowerCase()) return b = h.inArray(a, e), -1 !== b ? [d[b]] : null;
        if (a && "function" === typeof a.settings) return a.settings().toArray();
        "string" === typeof a ? c = h(a) : a instanceof h && (c = a);
      } else return [];

      if (c) return c.map(function () {
        b = h.inArray(this, e);
        return -1 !== b ? d[b] : null;
      }).toArray();
    };

    q = function (a, b) {
      if (!this instanceof q) throw "DT API must be constructed as a new object";

      var c = [],
          d = function (a) {
        (a = $b(a)) && c.push.apply(c, a);
      };

      if (h.isArray(a)) for (var e = 0, f = a.length; e < f; e++) d(a[e]);else d(a);
      this.context = Ja(c);
      b && this.push.apply(this, b.toArray ? b.toArray() : b);
      this.selector = {
        rows: null,
        cols: null,
        opts: null
      };
      q.extend(this, this, Rb);
    };

    p.Api = q;
    q.prototype = {
      concat: y.concat,
      context: [],
      each: function (a) {
        for (var b = 0, c = this.length; b < c; b++) a.call(this, this[b], b, this);

        return this;
      },
      eq: function (a) {
        var b = this.context;
        return b.length > a ? new q(b[a], this[a]) : null;
      },
      filter: function (a) {
        var b = [];
        if (y.filter) b = y.filter.call(this, a, this);else for (var c = 0, d = this.length; c < d; c++) a.call(this, this[c], c, this) && b.push(this[c]);
        return new q(this.context, b);
      },
      flatten: function () {
        var a = [];
        return new q(this.context, a.concat.apply(a, this.toArray()));
      },
      join: y.join,
      indexOf: y.indexOf || function (a, b) {
        for (var c = b || 0, d = this.length; c < d; c++) if (this[c] === a) return c;

        return -1;
      },
      iterator: function (a, b, c) {
        var d = [],
            e,
            f,
            g,
            h,
            i,
            o = this.context,
            m,
            n,
            k = this.selector;
        "string" === typeof a && (c = b, b = a, a = !1);
        f = 0;

        for (g = o.length; f < g; f++) if ("table" === b) e = c(o[f], f), e !== l && d.push(e);else if ("columns" === b || "rows" === b) e = c(o[f], this[f], f), e !== l && d.push(e);else if ("column" === b || "column-rows" === b || "row" === b || "cell" === b) {
          n = this[f];
          "column-rows" === b && (m = Ya(o[f], k.opts));
          h = 0;

          for (i = n.length; h < i; h++) e = n[h], e = "cell" === b ? c(o[f], e.row, e.column, f, h) : c(o[f], e, f, h, m), e !== l && d.push(e);
        }

        return d.length ? (a = new q(o, a ? d.concat.apply([], d) : d), b = a.selector, b.rows = k.rows, b.cols = k.cols, b.opts = k.opts, a) : this;
      },
      lastIndexOf: y.lastIndexOf || function (a, b) {
        return this.indexOf.apply(this.toArray.reverse(), arguments);
      },
      length: 0,
      map: function (a) {
        var b = [];
        if (y.map) b = y.map.call(this, a, this);else for (var c = 0, d = this.length; c < d; c++) b.push(a.call(this, this[c], c));
        return new q(this.context, b);
      },
      pluck: function (a) {
        return this.map(function (b) {
          return b[a];
        });
      },
      pop: y.pop,
      push: y.push,
      reduce: y.reduce || function (a, b) {
        return gb(this, a, b, 0, this.length, 1);
      },
      reduceRight: y.reduceRight || function (a, b) {
        return gb(this, a, b, this.length - 1, -1, -1);
      },
      reverse: y.reverse,
      selector: null,
      shift: y.shift,
      sort: y.sort,
      splice: y.splice,
      toArray: function () {
        return y.slice.call(this);
      },
      to$: function () {
        return h(this);
      },
      toJQuery: function () {
        return h(this);
      },
      unique: function () {
        return new q(this.context, Ja(this));
      },
      unshift: y.unshift
    };

    q.extend = function (a, b, c) {
      if (b && (b instanceof q || b.__dt_wrapper)) {
        var d,
            e,
            f,
            g = function (a, b, c) {
          return function () {
            var d = b.apply(a, arguments);
            q.extend(d, d, c.methodExt);
            return d;
          };
        };

        d = 0;

        for (e = c.length; d < e; d++) f = c[d], b[f.name] = "function" === typeof f.val ? g(a, f.val, f) : h.isPlainObject(f.val) ? {} : f.val, b[f.name].__dt_wrapper = !0, q.extend(a, b[f.name], f.propExt);
      }
    };

    q.register = r = function (a, b) {
      if (h.isArray(a)) for (var c = 0, d = a.length; c < d; c++) q.register(a[c], b);else for (var e = a.split("."), f = Rb, g, j, c = 0, d = e.length; c < d; c++) {
        g = (j = -1 !== e[c].indexOf("()")) ? e[c].replace("()", "") : e[c];
        var i;

        a: {
          i = 0;

          for (var o = f.length; i < o; i++) if (f[i].name === g) {
            i = f[i];
            break a;
          }

          i = null;
        }

        i || (i = {
          name: g,
          val: {},
          methodExt: [],
          propExt: []
        }, f.push(i));
        c === d - 1 ? i.val = b : f = j ? i.methodExt : i.propExt;
      }
    };

    q.registerPlural = v = function (a, b, c) {
      q.register(a, c);
      q.register(b, function () {
        var a = c.apply(this, arguments);
        return a === this ? this : a instanceof q ? a.length ? h.isArray(a[0]) ? new q(a.context, a[0]) : a[0] : l : a;
      });
    };

    r("tables()", function (a) {
      var b;

      if (a) {
        b = q;
        var c = this.context;
        if ("number" === typeof a) a = [c[a]];else var d = h.map(c, function (a) {
          return a.nTable;
        }),
            a = h(d).filter(a).map(function () {
          var a = h.inArray(this, d);
          return c[a];
        }).toArray();
        b = new b(a);
      } else b = this;

      return b;
    });
    r("table()", function (a) {
      var a = this.tables(a),
          b = a.context;
      return b.length ? new q(b[0]) : a;
    });
    v("tables().nodes()", "table().node()", function () {
      return this.iterator("table", function (a) {
        return a.nTable;
      });
    });
    v("tables().body()", "table().body()", function () {
      return this.iterator("table", function (a) {
        return a.nTBody;
      });
    });
    v("tables().header()", "table().header()", function () {
      return this.iterator("table", function (a) {
        return a.nTHead;
      });
    });
    v("tables().footer()", "table().footer()", function () {
      return this.iterator("table", function (a) {
        return a.nTFoot;
      });
    });
    v("tables().containers()", "table().container()", function () {
      return this.iterator("table", function (a) {
        return a.nTableWrapper;
      });
    });
    r("draw()", function (a) {
      return this.iterator("table", function (b) {
        L(b, !1 === a);
      });
    });
    r("page()", function (a) {
      return a === l ? this.page.info().page : this.iterator("table", function (b) {
        Ra(b, a);
      });
    });
    r("page.info()", function () {
      if (0 === this.context.length) return l;
      var a = this.context[0],
          b = a._iDisplayStart,
          c = a._iDisplayLength,
          d = a.fnRecordsDisplay(),
          e = -1 === c;
      return {
        page: e ? 0 : Math.floor(b / c),
        pages: e ? 1 : Math.ceil(d / c),
        start: b,
        end: a.fnDisplayEnd(),
        length: c,
        recordsTotal: a.fnRecordsTotal(),
        recordsDisplay: d
      };
    });
    r("page.len()", function (a) {
      return a === l ? 0 !== this.context.length ? this.context[0]._iDisplayLength : l : this.iterator("table", function (b) {
        Pa(b, a);
      });
    });

    var Sb = function (a, b, c) {
      "ssp" == z(a) ? L(a, b) : (B(a, !0), na(a, [], function (c) {
        ja(a);

        for (var c = oa(a, c), d = 0, g = c.length; d < g; d++) I(a, c[d]);

        L(a, b);
        B(a, !1);
      }));

      if (c) {
        var d = new q(a);
        d.one("draw", function () {
          c(d.ajax.json());
        });
      }
    };

    r("ajax.json()", function () {
      var a = this.context;
      if (0 < a.length) return a[0].json;
    });
    r("ajax.params()", function () {
      var a = this.context;
      if (0 < a.length) return a[0].oAjaxData;
    });
    r("ajax.reload()", function (a, b) {
      return this.iterator("table", function (c) {
        Sb(c, !1 === b, a);
      });
    });
    r("ajax.url()", function (a) {
      var b = this.context;

      if (a === l) {
        if (0 === b.length) return l;
        b = b[0];
        return b.ajax ? h.isPlainObject(b.ajax) ? b.ajax.url : b.ajax : b.sAjaxSource;
      }

      return this.iterator("table", function (b) {
        h.isPlainObject(b.ajax) ? b.ajax.url = a : b.ajax = a;
      });
    });
    r("ajax.url().load()", function (a, b) {
      return this.iterator("table", function (c) {
        Sb(c, !1 === b, a);
      });
    });

    var Za = function (a, b) {
      var c = [],
          d,
          e,
          f,
          g,
          j,
          i;
      if (!a || "string" === typeof a || a.length === l) a = [a];
      f = 0;

      for (g = a.length; f < g; f++) {
        e = a[f] && a[f].split ? a[f].split(",") : [a[f]];
        j = 0;

        for (i = e.length; j < i; j++) (d = b("string" === typeof e[j] ? h.trim(e[j]) : e[j])) && d.length && c.push.apply(c, d);
      }

      return c;
    },
        $a = function (a) {
      a || (a = {});
      a.filter && !a.search && (a.search = a.filter);
      return {
        search: a.search || "none",
        order: a.order || "current",
        page: a.page || "all"
      };
    },
        ab = function (a) {
      for (var b = 0, c = a.length; b < c; b++) if (0 < a[b].length) return a[0] = a[b], a.length = 1, a.context = [a.context[b]], a;

      a.length = 0;
      return a;
    },
        Ya = function (a, b) {
      var c,
          d,
          e,
          f = [],
          g = a.aiDisplay;
      c = a.aiDisplayMaster;
      var j = b.search;
      d = b.order;
      e = b.page;
      if ("ssp" == z(a)) return "removed" === j ? [] : S(0, c.length);

      if ("current" == e) {
        c = a._iDisplayStart;

        for (d = a.fnDisplayEnd(); c < d; c++) f.push(g[c]);
      } else if ("current" == d || "applied" == d) f = "none" == j ? c.slice() : "applied" == j ? g.slice() : h.map(c, function (a) {
        return -1 === h.inArray(a, g) ? a : null;
      });else if ("index" == d || "original" == d) {
        c = 0;

        for (d = a.aoData.length; c < d; c++) "none" == j ? f.push(c) : (e = h.inArray(c, g), (-1 === e && "removed" == j || 0 <= e && "applied" == j) && f.push(c));
      }

      return f;
    };

    r("rows()", function (a, b) {
      a === l ? a = "" : h.isPlainObject(a) && (b = a, a = "");
      var b = $a(b),
          c = this.iterator("table", function (c) {
        var e = b;
        return Za(a, function (a) {
          var b = Ob(a);
          if (b !== null && !e) return [b];
          var j = Ya(c, e);
          if (b !== null && h.inArray(b, j) !== -1) return [b];
          if (!a) return j;

          for (var b = [], i = 0, o = j.length; i < o; i++) b.push(c.aoData[j[i]].nTr);

          return a.nodeName && h.inArray(a, b) !== -1 ? [a._DT_RowIndex] : h(b).filter(a).map(function () {
            return this._DT_RowIndex;
          }).toArray();
        });
      });
      c.selector.rows = a;
      c.selector.opts = b;
      return c;
    });
    r("rows().nodes()", function () {
      return this.iterator("row", function (a, b) {
        return a.aoData[b].nTr || l;
      });
    });
    r("rows().data()", function () {
      return this.iterator(!0, "rows", function (a, b) {
        return xa(a.aoData, b, "_aData");
      });
    });
    v("rows().cache()", "row().cache()", function (a) {
      return this.iterator("row", function (b, c) {
        var d = b.aoData[c];
        return "search" === a ? d._aFilterData : d._aSortData;
      });
    });
    v("rows().invalidate()", "row().invalidate()", function (a) {
      return this.iterator("row", function (b, c) {
        la(b, c, a);
      });
    });
    v("rows().indexes()", "row().index()", function () {
      return this.iterator("row", function (a, b) {
        return b;
      });
    });
    v("rows().remove()", "row().remove()", function () {
      var a = this;
      return this.iterator("row", function (b, c, d) {
        var e = b.aoData;
        e.splice(c, 1);

        for (var f = 0, g = e.length; f < g; f++) null !== e[f].nTr && (e[f].nTr._DT_RowIndex = f);

        h.inArray(c, b.aiDisplay);
        ka(b.aiDisplayMaster, c);
        ka(b.aiDisplay, c);
        ka(a[d], c, !1);
        Qa(b);
      });
    });
    r("rows.add()", function (a) {
      var b = this.iterator("table", function (b) {
        var c,
            f,
            g,
            h = [];
        f = 0;

        for (g = a.length; f < g; f++) c = a[f], c.nodeName && "TR" === c.nodeName.toUpperCase() ? h.push(ha(b, c)[0]) : h.push(I(b, c));

        return h;
      }),
          c = this.rows(-1);
      c.pop();
      c.push.apply(c, b.toArray());
      return c;
    });
    r("row()", function (a, b) {
      return ab(this.rows(a, b));
    });
    r("row().data()", function (a) {
      var b = this.context;
      if (a === l) return b.length && this.length ? b[0].aoData[this[0]]._aData : l;
      b[0].aoData[this[0]]._aData = a;
      la(b[0], this[0], "data");
      return this;
    });
    r("row().node()", function () {
      var a = this.context;
      return a.length && this.length ? a[0].aoData[this[0]].nTr || null : null;
    });
    r("row.add()", function (a) {
      a instanceof h && a.length && (a = a[0]);
      var b = this.iterator("table", function (b) {
        return a.nodeName && "TR" === a.nodeName.toUpperCase() ? ha(b, a)[0] : I(b, a);
      });
      return this.row(b[0]);
    });

    var bb = function (a) {
      var b = a.context;
      b.length && a.length && (a = b[0].aoData[a[0]], a._details && (a._details.remove(), a._detailsShow = l, a._details = l));
    },
        Tb = function (a, b) {
      var c = a.context;

      if (c.length && a.length) {
        var d = c[0].aoData[a[0]];

        if (d._details) {
          (d._detailsShow = b) ? d._details.insertAfter(d.nTr) : d._details.detach();
          var e = c[0],
              f = new q(e),
              g = e.aoData;
          f.off("draw.dt.DT_details column-visibility.dt.DT_details destroy.dt.DT_details");
          0 < C(g, "_details").length && (f.on("draw.dt.DT_details", function (a, b) {
            e === b && f.rows({
              page: "current"
            }).eq(0).each(function (a) {
              a = g[a];
              a._detailsShow && a._details.insertAfter(a.nTr);
            });
          }), f.on("column-visibility.dt.DT_details", function (a, b) {
            if (e === b) for (var c, d = Z(b), f = 0, h = g.length; f < h; f++) c = g[f], c._details && c._details.children("td[colspan]").attr("colspan", d);
          }), f.on("destroy.dt.DT_details", function (a, b) {
            if (e === b) for (var c = 0, d = g.length; c < d; c++) g[c]._details && bb(g[c]);
          }));
        }
      }
    };

    r("row().child()", function (a, b) {
      var c = this.context;
      if (a === l) return c.length && this.length ? c[0].aoData[this[0]]._details : l;
      if (!0 === a) this.child.show();else if (!1 === a) bb(this);else if (c.length && this.length) {
        var d = c[0],
            c = c[0].aoData[this[0]],
            e = [],
            f = function (a, b) {
          if (a.nodeName && "tr" === a.nodeName.toLowerCase()) e.push(a);else {
            var c = h("<tr><td/></tr>").addClass(b);
            h("td", c).addClass(b).html(a)[0].colSpan = Z(d);
            e.push(c[0]);
          }
        };

        if (h.isArray(a) || a instanceof h) for (var g = 0, j = a.length; g < j; g++) f(a[g], b);else f(a, b);
        c._details && c._details.remove();
        c._details = h(e);
        c._detailsShow && c._details.insertAfter(c.nTr);
      }
      return this;
    });
    r(["row().child.show()", "row().child().show()"], function () {
      Tb(this, !0);
      return this;
    });
    r(["row().child.hide()", "row().child().hide()"], function () {
      Tb(this, !1);
      return this;
    });
    r(["row().child.remove()", "row().child().remove()"], function () {
      bb(this);
      return this;
    });
    r("row().child.isShown()", function () {
      var a = this.context;
      return a.length && this.length ? a[0].aoData[this[0]]._detailsShow || !1 : !1;
    });
    var ac = /^(.*):(name|visIdx|visible)$/;
    r("columns()", function (a, b) {
      a === l ? a = "" : h.isPlainObject(a) && (b = a, a = "");
      var b = $a(b),
          c = this.iterator("table", function (b) {
        var c = a,
            f = b.aoColumns,
            g = C(f, "sName"),
            j = C(f, "nTh");
        return Za(c, function (a) {
          var c = Ob(a);
          if (a === "") return S(f.length);
          if (c !== null) return [c >= 0 ? c : f.length + c];
          var e = typeof a === "string" ? a.match(ac) : "";
          if (e) switch (e[2]) {
            case "visIdx":
            case "visible":
              a = parseInt(e[1], 10);

              if (a < 0) {
                c = h.map(f, function (a, b) {
                  return a.bVisible ? b : null;
                });
                return [c[c.length + a]];
              }

              return [ga(b, a)];

            case "name":
              return h.map(g, function (a, b) {
                return a === e[1] ? b : null;
              });
          } else return h(j).filter(a).map(function () {
            return h.inArray(this, j);
          }).toArray();
        });
      });
      c.selector.cols = a;
      c.selector.opts = b;
      return c;
    });
    v("columns().header()", "column().header()", function () {
      return this.iterator("column", function (a, b) {
        return a.aoColumns[b].nTh;
      });
    });
    v("columns().footer()", "column().footer()", function () {
      return this.iterator("column", function (a, b) {
        return a.aoColumns[b].nTf;
      });
    });
    v("columns().data()", "column().data()", function () {
      return this.iterator("column-rows", function (a, b, c, d, e) {
        for (var c = [], d = 0, f = e.length; d < f; d++) c.push(A(a, e[d], b, ""));

        return c;
      });
    });
    v("columns().cache()", "column().cache()", function (a) {
      return this.iterator("column-rows", function (b, c, d, e, f) {
        return xa(b.aoData, f, "search" === a ? "_aFilterData" : "_aSortData", c);
      });
    });
    v("columns().nodes()", "column().nodes()", function () {
      return this.iterator("column-rows", function (a, b, c, d, e) {
        return xa(a.aoData, e, "anCells", b);
      });
    });
    v("columns().visible()", "column().visible()", function (a) {
      return this.iterator("column", function (b, c) {
        var d;
        if (a === l) d = b.aoColumns[c].bVisible;else {
          var e = b.aoColumns;
          d = e[c];
          var f = b.aoData,
              g,
              j,
              i;
          if (a === l) d = d.bVisible;else {
            if (d.bVisible !== a) {
              if (a) {
                var o = h.inArray(!0, C(e, "bVisible"), c + 1);
                g = 0;

                for (j = f.length; g < j; g++) i = f[g].nTr, e = f[g].anCells, i && i.insertBefore(e[c], e[o] || null);
              } else h(C(b.aoData, "anCells", c)).detach();

              d.bVisible = a;
              ba(b, b.aoHeader);
              ba(b, b.aoFooter);
              V(b);
              (b.oScroll.sX || b.oScroll.sY) && W(b);
              u(b, null, "column-visibility", [b, c, a]);
              ta(b);
            }

            d = void 0;
          }
        }
        return d;
      });
    });
    v("columns().indexes()", "column().index()", function (a) {
      return this.iterator("column", function (b, c) {
        return "visible" === a ? Y(b, c) : c;
      });
    });
    r("columns.adjust()", function () {
      return this.iterator("table", function (a) {
        V(a);
      });
    });
    r("column.index()", function (a, b) {
      if (0 !== this.context.length) {
        var c = this.context[0];
        if ("fromVisible" === a || "toData" === a) return ga(c, b);
        if ("fromData" === a || "toVisible" === a) return Y(c, b);
      }
    });
    r("column()", function (a, b) {
      return ab(this.columns(a, b));
    });
    r("cells()", function (a, b, c) {
      h.isPlainObject(a) && (typeof a.row !== l ? (c = b, b = null) : (c = a, a = null));
      h.isPlainObject(b) && (c = b, b = null);
      if (null === b || b === l) return this.iterator("table", function (b) {
        var d = a,
            e = $a(c),
            f = b.aoData,
            g = Ya(b, e),
            e = xa(f, g, "anCells"),
            i = h([].concat.apply([], e)),
            j,
            m = b.aoColumns.length,
            o,
            p,
            r,
            q;
        return Za(d, function (a) {
          if (a === null || a === l) {
            o = [];
            p = 0;

            for (r = g.length; p < r; p++) {
              j = g[p];

              for (q = 0; q < m; q++) o.push({
                row: j,
                column: q
              });
            }

            return o;
          }

          return h.isPlainObject(a) ? [a] : i.filter(a).map(function (a, b) {
            j = b.parentNode._DT_RowIndex;
            return {
              row: j,
              column: h.inArray(b, f[j].anCells)
            };
          }).toArray();
        });
      });
      var d = this.columns(b, c),
          e = this.rows(a, c),
          f,
          g,
          j,
          i,
          o,
          m = this.iterator("table", function (a, b) {
        f = [];
        g = 0;

        for (j = e[b].length; g < j; g++) {
          i = 0;

          for (o = d[b].length; i < o; i++) f.push({
            row: e[b][g],
            column: d[b][i]
          });
        }

        return f;
      });
      h.extend(m.selector, {
        cols: b,
        rows: a,
        opts: c
      });
      return m;
    });
    v("cells().nodes()", "cell().node()", function () {
      return this.iterator("cell", function (a, b, c) {
        return a.aoData[b].anCells[c];
      });
    });
    r("cells().data()", function () {
      return this.iterator("cell", function (a, b, c) {
        return A(a, b, c);
      });
    });
    v("cells().cache()", "cell().cache()", function (a) {
      a = "search" === a ? "_aFilterData" : "_aSortData";
      return this.iterator("cell", function (b, c, d) {
        return b.aoData[c][a][d];
      });
    });
    v("cells().indexes()", "cell().index()", function () {
      return this.iterator("cell", function (a, b, c) {
        return {
          row: b,
          column: c,
          columnVisible: Y(a, c)
        };
      });
    });
    r(["cells().invalidate()", "cell().invalidate()"], function (a) {
      var b = this.selector;
      this.rows(b.rows, b.opts).invalidate(a);
      return this;
    });
    r("cell()", function (a, b, c) {
      return ab(this.cells(a, b, c));
    });
    r("cell().data()", function (a) {
      var b = this.context,
          c = this[0];
      if (a === l) return b.length && c.length ? A(b[0], c[0].row, c[0].column) : l;
      Ea(b[0], c[0].row, c[0].column, a);
      la(b[0], c[0].row, "data", c[0].column);
      return this;
    });
    r("order()", function (a, b) {
      var c = this.context;
      if (a === l) return 0 !== c.length ? c[0].aaSorting : l;
      "number" === typeof a ? a = [[a, b]] : h.isArray(a[0]) || (a = Array.prototype.slice.call(arguments));
      return this.iterator("table", function (b) {
        b.aaSorting = a.slice();
      });
    });
    r("order.listener()", function (a, b, c) {
      return this.iterator("table", function (d) {
        Ka(d, a, b, c);
      });
    });
    r(["columns().order()", "column().order()"], function (a) {
      var b = this;
      return this.iterator("table", function (c, d) {
        var e = [];
        h.each(b[d], function (b, c) {
          e.push([c, a]);
        });
        c.aaSorting = e;
      });
    });
    r("search()", function (a, b, c, d) {
      var e = this.context;
      return a === l ? 0 !== e.length ? e[0].oPreviousSearch.sSearch : l : this.iterator("table", function (e) {
        e.oFeatures.bFilter && ca(e, h.extend({}, e.oPreviousSearch, {
          sSearch: a + "",
          bRegex: null === b ? !1 : b,
          bSmart: null === c ? !0 : c,
          bCaseInsensitive: null === d ? !0 : d
        }), 1);
      });
    });
    r(["columns().search()", "column().search()"], function (a, b, c, d) {
      return this.iterator("column", function (e, f) {
        var g = e.aoPreSearchCols;
        if (a === l) return g[f].sSearch;
        e.oFeatures.bFilter && (h.extend(g[f], {
          sSearch: a + "",
          bRegex: null === b ? !1 : b,
          bSmart: null === c ? !0 : c,
          bCaseInsensitive: null === d ? !0 : d
        }), ca(e, e.oPreviousSearch, 1));
      });
    });
    r("state()", function () {
      return this.context.length ? this.context[0].oSavedState : null;
    });
    r("state.clear()", function () {
      return this.iterator("table", function (a) {
        a.fnStateSaveCallback.call(a.oInstance, a, {});
      });
    });
    r("state.loaded()", function () {
      return this.context.length ? this.context[0].oLoadedState : null;
    });
    r("state.save()", function () {
      return this.iterator("table", function (a) {
        ta(a);
      });
    });

    p.versionCheck = p.fnVersionCheck = function (a) {
      for (var b = p.version.split("."), a = a.split("."), c, d, e = 0, f = a.length; e < f; e++) if (c = parseInt(b[e], 10) || 0, d = parseInt(a[e], 10) || 0, c !== d) return c > d;

      return !0;
    };

    p.isDataTable = p.fnIsDataTable = function (a) {
      var b = h(a).get(0),
          c = !1;
      h.each(p.settings, function (a, e) {
        if (e.nTable === b || e.nScrollHead === b || e.nScrollFoot === b) c = !0;
      });
      return c;
    };

    p.tables = p.fnTables = function (a) {
      return jQuery.map(p.settings, function (b) {
        if (!a || a && h(b.nTable).is(":visible")) return b.nTable;
      });
    };

    p.camelToHungarian = G;
    r("$()", function (a, b) {
      var c = this.rows(b).nodes(),
          c = h(c);
      return h([].concat(c.filter(a).toArray(), c.find(a).toArray()));
    });
    h.each(["on", "one", "off"], function (a, b) {
      r(b + "()", function () {
        var a = Array.prototype.slice.call(arguments);
        a[0].match(/\.dt\b/) || (a[0] += ".dt");
        var d = h(this.tables().nodes());
        d[b].apply(d, a);
        return this;
      });
    });
    r("clear()", function () {
      return this.iterator("table", function (a) {
        ja(a);
      });
    });
    r("settings()", function () {
      return new q(this.context, this.context);
    });
    r("data()", function () {
      return this.iterator("table", function (a) {
        return C(a.aoData, "_aData");
      }).flatten();
    });
    r("destroy()", function (a) {
      a = a || !1;
      return this.iterator("table", function (b) {
        var c = b.nTableWrapper.parentNode,
            d = b.oClasses,
            e = b.nTable,
            f = b.nTBody,
            g = b.nTHead,
            j = b.nTFoot,
            i = h(e),
            f = h(f),
            l = h(b.nTableWrapper),
            m = h.map(b.aoData, function (a) {
          return a.nTr;
        }),
            n;
        b.bDestroying = !0;
        u(b, "aoDestroyCallback", "destroy", [b]);
        a || new q(b).columns().visible(!0);
        l.unbind(".DT").find(":not(tbody *)").unbind(".DT");
        h(za).unbind(".DT-" + b.sInstance);
        e != g.parentNode && (i.children("thead").detach(), i.append(g));
        j && e != j.parentNode && (i.children("tfoot").detach(), i.append(j));
        i.detach();
        l.detach();
        b.aaSorting = [];
        b.aaSortingFixed = [];
        sa(b);
        h(m).removeClass(b.asStripeClasses.join(" "));
        h("th, td", g).removeClass(d.sSortable + " " + d.sSortableAsc + " " + d.sSortableDesc + " " + d.sSortableNone);
        b.bJUI && (h("th span." + d.sSortIcon + ", td span." + d.sSortIcon, g).detach(), h("th, td", g).each(function () {
          var a = h("div." + d.sSortJUIWrapper, this);
          h(this).append(a.contents());
          a.detach();
        }));
        !a && c && c.insertBefore(e, b.nTableReinsertBefore);
        f.children().detach();
        f.append(m);
        i.css("width", b.sDestroyWidth).removeClass(d.sTable);
        (n = b.asDestroyStripes.length) && f.children().each(function (a) {
          h(this).addClass(b.asDestroyStripes[a % n]);
        });
        c = h.inArray(b, p.settings);
        -1 !== c && p.settings.splice(c, 1);
      });
    });
    p.version = "1.10.1";
    p.settings = [];
    p.models = {};
    p.models.oSearch = {
      bCaseInsensitive: !0,
      sSearch: "",
      bRegex: !1,
      bSmart: !0
    };
    p.models.oRow = {
      nTr: null,
      anCells: null,
      _aData: [],
      _aSortData: null,
      _aFilterData: null,
      _sFilterRow: null,
      _sRowStripe: "",
      src: null
    };
    p.models.oColumn = {
      idx: null,
      aDataSort: null,
      asSorting: null,
      bSearchable: null,
      bSortable: null,
      bVisible: null,
      _sManualType: null,
      _bAttrSrc: !1,
      fnCreatedCell: null,
      fnGetData: null,
      fnSetData: null,
      mData: null,
      mRender: null,
      nTh: null,
      nTf: null,
      sClass: null,
      sContentPadding: null,
      sDefaultContent: null,
      sName: null,
      sSortDataType: "std",
      sSortingClass: null,
      sSortingClassJUI: null,
      sTitle: null,
      sType: null,
      sWidth: null,
      sWidthOrig: null
    };
    p.defaults = {
      aaData: null,
      aaSorting: [[0, "asc"]],
      aaSortingFixed: [],
      ajax: null,
      aLengthMenu: [10, 25, 50, 100],
      aoColumns: null,
      aoColumnDefs: null,
      aoSearchCols: [],
      asStripeClasses: null,
      bAutoWidth: !0,
      bDeferRender: !1,
      bDestroy: !1,
      bFilter: !0,
      bInfo: !0,
      bJQueryUI: !1,
      bLengthChange: !0,
      bPaginate: !0,
      bProcessing: !1,
      bRetrieve: !1,
      bScrollCollapse: !1,
      bServerSide: !1,
      bSort: !0,
      bSortMulti: !0,
      bSortCellsTop: !1,
      bSortClasses: !0,
      bStateSave: !1,
      fnCreatedRow: null,
      fnDrawCallback: null,
      fnFooterCallback: null,
      fnFormatNumber: function (a) {
        return a.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands);
      },
      fnHeaderCallback: null,
      fnInfoCallback: null,
      fnInitComplete: null,
      fnPreDrawCallback: null,
      fnRowCallback: null,
      fnServerData: null,
      fnServerParams: null,
      fnStateLoadCallback: function (a) {
        try {
          return JSON.parse((-1 === a.iStateDuration ? sessionStorage : localStorage).getItem("DataTables_" + a.sInstance + "_" + location.pathname));
        } catch (b) {}
      },
      fnStateLoadParams: null,
      fnStateLoaded: null,
      fnStateSaveCallback: function (a, b) {
        try {
          (-1 === a.iStateDuration ? sessionStorage : localStorage).setItem("DataTables_" + a.sInstance + "_" + location.pathname, JSON.stringify(b));
        } catch (c) {}
      },
      fnStateSaveParams: null,
      iStateDuration: 7200,
      iDeferLoading: null,
      iDisplayLength: 10,
      iDisplayStart: 0,
      iTabIndex: 0,
      oClasses: {},
      oLanguage: {
        oAria: {
          sSortAscending: ": activate to sort column ascending",
          sSortDescending: ": activate to sort column descending"
        },
        oPaginate: {
          sFirst: "First",
          sLast: "Last",
          sNext: "Next",
          sPrevious: "Previous"
        },
        sEmptyTable: "No data available in table",
        sInfo: "Showing _START_ to _END_ of _TOTAL_ entries",
        sInfoEmpty: "Showing 0 to 0 of 0 entries",
        sInfoFiltered: "(filtered from _MAX_ total entries)",
        sInfoPostFix: "",
        sDecimal: "",
        sThousands: ",",
        sLengthMenu: "Show _MENU_ entries",
        sLoadingRecords: "Loading...",
        sProcessing: "Processing...",
        sSearch: "Search:",
        sSearchPlaceholder: "",
        sUrl: "",
        sZeroRecords: "No matching records found"
      },
      oSearch: h.extend({}, p.models.oSearch),
      sAjaxDataProp: "data",
      sAjaxSource: null,
      sDom: "lfrtip",
      sPaginationType: "simple_numbers",
      sScrollX: "",
      sScrollXInner: "",
      sScrollY: "",
      sServerMethod: "GET",
      renderer: null
    };
    T(p.defaults);
    p.defaults.column = {
      aDataSort: null,
      iDataSort: -1,
      asSorting: ["asc", "desc"],
      bSearchable: !0,
      bSortable: !0,
      bVisible: !0,
      fnCreatedCell: null,
      mData: null,
      mRender: null,
      sCellType: "td",
      sClass: "",
      sContentPadding: "",
      sDefaultContent: null,
      sName: "",
      sSortDataType: "std",
      sTitle: null,
      sType: null,
      sWidth: null
    };
    T(p.defaults.column);
    p.models.oSettings = {
      oFeatures: {
        bAutoWidth: null,
        bDeferRender: null,
        bFilter: null,
        bInfo: null,
        bLengthChange: null,
        bPaginate: null,
        bProcessing: null,
        bServerSide: null,
        bSort: null,
        bSortMulti: null,
        bSortClasses: null,
        bStateSave: null
      },
      oScroll: {
        bCollapse: null,
        iBarWidth: 0,
        sX: null,
        sXInner: null,
        sY: null
      },
      oLanguage: {
        fnInfoCallback: null
      },
      oBrowser: {
        bScrollOversize: !1,
        bScrollbarLeft: !1
      },
      ajax: null,
      aanFeatures: [],
      aoData: [],
      aiDisplay: [],
      aiDisplayMaster: [],
      aoColumns: [],
      aoHeader: [],
      aoFooter: [],
      oPreviousSearch: {},
      aoPreSearchCols: [],
      aaSorting: null,
      aaSortingFixed: [],
      asStripeClasses: null,
      asDestroyStripes: [],
      sDestroyWidth: 0,
      aoRowCallback: [],
      aoHeaderCallback: [],
      aoFooterCallback: [],
      aoDrawCallback: [],
      aoRowCreatedCallback: [],
      aoPreDrawCallback: [],
      aoInitComplete: [],
      aoStateSaveParams: [],
      aoStateLoadParams: [],
      aoStateLoaded: [],
      sTableId: "",
      nTable: null,
      nTHead: null,
      nTFoot: null,
      nTBody: null,
      nTableWrapper: null,
      bDeferLoading: !1,
      bInitialised: !1,
      aoOpenRows: [],
      sDom: null,
      sPaginationType: "two_button",
      iStateDuration: 0,
      aoStateSave: [],
      aoStateLoad: [],
      oSavedState: null,
      oLoadedState: null,
      sAjaxSource: null,
      sAjaxDataProp: null,
      bAjaxDataGet: !0,
      jqXHR: null,
      json: l,
      oAjaxData: l,
      fnServerData: null,
      aoServerParams: [],
      sServerMethod: null,
      fnFormatNumber: null,
      aLengthMenu: null,
      iDraw: 0,
      bDrawing: !1,
      iDrawError: -1,
      _iDisplayLength: 10,
      _iDisplayStart: 0,
      _iRecordsTotal: 0,
      _iRecordsDisplay: 0,
      bJUI: null,
      oClasses: {},
      bFiltered: !1,
      bSorted: !1,
      bSortCellsTop: null,
      oInit: null,
      aoDestroyCallback: [],
      fnRecordsTotal: function () {
        return "ssp" == z(this) ? 1 * this._iRecordsTotal : this.aiDisplayMaster.length;
      },
      fnRecordsDisplay: function () {
        return "ssp" == z(this) ? 1 * this._iRecordsDisplay : this.aiDisplay.length;
      },
      fnDisplayEnd: function () {
        var a = this._iDisplayLength,
            b = this._iDisplayStart,
            c = b + a,
            d = this.aiDisplay.length,
            e = this.oFeatures,
            f = e.bPaginate;
        return e.bServerSide ? !1 === f || -1 === a ? b + d : Math.min(b + a, this._iRecordsDisplay) : !f || c > d || -1 === a ? d : c;
      },
      oInstance: null,
      sInstance: null,
      iTabIndex: 0,
      nScrollHead: null,
      nScrollFoot: null,
      aLastSort: [],
      oPlugins: {}
    };
    p.ext = t = {
      classes: {},
      errMode: "alert",
      feature: [],
      search: [],
      internal: {},
      legacy: {
        ajax: null
      },
      pager: {},
      renderer: {
        pageButton: {},
        header: {}
      },
      order: {},
      type: {
        detect: [],
        search: {},
        order: {}
      },
      _unique: 0,
      fnVersionCheck: p.fnVersionCheck,
      iApiIndex: 0,
      oJUIClasses: {},
      sVersion: p.version
    };
    h.extend(t, {
      afnFiltering: t.search,
      aTypes: t.type.detect,
      ofnSearch: t.type.search,
      oSort: t.type.order,
      afnSortData: t.order,
      aoFeatures: t.feature,
      oApi: t.internal,
      oStdClasses: t.classes,
      oPagination: t.pager
    });
    h.extend(p.ext.classes, {
      sTable: "dataTable",
      sNoFooter: "no-footer",
      sPageButton: "paginate_button",
      sPageButtonActive: "current",
      sPageButtonDisabled: "disabled",
      sStripeOdd: "odd",
      sStripeEven: "even",
      sRowEmpty: "dataTables_empty",
      sWrapper: "dataTables_wrapper",
      sFilter: "dataTables_filter",
      sInfo: "dataTables_info",
      sPaging: "dataTables_paginate paging_",
      sLength: "dataTables_length",
      sProcessing: "dataTables_processing",
      sSortAsc: "sorting_asc",
      sSortDesc: "sorting_desc",
      sSortable: "sorting",
      sSortableAsc: "sorting_asc_disabled",
      sSortableDesc: "sorting_desc_disabled",
      sSortableNone: "sorting_disabled",
      sSortColumn: "sorting_",
      sFilterInput: "",
      sLengthSelect: "",
      sScrollWrapper: "dataTables_scroll",
      sScrollHead: "dataTables_scrollHead",
      sScrollHeadInner: "dataTables_scrollHeadInner",
      sScrollBody: "dataTables_scrollBody",
      sScrollFoot: "dataTables_scrollFoot",
      sScrollFootInner: "dataTables_scrollFootInner",
      sHeaderTH: "",
      sFooterTH: "",
      sSortJUIAsc: "",
      sSortJUIDesc: "",
      sSortJUI: "",
      sSortJUIAscAllowed: "",
      sSortJUIDescAllowed: "",
      sSortJUIWrapper: "",
      sSortIcon: "",
      sJUIHeader: "",
      sJUIFooter: ""
    });
    var ya = "",
        ya = "",
        E = ya + "ui-state-default",
        ea = ya + "css_right ui-icon ui-icon-",
        Ub = ya + "fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix";
    h.extend(p.ext.oJUIClasses, p.ext.classes, {
      sPageButton: "fg-button ui-button " + E,
      sPageButtonActive: "ui-state-disabled",
      sPageButtonDisabled: "ui-state-disabled",
      sPaging: "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi ui-buttonset-multi paging_",
      sSortAsc: E + " sorting_asc",
      sSortDesc: E + " sorting_desc",
      sSortable: E + " sorting",
      sSortableAsc: E + " sorting_asc_disabled",
      sSortableDesc: E + " sorting_desc_disabled",
      sSortableNone: E + " sorting_disabled",
      sSortJUIAsc: ea + "triangle-1-n",
      sSortJUIDesc: ea + "triangle-1-s",
      sSortJUI: ea + "carat-2-n-s",
      sSortJUIAscAllowed: ea + "carat-1-n",
      sSortJUIDescAllowed: ea + "carat-1-s",
      sSortJUIWrapper: "DataTables_sort_wrapper",
      sSortIcon: "DataTables_sort_icon",
      sScrollHead: "dataTables_scrollHead " + E,
      sScrollFoot: "dataTables_scrollFoot " + E,
      sHeaderTH: E,
      sFooterTH: E,
      sJUIHeader: Ub + " ui-corner-tl ui-corner-tr",
      sJUIFooter: Ub + " ui-corner-bl ui-corner-br"
    });
    var Lb = p.ext.pager;
    h.extend(Lb, {
      simple: function () {
        return ["previous", "next"];
      },
      full: function () {
        return ["first", "previous", "next", "last"];
      },
      simple_numbers: function (a, b) {
        return ["previous", Ua(a, b), "next"];
      },
      full_numbers: function (a, b) {
        return ["first", "previous", Ua(a, b), "next", "last"];
      },
      _numbers: Ua,
      numbers_length: 7
    });
    h.extend(!0, p.ext.renderer, {
      pageButton: {
        _: function (a, b, c, d, e, f) {
          var g = a.oClasses,
              j = a.oLanguage.oPaginate,
              i,
              l,
              m = 0,
              n = function (b, d) {
            var k,
                p,
                r,
                q,
                s = function (b) {
              Ra(a, b.data.action, true);
            };

            k = 0;

            for (p = d.length; k < p; k++) {
              q = d[k];

              if (h.isArray(q)) {
                r = h("<" + (q.DT_el || "div") + "/>").appendTo(b);
                n(r, q);
              } else {
                l = i = "";

                switch (q) {
                  case "ellipsis":
                    b.append("<span>&hellip;</span>");
                    break;

                  case "first":
                    i = j.sFirst;
                    l = q + (e > 0 ? "" : " " + g.sPageButtonDisabled);
                    break;

                  case "previous":
                    i = j.sPrevious;
                    l = q + (e > 0 ? "" : " " + g.sPageButtonDisabled);
                    break;

                  case "next":
                    i = j.sNext;
                    l = q + (e < f - 1 ? "" : " " + g.sPageButtonDisabled);
                    break;

                  case "last":
                    i = j.sLast;
                    l = q + (e < f - 1 ? "" : " " + g.sPageButtonDisabled);
                    break;

                  default:
                    i = q + 1;
                    l = e === q ? g.sPageButtonActive : "";
                }

                if (i) {
                  r = h("<a>", {
                    "class": g.sPageButton + " " + l,
                    "aria-controls": a.sTableId,
                    "data-dt-idx": m,
                    tabindex: a.iTabIndex,
                    id: c === 0 && typeof q === "string" ? a.sTableId + "_" + q : null
                  }).html(i).appendTo(b);
                  Ta(r, {
                    action: q
                  }, s);
                  m++;
                }
              }
            }
          };

          try {
            var k = h(O.activeElement).data("dt-idx");
            n(h(b).empty(), d);
            k !== null && h(b).find("[data-dt-idx=" + k + "]").focus();
          } catch (p) {}
        }
      }
    });

    var va = function (a, b, c, d) {
      if (!a || "-" === a) return -Infinity;
      b && (a = Pb(a, b));
      a.replace && (c && (a = a.replace(c, "")), d && (a = a.replace(d, "")));
      return 1 * a;
    };

    h.extend(t.type.order, {
      "date-pre": function (a) {
        return Date.parse(a) || 0;
      },
      "html-pre": function (a) {
        return H(a) ? "" : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + "";
      },
      "string-pre": function (a) {
        return H(a) ? "" : "string" === typeof a ? a.toLowerCase() : !a.toString ? "" : a.toString();
      },
      "string-asc": function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      },
      "string-desc": function (a, b) {
        return a < b ? 1 : a > b ? -1 : 0;
      }
    });
    cb("");
    h.extend(p.ext.type.detect, [function (a, b) {
      var c = b.oLanguage.sDecimal;
      return Xa(a, c) ? "num" + c : null;
    }, function (a) {
      if (a && (!Yb.test(a) || !Zb.test(a))) return null;
      var b = Date.parse(a);
      return null !== b && !isNaN(b) || H(a) ? "date" : null;
    }, function (a, b) {
      var c = b.oLanguage.sDecimal;
      return Xa(a, c, !0) ? "num-fmt" + c : null;
    }, function (a, b) {
      var c = b.oLanguage.sDecimal;
      return Qb(a, c) ? "html-num" + c : null;
    }, function (a, b) {
      var c = b.oLanguage.sDecimal;
      return Qb(a, c, !0) ? "html-num-fmt" + c : null;
    }, function (a) {
      return H(a) || "string" === typeof a && -1 !== a.indexOf("<") ? "html" : null;
    }]);
    h.extend(p.ext.type.search, {
      html: function (a) {
        return H(a) ? a : "string" === typeof a ? a.replace(Nb, " ").replace(wa, "") : "";
      },
      string: function (a) {
        return H(a) ? a : "string" === typeof a ? a.replace(Nb, " ") : a;
      }
    });
    h.extend(!0, p.ext.renderer, {
      header: {
        _: function (a, b, c, d) {
          h(a.nTable).on("order.dt.DT", function (e, f, g, h) {
            if (a === f) {
              e = c.idx;
              b.removeClass(c.sSortingClass + " " + d.sSortAsc + " " + d.sSortDesc).addClass(h[e] == "asc" ? d.sSortAsc : h[e] == "desc" ? d.sSortDesc : c.sSortingClass);
            }
          });
        },
        jqueryui: function (a, b, c, d) {
          var e = c.idx;
          h("<div/>").addClass(d.sSortJUIWrapper).append(b.contents()).append(h("<span/>").addClass(d.sSortIcon + " " + c.sSortingClassJUI)).appendTo(b);
          h(a.nTable).on("order.dt.DT", function (f, g, h, i) {
            if (a === g) {
              b.removeClass(d.sSortAsc + " " + d.sSortDesc).addClass(i[e] == "asc" ? d.sSortAsc : i[e] == "desc" ? d.sSortDesc : c.sSortingClass);
              b.find("span." + d.sSortIcon).removeClass(d.sSortJUIAsc + " " + d.sSortJUIDesc + " " + d.sSortJUI + " " + d.sSortJUIAscAllowed + " " + d.sSortJUIDescAllowed).addClass(i[e] == "asc" ? d.sSortJUIAsc : i[e] == "desc" ? d.sSortJUIDesc : c.sSortingClassJUI);
            }
          });
        }
      }
    });
    p.render = {
      number: function (a, b, c, d) {
        return {
          display: function (e) {
            var f = 0 > e ? "-" : "",
                e = Math.abs(parseFloat(e)),
                g = parseInt(e, 10),
                e = c ? b + (e - g).toFixed(c).substring(2) : "";
            return f + (d || "") + g.toString().replace(/\B(?=(\d{3})+(?!\d))/g, a) + e;
          }
        };
      }
    };
    h.extend(p.ext.internal, {
      _fnExternApiFunc: Mb,
      _fnBuildAjax: na,
      _fnAjaxUpdate: jb,
      _fnAjaxParameters: sb,
      _fnAjaxUpdateDraw: tb,
      _fnAjaxDataSrc: oa,
      _fnAddColumn: Aa,
      _fnColumnOptions: fa,
      _fnAdjustColumnSizing: V,
      _fnVisibleToColumnIndex: ga,
      _fnColumnIndexToVisible: Y,
      _fnVisbleColumns: Z,
      _fnGetColumns: X,
      _fnColumnTypes: Da,
      _fnApplyColumnDefs: hb,
      _fnHungarianMap: T,
      _fnCamelToHungarian: G,
      _fnLanguageCompat: N,
      _fnBrowserDetect: fb,
      _fnAddData: I,
      _fnAddTr: ha,
      _fnNodeToDataIndex: function (a, b) {
        return b._DT_RowIndex !== l ? b._DT_RowIndex : null;
      },
      _fnNodeToColumnIndex: function (a, b, c) {
        return h.inArray(c, a.aoData[b].anCells);
      },
      _fnGetCellData: A,
      _fnSetCellData: Ea,
      _fnSplitObjNotation: Ga,
      _fnGetObjectDataFn: U,
      _fnSetObjectDataFn: Ba,
      _fnGetDataMaster: Ha,
      _fnClearTable: ja,
      _fnDeleteIndex: ka,
      _fnInvalidateRow: la,
      _fnGetRowElements: ia,
      _fnCreateTr: Fa,
      _fnBuildHead: ib,
      _fnDrawHead: ba,
      _fnDraw: K,
      _fnReDraw: L,
      _fnAddOptionsHtml: lb,
      _fnDetectHeader: aa,
      _fnGetUniqueThs: ma,
      _fnFeatureHtmlFilter: nb,
      _fnFilterComplete: ca,
      _fnFilterCustom: wb,
      _fnFilterColumn: vb,
      _fnFilter: ub,
      _fnFilterCreateSearch: Na,
      _fnEscapeRegex: Oa,
      _fnFilterData: xb,
      _fnFeatureHtmlInfo: qb,
      _fnUpdateInfo: Ab,
      _fnInfoMacros: Bb,
      _fnInitialise: ra,
      _fnInitComplete: pa,
      _fnLengthChange: Pa,
      _fnFeatureHtmlLength: mb,
      _fnFeatureHtmlPaginate: rb,
      _fnPageChange: Ra,
      _fnFeatureHtmlProcessing: ob,
      _fnProcessingDisplay: B,
      _fnFeatureHtmlTable: pb,
      _fnScrollDraw: W,
      _fnApplyToChildren: F,
      _fnCalculateColumnWidths: Ca,
      _fnThrottle: Ma,
      _fnConvertToWidth: Cb,
      _fnScrollingWidthAdjust: Eb,
      _fnGetWidestNode: Db,
      _fnGetMaxLenString: Fb,
      _fnStringToCss: s,
      _fnScrollBarWidth: Gb,
      _fnSortFlatten: R,
      _fnSort: kb,
      _fnSortAria: Ib,
      _fnSortListener: Sa,
      _fnSortAttachListener: Ka,
      _fnSortingClasses: sa,
      _fnSortData: Hb,
      _fnSaveState: ta,
      _fnLoadState: Jb,
      _fnSettingsFromNode: ua,
      _fnLog: P,
      _fnMap: D,
      _fnBindAction: Ta,
      _fnCallbackReg: x,
      _fnCallbackFire: u,
      _fnLengthOverflow: Qa,
      _fnRenderer: La,
      _fnDataSource: z,
      _fnRowAttributes: Ia,
      _fnCalculateEnd: function () {}
    });
    h.fn.dataTable = p;
    h.fn.dataTableSettings = p.settings;
    h.fn.dataTableExt = p.ext;

    h.fn.DataTable = function (a) {
      return h(this).dataTable(a).api();
    };

    h.each(p, function (a, b) {
      h.fn.DataTable[a] = b;
    });
    return h.fn.dataTable;
  };

   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(175)], __WEBPACK_AMD_DEFINE_FACTORY__ = (N),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(window, document);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175)))

/***/ }),

/***/ 3235:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3236);
/* harmony import */ var _source_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_source_js__WEBPACK_IMPORTED_MODULE_0__);
// Last time updated at Sep 07, 2014, 08:32:23
// Latest file can be found here: https://cdn.webrtc-experiment.com/getScreenId.js
// Muaz Khan         - www.MuazKhan.com
// MIT License       - www.WebRTC-Experiment.com/licence
// Documentation     - https://github.com/muaz-khan/WebRTC-Experiment/tree/master/getScreenId.js
// ______________
// getScreenId.js

/*
getScreenId(function (error, sourceId, screen_constraints) {
    // error    == null || 'permission-denied' || 'not-installed' || 'installed-disabled' || 'not-chrome'
    // sourceId == null || 'string' || 'firefox'
    
    if(sourceId == 'firefox') {
        navigator.mozGetUserMedia(screen_constraints, onSuccess, onFailure);
    }
    else navigator.webkitGetUserMedia(screen_constraints, onSuccess, onFailure);
});
*/


(function () {
  window.getScreenId = function (callback) {
    // for Firefox:
    // sourceId == 'firefox'
    // screen_constraints = {...}
    if (!!navigator.mozGetUserMedia) {
      callback(null, 'firefox', {
        video: {
          mozMediaSource: 'window',
          mediaSource: 'window'
        }
      });
      return;
    }

    const isInElectron = window.navigator.userAgent.indexOf("Electron") !== -1; //window.process && window.process.versions && window.process.versions.electron

    if (!isInElectron) {
      return callback(null, null, null);
    }

    callback(null, null, null); // by Electron
    //const isInElectron = window.navigator.userAgent.indexOf("Electron") !== -1;//window.process && window.process.versions && window.process.versions.electron
    //const isName =window.navigator.userAgent.indexOf("Electron") !== -1 ? 'ELectron桌面应用' : 'web应用'
    //const isInElectron = window.process && window.process.versions && window.process.versions.electron
    //console.log(`isName-------${isInElectron}`);
    //const ipcRenderer = window.require('electron');
    //console.log("ipcRenderer-------",ipcRenderer);
    // if(isInElectron) {
    //     window.require('electron').desktopCapturer.getSources({
    //         types: ['screen']
    //     }).then(sources => {
    //         console.log("sources---",sources);
    //         const source = sources.find(s => s.name === 'Electron')
    //         if(source) {
    //             callback(null, source.id, getScreenConstraints(null, source.id))
    //         }
    //     })
    //     return;
    // }
    // by ChromeExtension

    postMessage();
    window.addEventListener('message', onIFrameCallback);

    function onIFrameCallback(event) {
      if (!event.data) return;

      if (event.data.chromeMediaSourceId) {
        if (event.data.chromeMediaSourceId === 'PermissionDeniedError') {
          callback('permission-denied');
        } else callback(null, event.data.chromeMediaSourceId, getScreenConstraints(null, event.data.chromeMediaSourceId));
      }

      if (event.data.chromeExtensionStatus) {
        callback(event.data.chromeExtensionStatus, null, getScreenConstraints(event.data.chromeExtensionStatus));
      } // this event listener is no more needed


      window.removeEventListener('message', onIFrameCallback);
    }
  };

  function getScreenConstraints(error, sourceId) {
    console.log(`getScreenConstraints----${error ? 'screen' : 'desktop'}`);
    var screen_constraints = {
      audio: false,
      video: {
        mandatory: {
          chromeMediaSource: error ? 'screen' : 'desktop',
          maxWidth: 1080,
          //window.screen.width > 1920 ? window.screen.width : 1920,
          maxHeight: 720 //window.screen.height > 1080 ? window.screen.height : 1080

        },
        optional: []
      }
    };

    if (sourceId) {
      screen_constraints.video.mandatory.chromeMediaSourceId = sourceId;
    }

    return screen_constraints;
  }

  function postMessage() {
    if (!iframe.isLoaded) {
      setTimeout(postMessage, 100);
      return;
    }

    iframe.contentWindow.postMessage({
      captureSourceId: true
    }, '*');
  }

  var iframe = document.createElement('iframe');

  iframe.onload = function () {
    iframe.isLoaded = true;
  };

  iframe.src = {
    sourcejs: (_source_js__WEBPACK_IMPORTED_MODULE_0___default())
  };
  iframe.style.display = 'none';
  (document.body || document.documentElement).appendChild(iframe);
})();

/***/ }),

/***/ 3236:
/***/ (function(module, exports) {

// https://github.com/muaz-khan/DetectRTC
var DetectRTC = {};
var screenCallback;
DetectRTC.screen = {
  chromeMediaSource: 'screen',
  getSourceId: function (callback) {
    if (!callback) throw '"callback" parameter is mandatory.';
    screenCallback = callback;
    window.postMessage('get-sourceId', '*');
  },
  getCustomSourceId: function (arr, callback) {
    if (!arr || !arr.forEach) throw '"arr" parameter is mandatory and it must be an array.';
    if (!callback) throw '"callback" parameter is mandatory.';
    screenCallback = callback;
    window.postMessage({
      'get-custom-sourceId': arr
    }, '*');
  },
  getSourceIdWithAudio: function (callback) {
    if (!callback) throw '"callback" parameter is mandatory.';
    screenCallback = callback;
    window.postMessage('audio-plus-tab', '*');
  },
  onMessageCallback: function (data) {
    // "cancel" button is clicked
    if (data == 'PermissionDeniedError') {
      DetectRTC.screen.chromeMediaSource = 'PermissionDeniedError';
      if (screenCallback) return screenCallback('PermissionDeniedError');else throw new Error('PermissionDeniedError');
    } // extension notified his presence


    if (data == 'rtcmulticonnection-extension-loaded') {
      DetectRTC.screen.chromeMediaSource = 'desktop';
    } // extension shared temp sourceId


    if (data.sourceId) {
      DetectRTC.screen.sourceId = data.sourceId;

      if (screenCallback) {
        screenCallback(DetectRTC.screen.sourceId, data.canRequestAudioTrack === true);
      }
    }
  },
  getChromeExtensionStatus: function (callback) {
    // https://chrome.google.com/webstore/detail/screen-capturing/ajhifddimkapgcifgcodmmfdlknahffk
    var extensionid = 'inakjkgomghhfllcbepepflfalcgoahc';
    var image = document.createElement('img');
    image.src = 'chrome-extension://' + extensionid + '/icon.png';

    image.onload = function () {
      if (!DetectRTC.screen) DetectRTC.screen = {};
      if (!DetectRTC.screen.chromeMediaSource) DetectRTC.screen.chromeMediaSource = '';

      if (DetectRTC.screen.chromeMediaSource === 'desktop') {
        callback('installed-enabled');
        return;
      }

      DetectRTC.screen.chromeMediaSource = 'screen';
      window.postMessage('are-you-there', '*');
      setTimeout(function () {
        if (DetectRTC.screen.chromeMediaSource == 'screen') {
          callback('installed-disabled');
        } else {
          callback('installed-enabled');
        }
      }, 2000);
    };

    image.onerror = function () {
      callback('not-installed');
    };
  }
};
window.addEventListener('message', function (event) {
  if (!event.data || !(typeof event.data == 'string' || event.data.sourceId || event.data.captureSourceId || event.data.captureCustomSourceId || event.data.getChromeExtensionStatus || event.data.captureSourceIdWithAudio)) return;

  if (event.data.getChromeExtensionStatus) {
    DetectRTC.screen.getChromeExtensionStatus(function (status) {
      window.parent.postMessage({
        chromeExtensionStatus: status
      }, '*');
    });
    return;
  }

  if (event.data.captureCustomSourceId) {
    captureSourceId(null, event.data.captureCustomSourceId);
  }

  if (event.data.captureSourceId) {
    captureSourceId();
  }

  if (event.data.captureSourceIdWithAudio) {
    captureSourceId('system_audio');
  }

  DetectRTC.screen.onMessageCallback(event.data);
});

function captureSourceId(system_audio, custom_sourceId) {
  // check if desktop-capture extension installed.
  DetectRTC.screen.getChromeExtensionStatus(function (status) {
    if (status != 'installed-enabled') {
      window.parent.postMessage({
        chromeExtensionStatus: status
      }, '*');
      return;
    }

    if (!!custom_sourceId) {
      DetectRTC.screen.getCustomSourceId(custom_sourceId, function (sourceId, canRequestAudioTrack) {
        window.parent.postMessage({
          chromeMediaSourceId: sourceId,
          canRequestAudioTrack: !!canRequestAudioTrack
        }, '*');
      });
    } else if (!system_audio && !custom_sourceId) {
      DetectRTC.screen.getSourceId(function (sourceId) {
        window.parent.postMessage({
          chromeMediaSourceId: sourceId
        }, '*');
      });
    } else {
      DetectRTC.screen.getSourceIdWithAudio(function (sourceId, canRequestAudioTrack) {
        window.parent.postMessage({
          chromeMediaSourceId: sourceId,
          canRequestAudioTrack: !!canRequestAudioTrack
        }, '*');
      });
    }
  });
}

/***/ }),

/***/ 3237:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!function (a) {
  "use strict";

  function b(a, b) {
    var c = (65535 & a) + (65535 & b),
        d = (a >> 16) + (b >> 16) + (c >> 16);
    return d << 16 | 65535 & c;
  }

  function c(a, b) {
    return a << b | a >>> 32 - b;
  }

  function d(a, d, e, f, g, h) {
    return b(c(b(b(d, a), b(f, h)), g), e);
  }

  function e(a, b, c, e, f, g, h) {
    return d(b & c | ~b & e, a, b, f, g, h);
  }

  function f(a, b, c, e, f, g, h) {
    return d(b & e | c & ~e, a, b, f, g, h);
  }

  function g(a, b, c, e, f, g, h) {
    return d(b ^ c ^ e, a, b, f, g, h);
  }

  function h(a, b, c, e, f, g, h) {
    return d(c ^ (b | ~e), a, b, f, g, h);
  }

  function i(a, c) {
    a[c >> 5] |= 128 << c % 32, a[(c + 64 >>> 9 << 4) + 14] = c;
    var d,
        i,
        j,
        k,
        l,
        m = 1732584193,
        n = -271733879,
        o = -1732584194,
        p = 271733878;

    for (d = 0; d < a.length; d += 16) i = m, j = n, k = o, l = p, m = e(m, n, o, p, a[d], 7, -680876936), p = e(p, m, n, o, a[d + 1], 12, -389564586), o = e(o, p, m, n, a[d + 2], 17, 606105819), n = e(n, o, p, m, a[d + 3], 22, -1044525330), m = e(m, n, o, p, a[d + 4], 7, -176418897), p = e(p, m, n, o, a[d + 5], 12, 1200080426), o = e(o, p, m, n, a[d + 6], 17, -1473231341), n = e(n, o, p, m, a[d + 7], 22, -45705983), m = e(m, n, o, p, a[d + 8], 7, 1770035416), p = e(p, m, n, o, a[d + 9], 12, -1958414417), o = e(o, p, m, n, a[d + 10], 17, -42063), n = e(n, o, p, m, a[d + 11], 22, -1990404162), m = e(m, n, o, p, a[d + 12], 7, 1804603682), p = e(p, m, n, o, a[d + 13], 12, -40341101), o = e(o, p, m, n, a[d + 14], 17, -1502002290), n = e(n, o, p, m, a[d + 15], 22, 1236535329), m = f(m, n, o, p, a[d + 1], 5, -165796510), p = f(p, m, n, o, a[d + 6], 9, -1069501632), o = f(o, p, m, n, a[d + 11], 14, 643717713), n = f(n, o, p, m, a[d], 20, -373897302), m = f(m, n, o, p, a[d + 5], 5, -701558691), p = f(p, m, n, o, a[d + 10], 9, 38016083), o = f(o, p, m, n, a[d + 15], 14, -660478335), n = f(n, o, p, m, a[d + 4], 20, -405537848), m = f(m, n, o, p, a[d + 9], 5, 568446438), p = f(p, m, n, o, a[d + 14], 9, -1019803690), o = f(o, p, m, n, a[d + 3], 14, -187363961), n = f(n, o, p, m, a[d + 8], 20, 1163531501), m = f(m, n, o, p, a[d + 13], 5, -1444681467), p = f(p, m, n, o, a[d + 2], 9, -51403784), o = f(o, p, m, n, a[d + 7], 14, 1735328473), n = f(n, o, p, m, a[d + 12], 20, -1926607734), m = g(m, n, o, p, a[d + 5], 4, -378558), p = g(p, m, n, o, a[d + 8], 11, -2022574463), o = g(o, p, m, n, a[d + 11], 16, 1839030562), n = g(n, o, p, m, a[d + 14], 23, -35309556), m = g(m, n, o, p, a[d + 1], 4, -1530992060), p = g(p, m, n, o, a[d + 4], 11, 1272893353), o = g(o, p, m, n, a[d + 7], 16, -155497632), n = g(n, o, p, m, a[d + 10], 23, -1094730640), m = g(m, n, o, p, a[d + 13], 4, 681279174), p = g(p, m, n, o, a[d], 11, -358537222), o = g(o, p, m, n, a[d + 3], 16, -722521979), n = g(n, o, p, m, a[d + 6], 23, 76029189), m = g(m, n, o, p, a[d + 9], 4, -640364487), p = g(p, m, n, o, a[d + 12], 11, -421815835), o = g(o, p, m, n, a[d + 15], 16, 530742520), n = g(n, o, p, m, a[d + 2], 23, -995338651), m = h(m, n, o, p, a[d], 6, -198630844), p = h(p, m, n, o, a[d + 7], 10, 1126891415), o = h(o, p, m, n, a[d + 14], 15, -1416354905), n = h(n, o, p, m, a[d + 5], 21, -57434055), m = h(m, n, o, p, a[d + 12], 6, 1700485571), p = h(p, m, n, o, a[d + 3], 10, -1894986606), o = h(o, p, m, n, a[d + 10], 15, -1051523), n = h(n, o, p, m, a[d + 1], 21, -2054922799), m = h(m, n, o, p, a[d + 8], 6, 1873313359), p = h(p, m, n, o, a[d + 15], 10, -30611744), o = h(o, p, m, n, a[d + 6], 15, -1560198380), n = h(n, o, p, m, a[d + 13], 21, 1309151649), m = h(m, n, o, p, a[d + 4], 6, -145523070), p = h(p, m, n, o, a[d + 11], 10, -1120210379), o = h(o, p, m, n, a[d + 2], 15, 718787259), n = h(n, o, p, m, a[d + 9], 21, -343485551), m = b(m, i), n = b(n, j), o = b(o, k), p = b(p, l);

    return [m, n, o, p];
  }

  function j(a) {
    var b,
        c = "";

    for (b = 0; b < 32 * a.length; b += 8) c += String.fromCharCode(a[b >> 5] >>> b % 32 & 255);

    return c;
  }

  function k(a) {
    var b,
        c = [];

    for (c[(a.length >> 2) - 1] = void 0, b = 0; b < c.length; b += 1) c[b] = 0;

    for (b = 0; b < 8 * a.length; b += 8) c[b >> 5] |= (255 & a.charCodeAt(b / 8)) << b % 32;

    return c;
  }

  function l(a) {
    return j(i(k(a), 8 * a.length));
  }

  function m(a, b) {
    var c,
        d,
        e = k(a),
        f = [],
        g = [];

    for (f[15] = g[15] = void 0, e.length > 16 && (e = i(e, 8 * a.length)), c = 0; 16 > c; c += 1) f[c] = 909522486 ^ e[c], g[c] = 1549556828 ^ e[c];

    return d = i(f.concat(k(b)), 512 + 8 * b.length), j(i(g.concat(d), 640));
  }

  function n(a) {
    var b,
        c,
        d = "0123456789abcdef",
        e = "";

    for (c = 0; c < a.length; c += 1) b = a.charCodeAt(c), e += d.charAt(b >>> 4 & 15) + d.charAt(15 & b);

    return e;
  }

  function o(a) {
    return unescape(encodeURIComponent(a));
  }

  function p(a) {
    return l(o(a));
  }

  function q(a) {
    return n(p(a));
  }

  function r(a, b) {
    return m(o(a), o(b));
  }

  function s(a, b) {
    return n(r(a, b));
  }

  function t(a, b, c) {
    return b ? c ? r(b, a) : s(b, a) : c ? p(a) : q(a);
  }

   true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return t;
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
}(this);

/***/ }),

/***/ 3238:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {
  // Creates an iframe with an embedded HipChat conversation window.
  //
  // Options:
  //   url        - The url to the room to embed; required
  //   container  - The container in which to insert the HipChat panel; required
  //   timezone   - The timezone to use in the embedded room; required
  //   welcome    - A welcome message to display when the room is joined; optional
  //   noframes   - Content to include when iframes are disabled in the browser; optional
  //   width      - The width of the iframe; defaults to 100%
  //   height     - The height of the iframe; defaults to 400px
  $.createHipChat = function (options) {
    if (options && options.url && options.container && options.timezone) {
      var $container = $(options.container);
      if ($container.length === 0) return;
      var params = {
        anonymous: 0,
        timezone: options.timezone,
        minimal: 0
      };

      if (options.welcome) {
        params.welcome_msg = options.welcome;
      }

      var url = options.url + (options.url.indexOf('?') > 0 ? '&' : '?') + $.param(params);

      if (url.indexOf('https://') !== 0) {
        url = 'https://' + url;
      }

      var w = options.width || '100%';
      var h = options.height || 400;
      var nf = options.noframes || '';
      return {
        show: function () {
          $container.html('<iframe src="' + url + '" frameborder="' + 0 + '" width="' + w + '" height="' + h + '">' + nf + '</iframe>');
        }
      };
    }
  };

  $.fn.hipChatPanel = function (options) {
    options.container = this[0];
    var panel = $.createHipChat(options);
    this.html('<button class="show-hipchat ' + options.buttonClasses + '">' + (options.buttonTitle || 'Chat') + '</button>').find('.show-hipchat').click(function (e) {
      panel.show();
    });
  };
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175)))

/***/ }),

/***/ 3239:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery, global) {var require;var require;/*
 * Verto HTML5/Javascript Telephony Signaling and Control Protocol Stack for FreeSWITCH
 * Copyright (C) 2005-2014, Anthony Minessale II <anthm@freeswitch.org>
 *
 * Version: MPL 1.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Verto HTML5/Javascript Telephony Signaling and Control Protocol Stack for FreeSWITCH
 *
 * The Initial Developer of the Original Code is
 * Anthony Minessale II <anthm@freeswitch.org>
 * Portions created by the Initial Developer are Copyright (C)
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Anthony Minessale II <anthm@freeswitch.org>
 *
 * jquery.FSRTC.js - WebRTC Glue code
 *
 */
(function ($) {
  // Find the line in sdpLines that starts with |prefix|, and, if specified,
  // contains |substr| (case-insensitive search).
  function findLine(sdpLines, prefix, substr) {
    return findLineInRange(sdpLines, 0, -1, prefix, substr);
  } // Find the line in sdpLines[startLine...endLine - 1] that starts with |prefix|
  // and, if specified, contains |substr| (case-insensitive search).


  function findLineInRange(sdpLines, startLine, endLine, prefix, substr) {
    var realEndLine = endLine != -1 ? endLine : sdpLines.length;

    for (var i = startLine; i < realEndLine; ++i) {
      if (sdpLines[i].indexOf(prefix) === 0) {
        if (!substr || sdpLines[i].toLowerCase().indexOf(substr.toLowerCase()) !== -1) {
          return i;
        }
      }
    }

    return null;
  } // Gets the codec payload type from an a=rtpmap:X line.


  function getCodecPayloadType(sdpLine) {
    var pattern = new RegExp('a=rtpmap:(\\d+) \\w+\\/\\d+');
    var result = sdpLine.match(pattern);
    return result && result.length == 2 ? result[1] : null;
  } // Returns a new m= line with the specified codec as the first one.


  function setDefaultCodec(mLine, payload) {
    var elements = mLine.split(' ');
    var newLine = [];
    var index = 0;

    for (var i = 0; i < elements.length; i++) {
      if (index === 3) {
        // Format of media starts from the fourth.
        newLine[index++] = payload; // Put target payload to the first.
      }

      if (elements[i] !== payload) newLine[index++] = elements[i];
    }

    return newLine.join(' ');
  }

  $.FSRTC = function (options) {
    this.options = $.extend({
      useVideo: null,
      useStereo: false,
      userData: null,
      localVideo: null,
      screenShare: false,
      useCamera: "any",
      iceServers: false,
      videoParams: {},
      audioParams: {},
      callbacks: {
        onICEComplete: function () {},
        onICE: function () {},
        onOfferSDP: function () {}
      },
      useStream: null
    }, options);
    this.audioEnabled = true;
    this.videoEnabled = true;
    this.mediaData = {
      SDP: null,
      profile: {},
      candidateList: []
    };
    this.constraints = {
      offerToReceiveAudio: this.options.useSpeak === "none" ? false : true,
      offerToReceiveVideo: this.options.useVideo ? true : false
    };

    if (self.options.useVideo) {
      self.options.useVideo.style.display = 'none';
    }

    setCompat();
    checkCompat();
  };

  $.FSRTC.validRes = [];

  $.FSRTC.prototype.useVideo = function (obj, local) {
    var self = this;

    if (obj) {
      self.options.useVideo = obj;
      self.options.localVideo = local;
      self.constraints.offerToReceiveVideo = true;
    } else {
      self.options.useVideo = null;
      self.options.localVideo = null;
      self.constraints.offerToReceiveVideo = false;
    }

    if (self.options.useVideo) {
      self.options.useVideo.style.display = 'none';
    }
  };

  $.FSRTC.prototype.useStereo = function (on) {
    var self = this;
    self.options.useStereo = on;
  }; // Sets Opus in stereo if stereo is enabled, by adding the stereo=1 fmtp param.


  $.FSRTC.prototype.stereoHack = function (sdp) {
    var self = this;

    if (!self.options.useStereo) {
      return sdp;
    }

    var sdpLines = sdp.split('\r\n'); // Find opus payload.

    var opusIndex = findLine(sdpLines, 'a=rtpmap', 'opus/48000'),
        opusPayload;

    if (!opusIndex) {
      return sdp;
    } else {
      opusPayload = getCodecPayloadType(sdpLines[opusIndex]);
    } // Find the payload in fmtp line.


    var fmtpLineIndex = findLine(sdpLines, 'a=fmtp:' + opusPayload.toString());

    if (fmtpLineIndex === null) {
      // create an fmtp line
      sdpLines[opusIndex] = sdpLines[opusIndex] + '\r\na=fmtp:' + opusPayload.toString() + " stereo=1; sprop-stereo=1";
    } else {
      // Append stereo=1 to fmtp line.
      sdpLines[fmtpLineIndex] = sdpLines[fmtpLineIndex].concat('; stereo=1; sprop-stereo=1');
    }

    sdp = sdpLines.join('\r\n');
    return sdp;
  };

  function setCompat() {}

  function checkCompat() {
    return true;
  }

  function onStreamError(self, e) {
    console.log('There has been a problem retrieving the streams - did you allow access? Check Device Resolution', e);
    doCallback(self, "onError", e);
  }

  function onStreamSuccess(self, stream) {
    console.log("Stream Success");
    doCallback(self, "onStream", stream);
  }

  function onRemoteStreamSuccess(self, stream) {
    console.log("Remote Stream Success");
    doCallback(self, "onRemoteStream", stream);
  }

  function onICE(self, candidate) {
    self.mediaData.candidate = candidate;
    self.mediaData.candidateList.push(self.mediaData.candidate);
    doCallback(self, "onICE");
  }

  function doCallback(self, func, arg) {
    if (func in self.options.callbacks) {
      self.options.callbacks[func](self, arg);
    }
  }

  function onICEComplete(self, candidate) {
    console.log("ICE Complete");
    doCallback(self, "onICEComplete");
  }

  function onChannelError(self, e) {
    console.error("Channel Error", e);
    doCallback(self, "onError", e);
  }

  function onICESDP(self, sdp) {
    self.mediaData.SDP = self.stereoHack(sdp.sdp);
    console.log("ICE SDP");
    doCallback(self, "onICESDP");
  }

  function onAnswerSDP(self, sdp) {
    self.answer.SDP = self.stereoHack(sdp.sdp);
    console.log("ICE ANSWER SDP");
    doCallback(self, "onAnswerSDP", self.answer.SDP);
  }

  function onMessage(self, msg) {
    console.log("Message");
    doCallback(self, "onICESDP", msg);
  }

  FSRTCattachMediaStream = function (element, stream) {
    if (typeof element.srcObject !== 'undefined') {
      element.srcObject = stream;
    } else {
      console.error('Error attaching stream to element.');
    }
  };

  function onRemoteStream(self, stream) {
    if (self.options.useVideo) {
      self.options.useVideo.style.display = 'block'; // Hacks for Mobile Safari

      var iOS = ['iPad', 'iPhone', 'iPod'].indexOf(navigator.platform) >= 0;

      if (iOS) {
        self.options.useVideo.setAttribute("playsinline", true);
      }
    }

    var element = self.options.useAudio;
    console.log("REMOTE STREAM", stream, element);
    FSRTCattachMediaStream(element, stream); //self.options.useAudio.play();

    self.remoteStream = stream;
    onRemoteStreamSuccess(self, stream);
  }

  function onOfferSDP(self, sdp) {
    self.mediaData.SDP = self.stereoHack(sdp.sdp);
    console.log("Offer SDP");
    doCallback(self, "onOfferSDP");
  }

  $.FSRTC.prototype.answer = function (sdp, onSuccess, onError) {
    this.peer.addAnswerSDP({
      type: "answer",
      sdp: sdp
    }, onSuccess, onError);
  };

  $.FSRTC.prototype.stopPeer = function () {
    if (self.peer) {
      console.log("stopping peer");
      self.peer.stop();
    }
  };

  $.FSRTC.prototype.stop = function () {
    var self = this;

    if (self.options.useVideo) {
      self.options.useVideo.style.display = 'none';
      self.options.useVideo['src'] = '';
    }

    if (self.localStream && !self.options.useStream) {
      if (typeof self.localStream.stop == 'function') {
        self.localStream.stop();
      } else {
        if (self.localStream.active) {
          var tracks = self.localStream.getTracks();
          console.log(tracks);
          tracks.forEach(function (track, index) {
            console.log(track);
            track.stop();
          });
        }
      }

      self.localStream = null;
    }

    if (self.options.localVideo) {
      deactivateLocalVideo(self.options.localVideo);
    }

    if (self.options.localVideoStream && !self.options.useStream) {
      if (typeof self.options.localVideoStream.stop == 'function') {
        self.options.localVideoStream.stop();
      } else {
        if (self.options.localVideoStream.active) {
          var tracks = self.options.localVideoStream.getTracks();
          console.log(tracks);
          tracks.forEach(function (track, index) {
            console.log(track);
            track.stop();
          });
        }
      }
    }

    if (self.peer) {
      console.log("stopping peer");
      self.peer.stop();
    }
  };

  $.FSRTC.prototype.getMute = function () {
    var self = this;
    return self.audioEnabled;
  };

  $.FSRTC.prototype.setMute = function (what) {
    var self = this;

    if (!self.localStream) {
      return false;
    }

    var audioTracks = self.localStream.getAudioTracks();

    for (var i = 0, len = audioTracks.length; i < len; i++) {
      switch (what) {
        case "on":
          audioTracks[i].enabled = true;
          break;

        case "off":
          audioTracks[i].enabled = false;
          break;

        case "toggle":
          audioTracks[i].enabled = !audioTracks[i].enabled;

        default:
          break;
      }

      self.audioEnabled = audioTracks[i].enabled;
    }

    return !self.audioEnabled;
  };

  $.FSRTC.prototype.getVideoMute = function () {
    var self = this;
    return self.videoEnabled;
  };

  $.FSRTC.prototype.setVideoMute = function (what) {
    var self = this;

    if (!self.localStream) {
      return false;
    }

    var videoTracks = self.localStream.getVideoTracks();

    for (var i = 0, len = videoTracks.length; i < len; i++) {
      switch (what) {
        case "on":
          videoTracks[i].enabled = true;
          break;

        case "off":
          videoTracks[i].enabled = false;
          break;

        case "toggle":
          videoTracks[i].enabled = !videoTracks[i].enabled;

        default:
          break;
      }

      self.videoEnabled = videoTracks[i].enabled;
    }

    return !self.videoEnabled;
  };

  $.FSRTC.prototype.createAnswer = function (params) {
    var self = this;
    self.type = "answer";
    self.remoteSDP = params.sdp;
    console.debug("inbound sdp: ", params.sdp);

    function onSuccess(stream) {
      self.localStream = stream;
      self.peer = FSRTCPeerConnection({
        type: self.type,
        attachStream: self.localStream,
        onICE: function (candidate) {
          return onICE(self, candidate);
        },
        onICEComplete: function () {
          return onICEComplete(self);
        },
        onRemoteStream: function (stream) {
          return onRemoteStream(self, stream);
        },
        onICESDP: function (sdp) {
          return onICESDP(self, sdp);
        },
        onChannelError: function (e) {
          return onChannelError(self, e);
        },
        constraints: self.constraints,
        iceServers: self.options.iceServers,
        offerSDP: {
          type: "offer",
          sdp: self.remoteSDP
        },
        turnServer: self.options.turnServer
      });
      onStreamSuccess(self, stream);
    }

    function onError(e) {
      onStreamError(self, e);
    }

    var mediaParams = getMediaParams(self);
    console.log("Audio constraints", mediaParams.audio);
    console.log("Video constraints", mediaParams.video);

    if (self.options.useVideo && self.options.localVideo && !self.options.useStream) {
      getUserMedia({
        constraints: {
          audio: false,
          video: {
            deviceId: params.useCamera
          }
        },
        localVideo: self.options.localVideo,
        onsuccess: function (e) {
          self.options.localVideoStream = e;
          console.log("local video ready");
        },
        onerror: function (e) {
          console.error("local video error!");
        }
      });
    }

    if (self.options.useStream) {
      if (self.options.useVideo) {
        self.options.localVideoStream = self.options.useStream;

        if (self.options.localVideo) {
          activateLocalVideo(self.options.localVideo, self.options.useStream);
        }
      }

      onSuccess(self.options.useStream);
    } else {
      getUserMedia({
        constraints: {
          audio: mediaParams.audio,
          video: mediaParams.video
        },
        video: mediaParams.useVideo,
        onsuccess: onSuccess,
        onerror: onError
      });
    }
  };

  function getMediaParams(obj) {
    var audio;

    if (obj.options.useMic && obj.options.useMic === "none") {
      console.log("Microphone Disabled");
      audio = false;
    } else if (obj.options.videoParams && obj.options.screenShare) {
      //obj.options.videoParams.chromeMediaSource == 'desktop') {
      console.error("SCREEN SHARE", obj.options.videoParams);
      audio = false;
    } else {
      audio = {};

      if (obj.options.audioParams) {
        audio = obj.options.audioParams;
      }

      if (obj.options.useMic !== "any") {
        console.log(`dowin----1-1-1-1-1-1-1-1`); //audio.optional = [{sourceId: obj.options.useMic}];

        audio.deviceId = {
          exact: obj.options.useMic
        };
      }
    }

    if (obj.options.useVideo && obj.options.localVideo && !obj.options.useStream) {
      console.log(`dowin---000000`);
      getUserMedia({
        constraints: {
          audio: false,
          video: {
            deviceId: obj.options.useCamera
          }
        },
        localVideo: obj.options.localVideo,
        onsuccess: function (e) {
          obj.options.localVideoStream = e;
          console.log("local video ready");
        },
        onerror: function (e) {
          console.error("local video error!");
        }
      });
    }

    var video = {};
    var bestFrameRate = obj.options.videoParams.vertoBestFrameRate;
    var minFrameRate = obj.options.videoParams.minFrameRate || 15;
    delete obj.options.videoParams.vertoBestFrameRate;

    if (obj.options.screenShare) {
      if (!obj.options.useCamera && !!navigator.mozGetUserMedia) {
        //This is an issue, only FireFox needs to ask this additional question if its screen or window we need a better way
        var dowin = window.confirm("Do you want to share an application window?  If not you can share an entire screen."); //console.log(`dowin---1111--${dowin ? "window" : "screen"}`);

        video = {
          width: {
            min: obj.options.videoParams.minWidth,
            max: obj.options.videoParams.maxWidth
          },
          height: {
            min: obj.options.videoParams.minHeight,
            max: obj.options.videoParams.maxHeight
          },
          mediaSource: dowin ? "window" : "screen"
        };
      } else {
        //console.log(`dowin---22222`);
        var opt = [];

        if (obj.options.useCamera) {
          //console.log(`dowin---33333`);
          opt.push({
            sourceId: obj.options.useCamera
          });
        }

        if (bestFrameRate) {
          opt.push({
            minFrameRate: bestFrameRate
          });
          opt.push({
            maxFrameRate: bestFrameRate
          });
        } //console.log(`dowin---44444`);


        video = {
          mandatory: obj.options.videoParams,
          optional: opt
        }; // NOTE: This is a workaround for
        // https://bugs.chromium.org/p/chromium/issues/detail?id=862325

        if (!!navigator.userAgent.match(/Android/i)) {
          delete video.frameRate.min;
        }
      }
    } else {
      //console.log(`dowin---555555`);
      video = {
        //mandatory: obj.options.videoParams,
        width: {
          min: obj.options.videoParams.minWidth,
          max: obj.options.videoParams.maxWidth
        },
        height: {
          min: obj.options.videoParams.minHeight,
          max: obj.options.videoParams.maxHeight
        }
      };
      var useVideo = obj.options.useVideo;

      if (useVideo && obj.options.useCamera && obj.options.useCamera !== "none") {
        //if (!video.optional) {
        //video.optional = [];
        //}
        if (obj.options.useCamera !== "any") {
          //video.optional.push({sourceId: obj.options.useCamera});
          video.deviceId = {
            exact: obj.options.useCamera
          };
        }

        if (bestFrameRate) {
          //video.optional.push({minFrameRate: bestFrameRate});
          //video.optional.push({maxFrameRate: bestFrameRate});
          video.frameRate = {
            ideal: bestFrameRate,
            min: minFrameRate,
            max: 30
          };
        }
      } else {
        console.log("Camera Disabled");
        video = false;
        useVideo = false;
      }
    } //console.log(`dowin---66666666${audio}----${video}----${useVideo}`);


    return {
      audio: audio,
      video: video,
      useVideo: useVideo
    };
  }

  $.FSRTC.prototype.call = function (profile) {
    checkCompat();
    var self = this;
    var screen = false;
    self.type = "offer";

    if (self.options.videoParams && self.options.screenShare) {
      //self.options.videoParams.chromeMediaSource == 'desktop') {
      //console.log(`dowin---77777777`);
      screen = true;
    }

    function onSuccess(stream) {
      self.localStream = stream; //console.log(`dowin---888888${stream}---${screen}`);

      if (screen) {
        self.constraints.offerToReceiveVideo = false;
        self.constraints.offerToReceiveAudio = false;
        self.constraints.offerToSendAudio = false;
      }

      self.peer = FSRTCPeerConnection({
        type: self.type,
        attachStream: self.localStream,
        onICE: function (candidate) {
          return onICE(self, candidate);
        },
        onICEComplete: function () {
          return onICEComplete(self);
        },
        onRemoteStream: screen ? function (stream) {} : function (stream) {
          return onRemoteStream(self, stream);
        },
        onOfferSDP: function (sdp) {
          return onOfferSDP(self, sdp);
        },
        onICESDP: function (sdp) {
          return onICESDP(self, sdp);
        },
        onChannelError: function (e) {
          return onChannelError(self, e);
        },
        constraints: self.constraints,
        iceServers: self.options.iceServers,
        turnServer: self.options.turnServer
      });
      onStreamSuccess(self, stream);
    }

    function onError(e) {
      onStreamError(self, e);
    }

    var mediaParams = getMediaParams(self);
    console.log("Audio constraints", mediaParams.audio);
    console.log("Video constraints", mediaParams.video);

    if (self.options.useStream) {
      if (self.options.useVideo) {
        self.options.localVideoStream = self.options.useStream;

        if (self.options.localVideo) {
          activateLocalVideo(self.options.localVideo, self.options.useStream);
        }
      }

      onSuccess(self.options.useStream);
    } else if (mediaParams.audio || mediaParams.video) {
      getUserMedia({
        constraints: {
          audio: mediaParams.audio,
          video: mediaParams.video
        },
        video: mediaParams.useVideo,
        onsuccess: onSuccess,
        onerror: onError
      });
    } else {
      onSuccess(null);
    }
    /*
    navigator.getUserMedia({
        video: self.options.useVideo,
        audio: true
    }, onSuccess, onError);
    */

  }; // DERIVED from RTCPeerConnection-v1.5
  // 2013, @muazkh - github.com/muaz-khan
  // MIT License - https://www.webrtc-experiment.com/licence/
  // Documentation - https://github.com/muaz-khan/WebRTC-Experiment/tree/master/RTCPeerConnection


  function FSRTCPeerConnection(options) {
    var gathering = false,
        done = false;
    var config = {};
    var default_ice = [{
      urls: ['stun:stun.l.google.com:19302']
    }];

    if (self.options.turnServer) {
      default_ice.push(self.options.turnServer);
    }

    if (options.iceServers) {
      if (typeof options.iceServers === "boolean") {
        config.iceServers = default_ice;
      } else {
        config.iceServers = options.iceServers;
      }
    }

    config.bundlePolicy = "max-compat";
    var peer = new window.RTCPeerConnection(config);
    openOffererChannel();
    var x = 0;

    function ice_handler() {
      done = true;
      gathering = null;

      if (options.onICEComplete) {
        options.onICEComplete();
      }

      if (options.type == "offer") {
        options.onICESDP(peer.localDescription);
      } else {
        if (!x && options.onICESDP) {
          options.onICESDP(peer.localDescription);
        }
      }
    }

    peer.onicecandidate = function (event) {
      if (done) {
        return;
      }

      if (!gathering) {
        gathering = setTimeout(ice_handler, 1000);
      }

      if (event) {
        if (event.candidate) {
          options.onICE(event.candidate);
        }
      } else {
        done = true;

        if (gathering) {
          clearTimeout(gathering);
          gathering = null;
        }

        ice_handler();
      }
    }; // attachStream = MediaStream;


    if (options.attachStream) peer.addStream(options.attachStream); // attachStreams[0] = audio-stream;
    // attachStreams[1] = video-stream;
    // attachStreams[2] = screen-capturing-stream;

    if (options.attachStreams && options.attachStream.length) {
      var streams = options.attachStreams;

      for (var i = 0; i < streams.length; i++) {
        peer.addStream(streams[i]);
      }
    }

    peer.onaddstream = function (event) {
      var remoteMediaStream = event.stream; // onRemoteStreamEnded(MediaStream)

      remoteMediaStream.oninactive = function () {
        if (options.onRemoteStreamEnded) options.onRemoteStreamEnded(remoteMediaStream);
      }; // onRemoteStream(MediaStream)


      if (options.onRemoteStream) options.onRemoteStream(remoteMediaStream); //console.debug('on:add:stream', remoteMediaStream);
    }; //var constraints = options.constraints || {
    //offerToReceiveAudio: true,
    //offerToReceiveVideo: true   
    //};
    // onOfferSDP(RTCSessionDescription)


    function createOffer() {
      if (!options.onOfferSDP) return;
      peer.createOffer(function (sessionDescription) {
        sessionDescription.sdp = serializeSdp(sessionDescription.sdp);
        peer.setLocalDescription(sessionDescription);
        options.onOfferSDP(sessionDescription);
      }, onSdpError, options.constraints);
    } // onAnswerSDP(RTCSessionDescription)


    function createAnswer() {
      if (options.type != "answer") return; //options.offerSDP.sdp = addStereo(options.offerSDP.sdp);

      peer.setRemoteDescription(new window.RTCSessionDescription(options.offerSDP), onSdpSuccess, onSdpError);
      peer.createAnswer(function (sessionDescription) {
        sessionDescription.sdp = serializeSdp(sessionDescription.sdp);
        peer.setLocalDescription(sessionDescription);

        if (options.onAnswerSDP) {
          options.onAnswerSDP(sessionDescription);
        }
      }, onSdpError);
    }

    if (options.onChannelMessage || !options.onChannelMessage) {
      createOffer();
      createAnswer();
    } // DataChannel Bandwidth


    function setBandwidth(sdp) {
      // remove existing bandwidth lines
      sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, '');
      sdp = sdp.replace(/a=mid:data\r\n/g, 'a=mid:data\r\nb=AS:1638400\r\n');
      return sdp;
    } // old: FF<>Chrome interoperability management


    function getInteropSDP(sdp) {
      var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''),
          extractedChars = '';

      function getChars() {
        extractedChars += chars[parseInt(Math.random() * 40)] || '';
        if (extractedChars.length < 40) getChars();
        return extractedChars;
      } // usually audio-only streaming failure occurs out of audio-specific crypto line
      // a=crypto:1 AES_CM_128_HMAC_SHA1_32 --------- kAttributeCryptoVoice


      if (options.onAnswerSDP) sdp = sdp.replace(/(a=crypto:0 AES_CM_128_HMAC_SHA1_32)(.*?)(\r\n)/g, ''); // video-specific crypto line i.e. SHA1_80
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 --------- kAttributeCryptoVideo

      var inline = getChars() + '\r\n' + (extractedChars = '');
      sdp = sdp.indexOf('a=crypto') == -1 ? sdp.replace(/c=IN/g, 'a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:' + inline + 'c=IN') : sdp;
      return sdp;
    }

    function serializeSdp(sdp) {
      return sdp;
    } // DataChannel management


    var channel;

    function openOffererChannel() {
      if (!options.onChannelMessage) return;

      _openOffererChannel();

      return;
    }

    function _openOffererChannel() {
      channel = peer.createDataChannel(options.channel || 'RTCDataChannel', {
        reliable: false
      });
      setChannelEvents();
    }

    function setChannelEvents() {
      channel.onmessage = function (event) {
        if (options.onChannelMessage) options.onChannelMessage(event);
      };

      channel.onopen = function () {
        if (options.onChannelOpened) options.onChannelOpened(channel);
      };

      channel.onclose = function (event) {
        if (options.onChannelClosed) options.onChannelClosed(event);
        console.warn('WebRTC DataChannel closed', event);
      };

      channel.onerror = function (event) {
        if (options.onChannelError) options.onChannelError(event);
        console.error('WebRTC DataChannel error', event);
      };
    }

    function openAnswererChannel() {
      peer.ondatachannel = function (event) {
        channel = event.channel;
        channel.binaryType = 'blob';
        setChannelEvents();
      };

      return;
    } // fake:true is also available on chrome under a flag!


    function useless() {
      log('Error in fake:true');
    }

    function onSdpSuccess() {}

    function onSdpError(e) {
      if (options.onChannelError) {
        options.onChannelError(e);
      }

      console.error('sdp error:', e);
    }

    return {
      addAnswerSDP: function (sdp, cbSuccess, cbError) {
        peer.setRemoteDescription(new window.RTCSessionDescription(sdp), cbSuccess ? cbSuccess : onSdpSuccess, cbError ? cbError : onSdpError);
      },
      addICE: function (candidate) {
        peer.addIceCandidate(new window.RTCIceCandidate({
          sdpMLineIndex: candidate.sdpMLineIndex,
          candidate: candidate.candidate
        }));
      },
      peer: peer,
      channel: channel,
      sendData: function (message) {
        if (channel) {
          channel.send(message);
        }
      },
      stop: function () {
        peer.close();

        if (options.attachStream) {
          if (typeof options.attachStream.stop == 'function') {
            options.attachStream.stop();
          } else {
            options.attachStream.active = false;
          }
        }
      }
    };
  } // getUserMedia


  var video_constraints = {//mandatory: {},
    //optional: []
  };

  function activateLocalVideo(el, stream) {
    el.srcObject = stream;
    el.style.display = 'block';
  }

  function deactivateLocalVideo(el) {
    el.srcObject = null;
    el.style.display = 'none';
  }

  function getUserMedia(options) {
    var n = navigator,
        media;

    if (!n.getUserMedia) {
      console.log("不支持视频");
      return;
    }

    n.getMedia = n.getUserMedia;
    n.getMedia(options.constraints || {
      audio: true,
      video: {
        width: 1280,
        height: 720 //1280, 720

      }
    }, streaming, options.onerror || function (e) {
      console.error(`硬件报错----${e}`);
    });

    function streaming(stream) {
      if (options.localVideo) {
        activateLocalVideo(options.localVideo, stream);
      }

      if (options.onsuccess) {
        options.onsuccess(stream);
      }

      media = stream;
    }

    return media;
  }

  $.FSRTC.resSupported = function (w, h) {
    for (var i in $.FSRTC.validRes) {
      if ($.FSRTC.validRes[i][0] == w && $.FSRTC.validRes[i][1] == h) {
        return true;
      }
    }

    return false;
  };

  $.FSRTC.bestResSupported = function () {
    var w = 0,
        h = 0;

    for (var i in $.FSRTC.validRes) {
      if ($.FSRTC.validRes[i][0] >= w && $.FSRTC.validRes[i][1] >= h) {
        w = $.FSRTC.validRes[i][0];
        h = $.FSRTC.validRes[i][1];
      }
    }

    return [w, h];
  };

  var resList = [[160, 120], [320, 180], [320, 240], [640, 360], [640, 480], [1280, 720], [1920, 1080]];
  var resI = 0;
  var ttl = 0;

  var checkRes = function (cam, func) {
    if (resI >= resList.length) {
      var res = {
        'validRes': $.FSRTC.validRes,
        'bestResSupported': $.FSRTC.bestResSupported()
      };
      localStorage.setItem("res_" + cam, $.toJSON(res));
      if (func) return func(res);
      return;
    }

    w = resList[resI][0];
    h = resList[resI][1];
    resI++;
    var video = {
      width: {
        exact: w
      },
      height: {
        exact: h
      }
    };

    if (cam !== "any") {
      video.deviceId = {
        exact: cam
      };
    }

    getUserMedia({
      constraints: {
        audio: ttl++ == 0,
        video: video
      },
      onsuccess: function (e) {
        e.getTracks().forEach(function (track) {
          track.stop();
        });
        console.info(w + "x" + h + " supported.");
        $.FSRTC.validRes.push([w, h]);
        checkRes(cam, func);
      },
      onerror: function (e) {
        console.warn(w + "x" + h + " not supported.");
        checkRes(cam, func);
      }
    });
  };

  $.FSRTC.getValidRes = function (cam, func) {
    var used = [];
    var cached = localStorage.getItem("res_" + cam);

    if (cached) {
      var cache = $.parseJSON(cached);

      if (cache) {
        $.FSRTC.validRes = cache.validRes;
        console.log("CACHED RES FOR CAM " + cam, cache);
      } else {
        console.error("INVALID CACHE");
      }

      return func ? func(cache) : null;
    }

    $.FSRTC.validRes = [];
    resI = 0;
    checkRes(cam, func);
  };

  $.FSRTC.checkPerms = function (runtime, check_audio, check_video) {
    getUserMedia({
      constraints: {
        audio: check_audio,
        video: check_video
      },
      onsuccess: function (e) {
        e.getTracks().forEach(function (track) {
          track.stop();
        });
        console.info("media perm init complete");

        if (runtime) {
          setTimeout(runtime, 100, true);
        }
      },
      onerror: function (e) {
        if (check_audio) {
          console.error("error, retesting with audio params only");
          return $.FSRTC.checkPerms(runtime, check_audio, false);
        }

        console.error("media perm init error");

        if (runtime) {
          runtime(false);
        }
      }
    });
  };
})(jQuery);
/*
* Verto HTML5/Javascript Telephony Signaling and Control Protocol Stack for FreeSWITCH
* Copyright (C) 2005-2014, Anthony Minessale II <anthm@freeswitch.org>
*
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public License Version
* 1.1 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
* for the specific language governing rights and limitations under the
* License.
*
* The Original Code is jquery.jsonrpclient.js modified for Verto HTML5/Javascript Telephony Signaling and Control Protocol Stack for FreeSWITCH
*
* The Initial Developer of the Original Code is
* Textalk AB http://textalk.se/
* Portions created by the Initial Developer are Copyright (C)
* the Initial Developer. All Rights Reserved.
*
* Contributor(s):
*
* Anthony Minessale II <anthm@freeswitch.org>
*
* jquery.jsonrpclient.js - JSON RPC client code
*
*/

/**
* This plugin requires jquery.json.js to be available, or at least the methods $.toJSON and
* $.parseJSON.
*
* The plan is to make use of websockets if they are available, but work just as well with only
* http if not.
*
* Usage example:
*
*   var foo = new $.JsonRpcClient({ ajaxUrl: '/backend/jsonrpc' });
*   foo.call(
*     'bar', [ 'A parameter', 'B parameter' ],
*     function(result) { alert('Foo bar answered: ' + result.my_answer); },
*     function(error)  { console.log('There was an error', error); }
*   );
*
* More examples are available in README.md
*/


(function ($) {
  /**
   * @fn new
   * @memberof $.JsonRpcClient
   *
   * @param options An object stating the backends:
   *                ajaxUrl    A url (relative or absolute) to a http(s) backend.
   *                socketUrl  A url (relative of absolute) to a ws(s) backend.
   *                onmessage  A socket message handler for other messages (non-responses).
   *                getSocket  A function returning a WebSocket or null.
   *                           It must take an onmessage_cb and bind it to the onmessage event
   *                           (or chain it before/after some other onmessage handler).
   *                           Or, it could return null if no socket is available.
   *                           The returned instance must have readyState <= 1, and if less than 1,
   *                           react to onopen binding.
   */
  $.JsonRpcClient = function (options) {
    var self = this;
    this.options = $.extend({
      ajaxUrl: null,
      socketUrl: null,
      ///< The ws-url for default getSocket.
      onmessage: null,
      ///< Other onmessage-handler.
      login: null,
      /// auth login
      passwd: null,
      /// auth passwd
      sessid: null,
      loginParams: null,
      userVariables: null,
      getSocket: function (onmessage_cb) {
        return self._getSocket(onmessage_cb);
      }
    }, options);
    self.ws_cnt = 0; // Declare an instance version of the onmessage callback to wrap 'this'.

    this.wsOnMessage = function (event) {
      self._wsOnMessage(event);
    };
  }; /// Holding the WebSocket on default getsocket.


  $.JsonRpcClient.prototype._ws_socket = null; /// Object <id>: { success_cb: cb, error_cb: cb }

  $.JsonRpcClient.prototype._ws_callbacks = {}; /// The next JSON-RPC request id.

  $.JsonRpcClient.prototype._current_id = 1;

  $.JsonRpcClient.prototype.speedTest = function (bytes, cb) {
    var socket = this.options.getSocket(this.wsOnMessage);

    if (socket !== null) {
      this.speedCB = cb;
      this.speedBytes = bytes;
      socket.send("#SPU " + bytes);
      var loops = bytes / 1024;
      var rem = bytes % 1024;
      var i;
      var data = new Array(1024).join(".");

      for (i = 0; i < loops; i++) {
        socket.send("#SPB " + data);
      }

      if (rem) {
        socket.send("#SPB " + data);
      }

      socket.send("#SPE");
    }
  };
  /**
   * @fn call
   * @memberof $.JsonRpcClient
   *
   * @param method     The method to run on JSON-RPC server.
   * @param params     The params; an array or object.
   * @param success_cb A callback for successful request.
   * @param error_cb   A callback for error.
   */


  $.JsonRpcClient.prototype.call = function (method, params, success_cb, error_cb) {
    // Construct the JSON-RPC 2.0 request.
    if (!params) {
      params = {};
    }

    if (this.options.sessid) {
      params.sessid = this.options.sessid;
    }

    var request = {
      jsonrpc: '2.0',
      method: method,
      params: params,
      id: this._current_id++ // Increase the id counter to match request/response

    };

    if (!success_cb) {
      success_cb = function (e) {
        console.log("Success: ", e);
      };
    }

    if (!error_cb) {
      error_cb = function (e) {
        console.log("Error: ", e);
      };
    } // Try making a WebSocket call.


    var socket = this.options.getSocket(this.wsOnMessage);

    if (socket !== null) {
      this._wsCall(socket, request, success_cb, error_cb);

      return;
    } // No WebSocket, and no HTTP backend?  This won't work.


    if (this.options.ajaxUrl === null) {
      throw "$.JsonRpcClient.call used with no websocket and no http endpoint.";
    }

    $.ajax({
      type: 'POST',
      url: this.options.ajaxUrl,
      data: $.toJSON(request),
      dataType: 'json',
      cache: false,
      success: function (data) {
        if ('error' in data) error_cb(data.error, this);
        success_cb(data.result, this);
      },
      // JSON-RPC Server could return non-200 on error
      error: function (jqXHR, textStatus, errorThrown) {
        try {
          var response = $.parseJSON(jqXHR.responseText);
          if ('console' in window) console.log(response);
          error_cb(response.error, this);
        } catch (err) {
          // Perhaps the responseText wasn't really a jsonrpc-error.
          error_cb({
            error: jqXHR.responseText
          }, this);
        }
      }
    });
  };
  /**
   * Notify sends a command to the server that won't need a response.  In http, there is probably
   * an empty response - that will be dropped, but in ws there should be no response at all.
   *
   * This is very similar to call, but has no id and no handling of callbacks.
   *
   * @fn notify
   * @memberof $.JsonRpcClient
   *
   * @param method     The method to run on JSON-RPC server.
   * @param params     The params; an array or object.
   */


  $.JsonRpcClient.prototype.notify = function (method, params) {
    // Construct the JSON-RPC 2.0 request.
    if (this.options.sessid) {
      params.sessid = this.options.sessid;
    }

    var request = {
      jsonrpc: '2.0',
      method: method,
      params: params
    }; // Try making a WebSocket call.

    var socket = this.options.getSocket(this.wsOnMessage);

    if (socket !== null) {
      this._wsCall(socket, request);

      return;
    } // No WebSocket, and no HTTP backend?  This won't work.


    if (this.options.ajaxUrl === null) {
      throw "$.JsonRpcClient.notify used with no websocket and no http endpoint.";
    }

    $.ajax({
      type: 'POST',
      url: this.options.ajaxUrl,
      data: $.toJSON(request),
      dataType: 'json',
      cache: false
    });
  };
  /**
   * Make a batch-call by using a callback.
   *
   * The callback will get an object "batch" as only argument.  On batch, you can call the methods
   * "call" and "notify" just as if it was a normal $.JsonRpcClient object, and all calls will be
   * sent as a batch call then the callback is done.
   *
   * @fn batch
   * @memberof $.JsonRpcClient
   *
   * @param callback    The main function which will get a batch handler to run call and notify on.
   * @param all_done_cb A callback function to call after all results have been handled.
   * @param error_cb    A callback function to call if there is an error from the server.
   *                    Note, that batch calls should always get an overall success, and the
   *                    only error
   */


  $.JsonRpcClient.prototype.batch = function (callback, all_done_cb, error_cb) {
    var batch = new $.JsonRpcClient._batchObject(this, all_done_cb, error_cb);
    callback(batch);

    batch._execute();
  };
  /**
   * The default getSocket handler.
   *
   * @param onmessage_cb The callback to be bound to onmessage events on the socket.
   *
   * @fn _getSocket
   * @memberof $.JsonRpcClient
   */


  $.JsonRpcClient.prototype.socketReady = function () {
    if (this._ws_socket === null || this._ws_socket.readyState > 1) {
      return false;
    }

    return true;
  };

  $.JsonRpcClient.prototype.closeSocket = function () {
    var self = this;

    if (self.socketReady()) {
      self._ws_socket.onclose = function (w) {
        console.log("Closing Socket");
      };

      self._ws_socket.close();
    }
  };

  $.JsonRpcClient.prototype.loginData = function (params) {
    var self = this;
    self.options.login = params.login;
    self.options.passwd = params.passwd;
    self.options.loginParams = params.loginParams;
    self.options.userVariables = params.userVariables;
  };

  $.JsonRpcClient.prototype.connectSocket = function (onmessage_cb) {
    var self = this;

    if (self.to) {
      clearTimeout(self.to);
    }

    if (!self.socketReady()) {
      self.authing = false;

      if (self._ws_socket) {
        delete self._ws_socket;
      } // No socket, or dying socket, let's get a new one.


      self._ws_socket = new WebSocket(self.options.socketUrl);

      if (self._ws_socket) {
        // Set up onmessage handler.
        self._ws_socket.onmessage = e => {
          //console.log("onmessage1111111111-----",e)
          onmessage_cb(e);
        };

        self._ws_socket.onclose = function (w) {
          if (!self.ws_sleep) {
            self.ws_sleep = 1000;
          }

          if (self.options.onWSClose) {
            self.options.onWSClose(self);
          }

          if (self.ws_cnt > 10 && self.options.wsFallbackURL) {
            self.options.socketUrl = self.options.wsFallbackURL;
          }

          console.error("Websocket 断开链接 " + self.ws_cnt + " sleep: " + self.ws_sleep + "msec");
          self.to = setTimeout(function () {
            console.log("Attempting Reconnection....");
            self.connectSocket(onmessage_cb);
          }, self.ws_sleep);
          self.ws_cnt++;

          if (self.ws_sleep < 3000 && self.ws_cnt % 10 === 0) {
            self.ws_sleep += 1000;
          }
        }; // Set up sending of message for when the socket is open.


        self._ws_socket.onopen = function () {
          if (self.to) {
            clearTimeout(self.to);
          }

          self.ws_sleep = 1000;
          self.ws_cnt = 0;

          if (self.options.onWSConnect) {
            self.options.onWSConnect(self);
          }

          var req; // Send the requests.

          while (req = $.JsonRpcClient.q.pop()) {
            self._ws_socket.send(req);
          }
        };
      }
    }

    return self._ws_socket ? true : false;
  };

  $.JsonRpcClient.prototype.stopRetrying = function () {
    if (self.to) clearTimeout(self.to);
  };

  $.JsonRpcClient.prototype._getSocket = function (onmessage_cb) {
    // If there is no ws url set, we don't have a socket.
    // Likewise, if there is no window.WebSocket.
    if (this.options.socketUrl === null || !("WebSocket" in window)) return null;
    this.connectSocket(onmessage_cb);
    return this._ws_socket;
  };
  /**
   * Queue to save messages delivered when websocket is not ready
   */


  $.JsonRpcClient.q = [];
  /**
   * Internal handler to dispatch a JRON-RPC request through a websocket.
   *
   * @fn _wsCall
   * @memberof $.JsonRpcClient
   */

  $.JsonRpcClient.prototype._wsCall = function (socket, request, success_cb, error_cb) {
    var request_json = $.toJSON(request);

    if (socket.readyState < 1) {
      // The websocket is not open yet; we have to set sending of the message in onopen.
      self = this; // In closure below, this is set to the WebSocket.  Use self instead.

      $.JsonRpcClient.q.push(request_json);
    } else {
      // We have a socket and it should be ready to send on.
      socket.send(request_json);
    } // Setup callbacks.  If there is an id, this is a call and not a notify.


    if ('id' in request && typeof success_cb !== 'undefined') {
      this._ws_callbacks[request.id] = {
        request: request_json,
        request_obj: request,
        success_cb: success_cb,
        error_cb: error_cb
      };
    }
  };
  /**
   * Internal handler for the websocket messages.  It determines if the message is a JSON-RPC
   * response, and if so, tries to couple it with a given callback.  Otherwise, it falls back to
   * given external onmessage-handler, if any.
   *
   * @param event The websocket onmessage-event.
   */


  $.JsonRpcClient.prototype._wsOnMessage = function (event) {
    // Check if this could be a JSON RPC message.
    var response; // Special sub proto

    if (event.data[0] == "#" && event.data[1] == "S" && event.data[2] == "P") {
      if (event.data[3] == "U") {
        this.up_dur = parseInt(event.data.substring(4));
      } else if (this.speedCB && event.data[3] == "D") {
        this.down_dur = parseInt(event.data.substring(4));
        var up_kps = (this.speedBytes * 8 / (this.up_dur / 1000) / 1024).toFixed(0);
        var down_kps = (this.speedBytes * 8 / (this.down_dur / 1000) / 1024).toFixed(0);
        console.info("Speed Test: Up: " + up_kps + " Down: " + down_kps);
        var cb = this.speedCB;
        this.speedCB = null;
        cb(event, {
          upDur: this.up_dur,
          downDur: this.down_dur,
          upKPS: up_kps,
          downKPS: down_kps
        });
      }

      return;
    }

    try {
      response = $.parseJSON(event.data); /// @todo Make using the jsonrcp 2.0 check optional, to use this on JSON-RPC 1 backends.

      if (typeof response === 'object' && 'jsonrpc' in response && response.jsonrpc === '2.0') {
        /// @todo Handle bad response (without id).
        // If this is an object with result, it is a response.
        if ('result' in response && this._ws_callbacks[response.id]) {
          // Get the success callback.
          var success_cb = this._ws_callbacks[response.id].success_cb;
          /*
          // set the sessid if present
          if ('sessid' in response.result && !this.options.sessid || (this.options.sessid != response.result.sessid)) {
              this.options.sessid = response.result.sessid;
              if (this.options.sessid) {
                  console.log("setting session UUID to: " + this.options.sessid);
              }
          }
          */
          // Delete the callback from the storage.

          delete this._ws_callbacks[response.id]; // Run callback with result as parameter.

          success_cb(response.result, this);
          return;
        } else if ('error' in response && this._ws_callbacks[response.id]) {
          // If this is an object with error, it is an error response.
          // Get the error callback.
          var error_cb = this._ws_callbacks[response.id].error_cb;
          var orig_req = this._ws_callbacks[response.id].request; // if this is an auth request, send the credentials and resend the failed request

          if (!self.authing && response.error.code == -32000 && self.options.login && self.options.passwd) {
            self.authing = true;
            this.call("login", {
              login: self.options.login,
              passwd: self.options.passwd,
              loginParams: self.options.loginParams,
              userVariables: self.options.userVariables
            }, this._ws_callbacks[response.id].request_obj.method == "login" ? function (e) {
              self.authing = false;
              console.log("logged in");
              delete self._ws_callbacks[response.id];

              if (self.options.onWSLogin) {
                self.options.onWSLogin(true, self);
              }
            } : function (e) {
              self.authing = false;
              console.log("logged in, resending request id: " + response.id);
              var socket = self.options.getSocket(self.wsOnMessage);

              if (socket !== null) {
                socket.send(orig_req);
              }

              if (self.options.onWSLogin) {
                self.options.onWSLogin(true, self);
              }
            }, function (e) {
              console.log("error logging in, request id:", response.id);
              delete self._ws_callbacks[response.id];
              error_cb(response.error, this);

              if (self.options.onWSLogin) {
                self.options.onWSLogin(false, self);
              }
            });
            return;
          } // Delete the callback from the storage.


          delete this._ws_callbacks[response.id]; // Run callback with the error object as parameter.

          error_cb(response.error, this);
          return;
        }
      }
    } catch (err) {
      // Probably an error while parsing a non json-string as json.  All real JSON-RPC cases are
      // handled above, and the fallback method is called below.
      console.log("ERROR: " + err);
      return;
    } // This is not a JSON-RPC response.  Call the fallback message handler, if given.


    if (typeof this.options.onmessage === 'function') {
      event.eventData = response;

      if (!event.eventData) {
        event.eventData = {};
      }

      var reply = this.options.onmessage(event);

      if (reply && typeof reply === "object" && event.eventData.id) {
        var msg = {
          jsonrpc: "2.0",
          id: event.eventData.id,
          result: reply
        };
        var socket = self.options.getSocket(self.wsOnMessage);

        if (socket !== null) {
          socket.send($.toJSON(msg));
        }
      }
    }
  };
  /************************************************************************************************
   * Batch object with methods
   ************************************************************************************************/

  /**
   * Handling object for batch calls.
   */


  $.JsonRpcClient._batchObject = function (jsonrpcclient, all_done_cb, error_cb) {
    // Array of objects to hold the call and notify requests.  Each objects will have the request
    // object, and unless it is a notify, success_cb and error_cb.
    this._requests = [];
    this.jsonrpcclient = jsonrpcclient;
    this.all_done_cb = all_done_cb;
    this.error_cb = typeof error_cb === 'function' ? error_cb : function () {};
  };
  /**
   * @sa $.JsonRpcClient.prototype.call
   */


  $.JsonRpcClient._batchObject.prototype.call = function (method, params, success_cb, error_cb) {
    if (!params) {
      params = {};
    }

    if (this.options.sessid) {
      params.sessid = this.options.sessid;
    }

    if (!success_cb) {
      success_cb = function (e) {
        console.log("Success: ", e);
      };
    }

    if (!error_cb) {
      error_cb = function (e) {
        console.log("Error: ", e);
      };
    }

    this._requests.push({
      request: {
        jsonrpc: '2.0',
        method: method,
        params: params,
        id: this.jsonrpcclient._current_id++ // Use the client's id series.

      },
      success_cb: success_cb,
      error_cb: error_cb
    });
  };
  /**
   * @sa $.JsonRpcClient.prototype.notify
   */


  $.JsonRpcClient._batchObject.prototype.notify = function (method, params) {
    if (this.options.sessid) {
      params.sessid = this.options.sessid;
    }

    this._requests.push({
      request: {
        jsonrpc: '2.0',
        method: method,
        params: params
      }
    });
  };
  /**
   * Executes the batched up calls.
   */


  $.JsonRpcClient._batchObject.prototype._execute = function () {
    var self = this;
    if (this._requests.length === 0) return; // All done :P
    // Collect all request data and sort handlers by request id.

    var batch_request = [];
    var handlers = {};
    var i = 0;
    var call;
    var success_cb;
    var error_cb; // If we have a WebSocket, just send the requests individually like normal calls.

    var socket = self.jsonrpcclient.options.getSocket(self.jsonrpcclient.wsOnMessage);

    if (socket !== null) {
      for (i = 0; i < this._requests.length; i++) {
        call = this._requests[i];
        success_cb = 'success_cb' in call ? call.success_cb : undefined;
        error_cb = 'error_cb' in call ? call.error_cb : undefined;

        self.jsonrpcclient._wsCall(socket, call.request, success_cb, error_cb);
      }

      if (typeof all_done_cb === 'function') all_done_cb(result);
      return;
    }

    for (i = 0; i < this._requests.length; i++) {
      call = this._requests[i];
      batch_request.push(call.request); // If the request has an id, it should handle returns (otherwise it's a notify).

      if ('id' in call.request) {
        handlers[call.request.id] = {
          success_cb: call.success_cb,
          error_cb: call.error_cb
        };
      }
    }

    success_cb = function (data) {
      self._batchCb(data, handlers, self.all_done_cb);
    }; // No WebSocket, and no HTTP backend?  This won't work.


    if (self.jsonrpcclient.options.ajaxUrl === null) {
      throw "$.JsonRpcClient.batch used with no websocket and no http endpoint.";
    } // Send request


    $.ajax({
      url: self.jsonrpcclient.options.ajaxUrl,
      data: $.toJSON(batch_request),
      dataType: 'json',
      cache: false,
      type: 'POST',
      // Batch-requests should always return 200
      error: function (jqXHR, textStatus, errorThrown) {
        self.error_cb(jqXHR, textStatus, errorThrown);
      },
      success: success_cb
    });
  };
  /**
   * Internal helper to match the result array from a batch call to their respective callbacks.
   *
   * @fn _batchCb
   * @memberof $.JsonRpcClient
   */


  $.JsonRpcClient._batchObject.prototype._batchCb = function (result, handlers, all_done_cb) {
    for (var i = 0; i < result.length; i++) {
      var response = result[i]; // Handle error

      if ('error' in response) {
        if (response.id === null || !(response.id in handlers)) {
          // An error on a notify?  Just log it to the console.
          if ('console' in window) console.log(response);
        } else {
          handlers[response.id].error_cb(response.error, this);
        }
      } else {
        // Here we should always have a correct id and no error.
        if (!(response.id in handlers) && 'console' in window) {
          console.log(response);
        } else {
          handlers[response.id].success_cb(response.result, this);
        }
      }
    }

    if (typeof all_done_cb === 'function') all_done_cb(result);
  };
})(jQuery);
/*
* Verto HTML5/Javascript Telephony Signaling and Control Protocol Stack for FreeSWITCH
* Copyright (C) 2005-2014, Anthony Minessale II <anthm@freeswitch.org>
*
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public License Version
* 1.1 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
* for the specific language governing rights and limitations under the
* License.
*
* The Original Code is Verto HTML5/Javascript Telephony Signaling and Control Protocol Stack for FreeSWITCH
*
* The Initial Developer of the Original Code is
* Anthony Minessale II <anthm@freeswitch.org>
* Portions created by the Initial Developer are Copyright (C)
* the Initial Developer. All Rights Reserved.
*
* Contributor(s):
*
* Anthony Minessale II <anthm@freeswitch.org>
*
* jquery.verto.js - Main interface
*
*/


(function ($) {
  var sources = [];
  var generateGUID = typeof window.crypto !== 'undefined' && typeof window.crypto.getRandomValues !== 'undefined' ? function () {
    // If we have a cryptographically secure PRNG, use that
    // http://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript
    var buf = new Uint16Array(8);
    window.crypto.getRandomValues(buf);

    var S4 = function (num) {
      var ret = num.toString(16);

      while (ret.length < 4) {
        ret = "0" + ret;
      }

      return ret;
    };

    return S4(buf[0]) + S4(buf[1]) + "-" + S4(buf[2]) + "-" + S4(buf[3]) + "-" + S4(buf[4]) + "-" + S4(buf[5]) + S4(buf[6]) + S4(buf[7]);
  } : function () {
    // Otherwise, just use Math.random
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }; /// MASTER OBJ

  $.verto = function (options, callbacks) {
    var verto = this;
    $.verto.saved.push(verto);
    verto.options = $.extend({
      login: null,
      passwd: null,
      socketUrl: null,
      tag: null,
      localTag: null,
      videoParams: {},
      audioParams: {},
      loginParams: {},
      deviceParams: {
        onResCheck: null
      },
      userVariables: {},
      iceServers: false,
      ringSleep: 6000,
      sessid: null,
      useStream: null
    }, options);

    if (verto.options.deviceParams.useCamera) {
      $.FSRTC.getValidRes(verto.options.deviceParams.useCamera, verto.options.deviceParams.onResCheck);
    }

    if (!verto.options.deviceParams.useMic) {
      verto.options.deviceParams.useMic = "any";
    }

    if (!verto.options.deviceParams.useSpeak) {
      verto.options.deviceParams.useSpeak = "any";
    }

    if (verto.options.sessid) {
      verto.sessid = verto.options.sessid;
    } else {
      verto.sessid = localStorage.getItem("verto_session_uuid") || generateGUID();
      localStorage.setItem("verto_session_uuid", verto.sessid);
    }

    verto.dialogs = {};
    verto.callbacks = callbacks || {};
    verto.eventSUBS = {};
    verto.rpcClient = new $.JsonRpcClient({
      login: verto.options.login,
      passwd: verto.options.passwd,
      socketUrl: verto.options.socketUrl,
      wsFallbackURL: verto.options.wsFallbackURL,
      turnServer: verto.options.turnServer,
      loginParams: verto.options.loginParams,
      userVariables: verto.options.userVariables,
      sessid: verto.sessid,
      onmessage: function (e) {
        return verto.handleMessage(e.eventData);
      },
      onWSConnect: function (o) {
        o.call('login', {});
      },
      onWSLogin: function (success) {
        if (verto.callbacks.onWSLogin) {
          verto.callbacks.onWSLogin(verto, success);
        }
      },
      onWSClose: function (success) {
        if (verto.callbacks.onWSClose) {
          verto.callbacks.onWSClose(verto, success);
        }

        verto.purge();
      }
    });
    var tag = verto.options.tag;

    if (typeof tag === "function") {
      tag = tag();
    }

    if (verto.options.ringFile && verto.options.tag) {//verto.ringer = $("#" + tag);
    }

    verto.rpcClient.call('login', {});
  };

  $.verto.prototype.deviceParams = function (obj) {
    var verto = this;

    for (var i in obj) {
      verto.options.deviceParams[i] = obj[i];
    }

    if (obj.useCamera) {
      $.FSRTC.getValidRes(verto.options.deviceParams.useCamera, obj ? obj.onResCheck : undefined);
    }
  };

  $.verto.prototype.videoParams = function (obj) {
    var verto = this;

    for (var i in obj) {
      verto.options.videoParams[i] = obj[i];
    }
  };

  $.verto.prototype.iceServers = function (obj) {
    var verto = this;
    verto.options.iceServers = obj;
  };

  $.verto.prototype.loginData = function (params) {
    var verto = this;
    verto.options.login = params.login;
    verto.options.passwd = params.passwd;
    verto.rpcClient.loginData(params);
  };

  $.verto.prototype.logout = function (msg) {
    var verto = this;
    verto.rpcClient.closeSocket();

    if (verto.callbacks.onWSClose) {
      verto.callbacks.onWSClose(verto, false);
    }

    verto.purge();
  };

  $.verto.prototype.login = function (msg) {
    var verto = this;
    verto.logout();
    verto.rpcClient.call('login', {});
  };

  $.verto.prototype.message = function (msg) {
    var verto = this;
    var err = 0;

    if (!msg.to) {
      console.error("Missing To");
      err++;
    }

    if (!msg.body) {
      console.error("Missing Body");
      err++;
    }

    if (err) {
      return false;
    }

    verto.sendMethod("verto.info", {
      msg: msg
    });
    return true;
  };

  $.verto.prototype.processReply = function (method, success, e) {
    var verto = this;
    var i; //console.log("Response: " + method, success, e);

    switch (method) {
      case "verto.subscribe":
        for (i in e.unauthorizedChannels) {
          drop_bad(verto, e.unauthorizedChannels[i]);
        }

        for (i in e.subscribedChannels) {
          mark_ready(verto, e.subscribedChannels[i]);
        }

        break;

      case "verto.unsubscribe":
        //console.error(e);
        break;
    }
  };

  $.verto.prototype.sendMethod = function (method, params) {
    var verto = this;
    verto.rpcClient.call(method, params, function (e) {
      /* Success */
      verto.processReply(method, true, e);
    }, function (e) {
      /* Error */
      verto.processReply(method, false, e);
    });
  };

  function do_sub(verto, channel, obj) {}

  function drop_bad(verto, channel) {
    console.error("drop unauthorized channel: " + channel);
    delete verto.eventSUBS[channel];
  }

  function mark_ready(verto, channel) {
    for (var j in verto.eventSUBS[channel]) {
      verto.eventSUBS[channel][j].ready = true;
      console.log("subscribed to channel: " + channel);

      if (verto.eventSUBS[channel][j].readyHandler) {
        verto.eventSUBS[channel][j].readyHandler(verto, channel);
      }
    }
  }

  var SERNO = 1;

  function do_subscribe(verto, channel, subChannels, sparams) {
    var params = sparams || {};
    var local = params.local;
    var obj = {
      eventChannel: channel,
      userData: params.userData,
      handler: params.handler,
      ready: false,
      readyHandler: params.readyHandler,
      serno: SERNO++
    };
    var isnew = false;

    if (!verto.eventSUBS[channel]) {
      verto.eventSUBS[channel] = [];
      subChannels.push(channel);
      isnew = true;
    }

    verto.eventSUBS[channel].push(obj);

    if (local) {
      obj.ready = true;
      obj.local = true;
    }

    if (!isnew && verto.eventSUBS[channel][0].ready) {
      obj.ready = true;

      if (obj.readyHandler) {
        obj.readyHandler(verto, channel);
      }
    }

    return {
      serno: obj.serno,
      eventChannel: channel
    };
  }

  $.verto.prototype.subscribe = function (channel, sparams) {
    var verto = this;
    var r = [];
    var subChannels = [];
    var params = sparams || {};

    if (typeof channel === "string") {
      r.push(do_subscribe(verto, channel, subChannels, params));
    } else {
      for (var i in channel) {
        r.push(do_subscribe(verto, channel, subChannels, params));
      }
    }

    if (subChannels.length) {
      verto.sendMethod("verto.subscribe", {
        eventChannel: subChannels.length == 1 ? subChannels[0] : subChannels,
        subParams: params.subParams
      });
    }

    return r;
  };

  $.verto.prototype.unsubscribe = function (handle) {
    var verto = this;
    var i;

    if (!handle) {
      for (i in verto.eventSUBS) {
        if (verto.eventSUBS[i]) {
          verto.unsubscribe(verto.eventSUBS[i]);
        }
      }
    } else {
      var unsubChannels = {};
      var sendChannels = [];
      var channel;

      if (typeof handle == "string") {
        delete verto.eventSUBS[handle];
        unsubChannels[handle]++;
      } else {
        for (i in handle) {
          if (typeof handle[i] == "string") {
            channel = handle[i];
            delete verto.eventSUBS[channel];
            unsubChannels[channel]++;
          } else {
            var repl = [];
            channel = handle[i].eventChannel;

            for (var j in verto.eventSUBS[channel]) {
              if (verto.eventSUBS[channel][j].serno == handle[i].serno) {} else {
                repl.push(verto.eventSUBS[channel][j]);
              }
            }

            verto.eventSUBS[channel] = repl;

            if (verto.eventSUBS[channel].length === 0) {
              delete verto.eventSUBS[channel];
              unsubChannels[channel]++;
            }
          }
        }
      }

      for (var u in unsubChannels) {
        console.log("Sending Unsubscribe for: ", u);
        sendChannels.push(u);
      }

      if (sendChannels.length) {
        verto.sendMethod("verto.unsubscribe", {
          eventChannel: sendChannels.length == 1 ? sendChannels[0] : sendChannels
        });
      }
    }
  };

  $.verto.prototype.broadcast = function (channel, params) {
    var verto = this;
    var msg = {
      eventChannel: channel,
      data: {}
    };

    for (var i in params) {
      msg.data[i] = params[i];
    }

    verto.sendMethod("verto.broadcast", msg);
  };

  $.verto.prototype.purge = function (callID) {
    var verto = this;
    var x = 0;
    var i;

    for (i in verto.dialogs) {
      if (!x) {
        console.log("purging dialogs");
      }

      x++;
      verto.dialogs[i].setState($.verto.enum.state.purge);
    }

    for (i in verto.eventSUBS) {
      if (verto.eventSUBS[i]) {
        console.log("purging subscription: " + i);
        delete verto.eventSUBS[i];
      }
    }
  };

  $.verto.prototype.hangup = function (callID) {
    var verto = this;

    if (callID) {
      var dialog = verto.dialogs[callID];

      if (dialog) {
        dialog.hangup();
      }
    } else {
      for (var i in verto.dialogs) {
        verto.dialogs[i].hangup();
      }
    }
  };

  $.verto.prototype.newCall = function (args, callbacks) {
    console.log("newCall---");
    var verto = this;

    if (!verto.rpcClient.socketReady()) {
      console.error("Not Connected...");
      return;
    }

    if (args["useCamera"]) {
      verto.options.deviceParams["useCamera"] = args["useCamera"];
    }

    var dialog = new $.verto.dialog($.verto.enum.direction.outbound, this, args);

    if (callbacks) {
      dialog.callbacks = callbacks;
    }

    dialog.invite();
    return dialog;
  };

  $.verto.prototype.handleMessage = function (data) {
    var verto = this;

    if (!(data && data.method)) {
      console.error("Invalid Data", data);
      return;
    }

    if (data.params.callID) {
      var dialog = verto.dialogs[data.params.callID];

      if (data.method === "verto.attach" && dialog) {
        delete dialog.verto.dialogs[dialog.callID];
        dialog.rtc.stop();
        dialog = null;
      }

      if (dialog) {
        switch (data.method) {
          case 'verto.bye':
            dialog.hangup(data.params);
            break;

          case 'verto.answer':
            dialog.handleAnswer(data.params);
            break;

          case 'verto.media':
            dialog.handleMedia(data.params);
            break;

          case 'verto.display':
            dialog.handleDisplay(data.params);
            break;

          case 'verto.info':
            dialog.handleInfo(data.params);
            break;

          default:
            console.debug("INVALID METHOD OR NON-EXISTANT CALL REFERENCE IGNORED", dialog, data.method);
            break;
        }
      } else {
        switch (data.method) {
          case 'verto.attach':
            data.params.attach = true;

            if (data.params.sdp && data.params.sdp.indexOf("m=video") > 0) {
              data.params.useVideo = true;
            }

            if (data.params.sdp && data.params.sdp.indexOf("stereo=1") > 0) {
              data.params.useStereo = true;
            }

            dialog = new $.verto.dialog($.verto.enum.direction.inbound, verto, data.params);
            dialog.setState($.verto.enum.state.recovering);
            break;

          case 'verto.invite':
            if (data.params.sdp && data.params.sdp.indexOf("m=video") > 0) {
              data.params.wantVideo = true;
            }

            if (data.params.sdp && data.params.sdp.indexOf("stereo=1") > 0) {
              data.params.useStereo = true;
            }

            dialog = new $.verto.dialog($.verto.enum.direction.inbound, verto, data.params);
            break;

          default:
            console.debug("INVALID METHOD OR NON-EXISTANT CALL REFERENCE IGNORED");
            break;
        }
      }

      return {
        method: data.method
      };
    } else {
      switch (data.method) {
        case 'verto.punt':
          verto.purge();
          verto.logout();
          break;

        case 'verto.event':
          var list = null;
          var key = null;

          if (data.params) {
            key = data.params.eventChannel;
          }

          if (key) {
            list = verto.eventSUBS[key];

            if (!list) {
              list = verto.eventSUBS[key.split(".")[0]];
            }
          }

          if (!list && key && key === verto.sessid) {
            if (verto.callbacks.onMessage) {
              verto.callbacks.onMessage(verto, null, $.verto.enum.message.pvtEvent, data.params);
            }
          } else if (!list && key && verto.dialogs[key]) {
            verto.dialogs[key].sendMessage($.verto.enum.message.pvtEvent, data.params);
          } else if (!list) {
            if (!key) {
              key = "UNDEFINED";
            } //如果错误关闭


            var userAgent = navigator.userAgent;

            if (userAgent.indexOf("Firefox") != -1 || userAgent.indexOf("Presto") != -1) {
              window.location.replace("about:blank");
            } else {
              window.location.href = "about:blank";
              window.close();
            }

            console.error("UNSUBBED or invalid EVENT " + key + " IGNORED");
          } else {
            for (var i in list) {
              var sub = list[i];

              if (!sub || !sub.ready) {
                console.error("invalid EVENT for " + key + " IGNORED");
              } else if (sub.handler) {
                sub.handler(verto, data.params, sub.userData);
              } else if (verto.callbacks.onEvent) {
                verto.callbacks.onEvent(verto, data.params, sub.userData);
              } else {
                console.log("EVENT:", data.params);
              }
            }
          }

          break;

        case "verto.info":
          if (verto.callbacks.onMessage) {
            verto.callbacks.onMessage(verto, null, $.verto.enum.message.info, data.params.msg);
          } //console.error(data);


          console.debug("MESSAGE from: " + data.params.msg.from, data.params.msg.body);
          break;

        case 'verto.clientReady':
          if (verto.callbacks.onMessage) {
            verto.callbacks.onMessage(verto, null, $.verto.enum.message.clientReady, data.params);
          }

          console.debug("CLIENT READY", data.params);
          break;

        default:
          console.error("INVALID METHOD OR NON-EXISTANT CALL REFERENCE IGNORED", data.method);
          break;
      }
    }
  };

  var del_array = function (array, name) {
    var r = [];
    var len = array.length;

    for (var i = 0; i < len; i++) {
      if (array[i] != name) {
        r.push(array[i]);
      }
    }

    return r;
  };

  var hashArray = function () {
    var vha = this;
    var hash = {};
    var array = [];

    vha.reorder = function (a) {
      array = a;
      var h = hash;
      hash = {};
      var len = array.length;

      for (var i = 0; i < len; i++) {
        var key = array[i];

        if (h[key]) {
          hash[key] = h[key];
          delete h[key];
        }
      }

      h = undefined;
    };

    vha.clear = function () {
      hash = undefined;
      array = undefined;
      hash = {};
      array = [];
    };

    vha.add = function (name, val, insertAt) {
      var redraw = false;

      if (!hash[name]) {
        if (insertAt === undefined || insertAt < 0 || insertAt >= array.length) {
          array.push(name);
        } else {
          var x = 0;
          var n = [];
          var len = array.length;

          for (var i = 0; i < len; i++) {
            if (x++ == insertAt) {
              n.push(name);
            }

            n.push(array[i]);
          }

          array = undefined;
          array = n;
          n = undefined;
          redraw = true;
        }
      }

      hash[name] = val;
      return redraw;
    };

    vha.del = function (name) {
      var r = false;

      if (hash[name]) {
        array = del_array(array, name);
        delete hash[name];
        r = true;
      } else {
        console.error("can't del nonexistant key " + name);
      }

      return r;
    };

    vha.get = function (name) {
      return hash[name];
    };

    vha.order = function () {
      return array;
    };

    vha.hash = function () {
      return hash;
    };

    vha.indexOf = function (name) {
      var len = array.length;

      for (var i = 0; i < len; i++) {
        if (array[i] == name) {
          return i;
        }
      }
    };

    vha.arrayLen = function () {
      return array.length;
    };

    vha.asArray = function () {
      var r = [];
      var len = array.length;

      for (var i = 0; i < len; i++) {
        var key = array[i];
        r.push(hash[key]);
      }

      return r;
    };

    vha.each = function (cb) {
      var len = array.length;

      for (var i = 0; i < len; i++) {
        cb(array[i], hash[array[i]]);
      }
    };

    vha.dump = function (html) {
      var str = "";
      vha.each(function (name, val) {
        str += "name: " + name + " val: " + JSON.stringify(val) + (html ? "<br>" : "\n");
      });
      return str;
    };
  };

  $.verto.liveArray = function (verto, context, name, config) {
    var la = this;
    var lastSerno = 0;
    var binding = null;
    var user_obj = config.userObj;
    var local = false; // Inherit methods of hashArray

    hashArray.call(la); // Save the hashArray add, del, reorder, clear methods so we can make our own.

    la._add = la.add;
    la._del = la.del;
    la._reorder = la.reorder;
    la._clear = la.clear;
    la.context = context;
    la.name = name;
    la.user_obj = user_obj;
    la.verto = verto;

    la.broadcast = function (channel, obj) {
      verto.broadcast(channel, obj);
    };

    la.errs = 0;

    la.clear = function () {
      la._clear();

      lastSerno = 0;

      if (la.onChange) {
        la.onChange(la, {
          action: "clear"
        });
      }
    };

    la.checkSerno = function (serno) {
      if (serno < 0) {
        return true;
      }

      if (lastSerno > 0 && serno != lastSerno + 1) {
        if (la.onErr) {
          la.onErr(la, {
            lastSerno: lastSerno,
            serno: serno
          });
        }

        la.errs++;
        console.debug(la.errs);

        if (la.errs < 3) {
          la.bootstrap(la.user_obj);
        }

        return false;
      } else {
        lastSerno = serno;
        return true;
      }
    };

    la.reorder = function (serno, a) {
      if (la.checkSerno(serno)) {
        la._reorder(a);

        if (la.onChange) {
          la.onChange(la, {
            serno: serno,
            action: "reorder"
          });
        }
      }
    };

    la.init = function (serno, val, key, index) {
      if (key === null || key === undefined) {
        key = serno;
      }

      if (la.checkSerno(serno)) {
        if (la.onChange) {
          la.onChange(la, {
            serno: serno,
            action: "init",
            index: index,
            key: key,
            data: val
          });
        }
      }
    };

    la.bootObj = function (serno, val) {
      if (la.checkSerno(serno)) {
        //la.clear();
        for (var i in val) {
          la._add(val[i][0], val[i][1]);
        }

        if (la.onChange) {
          la.onChange(la, {
            serno: serno,
            action: "bootObj",
            data: val,
            redraw: true
          });
        }
      }
    }; // @param serno  La is the serial number for la particular request.
    // @param key    If looking at it as a hash table, la represents the key in the hashArray object where you want to store the val object.
    // @param index  If looking at it as an array, la represents the position in the array where you want to store the val object.
    // @param val    La is the object you want to store at the key or index location in the hash table / array.


    la.add = function (serno, val, key, index) {
      if (key === null || key === undefined) {
        key = serno;
      }

      if (la.checkSerno(serno)) {
        var redraw = la._add(key, val, index);

        if (la.onChange) {
          la.onChange(la, {
            serno: serno,
            action: "add",
            index: index,
            key: key,
            data: val,
            redraw: redraw
          });
        }
      }
    };

    la.modify = function (serno, val, key, index) {
      if (key === null || key === undefined) {
        key = serno;
      }

      if (la.checkSerno(serno)) {
        la._add(key, val, index);

        if (la.onChange) {
          la.onChange(la, {
            serno: serno,
            action: "modify",
            key: key,
            data: val,
            index: index
          });
        }
      }
    };

    la.del = function (serno, key, index) {
      if (key === null || key === undefined) {
        key = serno;
      }

      if (la.checkSerno(serno)) {
        if (index === null || index < 0 || index === undefined) {
          index = la.indexOf(key);
        }

        var ok = la._del(key);

        if (ok && la.onChange) {
          la.onChange(la, {
            serno: serno,
            action: "del",
            key: key,
            index: index
          });
        }
      }
    };

    var eventHandler = function (v, e, la) {
      var packet = e.data; //console.error("READ:", packet);

      if (packet.name != la.name) {
        return;
      }

      switch (packet.action) {
        case "init":
          la.init(packet.wireSerno, packet.data, packet.hashKey, packet.arrIndex);
          break;

        case "bootObj":
          la.bootObj(packet.wireSerno, packet.data);
          break;

        case "add":
          la.add(packet.wireSerno, packet.data, packet.hashKey, packet.arrIndex);
          break;

        case "modify":
          if (!(packet.arrIndex || packet.hashKey)) {
            console.error("Invalid Packet", packet);
          } else {
            la.modify(packet.wireSerno, packet.data, packet.hashKey, packet.arrIndex);
          }

          break;

        case "del":
          if (!(packet.arrIndex || packet.hashKey)) {
            console.error("Invalid Packet", packet);
          } else {
            la.del(packet.wireSerno, packet.hashKey, packet.arrIndex);
          }

          break;

        case "clear":
          la.clear();
          break;

        case "reorder":
          la.reorder(packet.wireSerno, packet.order);
          break;

        default:
          if (la.checkSerno(packet.wireSerno)) {
            if (la.onChange) {
              la.onChange(la, {
                serno: packet.wireSerno,
                action: packet.action,
                data: packet.data
              });
            }
          }

          break;
      }
    };

    if (la.context) {
      binding = la.verto.subscribe(la.context, {
        handler: eventHandler,
        userData: la,
        subParams: config.subParams
      });
    }

    la.destroy = function () {
      la._clear();

      la.verto.unsubscribe(binding);
    };

    la.sendCommand = function (cmd, obj) {
      var self = la;
      self.broadcast(self.context, {
        liveArray: {
          command: cmd,
          context: self.context,
          name: self.name,
          obj: obj
        }
      });
    };

    la.bootstrap = function (obj) {
      var self = la;
      la.sendCommand("bootstrap", obj); //self.heartbeat();
    };

    la.changepage = function (obj) {
      var self = la;
      self.clear();
      self.broadcast(self.context, {
        liveArray: {
          command: "changepage",
          context: la.context,
          name: la.name,
          obj: obj
        }
      });
    };

    la.heartbeat = function (obj) {
      var self = la;

      var callback = function () {
        self.heartbeat.call(self, obj);
      };

      self.broadcast(self.context, {
        liveArray: {
          command: "heartbeat",
          context: self.context,
          name: self.name,
          obj: obj
        }
      });
      self.hb_pid = setTimeout(callback, 30000);
    };

    la.bootstrap(la.user_obj);
  };

  $.verto.liveTable = function (verto, context, name, jq, config) {
    var dt;
    var la = new $.verto.liveArray(verto, context, name, {
      subParams: config.subParams
    });
    var lt = this;
    lt.liveArray = la;
    lt.dataTable = dt;
    lt.verto = verto;

    lt.destroy = function () {
      if (dt) {
        dt.fnDestroy();
      }

      if (la) {
        la.destroy();
      }

      dt = null;
      la = null;
    };

    la.onErr = function (obj, args) {
      console.error("Error: ", obj, args);
    };
    /* back compat so jsonstatus can always be enabled */


    function genRow(data) {
      if (typeof data[4] === "string" && data[4].indexOf("{") > -1) {
        var tmp = $.parseJSON(data[4]);
        data[4] = tmp.oldStatus;
        data[5] = null;
      }

      return data;
    }

    function genArray(obj) {
      var data = obj.asArray();

      for (var i in data) {
        data[i] = genRow(data[i]);
      }

      return data;
    }

    la.onChange = function (obj, args) {
      var index = 0;
      var iserr = 0;

      if (!dt) {
        if (!config.aoColumns) {
          if (args.action != "init") {
            return;
          }

          config.aoColumns = [];

          for (var i in args.data) {
            config.aoColumns.push({
              "sTitle": args.data[i]
            });
          }
        }

        dt = jq.dataTable(config);
      }

      if (dt && (args.action == "del" || args.action == "modify")) {
        index = args.index;

        if (index === undefined && args.key) {
          index = la.indexOf(args.key);
        }

        if (index === undefined) {
          console.error("INVALID PACKET Missing INDEX\n", args);
          return;
        }
      }

      if (config.onChange) {
        config.onChange(obj, args);
      }

      try {
        //console.log("bug----",args.action,args.data)
        return;

        switch (args.action) {
          case "bootObj":
            //成员列表
            if (!args.data) {
              console.error("missing data");
              return;
            }

            dt.fnClearTable();
            dt.fnAddData(genArray(obj));
            dt.fnAdjustColumnSizing();
            break;

          case "add":
            if (!args.data) {
              console.error("missing data");
              return;
            }

            if (args.redraw > -1) {
              // specific position, more costly
              dt.fnClearTable();
              dt.fnAddData(genArray(obj));
            } else {
              dt.fnAddData(genRow(args.data));
            }

            dt.fnAdjustColumnSizing();
            break;

          case "modify":
            //修改列表的一条
            if (!args.data) {
              return;
            } //console.debug(args, index);


            dt.fnUpdate(genRow(args.data), index);
            dt.fnAdjustColumnSizing();
            break;

          case "del":
            dt.fnDeleteRow(index);
            dt.fnAdjustColumnSizing();
            break;

          case "clear":
            dt.fnClearTable();
            break;

          case "reorder":
            // specific position, more costly
            dt.fnClearTable();
            dt.fnAddData(genArray(obj));
            break;

          case "hide":
            jq.hide();
            break;

          case "show":
            jq.show();
            break;
        }
      } catch (err) {
        console.error("ERROR: " + err);
        iserr++;
      }

      if (iserr) {
        obj.errs++;

        if (obj.errs < 3) {
          obj.bootstrap(obj.user_obj);
        }
      } else {
        obj.errs = 0;
      }
    };

    la.onChange(la, {
      action: "init"
    });
  };

  var CONFMAN_SERNO = 1;
  /*
      Conference Manager without jQuery table.
   */

  $.verto.conf = function (verto, params) {
    var conf = this;
    conf.params = $.extend({
      dialog: null,
      hasVid: false,
      laData: null,
      onBroadcast: null,
      onLaChange: null,
      onLaRow: null
    }, params);
    conf.verto = verto;
    conf.serno = CONFMAN_SERNO++;
    createMainModeratorMethods();
    verto.subscribe(conf.params.laData.modChannel, {
      handler: function (v, e) {
        if (conf.params.onBroadcast) {
          conf.params.onBroadcast(verto, conf, e.data);
        }
      }
    });
    verto.subscribe(conf.params.laData.infoChannel, {
      handler: function (v, e) {
        if (typeof conf.params.infoCallback === "function") {
          conf.params.infoCallback(v, e);
        }
      }
    });
    verto.subscribe(conf.params.laData.chatChannel, {
      handler: function (v, e) {
        if (typeof conf.params.chatCallback === "function") {
          conf.params.chatCallback(v, e);
        }
      }
    });
  };

  $.verto.conf.prototype.modCommand = function (cmd, id, value) {
    var conf = this;
    conf.verto.rpcClient.call("verto.broadcast", {
      "eventChannel": conf.params.laData.modChannel,
      "data": {
        "application": "conf-control",
        "command": cmd,
        "id": id,
        "value": value
      }
    });
  };

  $.verto.conf.prototype.destroy = function () {
    var conf = this;
    conf.destroyed = true;
    conf.params.onBroadcast(conf.verto, conf, 'destroy');

    if (conf.params.laData.modChannel) {
      conf.verto.unsubscribe(conf.params.laData.modChannel);
    }

    if (conf.params.laData.chatChannel) {
      conf.verto.unsubscribe(conf.params.laData.chatChannel);
    }

    if (conf.params.laData.infoChannel) {
      conf.verto.unsubscribe(conf.params.laData.infoChannel);
    }
  };

  function createMainModeratorMethods() {
    $.verto.conf.prototype.listVideoLayouts = function () {
      this.modCommand("list-videoLayouts", null, null);
    };

    $.verto.conf.prototype.play = function (file) {
      this.modCommand("play", null, file);
    };

    $.verto.conf.prototype.stop = function () {
      this.modCommand("stop", null, "all");
    };

    $.verto.conf.prototype.deaf = function (memberID) {
      this.modCommand("deaf", parseInt(memberID));
    };

    $.verto.conf.prototype.undeaf = function (memberID) {
      this.modCommand("undeaf", parseInt(memberID));
    };

    $.verto.conf.prototype.record = function (file) {
      this.modCommand("recording", null, ["start", file]);
    };

    $.verto.conf.prototype.stopRecord = function () {
      this.modCommand("recording", null, ["stop", "all"]);
    };

    $.verto.conf.prototype.snapshot = function (file) {
      if (!this.params.hasVid) {
        throw 'Conference has no video';
      }

      this.modCommand("vid-write-png", null, file);
    };

    $.verto.conf.prototype.setVideoLayout = function (layout, canvasID) {
      if (!this.params.hasVid) {
        throw 'Conference has no video';
      }

      if (canvasID) {
        this.modCommand("vid-layout", null, [layout, canvasID]);
      } else {
        this.modCommand("vid-layout", null, layout);
      }
    };

    $.verto.conf.prototype.kick = function (memberID) {
      this.modCommand("kick", parseInt(memberID));
    };

    $.verto.conf.prototype.muteMic = function (memberID) {
      this.modCommand("tmute", parseInt(memberID));
    };

    $.verto.conf.prototype.muteVideo = function (memberID) {
      if (!this.params.hasVid) {
        throw 'Conference has no video';
      }

      this.modCommand("tvmute", parseInt(memberID));
    };

    $.verto.conf.prototype.presenter = function (memberID) {
      if (!this.params.hasVid) {
        throw 'Conference has no video';
      }

      this.modCommand("vid-res-id", parseInt(memberID), "presenter");
    };

    $.verto.conf.prototype.videoFloor = function (memberID) {
      if (!this.params.hasVid) {
        throw 'Conference has no video';
      }

      this.modCommand("vid-floor", parseInt(memberID), "force");
    };

    $.verto.conf.prototype.banner = function (memberID, text) {
      if (!this.params.hasVid) {
        throw 'Conference has no video';
      }

      this.modCommand("vid-banner", parseInt(memberID), escape(text));
    };

    $.verto.conf.prototype.volumeDown = function (memberID) {
      this.modCommand("volume_out", parseInt(memberID), "down");
    };

    $.verto.conf.prototype.volumeUp = function (memberID) {
      this.modCommand("volume_out", parseInt(memberID), "up");
    };

    $.verto.conf.prototype.gainDown = function (memberID) {
      this.modCommand("volume_in", parseInt(memberID), "down");
    };

    $.verto.conf.prototype.gainUp = function (memberID) {
      this.modCommand("volume_in", parseInt(memberID), "up");
    };

    $.verto.conf.prototype.transfer = function (memberID, exten) {
      this.modCommand("transfer", parseInt(memberID), exten);
    };

    $.verto.conf.prototype.sendChat = function (message, type) {
      var conf = this;
      conf.verto.rpcClient.call("verto.broadcast", {
        "eventChannel": conf.params.laData.chatChannel,
        "data": {
          "action": "send",
          "message": message,
          "type": type
        }
      });
    };
  }

  $.verto.modfuncs = {};

  $.verto.confMan = function (verto, params) {
    var confMan = this;
    confMan.params = $.extend({
      tableID: null,
      statusID: null,
      mainModID: null,
      listCallBack: null,
      dialog: null,
      hasVid: false,
      laData: null,
      onBroadcast: null,
      onLaChange: null,
      onLaRow: null
    }, params);
    confMan.verto = verto;
    confMan.serno = CONFMAN_SERNO++;
    confMan.canvasCount = confMan.params.laData.canvasCount;

    function genMainMod(jq) {
      var play_id = "play_" + confMan.serno;
      var stop_id = "stop_" + confMan.serno;
      var recording_id = "recording_" + confMan.serno;
      var snapshot_id = "snapshot_" + confMan.serno;
      var rec_stop_id = "recording_stop" + confMan.serno;
      var div_id = "confman_" + confMan.serno;
      var html = "<div id='" + div_id + "'><br>" + "<button class='ctlbtn' id='" + play_id + "'>Play</button>" + "<button class='ctlbtn' id='" + stop_id + "'>Stop</button>" + "<button class='ctlbtn' id='" + recording_id + "'>Record</button>" + "<button class='ctlbtn' id='" + rec_stop_id + "'>Record Stop</button>" + (confMan.params.hasVid ? "<button class='ctlbtn' id='" + snapshot_id + "'>PNG Snapshot</button>" : "") + "<br><br></div>";
      jq.html(html);

      $.verto.modfuncs.change_video_layout = function (id, canvas_id) {
        var val = $("#" + id + " option:selected").text();

        if (val !== "none") {
          confMan.modCommand("vid-layout", null, [val, canvas_id]);
        }
      };

      if (confMan.params.hasVid) {
        for (var j = 0; j < confMan.canvasCount; j++) {
          var vlayout_id = "confman_vid_layout_" + j + "_" + confMan.serno;
          var vlselect_id = "confman_vl_select_" + j + "_" + confMan.serno;
          var vlhtml = "<div id='" + vlayout_id + "'><br>" + "<b>Video Layout Canvas " + (j + 1) + "</b> <select onChange='$.verto.modfuncs.change_video_layout(\"" + vlayout_id + "\", \"" + (j + 1) + "\")' id='" + vlselect_id + "'></select> " + "<br><br></div>";
          jq.append(vlhtml);
        }

        $("#" + snapshot_id).click(function () {
          var file = prompt("Please enter file name", "");

          if (file) {
            confMan.modCommand("vid-write-png", null, file);
          }
        });
      }

      $("#" + play_id).click(function () {
        var file = prompt("Please enter file name", "");

        if (file) {
          confMan.modCommand("play", null, file);
        }
      });
      $("#" + stop_id).click(function () {
        confMan.modCommand("stop", null, "all");
      });
      $("#" + recording_id).click(function () {
        var file = prompt("Please enter file name", "");

        if (file) {
          confMan.modCommand("recording", null, ["start", file]);
        }
      });
      $("#" + rec_stop_id).click(function () {
        confMan.modCommand("recording", null, ["stop", "all"]);
      });
    }

    function genControls(jq, rowid) {
      var x = parseInt(rowid);
      var kick_id = "kick_" + x;
      var canvas_in_next_id = "canvas_in_next_" + x;
      var canvas_in_prev_id = "canvas_in_prev_" + x;
      var canvas_out_next_id = "canvas_out_next_" + x;
      var canvas_out_prev_id = "canvas_out_prev_" + x;
      var canvas_in_set_id = "canvas_in_set_" + x;
      var canvas_out_set_id = "canvas_out_set_" + x;
      var layer_set_id = "layer_set_" + x;
      var layer_next_id = "layer_next_" + x;
      var layer_prev_id = "layer_prev_" + x;
      var tmute_id = "tmute_" + x;
      var tvmute_id = "tvmute_" + x;
      var vbanner_id = "vbanner_" + x;
      var tvpresenter_id = "tvpresenter_" + x;
      var tvfloor_id = "tvfloor_" + x;
      var box_id = "box_" + x;
      var gainup_id = "gain_in_up" + x;
      var gaindn_id = "gain_in_dn" + x;
      var volup_id = "vol_in_up" + x;
      var voldn_id = "vol_in_dn" + x;
      var transfer_id = "transfer" + x;
      var html = "<div id='" + box_id + "'>";
      html += "<b>General Controls</b><hr noshade>";
      html += "<button class='ctlbtn' id='" + kick_id + "'>Kick</button>" + "<button class='ctlbtn' id='" + tmute_id + "'>Mute</button>" + "<button class='ctlbtn' id='" + gainup_id + "'>Gain -</button>" + "<button class='ctlbtn' id='" + gaindn_id + "'>Gain +</button>" + "<button class='ctlbtn' id='" + voldn_id + "'>Vol -</button>" + "<button class='ctlbtn' id='" + volup_id + "'>Vol +</button>" + "<button class='ctlbtn' id='" + transfer_id + "'>Transfer</button>";

      if (confMan.params.hasVid) {
        html += "<br><br><b>Video Controls</b><hr noshade>";
        html += "<button class='ctlbtn' id='" + tvmute_id + "'>VMute</button>" + "<button class='ctlbtn' id='" + tvpresenter_id + "'>Presenter</button>" + "<button class='ctlbtn' id='" + tvfloor_id + "'>Vid Floor</button>" + "<button class='ctlbtn' id='" + vbanner_id + "'>Banner</button>";

        if (confMan.canvasCount > 1) {
          html += "<br><br><b>Canvas Controls</b><hr noshade>" + "<button class='ctlbtn' id='" + canvas_in_set_id + "'>Set Input Canvas</button>" + "<button class='ctlbtn' id='" + canvas_in_prev_id + "'>Prev Input Canvas</button>" + "<button class='ctlbtn' id='" + canvas_in_next_id + "'>Next Input Canvas</button>" + "<br>" + "<button class='ctlbtn' id='" + canvas_out_set_id + "'>Set Watching Canvas</button>" + "<button class='ctlbtn' id='" + canvas_out_prev_id + "'>Prev Watching Canvas</button>" + "<button class='ctlbtn' id='" + canvas_out_next_id + "'>Next Watching Canvas</button>";
        }

        html += "<br>" + "<button class='ctlbtn' id='" + layer_set_id + "'>Set Layer</button>" + "<button class='ctlbtn' id='" + layer_prev_id + "'>Prev Layer</button>" + "<button class='ctlbtn' id='" + layer_next_id + "'>Next Layer</button>" + "</div>";
      }

      jq.html(html);

      if (!jq.data("mouse")) {//$("#" + box_id).hide();
      }

      jq.mouseover(function (e) {
        jq.data({
          "mouse": true
        }); //$("#" + box_id).show();
      });
      jq.mouseout(function (e) {
        jq.data({
          "mouse": false
        }); //$("#" + box_id).hide();
      });
      $("#" + transfer_id).click(function () {
        var xten = prompt("Enter Extension");

        if (xten) {
          confMan.modCommand("transfer", x, xten);
        }
      });
      $("#" + kick_id).click(function () {
        confMan.modCommand("kick", x);
      });
      $("#" + layer_set_id).click(function () {
        var cid = prompt("Please enter layer ID", "");

        if (cid) {
          confMan.modCommand("vid-layer", x, cid);
        }
      });
      $("#" + layer_next_id).click(function () {
        confMan.modCommand("vid-layer", x, "next");
      });
      $("#" + layer_prev_id).click(function () {
        confMan.modCommand("vid-layer", x, "prev");
      });
      $("#" + canvas_in_set_id).click(function () {
        var cid = prompt("Please enter canvas ID", "");

        if (cid) {
          confMan.modCommand("vid-canvas", x, cid);
        }
      });
      $("#" + canvas_out_set_id).click(function () {
        var cid = prompt("Please enter canvas ID", "");

        if (cid) {
          confMan.modCommand("vid-watching-canvas", x, cid);
        }
      });
      $("#" + canvas_in_next_id).click(function () {
        confMan.modCommand("vid-canvas", x, "next");
      });
      $("#" + canvas_in_prev_id).click(function () {
        confMan.modCommand("vid-canvas", x, "prev");
      });
      $("#" + canvas_out_next_id).click(function () {
        confMan.modCommand("vid-watching-canvas", x, "next");
      });
      $("#" + canvas_out_prev_id).click(function () {
        confMan.modCommand("vid-watching-canvas", x, "prev");
      });
      $("#" + tmute_id).click(function () {
        confMan.modCommand("tmute", x);
      });

      if (confMan.params.hasVid) {
        $("#" + tvmute_id).click(function () {
          confMan.modCommand("tvmute", x);
        });
        $("#" + tvpresenter_id).click(function () {
          confMan.modCommand("vid-res-id", x, "presenter");
        });
        $("#" + tvfloor_id).click(function () {
          confMan.modCommand("vid-floor", x, "force");
        });
        $("#" + vbanner_id).click(function () {
          var text = prompt("Please enter text", "");

          if (text) {
            confMan.modCommand("vid-banner", x, escape(text));
          }
        });
      }

      $("#" + gainup_id).click(function () {
        confMan.modCommand("volume_in", x, "up");
      });
      $("#" + gaindn_id).click(function () {
        confMan.modCommand("volume_in", x, "down");
      });
      $("#" + volup_id).click(function () {
        confMan.modCommand("volume_out", x, "up");
      });
      $("#" + voldn_id).click(function () {
        confMan.modCommand("volume_out", x, "down");
      });
      return html;
    }

    var atitle = "";
    var awidth = 0; //$(".jsDataTable").width(confMan.params.hasVid ? "900px" : "800px");

    verto.subscribe(confMan.params.laData.infoChannel, {
      handler: function (v, e) {
        if (typeof confMan.params.infoCallback === "function") {
          confMan.params.infoCallback(v, e);
        }
      }
    });
    verto.subscribe(confMan.params.laData.chatChannel, {
      handler: function (v, e) {
        if (typeof confMan.params.chatCallback === "function") {
          confMan.params.chatCallback(v, e);
        }
      }
    });

    if (confMan.params.laData.role === "moderator") {
      atitle = "Action";
      awidth = 600;

      if (confMan.params.mainModID) {
        genMainMod($(confMan.params.mainModID)); //$(confMan.params.displayID).html("Moderator Controls Ready<br><br>");
      } else {//$(confMan.params.mainModID).html("");
        }

      verto.subscribe(confMan.params.laData.modChannel, {
        handler: function (v, e) {
          //console.error("MODDATA:", e.data);
          if (confMan.params.onBroadcast) {
            confMan.params.onBroadcast(verto, confMan, e.data);
          }

          if (e.data["conf-command"] === "list-videoLayouts") {
            for (var j = 0; j < confMan.canvasCount; j++) {
              var vlselect_id = "#confman_vl_select_" + j + "_" + confMan.serno;
              var vlayout_id = "#confman_vid_layout_" + j + "_" + confMan.serno;
              var x = 0;
              var options; // $(vlselect_id).selectmenu({});
              // $(vlselect_id).selectmenu("enable");
              // $(vlselect_id).empty();
              // $(vlselect_id).append(new Option("Choose a Layout", "none"));

              if (e.data.responseData) {
                var rdata = [];

                for (var i in e.data.responseData) {
                  rdata.push(e.data.responseData[i].name);
                }

                options = rdata.sort(function (a, b) {
                  var ga = a.substring(0, 6) == "group:" ? true : false;
                  var gb = b.substring(0, 6) == "group:" ? true : false;

                  if ((ga || gb) && ga != gb) {
                    return ga ? -1 : 1;
                  }

                  return a == b ? 0 : a > b ? 1 : -1;
                });

                for (var i in options) {
                  //$(vlselect_id).append(new Option(options[i], options[i]));
                  x++;
                }
              }

              if (x) {//$(vlselect_id).selectmenu('refresh', true);
              } else {//$(vlayout_id).hide();
                }
            }
          } else {
            if (!confMan.destroyed && confMan.params.displayID) {
              //$(confMan.params.displayID).html(e.data.response + "<br><br>");
              if (confMan.lastTimeout) {
                clearTimeout(confMan.lastTimeout);
                confMan.lastTimeout = 0;
              }

              confMan.lastTimeout = setTimeout(function () {
                $(confMan.params.displayID).html(confMan.destroyed ? "" : "Moderator Controls Ready<br><br>");
              }, 4000);
            }
          }
        }
      });

      if (confMan.params.hasVid) {
        confMan.modCommand("list-videoLayouts", null, null);
      }
    }

    var row_callback = null;

    if (confMan.params.laData.role === "moderator") {
      row_callback = function (nRow, aData, iDisplayIndex, iDisplayIndexFull) {
        if (!aData[5]) {
          var $row = $('td:eq(5)', nRow);
          genControls($row, aData);

          if (confMan.params.onLaRow) {
            confMan.params.onLaRow(verto, confMan, $row, aData);
          }
        }
      };
    }

    confMan.lt = new $.verto.liveTable(verto, confMan.params.laData.laChannel, confMan.params.laData.laName, $(confMan.params.tableID), {
      subParams: {
        callID: confMan.params.dialog ? confMan.params.dialog.callID : null
      },
      "onChange": function (obj, args) {
        //$(confMan.params.statusID).text("Conference Members: " + " (" + obj.arrayLen() + " Total)");
        if (confMan.params.onLaChange) {
          confMan.params.onLaChange(verto, confMan, obj, args);
        }
      },
      "aaData": [],
      "aoColumns": [{
        "sTitle": "ID",
        "sWidth": "50"
      }, {
        "sTitle": "Number",
        "sWidth": "250"
      }, {
        "sTitle": "Name",
        "sWidth": "250"
      }, {
        "sTitle": "Codec",
        "sWidth": "100"
      }, {
        "sTitle": "Status",
        "sWidth": confMan.params.hasVid ? "200px" : "150px"
      }, {
        "sTitle": atitle,
        "sWidth": awidth
      }],
      "bAutoWidth": true,
      "bDestroy": true,
      "bSort": false,
      "bInfo": false,
      "bFilter": false,
      "bLengthChange": false,
      "bPaginate": false,
      "iDisplayLength": 1400,
      "oLanguage": {
        "sEmptyTable": "The Conference is Empty....."
      },
      "fnRowCallback": row_callback
    });
  };

  $.verto.confMan.prototype.modCommand = function (cmd, id, value) {
    var confMan = this;
    confMan.verto.rpcClient.call("verto.broadcast", {
      "eventChannel": confMan.params.laData.modChannel,
      "data": {
        "application": "conf-control",
        "command": cmd,
        "id": id,
        "value": value
      }
    });
  };

  $.verto.confMan.prototype.sendChat = function (message, type) {
    var confMan = this;
    confMan.verto.rpcClient.call("verto.broadcast", {
      "eventChannel": confMan.params.laData.chatChannel,
      "data": {
        "action": "send",
        "message": message,
        "type": type
      }
    });
  };

  $.verto.confMan.prototype.destroy = function () {
    var confMan = this;
    confMan.destroyed = true;

    if (confMan.lt) {
      confMan.lt.destroy();
    }

    if (confMan.params.laData.chatChannel) {
      confMan.verto.unsubscribe(confMan.params.laData.chatChannel);
    }

    if (confMan.params.laData.modChannel) {
      confMan.verto.unsubscribe(confMan.params.laData.modChannel);
    }

    if (confMan.params.mainModID) {
      $(confMan.params.mainModID).html("");
    }
  };

  $.verto.dialog = function (direction, verto, params) {
    var dialog = this;
    dialog.params = $.extend({
      useVideo: verto.options.useVideo,
      useStereo: verto.options.useStereo,
      screenShare: false,
      useCamera: false,
      useMic: verto.options.deviceParams.useMic,
      useSpeak: verto.options.deviceParams.useSpeak,
      tag: verto.options.tag,
      localTag: verto.options.localTag,
      login: verto.options.login,
      videoParams: verto.options.videoParams,
      useStream: verto.options.useStream
    }, params);

    if (!dialog.params.screenShare) {
      dialog.params.useCamera = verto.options.deviceParams.useCamera;
    }

    dialog.verto = verto;
    dialog.direction = direction;
    dialog.lastState = null;
    dialog.state = dialog.lastState = $.verto.enum.state.new;
    dialog.callbacks = verto.callbacks;
    dialog.answered = false;
    dialog.attach = params.attach || false;
    dialog.screenShare = params.screenShare || false;
    dialog.useCamera = dialog.params.useCamera;
    dialog.useMic = dialog.params.useMic;
    dialog.useSpeak = dialog.params.useSpeak;

    if (dialog.params.callID) {
      dialog.callID = dialog.params.callID;
    } else {
      dialog.callID = dialog.params.callID = generateGUID();
    }

    if (typeof dialog.params.tag === "function") {
      dialog.params.tag = dialog.params.tag();
    }

    if (dialog.params.tag) {
      dialog.audioStream = document.getElementById(dialog.params.tag);

      if (dialog.params.useVideo) {
        dialog.videoStream = dialog.audioStream;
      }
    } //else conjure one TBD


    if (dialog.params.localTag) {
      dialog.localVideo = document.getElementById(dialog.params.localTag);
    }

    dialog.verto.dialogs[dialog.callID] = dialog;
    var RTCcallbacks = {};

    if (dialog.direction == $.verto.enum.direction.inbound) {
      if (dialog.params.display_direction === "outbound") {
        dialog.params.remote_caller_id_name = dialog.params.caller_id_name;
        dialog.params.remote_caller_id_number = dialog.params.caller_id_number;
      } else {
        dialog.params.remote_caller_id_name = dialog.params.callee_id_name;
        dialog.params.remote_caller_id_number = dialog.params.callee_id_number;
      }

      if (!dialog.params.remote_caller_id_name) {
        dialog.params.remote_caller_id_name = "Nobody";
      }

      if (!dialog.params.remote_caller_id_number) {
        dialog.params.remote_caller_id_number = "UNKNOWN";
      }

      RTCcallbacks.onMessage = function (rtc, msg) {
        console.debug(msg);
      };

      RTCcallbacks.onAnswerSDP = function (rtc, sdp) {
        console.error("answer sdp", sdp);
      };
    } else {
      dialog.params.remote_caller_id_name = "Outbound Call";
      dialog.params.remote_caller_id_number = dialog.params.destination_number;
    }

    RTCcallbacks.onICESDP = function (rtc) {
      console.log("RECV " + rtc.type + " SDP", rtc.mediaData.SDP);

      if (dialog.state == $.verto.enum.state.requesting || dialog.state == $.verto.enum.state.answering || dialog.state == $.verto.enum.state.active) {
        location.reload();
        return;
      }

      if (rtc.type == "offer") {
        if (dialog.state == $.verto.enum.state.active) {
          dialog.setState($.verto.enum.state.requesting);
          dialog.sendMethod("verto.attach", {
            sdp: rtc.mediaData.SDP
          });
        } else {
          dialog.setState($.verto.enum.state.requesting);
          dialog.sendMethod("verto.invite", {
            sdp: rtc.mediaData.SDP
          });
        }
      } else {
        //answer
        dialog.setState($.verto.enum.state.answering);
        dialog.sendMethod(dialog.attach ? "verto.attach" : "verto.answer", {
          sdp: dialog.rtc.mediaData.SDP
        });
      }
    };

    RTCcallbacks.onICE = function (rtc) {
      //console.log("cand", rtc.mediaData.candidate);
      if (rtc.type == "offer") {
        console.log("offer", rtc.mediaData.candidate);
        return;
      }
    };

    RTCcallbacks.onStream = function (rtc, stream) {
      if (dialog.callbacks.permissionCallback && typeof dialog.callbacks.permissionCallback.onGranted === 'function') {
        dialog.callbacks.permissionCallback.onGranted(stream);
      } else if (dialog.verto.options.permissionCallback && typeof dialog.verto.options.permissionCallback.onGranted === 'function') {
        dialog.verto.options.permissionCallback.onGranted(stream);
      }

      console.log("stream started");
    };

    RTCcallbacks.onRemoteStream = function (rtc, stream) {
      if (typeof dialog.callbacks.onRemoteStream === 'function') {
        dialog.callbacks.onRemoteStream(stream, dialog);
      }

      console.log("remote stream started");
    };

    RTCcallbacks.onError = function (e) {
      if (dialog.callbacks.permissionCallback && typeof dialog.callbacks.permissionCallback.onDenied === 'function') {
        dialog.callbacks.permissionCallback.onDenied();
      } else if (dialog.verto.options.permissionCallback && typeof dialog.verto.options.permissionCallback.onDenied === 'function') {
        dialog.verto.options.permissionCallback.onDenied();
      }

      console.error("ERROR:", e);
      dialog.hangup({
        cause: "Device or Permission Error"
      });
    };

    dialog.rtc = new $.FSRTC({
      callbacks: RTCcallbacks,
      localVideo: dialog.screenShare ? null : dialog.localVideo,
      useVideo: dialog.params.useVideo ? dialog.videoStream : null,
      useAudio: dialog.audioStream,
      useStereo: dialog.params.useStereo,
      videoParams: dialog.params.videoParams,
      audioParams: verto.options.audioParams,
      iceServers: verto.options.iceServers,
      screenShare: dialog.screenShare,
      useCamera: dialog.useCamera,
      useMic: dialog.useMic,
      useSpeak: dialog.useSpeak,
      turnServer: verto.options.turnServer,
      useStream: dialog.params.useStream
    });
    dialog.rtc.verto = dialog.verto;

    if (dialog.direction == $.verto.enum.direction.inbound) {
      if (dialog.attach) {
        dialog.answer();
      } else {
        dialog.ring();
      }
    }
  };

  $.verto.dialog.prototype.invite = function () {
    var dialog = this;
    dialog.rtc.call();
  };

  $.verto.dialog.prototype.sendMethod = function (method, obj) {
    var dialog = this;
    obj.dialogParams = {};

    for (var i in dialog.params) {
      if (i == "sdp" && method != "verto.invite" && method != "verto.attach") {
        continue;
      }

      if (obj.noDialogParams && i != "callID") {
        continue;
      }

      obj.dialogParams[i] = dialog.params[i];
    }

    delete obj.noDialogParams;
    dialog.verto.rpcClient.call(method, obj, function (e) {
      /* Success */
      dialog.processReply(method, true, e);
    }, function (e) {
      /* Error */
      dialog.processReply(method, false, e);
    });
  };

  function checkStateChange(oldS, newS) {
    if (newS == $.verto.enum.state.purge || $.verto.enum.states[oldS.name][newS.name]) {
      return true;
    }

    return false;
  } // Attach audio output device to video element using device/sink ID.                                                                                           


  function find_name(id) {
    for (var i in $.verto.audioOutDevices) {
      var source = $.verto.audioOutDevices[i];

      if (source.id === id) {
        return source.label;
      }
    }

    return id;
  }

  $.verto.dialog.prototype.setAudioPlaybackDevice = function (sinkId, callback, arg) {
    var dialog = this;
    var element = dialog.audioStream;

    if (typeof element.sinkId !== 'undefined') {
      var devname = find_name(sinkId);
      console.info("Dialog: " + dialog.callID + " Setting speaker:", element, devname);
      element.setSinkId(sinkId).then(function () {
        console.log("Dialog: " + dialog.callID + ' Success, audio output device attached: ' + sinkId);

        if (callback) {
          callback(true, devname, arg);
        }
      }).catch(function (error) {
        var errorMessage = error;

        if (error.name === 'SecurityError') {
          errorMessage = "Dialog: " + dialog.callID + ' You need to use HTTPS for selecting audio output ' + 'device: ' + error;
        }

        if (callback) {
          callback(false, null, arg);
        }

        console.error(errorMessage);
      });
    } else {
      console.warn("Dialog: " + dialog.callID + ' Browser does not support output device selection.');

      if (callback) {
        callback(false, null, arg);
      }
    }
  };

  $.verto.dialog.prototype.setState = function (state) {
    var dialog = this;

    if (dialog.state == $.verto.enum.state.ringing) {
      dialog.stopRinging();
    }

    if (dialog.state == state || !checkStateChange(dialog.state, state)) {
      console.error("Dialog " + dialog.callID + ": INVALID state change from " + dialog.state.name + " to " + state.name);
      dialog.hangup();
      return false;
    }

    console.log("Dialog " + dialog.callID + ": state change from " + dialog.state.name + " to " + state.name);
    dialog.lastState = dialog.state;
    dialog.state = state;

    if (dialog.callbacks.onDialogState) {
      dialog.callbacks.onDialogState(this);
    }

    switch (dialog.state) {
      case $.verto.enum.state.early:
      case $.verto.enum.state.active:
        var speaker = dialog.useSpeak;
        console.info("Using Speaker: ", speaker);

        if (speaker && speaker !== "any" && speaker !== "none") {
          setTimeout(function () {
            dialog.setAudioPlaybackDevice(speaker);
          }, 500);
        }

        break;

      case $.verto.enum.state.trying:
        setTimeout(function () {
          if (dialog.state == $.verto.enum.state.trying) {
            dialog.setState($.verto.enum.state.hangup);
          }
        }, 30000);
        break;

      case $.verto.enum.state.purge:
        dialog.setState($.verto.enum.state.destroy);
        break;

      case $.verto.enum.state.hangup:
        if (dialog.lastState.val > $.verto.enum.state.requesting.val && dialog.lastState.val < $.verto.enum.state.hangup.val) {
          dialog.sendMethod("verto.bye", {});
        }

        dialog.setState($.verto.enum.state.destroy);
        break;

      case $.verto.enum.state.destroy:
        if (typeof dialog.verto.options.tag === "function") {
          $('#' + dialog.params.tag).remove();
        }

        delete dialog.verto.dialogs[dialog.callID];

        if (dialog.params.screenShare) {
          dialog.rtc.stopPeer(); //dialog.rtc.stop();
        } else {
          dialog.rtc.stop();
        }

        break;
    }

    return true;
  };

  $.verto.dialog.prototype.processReply = function (method, success, e) {
    var dialog = this; //console.log("Response: " + method + " State:" + dialog.state.name, success, e);

    switch (method) {
      case "verto.answer":
      case "verto.attach":
        if (success) {
          dialog.setState($.verto.enum.state.active);
        } else {
          dialog.hangup();
        }

        break;

      case "verto.invite":
        if (success) {
          dialog.setState($.verto.enum.state.trying);
        } else {
          dialog.setState($.verto.enum.state.destroy);
        }

        break;

      case "verto.bye":
        dialog.hangup();
        break;

      case "verto.modify":
        if (e.holdState) {
          if (e.holdState == "held") {
            if (dialog.state != $.verto.enum.state.held) {
              dialog.setState($.verto.enum.state.held);
            }
          } else if (e.holdState == "active") {
            if (dialog.state != $.verto.enum.state.active) {
              dialog.setState($.verto.enum.state.active);
            }
          }
        }

        if (success) {}

        break;

      default:
        break;
    }
  };

  $.verto.dialog.prototype.hangup = function (params) {
    var dialog = this;

    if (params) {
      if (params.causeCode) {
        dialog.causeCode = params.causeCode;
      }

      if (params.cause) {
        dialog.cause = params.cause;
      }
    }

    if (!dialog.cause && !dialog.causeCode) {
      dialog.cause = "NORMAL_CLEARING";
    }

    if (dialog.state.val >= $.verto.enum.state.new.val && dialog.state.val < $.verto.enum.state.hangup.val) {
      dialog.setState($.verto.enum.state.hangup);
    } else if (dialog.state.val < $.verto.enum.state.destroy) {
      dialog.setState($.verto.enum.state.destroy);
    }
  };

  $.verto.dialog.prototype.stopRinging = function () {
    var dialog = this;

    if (dialog.verto.ringer) {
      dialog.verto.ringer.stop();
    }
  };

  $.verto.dialog.prototype.indicateRing = function () {
    var dialog = this;

    if (dialog.verto.ringer) {
      dialog.verto.ringer.attr("src", dialog.verto.options.ringFile)[0].play();
      setTimeout(function () {
        dialog.stopRinging();

        if (dialog.state == $.verto.enum.state.ringing) {
          dialog.indicateRing();
        }
      }, dialog.verto.options.ringSleep);
    }
  };

  $.verto.dialog.prototype.ring = function () {
    var dialog = this;
    dialog.setState($.verto.enum.state.ringing);
    dialog.indicateRing();
  };

  $.verto.dialog.prototype.useVideo = function (on) {
    var dialog = this;
    dialog.params.useVideo = on;

    if (on) {
      dialog.videoStream = dialog.audioStream;
    } else {
      dialog.videoStream = null;
    }

    dialog.rtc.useVideo(dialog.videoStream, dialog.localVideo);
  };

  $.verto.dialog.prototype.setMute = function (what) {
    var dialog = this;
    return dialog.rtc.setMute(what);
  };

  $.verto.dialog.prototype.getMute = function () {
    var dialog = this;
    return dialog.rtc.getMute();
  };

  $.verto.dialog.prototype.setVideoMute = function (what) {
    var dialog = this;
    return dialog.rtc.setVideoMute(what);
  };

  $.verto.dialog.prototype.getVideoMute = function () {
    var dialog = this;
    return dialog.rtc.getVideoMute();
  };

  $.verto.dialog.prototype.useStereo = function (on) {
    var dialog = this;
    dialog.params.useStereo = on;
    dialog.rtc.useStereo(on);
  };

  $.verto.dialog.prototype.dtmf = function (digits) {
    var dialog = this;

    if (digits) {
      dialog.sendMethod("verto.info", {
        dtmf: digits
      });
    }
  };

  $.verto.dialog.prototype.rtt = function (obj) {
    var dialog = this;
    var pobj = {};

    if (!obj) {
      return false;
    }

    pobj.code = obj.code;
    pobj.chars = obj.chars;

    if (pobj.chars || pobj.code) {
      dialog.sendMethod("verto.info", {
        txt: obj,
        noDialogParams: true
      });
    }
  };

  $.verto.dialog.prototype.transfer = function (dest, params) {
    var dialog = this;

    if (dest) {
      dialog.sendMethod("verto.modify", {
        action: "transfer",
        destination: dest,
        params: params
      });
    }
  };

  $.verto.dialog.prototype.replace = function (replaceCallID, params) {
    var dialog = this;

    if (replaceCallID) {
      dialog.sendMethod("verto.modify", {
        action: "replace",
        replaceCallID: replaceCallID,
        params: params
      });
    }
  };

  $.verto.dialog.prototype.hold = function (params) {
    var dialog = this;
    dialog.sendMethod("verto.modify", {
      action: "hold",
      params: params
    });
  };

  $.verto.dialog.prototype.unhold = function (params) {
    var dialog = this;
    dialog.sendMethod("verto.modify", {
      action: "unhold",
      params: params
    });
  };

  $.verto.dialog.prototype.toggleHold = function (params) {
    var dialog = this;
    dialog.sendMethod("verto.modify", {
      action: "toggleHold",
      params: params
    });
  };

  $.verto.dialog.prototype.message = function (msg) {
    var dialog = this;
    var err = 0;
    msg.from = dialog.params.login;

    if (!msg.to) {
      console.error("Missing To");
      err++;
    }

    if (!msg.body) {
      console.error("Missing Body");
      err++;
    }

    if (err) {
      return false;
    }

    dialog.sendMethod("verto.info", {
      msg: msg
    });
    return true;
  };

  $.verto.dialog.prototype.answer = function (params) {
    var dialog = this;

    if (!dialog.answered) {
      if (!params) {
        params = {};
      }

      params.sdp = dialog.params.sdp;

      if (params) {
        if (params.useVideo) {
          dialog.useVideo(true);
        }

        dialog.params.callee_id_name = params.callee_id_name;
        dialog.params.callee_id_number = params.callee_id_number;

        if (params.useCamera) {
          dialog.useCamera = params.useCamera;
        }

        if (params.useMic) {
          dialog.useMic = params.useMic;
        }

        if (params.useSpeak) {
          dialog.useSpeak = params.useSpeak;
        }
      }

      dialog.rtc.createAnswer(params);
      dialog.answered = true;
    }
  };

  $.verto.dialog.prototype.handleAnswer = function (params) {
    var dialog = this;
    dialog.gotAnswer = true;

    if (dialog.state.val >= $.verto.enum.state.active.val) {
      return;
    }

    if (dialog.state.val >= $.verto.enum.state.early.val) {
      dialog.setState($.verto.enum.state.active);
    } else {
      if (dialog.gotEarly) {
        console.log("Dialog " + dialog.callID + " Got answer while still establishing early media, delaying...");
      } else {
        console.log("Dialog " + dialog.callID + " Answering Channel");
        dialog.rtc.answer(params.sdp, function () {
          dialog.setState($.verto.enum.state.active);
        }, function (e) {
          console.error(e);
          dialog.hangup();
        });
        console.log("Dialog " + dialog.callID + "ANSWER SDP", params.sdp);
      }
    }
  };

  $.verto.dialog.prototype.cidString = function (enc) {
    var dialog = this;
    var party = dialog.params.remote_caller_id_name + (enc ? " &lt;" : " <") + dialog.params.remote_caller_id_number + (enc ? "&gt;" : ">");
    return party;
  };

  $.verto.dialog.prototype.sendMessage = function (msg, params) {
    var dialog = this;

    if (dialog.callbacks.onMessage) {
      dialog.callbacks.onMessage(dialog.verto, dialog, msg, params);
    }
  };

  $.verto.dialog.prototype.handleInfo = function (params) {
    var dialog = this;
    dialog.sendMessage($.verto.enum.message.info, params);
  };

  $.verto.dialog.prototype.handleDisplay = function (params) {
    var dialog = this;

    if (params.display_name) {
      dialog.params.remote_caller_id_name = params.display_name;
    }

    if (params.display_number) {
      dialog.params.remote_caller_id_number = params.display_number;
    }

    dialog.sendMessage($.verto.enum.message.display, {});
  };

  $.verto.dialog.prototype.handleMedia = function (params) {
    var dialog = this;

    if (dialog.state.val >= $.verto.enum.state.early.val) {
      return;
    }

    dialog.gotEarly = true;
    dialog.rtc.answer(params.sdp, function () {
      console.log("Dialog " + dialog.callID + "Establishing early media");
      dialog.setState($.verto.enum.state.early);

      if (dialog.gotAnswer) {
        console.log("Dialog " + dialog.callID + "Answering Channel");
        dialog.setState($.verto.enum.state.active);
      }
    }, function (e) {
      console.error(e);
      dialog.hangup();
    });
    console.log("Dialog " + dialog.callID + "EARLY SDP", params.sdp);
  };

  $.verto.ENUM = function (s) {
    var i = 0,
        o = {};
    s.split(" ").map(function (x) {
      o[x] = {
        name: x,
        val: i++
      };
    });
    return Object.freeze(o);
  };

  $.verto.enum = {};
  $.verto.enum.states = Object.freeze({
    new: {
      requesting: 1,
      recovering: 1,
      ringing: 1,
      destroy: 1,
      answering: 1,
      hangup: 1
    },
    requesting: {
      trying: 1,
      hangup: 1,
      active: 1
    },
    recovering: {
      answering: 1,
      hangup: 1
    },
    trying: {
      active: 1,
      early: 1,
      hangup: 1
    },
    ringing: {
      answering: 1,
      hangup: 1
    },
    answering: {
      active: 1,
      hangup: 1
    },
    active: {
      answering: 1,
      requesting: 1,
      hangup: 1,
      held: 1
    },
    held: {
      hangup: 1,
      active: 1
    },
    early: {
      hangup: 1,
      active: 1
    },
    hangup: {
      destroy: 1
    },
    destroy: {},
    purge: {
      destroy: 1
    }
  });
  $.verto.enum.state = $.verto.ENUM("new requesting trying recovering ringing answering early active held hangup destroy purge");
  $.verto.enum.direction = $.verto.ENUM("inbound outbound");
  $.verto.enum.message = $.verto.ENUM("display info pvtEvent clientReady");
  $.verto.enum = Object.freeze($.verto.enum);
  $.verto.saved = [];
  $.verto.unloadJobs = [];
  var unloadEventName = 'beforeunload'; // Hacks for Mobile Safari

  var iOS = ['iPad', 'iPhone', 'iPod'].indexOf(navigator.platform) >= 0;

  if (iOS) {
    unloadEventName = 'pagehide';
  }

  $(window).bind(unloadEventName, function () {
    for (var f in $.verto.unloadJobs) {
      $.verto.unloadJobs[f]();
    }

    if ($.verto.haltClosure) return $.verto.haltClosure();

    for (var i in $.verto.saved) {
      var verto = $.verto.saved[i];

      if (verto) {
        verto.purge();
        verto.logout();
      }
    }

    return $.verto.warnOnUnload;
  });
  $.verto.videoDevices = [];
  $.verto.audioInDevices = [];
  $.verto.audioOutDevices = [];

  var checkDevices = function (runtime) {
    console.info("检查硬件---");
    var aud_in = [],
        aud_out = [],
        vid = [];
    var has_video = 0,
        has_audio = 0;
    var Xstream;

    function gotDevices(deviceInfos) {
      // Handles being called several times to update labels. Preserve values.
      for (var i = 0; i !== deviceInfos.length; ++i) {
        var deviceInfo = deviceInfos[i];
        var text = "";
        console.log(deviceInfo);
        console.log(deviceInfo.kind + ": " + deviceInfo.label + " id = " + deviceInfo.deviceId);

        if (deviceInfo.kind === 'audioinput') {
          text = deviceInfo.label || 'microphone ' + (aud_in.length + 1);
          aud_in.push({
            id: deviceInfo.deviceId,
            kind: "audio_in",
            label: text
          });
        } else if (deviceInfo.kind === 'audiooutput') {
          text = deviceInfo.label || 'speaker ' + (aud_out.length + 1);
          aud_out.push({
            id: deviceInfo.deviceId,
            kind: "audio_out",
            label: text
          });
        } else if (deviceInfo.kind === 'videoinput') {
          text = deviceInfo.label || 'camera ' + (vid.length + 1);
          vid.push({
            id: deviceInfo.deviceId,
            kind: "video",
            label: text
          });
        } else {
          console.log('Some other kind of source/device: ', deviceInfo);
        }
      }

      $.verto.videoDevices = vid;
      $.verto.audioInDevices = aud_in;
      $.verto.audioOutDevices = aud_out;
      console.info("Audio IN Devices", $.verto.audioInDevices);
      console.info("Audio Out Devices", $.verto.audioOutDevices);
      console.info("Video Devices", $.verto.videoDevices);

      if (Xstream) {
        Xstream.getTracks().forEach(function (track) {
          track.stop();
        });
      }

      if (runtime) {
        runtime(true);
      }
    }

    function handleError(error) {
      console.log('device enumeration error: ', error);
      if (runtime) runtime(false);
    }

    function checkTypes(devs) {
      for (var i = 0; i !== devs.length; ++i) {
        if (devs[i].kind === 'audioinput') {
          has_audio++;
        } else if (devs[i].kind === 'videoinput') {
          has_video++;
        }
      } //navigator.getUserMedia({ audio: (has_audio > 0 ? true : false), video: (has_video > 0 ? true : false)},


      navigator.getUserMedia({
        audio: has_audio > 0 ? true : false,
        video: false
      }, function (stream) {
        Xstream = stream;
        navigator.mediaDevices.enumerateDevices().then(gotDevices).catch(handleError);
      }, function (err) {
        console.log("The following error occurred: " + err.name);
      });
    }

    navigator.mediaDevices.enumerateDevices().then(checkTypes).catch(handleError);
  };

  $.verto.refreshDevices = function (runtime) {
    checkDevices(runtime);
  };

  $.verto.init = function (obj, runtime) {
    if (!obj) {
      obj = {};
    }

    if (!obj.skipPermCheck && !obj.skipDeviceCheck) {
      $.FSRTC.checkPerms(function (status) {
        checkDevices(runtime);
      }, true, false); //最后一位是视频
    } else if (obj.skipPermCheck && !obj.skipDeviceCheck) {
      checkDevices(runtime);
    } else if (!obj.skipPermCheck && obj.skipDeviceCheck) {
      $.FSRTC.checkPerms(function (status) {
        runtime(status);
      }, true, true);
    } else {
      runtime(null);
    }
  };

  $.verto.genUUID = function () {
    return generateGUID();
  };
})(jQuery);

(function (f) {
  if (true) {
    module.exports = f();
  } else { var g; }
})(function () {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a) return require(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }

        var l = n[o] = {
          exports: {}
        };
        t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }

      return n[o].exports;
    }

    var i = typeof require == "function" && require;

    for (var o = 0; o < r.length; o++) s(r[o]);

    return s;
  }({
    1: [function (require, module, exports) {
      /*
      *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */

      /* eslint-env node */
      'use strict';

      var SDPUtils = require('sdp');

      function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
        var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps); // Map ICE parameters (ufrag, pwd) to SDP.

        sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters()); // Map DTLS parameters to SDP.

        sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : dtlsRole || 'active');
        sdp += 'a=mid:' + transceiver.mid + '\r\n';

        if (transceiver.rtpSender && transceiver.rtpReceiver) {
          sdp += 'a=sendrecv\r\n';
        } else if (transceiver.rtpSender) {
          sdp += 'a=sendonly\r\n';
        } else if (transceiver.rtpReceiver) {
          sdp += 'a=recvonly\r\n';
        } else {
          sdp += 'a=inactive\r\n';
        }

        if (transceiver.rtpSender) {
          // spec.
          var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\r\n';
          sdp += 'a=' + msid; // for Chrome.

          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;

          if (transceiver.sendEncodingParameters[0].rtx) {
            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
            sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
          }
        } // FIXME: this should be written by writeRtpDescription.


        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';

        if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
        }

        return sdp;
      } // Edge does not like
      // 1) stun: filtered after 14393 unless ?transport=udp is present
      // 2) turn: that does not have all of turn:host:port?transport=udp
      // 3) turn: with ipv6 addresses
      // 4) turn: occurring muliple times


      function filterIceServers(iceServers, edgeVersion) {
        var hasTurn = false;
        iceServers = JSON.parse(JSON.stringify(iceServers));
        return iceServers.filter(function (server) {
          if (server && (server.urls || server.url)) {
            var urls = server.urls || server.url;

            if (server.url && !server.urls) {
              console.warn('RTCIceServer.url is deprecated! Use urls instead.');
            }

            var isString = typeof urls === 'string';

            if (isString) {
              urls = [urls];
            }

            urls = urls.filter(function (url) {
              var validTurn = url.indexOf('turn:') === 0 && url.indexOf('transport=udp') !== -1 && url.indexOf('turn:[') === -1 && !hasTurn;

              if (validTurn) {
                hasTurn = true;
                return true;
              }

              return url.indexOf('stun:') === 0 && edgeVersion >= 14393 && url.indexOf('?transport=udp') === -1;
            });
            delete server.url;
            server.urls = isString ? urls[0] : urls;
            return !!urls.length;
          }
        });
      } // Determines the intersection of local and remote capabilities.


      function getCommonCapabilities(localCapabilities, remoteCapabilities) {
        var commonCapabilities = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: []
        };

        var findCodecByPayloadType = function (pt, codecs) {
          pt = parseInt(pt, 10);

          for (var i = 0; i < codecs.length; i++) {
            if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) {
              return codecs[i];
            }
          }
        };

        var rtxCapabilityMatches = function (lRtx, rRtx, lCodecs, rCodecs) {
          var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
          var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
          return lCodec && rCodec && lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
        };

        localCapabilities.codecs.forEach(function (lCodec) {
          for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
            var rCodec = remoteCapabilities.codecs[i];

            if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() && lCodec.clockRate === rCodec.clockRate) {
              if (lCodec.name.toLowerCase() === 'rtx' && lCodec.parameters && rCodec.parameters.apt) {
                // for RTX we need to find the local rtx that has a apt
                // which points to the same local codec as the remote one.
                if (!rtxCapabilityMatches(lCodec, rCodec, localCapabilities.codecs, remoteCapabilities.codecs)) {
                  continue;
                }
              }

              rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
              // number of channels is the highest common number of channels

              rCodec.numChannels = Math.min(lCodec.numChannels, rCodec.numChannels); // push rCodec so we reply with offerer payload type

              commonCapabilities.codecs.push(rCodec); // determine common feedback mechanisms

              rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function (fb) {
                for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
                  if (lCodec.rtcpFeedback[j].type === fb.type && lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                    return true;
                  }
                }

                return false;
              }); // FIXME: also need to determine .parameters
              //  see https://github.com/openpeer/ortc/issues/569

              break;
            }
          }
        });
        localCapabilities.headerExtensions.forEach(function (lHeaderExtension) {
          for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {
            var rHeaderExtension = remoteCapabilities.headerExtensions[i];

            if (lHeaderExtension.uri === rHeaderExtension.uri) {
              commonCapabilities.headerExtensions.push(rHeaderExtension);
              break;
            }
          }
        }); // FIXME: fecMechanisms

        return commonCapabilities;
      } // is action=setLocalDescription with type allowed in signalingState


      function isActionAllowedInSignalingState(action, type, signalingState) {
        return {
          offer: {
            setLocalDescription: ['stable', 'have-local-offer'],
            setRemoteDescription: ['stable', 'have-remote-offer']
          },
          answer: {
            setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
            setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
          }
        }[type][action].indexOf(signalingState) !== -1;
      }

      function maybeAddCandidate(iceTransport, candidate) {
        // Edge's internal representation adds some fields therefore
        // not all fieldѕ are taken into account.
        var alreadyAdded = iceTransport.getRemoteCandidates().find(function (remoteCandidate) {
          return candidate.foundation === remoteCandidate.foundation && candidate.ip === remoteCandidate.ip && candidate.port === remoteCandidate.port && candidate.priority === remoteCandidate.priority && candidate.protocol === remoteCandidate.protocol && candidate.type === remoteCandidate.type;
        });

        if (!alreadyAdded) {
          iceTransport.addRemoteCandidate(candidate);
        }

        return !alreadyAdded;
      } // https://w3c.github.io/mediacapture-main/#mediastream
      // Helper function to add the track to the stream and
      // dispatch the event ourselves.


      function addTrackToStreamAndFireEvent(track, stream) {
        stream.addTrack(track);
        var e = new Event('addtrack'); // TODO: MediaStreamTrackEvent

        e.track = track;
        stream.dispatchEvent(e);
      }

      function removeTrackFromStreamAndFireEvent(track, stream) {
        stream.removeTrack(track);
        var e = new Event('removetrack'); // TODO: MediaStreamTrackEvent

        e.track = track;
        stream.dispatchEvent(e);
      }

      function fireAddTrack(pc, track, receiver, streams) {
        var trackEvent = new Event('track');
        trackEvent.track = track;
        trackEvent.receiver = receiver;
        trackEvent.transceiver = {
          receiver: receiver
        };
        trackEvent.streams = streams;
        window.setTimeout(function () {
          pc._dispatchEvent('track', trackEvent);
        });
      }

      function makeError(name, description) {
        var e = new Error(description);
        e.name = name;
        return e;
      }

      module.exports = function (window, edgeVersion) {
        var RTCPeerConnection = function (config) {
          var pc = this;

          var _eventTarget = document.createDocumentFragment();

          ['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(function (method) {
            pc[method] = _eventTarget[method].bind(_eventTarget);
          });
          this.canTrickleIceCandidates = null;
          this.needNegotiation = false;
          this.localStreams = [];
          this.remoteStreams = [];
          this.localDescription = null;
          this.remoteDescription = null;
          this.signalingState = 'stable';
          this.iceConnectionState = 'new';
          this.iceGatheringState = 'new';
          config = JSON.parse(JSON.stringify(config || {}));
          this.usingBundle = config.bundlePolicy === 'max-bundle';

          if (config.rtcpMuxPolicy === 'negotiate') {
            throw makeError('NotSupportedError', 'rtcpMuxPolicy \'negotiate\' is not supported');
          } else if (!config.rtcpMuxPolicy) {
            config.rtcpMuxPolicy = 'require';
          }

          switch (config.iceTransportPolicy) {
            case 'all':
            case 'relay':
              break;

            default:
              config.iceTransportPolicy = 'all';
              break;
          }

          switch (config.bundlePolicy) {
            case 'balanced':
            case 'max-compat':
            case 'max-bundle':
              break;

            default:
              config.bundlePolicy = 'balanced';
              break;
          }

          config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);
          this._iceGatherers = [];

          if (config.iceCandidatePoolSize) {
            for (var i = config.iceCandidatePoolSize; i > 0; i--) {
              this._iceGatherers = new window.RTCIceGatherer({
                iceServers: config.iceServers,
                gatherPolicy: config.iceTransportPolicy
              });
            }
          } else {
            config.iceCandidatePoolSize = 0;
          }

          this._config = config; // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
          // everything that is needed to describe a SDP m-line.

          this.transceivers = [];
          this._sdpSessionId = SDPUtils.generateSessionId();
          this._sdpSessionVersion = 0;
          this._dtlsRole = undefined; // role for a=setup to use in answers.

          this._isClosed = false;
        }; // set up event handlers on prototype


        RTCPeerConnection.prototype.onicecandidate = null;
        RTCPeerConnection.prototype.onaddstream = null;
        RTCPeerConnection.prototype.ontrack = null;
        RTCPeerConnection.prototype.onremovestream = null;
        RTCPeerConnection.prototype.onsignalingstatechange = null;
        RTCPeerConnection.prototype.oniceconnectionstatechange = null;
        RTCPeerConnection.prototype.onicegatheringstatechange = null;
        RTCPeerConnection.prototype.onnegotiationneeded = null;
        RTCPeerConnection.prototype.ondatachannel = null;

        RTCPeerConnection.prototype._dispatchEvent = function (name, event) {
          if (this._isClosed) {
            return;
          }

          this.dispatchEvent(event);

          if (typeof this['on' + name] === 'function') {
            this['on' + name](event);
          }
        };

        RTCPeerConnection.prototype._emitGatheringStateChange = function () {
          var event = new Event('icegatheringstatechange');

          this._dispatchEvent('icegatheringstatechange', event);
        };

        RTCPeerConnection.prototype.getConfiguration = function () {
          return this._config;
        };

        RTCPeerConnection.prototype.getLocalStreams = function () {
          return this.localStreams;
        };

        RTCPeerConnection.prototype.getRemoteStreams = function () {
          return this.remoteStreams;
        }; // internal helper to create a transceiver object.
        // (whih is not yet the same as the WebRTC 1.0 transceiver)


        RTCPeerConnection.prototype._createTransceiver = function (kind) {
          var hasBundleTransport = this.transceivers.length > 0;
          var transceiver = {
            track: null,
            iceGatherer: null,
            iceTransport: null,
            dtlsTransport: null,
            localCapabilities: null,
            remoteCapabilities: null,
            rtpSender: null,
            rtpReceiver: null,
            kind: kind,
            mid: null,
            sendEncodingParameters: null,
            recvEncodingParameters: null,
            stream: null,
            associatedRemoteMediaStreams: [],
            wantReceive: true
          };

          if (this.usingBundle && hasBundleTransport) {
            transceiver.iceTransport = this.transceivers[0].iceTransport;
            transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
          } else {
            var transports = this._createIceAndDtlsTransports();

            transceiver.iceTransport = transports.iceTransport;
            transceiver.dtlsTransport = transports.dtlsTransport;
          }

          this.transceivers.push(transceiver);
          return transceiver;
        };

        RTCPeerConnection.prototype.addTrack = function (track, stream) {
          var alreadyExists = this.transceivers.find(function (s) {
            return s.track === track;
          });

          if (alreadyExists) {
            throw makeError('InvalidAccessError', 'Track already exists.');
          }

          if (this.signalingState === 'closed') {
            throw makeError('InvalidStateError', 'Attempted to call addTrack on a closed peerconnection.');
          }

          var transceiver;

          for (var i = 0; i < this.transceivers.length; i++) {
            if (!this.transceivers[i].track && this.transceivers[i].kind === track.kind) {
              transceiver = this.transceivers[i];
            }
          }

          if (!transceiver) {
            transceiver = this._createTransceiver(track.kind);
          }

          this._maybeFireNegotiationNeeded();

          if (this.localStreams.indexOf(stream) === -1) {
            this.localStreams.push(stream);
          }

          transceiver.track = track;
          transceiver.stream = stream;
          transceiver.rtpSender = new window.RTCRtpSender(track, transceiver.dtlsTransport);
          return transceiver.rtpSender;
        };

        RTCPeerConnection.prototype.addStream = function (stream) {
          var pc = this;

          if (edgeVersion >= 15025) {
            stream.getTracks().forEach(function (track) {
              pc.addTrack(track, stream);
            });
          } else {
            // Clone is necessary for local demos mostly, attaching directly
            // to two different senders does not work (build 10547).
            // Fixed in 15025 (or earlier)
            var clonedStream = stream.clone();
            stream.getTracks().forEach(function (track, idx) {
              var clonedTrack = clonedStream.getTracks()[idx];
              track.addEventListener('enabled', function (event) {
                clonedTrack.enabled = event.enabled;
              });
            });
            clonedStream.getTracks().forEach(function (track) {
              pc.addTrack(track, clonedStream);
            });
          }
        };

        RTCPeerConnection.prototype.removeTrack = function (sender) {
          if (!(sender instanceof window.RTCRtpSender)) {
            throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.');
          }

          var transceiver = this.transceivers.find(function (t) {
            return t.rtpSender === sender;
          });

          if (!transceiver) {
            throw makeError('InvalidAccessError', 'Sender was not created by this connection.');
          }

          var stream = transceiver.stream;
          transceiver.rtpSender.stop();
          transceiver.rtpSender = null;
          transceiver.track = null;
          transceiver.stream = null; // remove the stream from the set of local streams

          var localStreams = this.transceivers.map(function (t) {
            return t.stream;
          });

          if (localStreams.indexOf(stream) === -1 && this.localStreams.indexOf(stream) > -1) {
            this.localStreams.splice(this.localStreams.indexOf(stream), 1);
          }

          this._maybeFireNegotiationNeeded();
        };

        RTCPeerConnection.prototype.removeStream = function (stream) {
          var pc = this;
          stream.getTracks().forEach(function (track) {
            var sender = pc.getSenders().find(function (s) {
              return s.track === track;
            });

            if (sender) {
              pc.removeTrack(sender);
            }
          });
        };

        RTCPeerConnection.prototype.getSenders = function () {
          return this.transceivers.filter(function (transceiver) {
            return !!transceiver.rtpSender;
          }).map(function (transceiver) {
            return transceiver.rtpSender;
          });
        };

        RTCPeerConnection.prototype.getReceivers = function () {
          return this.transceivers.filter(function (transceiver) {
            return !!transceiver.rtpReceiver;
          }).map(function (transceiver) {
            return transceiver.rtpReceiver;
          });
        };

        RTCPeerConnection.prototype._createIceGatherer = function (sdpMLineIndex, usingBundle) {
          var pc = this;

          if (usingBundle && sdpMLineIndex > 0) {
            return this.transceivers[0].iceGatherer;
          } else if (this._iceGatherers.length) {
            return this._iceGatherers.shift();
          }

          var iceGatherer = new window.RTCIceGatherer({
            iceServers: this._config.iceServers,
            gatherPolicy: this._config.iceTransportPolicy
          });
          Object.defineProperty(iceGatherer, 'state', {
            value: 'new',
            writable: true
          });
          this.transceivers[sdpMLineIndex].candidates = [];

          this.transceivers[sdpMLineIndex].bufferCandidates = function (event) {
            var end = !event.candidate || Object.keys(event.candidate).length === 0; // polyfill since RTCIceGatherer.state is not implemented in
            // Edge 10547 yet.

            iceGatherer.state = end ? 'completed' : 'gathering';

            if (pc.transceivers[sdpMLineIndex].candidates !== null) {
              pc.transceivers[sdpMLineIndex].candidates.push(event.candidate);
            }
          };

          iceGatherer.addEventListener('localcandidate', this.transceivers[sdpMLineIndex].bufferCandidates);
          return iceGatherer;
        }; // start gathering from an RTCIceGatherer.


        RTCPeerConnection.prototype._gather = function (mid, sdpMLineIndex) {
          var pc = this;
          var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;

          if (iceGatherer.onlocalcandidate) {
            return;
          }

          var candidates = this.transceivers[sdpMLineIndex].candidates;
          this.transceivers[sdpMLineIndex].candidates = null;
          iceGatherer.removeEventListener('localcandidate', this.transceivers[sdpMLineIndex].bufferCandidates);

          iceGatherer.onlocalcandidate = function (evt) {
            if (pc.usingBundle && sdpMLineIndex > 0) {
              // if we know that we use bundle we can drop candidates with
              // ѕdpMLineIndex > 0. If we don't do this then our state gets
              // confused since we dispose the extra ice gatherer.
              return;
            }

            var event = new Event('icecandidate');
            event.candidate = {
              sdpMid: mid,
              sdpMLineIndex: sdpMLineIndex
            };
            var cand = evt.candidate; // Edge emits an empty object for RTCIceCandidateComplete‥

            var end = !cand || Object.keys(cand).length === 0;

            if (end) {
              // polyfill since RTCIceGatherer.state is not implemented in
              // Edge 10547 yet.
              if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
                iceGatherer.state = 'completed';
              }
            } else {
              if (iceGatherer.state === 'new') {
                iceGatherer.state = 'gathering';
              } // RTCIceCandidate doesn't have a component, needs to be added


              cand.component = 1;
              event.candidate.candidate = SDPUtils.writeCandidate(cand);
            } // update local description.


            var sections = SDPUtils.splitSections(pc.localDescription.sdp);

            if (!end) {
              sections[event.candidate.sdpMLineIndex + 1] += 'a=' + event.candidate.candidate + '\r\n';
            } else {
              sections[event.candidate.sdpMLineIndex + 1] += 'a=end-of-candidates\r\n';
            }

            pc.localDescription.sdp = sections.join('');
            var complete = pc.transceivers.every(function (transceiver) {
              return transceiver.iceGatherer && transceiver.iceGatherer.state === 'completed';
            });

            if (pc.iceGatheringState !== 'gathering') {
              pc.iceGatheringState = 'gathering';

              pc._emitGatheringStateChange();
            } // Emit candidate. Also emit null candidate when all gatherers are
            // complete.


            if (!end) {
              pc._dispatchEvent('icecandidate', event);
            }

            if (complete) {
              pc._dispatchEvent('icecandidate', new Event('icecandidate'));

              pc.iceGatheringState = 'complete';

              pc._emitGatheringStateChange();
            }
          }; // emit already gathered candidates.


          window.setTimeout(function () {
            candidates.forEach(function (candidate) {
              var e = new Event('RTCIceGatherEvent');
              e.candidate = candidate;
              iceGatherer.onlocalcandidate(e);
            });
          }, 0);
        }; // Create ICE transport and DTLS transport.


        RTCPeerConnection.prototype._createIceAndDtlsTransports = function () {
          var pc = this;
          var iceTransport = new window.RTCIceTransport(null);

          iceTransport.onicestatechange = function () {
            pc._updateConnectionState();
          };

          var dtlsTransport = new window.RTCDtlsTransport(iceTransport);

          dtlsTransport.ondtlsstatechange = function () {
            pc._updateConnectionState();
          };

          dtlsTransport.onerror = function () {
            // onerror does not set state to failed by itpc.
            Object.defineProperty(dtlsTransport, 'state', {
              value: 'failed',
              writable: true
            });

            pc._updateConnectionState();
          };

          return {
            iceTransport: iceTransport,
            dtlsTransport: dtlsTransport
          };
        }; // Destroy ICE gatherer, ICE transport and DTLS transport.
        // Without triggering the callbacks.


        RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function (sdpMLineIndex) {
          var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;

          if (iceGatherer) {
            delete iceGatherer.onlocalcandidate;
            delete this.transceivers[sdpMLineIndex].iceGatherer;
          }

          var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;

          if (iceTransport) {
            delete iceTransport.onicestatechange;
            delete this.transceivers[sdpMLineIndex].iceTransport;
          }

          var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;

          if (dtlsTransport) {
            delete dtlsTransport.ondtlsstatechange;
            delete dtlsTransport.onerror;
            delete this.transceivers[sdpMLineIndex].dtlsTransport;
          }
        }; // Start the RTP Sender and Receiver for a transceiver.


        RTCPeerConnection.prototype._transceive = function (transceiver, send, recv) {
          var params = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);

          if (send && transceiver.rtpSender) {
            params.encodings = transceiver.sendEncodingParameters;
            params.rtcp = {
              cname: SDPUtils.localCName,
              compound: transceiver.rtcpParameters.compound
            };

            if (transceiver.recvEncodingParameters.length) {
              params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
            }

            transceiver.rtpSender.send(params);
          }

          if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
            // remove RTX field in Edge 14942
            if (transceiver.kind === 'video' && transceiver.recvEncodingParameters && edgeVersion < 15019) {
              transceiver.recvEncodingParameters.forEach(function (p) {
                delete p.rtx;
              });
            }

            if (transceiver.recvEncodingParameters.length) {
              params.encodings = transceiver.recvEncodingParameters;
            }

            params.rtcp = {
              compound: transceiver.rtcpParameters.compound
            };

            if (transceiver.rtcpParameters.cname) {
              params.rtcp.cname = transceiver.rtcpParameters.cname;
            }

            if (transceiver.sendEncodingParameters.length) {
              params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
            }

            transceiver.rtpReceiver.receive(params);
          }
        };

        RTCPeerConnection.prototype.setLocalDescription = function (description) {
          var pc = this;

          if (!isActionAllowedInSignalingState('setLocalDescription', description.type, this.signalingState) || this._isClosed) {
            return Promise.reject(makeError('InvalidStateError', 'Can not set local ' + description.type + ' in state ' + pc.signalingState));
          }

          var sections;
          var sessionpart;

          if (description.type === 'offer') {
            // VERY limited support for SDP munging. Limited to:
            // * changing the order of codecs
            sections = SDPUtils.splitSections(description.sdp);
            sessionpart = sections.shift();
            sections.forEach(function (mediaSection, sdpMLineIndex) {
              var caps = SDPUtils.parseRtpParameters(mediaSection);
              pc.transceivers[sdpMLineIndex].localCapabilities = caps;
            });
            this.transceivers.forEach(function (transceiver, sdpMLineIndex) {
              pc._gather(transceiver.mid, sdpMLineIndex);
            });
          } else if (description.type === 'answer') {
            sections = SDPUtils.splitSections(pc.remoteDescription.sdp);
            sessionpart = sections.shift();
            var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;
            sections.forEach(function (mediaSection, sdpMLineIndex) {
              var transceiver = pc.transceivers[sdpMLineIndex];
              var iceGatherer = transceiver.iceGatherer;
              var iceTransport = transceiver.iceTransport;
              var dtlsTransport = transceiver.dtlsTransport;
              var localCapabilities = transceiver.localCapabilities;
              var remoteCapabilities = transceiver.remoteCapabilities; // treat bundle-only as not-rejected.

              var rejected = SDPUtils.isRejected(mediaSection) && SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

              if (!rejected && !transceiver.isDatachannel) {
                var remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
                var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);

                if (isIceLite) {
                  remoteDtlsParameters.role = 'server';
                }

                if (!pc.usingBundle || sdpMLineIndex === 0) {
                  pc._gather(transceiver.mid, sdpMLineIndex);

                  if (iceTransport.state === 'new') {
                    iceTransport.start(iceGatherer, remoteIceParameters, isIceLite ? 'controlling' : 'controlled');
                  }

                  if (dtlsTransport.state === 'new') {
                    dtlsTransport.start(remoteDtlsParameters);
                  }
                } // Calculate intersection of capabilities.


                var params = getCommonCapabilities(localCapabilities, remoteCapabilities); // Start the RTCRtpSender. The RTCRtpReceiver for this
                // transceiver has already been started in setRemoteDescription.

                pc._transceive(transceiver, params.codecs.length > 0, false);
              }
            });
          }

          this.localDescription = {
            type: description.type,
            sdp: description.sdp
          };

          switch (description.type) {
            case 'offer':
              this._updateSignalingState('have-local-offer');

              break;

            case 'answer':
              this._updateSignalingState('stable');

              break;

            default:
              throw new TypeError('unsupported type "' + description.type + '"');
          }

          return Promise.resolve();
        };

        RTCPeerConnection.prototype.setRemoteDescription = function (description) {
          var pc = this;

          if (!isActionAllowedInSignalingState('setRemoteDescription', description.type, this.signalingState) || this._isClosed) {
            return Promise.reject(makeError('InvalidStateError', 'Can not set remote ' + description.type + ' in state ' + pc.signalingState));
          }

          var streams = {};
          this.remoteStreams.forEach(function (stream) {
            streams[stream.id] = stream;
          });
          var receiverList = [];
          var sections = SDPUtils.splitSections(description.sdp);
          var sessionpart = sections.shift();
          var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;
          var usingBundle = SDPUtils.matchPrefix(sessionpart, 'a=group:BUNDLE ').length > 0;
          this.usingBundle = usingBundle;
          var iceOptions = SDPUtils.matchPrefix(sessionpart, 'a=ice-options:')[0];

          if (iceOptions) {
            this.canTrickleIceCandidates = iceOptions.substr(14).split(' ').indexOf('trickle') >= 0;
          } else {
            this.canTrickleIceCandidates = false;
          }

          sections.forEach(function (mediaSection, sdpMLineIndex) {
            var lines = SDPUtils.splitLines(mediaSection);
            var kind = SDPUtils.getKind(mediaSection); // treat bundle-only as not-rejected.

            var rejected = SDPUtils.isRejected(mediaSection) && SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
            var protocol = lines[0].substr(2).split(' ')[2];
            var direction = SDPUtils.getDirection(mediaSection, sessionpart);
            var remoteMsid = SDPUtils.parseMsid(mediaSection);
            var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier(); // Reject datachannels which are not implemented yet.

            if (kind === 'application' && protocol === 'DTLS/SCTP') {
              pc.transceivers[sdpMLineIndex] = {
                mid: mid,
                isDatachannel: true
              };
              return;
            }

            var transceiver;
            var iceGatherer;
            var iceTransport;
            var dtlsTransport;
            var rtpReceiver;
            var sendEncodingParameters;
            var recvEncodingParameters;
            var localCapabilities;
            var track; // FIXME: ensure the mediaSection has rtcp-mux set.

            var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
            var remoteIceParameters;
            var remoteDtlsParameters;

            if (!rejected) {
              remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
              remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);
              remoteDtlsParameters.role = 'client';
            }

            recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection);
            var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);
            var isComplete = SDPUtils.matchPrefix(mediaSection, 'a=end-of-candidates', sessionpart).length > 0;
            var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:').map(function (cand) {
              return SDPUtils.parseCandidate(cand);
            }).filter(function (cand) {
              return cand.component === 1;
            }); // Check if we can use BUNDLE and dispose transports.

            if ((description.type === 'offer' || description.type === 'answer') && !rejected && usingBundle && sdpMLineIndex > 0 && pc.transceivers[sdpMLineIndex]) {
              pc._disposeIceAndDtlsTransports(sdpMLineIndex);

              pc.transceivers[sdpMLineIndex].iceGatherer = pc.transceivers[0].iceGatherer;
              pc.transceivers[sdpMLineIndex].iceTransport = pc.transceivers[0].iceTransport;
              pc.transceivers[sdpMLineIndex].dtlsTransport = pc.transceivers[0].dtlsTransport;

              if (pc.transceivers[sdpMLineIndex].rtpSender) {
                pc.transceivers[sdpMLineIndex].rtpSender.setTransport(pc.transceivers[0].dtlsTransport);
              }

              if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
                pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(pc.transceivers[0].dtlsTransport);
              }
            }

            if (description.type === 'offer' && !rejected) {
              transceiver = pc.transceivers[sdpMLineIndex] || pc._createTransceiver(kind);
              transceiver.mid = mid;

              if (!transceiver.iceGatherer) {
                transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, usingBundle);
              }

              if (cands.length && transceiver.iceTransport.state === 'new') {
                if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
                  transceiver.iceTransport.setRemoteCandidates(cands);
                } else {
                  cands.forEach(function (candidate) {
                    maybeAddCandidate(transceiver.iceTransport, candidate);
                  });
                }
              }

              localCapabilities = window.RTCRtpReceiver.getCapabilities(kind); // filter RTX until additional stuff needed for RTX is implemented
              // in adapter.js

              if (edgeVersion < 15019) {
                localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {
                  return codec.name !== 'rtx';
                });
              }

              sendEncodingParameters = transceiver.sendEncodingParameters || [{
                ssrc: (2 * sdpMLineIndex + 2) * 1001
              }]; // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams

              var isNewTrack = false;

              if (direction === 'sendrecv' || direction === 'sendonly') {
                isNewTrack = !transceiver.rtpReceiver;
                rtpReceiver = transceiver.rtpReceiver || new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

                if (isNewTrack) {
                  var stream;
                  track = rtpReceiver.track; // FIXME: does not work with Plan B.

                  if (remoteMsid && remoteMsid.stream === '-') {// no-op. a stream id of '-' means: no associated stream.
                  } else if (remoteMsid) {
                    if (!streams[remoteMsid.stream]) {
                      streams[remoteMsid.stream] = new window.MediaStream();
                      Object.defineProperty(streams[remoteMsid.stream], 'id', {
                        get: function () {
                          return remoteMsid.stream;
                        }
                      });
                    }

                    Object.defineProperty(track, 'id', {
                      get: function () {
                        return remoteMsid.track;
                      }
                    });
                    stream = streams[remoteMsid.stream];
                  } else {
                    if (!streams.default) {
                      streams.default = new window.MediaStream();
                    }

                    stream = streams.default;
                  }

                  if (stream) {
                    addTrackToStreamAndFireEvent(track, stream);
                    transceiver.associatedRemoteMediaStreams.push(stream);
                  }

                  receiverList.push([track, rtpReceiver, stream]);
                }
              } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
                transceiver.associatedRemoteMediaStreams.forEach(function (s) {
                  var nativeTrack = s.getTracks().find(function (t) {
                    return t.id === transceiver.rtpReceiver.track.id;
                  });

                  if (nativeTrack) {
                    removeTrackFromStreamAndFireEvent(nativeTrack, s);
                  }
                });
                transceiver.associatedRemoteMediaStreams = [];
              }

              transceiver.localCapabilities = localCapabilities;
              transceiver.remoteCapabilities = remoteCapabilities;
              transceiver.rtpReceiver = rtpReceiver;
              transceiver.rtcpParameters = rtcpParameters;
              transceiver.sendEncodingParameters = sendEncodingParameters;
              transceiver.recvEncodingParameters = recvEncodingParameters; // Start the RTCRtpReceiver now. The RTPSender is started in
              // setLocalDescription.

              pc._transceive(pc.transceivers[sdpMLineIndex], false, isNewTrack);
            } else if (description.type === 'answer' && !rejected) {
              transceiver = pc.transceivers[sdpMLineIndex];
              iceGatherer = transceiver.iceGatherer;
              iceTransport = transceiver.iceTransport;
              dtlsTransport = transceiver.dtlsTransport;
              rtpReceiver = transceiver.rtpReceiver;
              sendEncodingParameters = transceiver.sendEncodingParameters;
              localCapabilities = transceiver.localCapabilities;
              pc.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters;
              pc.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities;
              pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

              if (cands.length && iceTransport.state === 'new') {
                if ((isIceLite || isComplete) && (!usingBundle || sdpMLineIndex === 0)) {
                  iceTransport.setRemoteCandidates(cands);
                } else {
                  cands.forEach(function (candidate) {
                    maybeAddCandidate(transceiver.iceTransport, candidate);
                  });
                }
              }

              if (!usingBundle || sdpMLineIndex === 0) {
                if (iceTransport.state === 'new') {
                  iceTransport.start(iceGatherer, remoteIceParameters, 'controlling');
                }

                if (dtlsTransport.state === 'new') {
                  dtlsTransport.start(remoteDtlsParameters);
                }
              }

              pc._transceive(transceiver, direction === 'sendrecv' || direction === 'recvonly', direction === 'sendrecv' || direction === 'sendonly'); // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams


              if (rtpReceiver && (direction === 'sendrecv' || direction === 'sendonly')) {
                track = rtpReceiver.track;

                if (remoteMsid) {
                  if (!streams[remoteMsid.stream]) {
                    streams[remoteMsid.stream] = new window.MediaStream();
                  }

                  addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
                  receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
                } else {
                  if (!streams.default) {
                    streams.default = new window.MediaStream();
                  }

                  addTrackToStreamAndFireEvent(track, streams.default);
                  receiverList.push([track, rtpReceiver, streams.default]);
                }
              } else {
                // FIXME: actually the receiver should be created later.
                delete transceiver.rtpReceiver;
              }
            }
          });

          if (this._dtlsRole === undefined) {
            this._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
          }

          this.remoteDescription = {
            type: description.type,
            sdp: description.sdp
          };

          switch (description.type) {
            case 'offer':
              this._updateSignalingState('have-remote-offer');

              break;

            case 'answer':
              this._updateSignalingState('stable');

              break;

            default:
              throw new TypeError('unsupported type "' + description.type + '"');
          }

          Object.keys(streams).forEach(function (sid) {
            var stream = streams[sid];

            if (stream.getTracks().length) {
              if (pc.remoteStreams.indexOf(stream) === -1) {
                pc.remoteStreams.push(stream);
                var event = new Event('addstream');
                event.stream = stream;
                window.setTimeout(function () {
                  pc._dispatchEvent('addstream', event);
                });
              }

              receiverList.forEach(function (item) {
                var track = item[0];
                var receiver = item[1];

                if (stream.id !== item[2].id) {
                  return;
                }

                fireAddTrack(pc, track, receiver, [stream]);
              });
            }
          });
          receiverList.forEach(function (item) {
            if (item[2]) {
              return;
            }

            fireAddTrack(pc, item[0], item[1], []);
          }); // check whether addIceCandidate({}) was called within four seconds after
          // setRemoteDescription.

          window.setTimeout(function () {
            if (!(pc && pc.transceivers)) {
              return;
            }

            pc.transceivers.forEach(function (transceiver) {
              if (transceiver.iceTransport && transceiver.iceTransport.state === 'new' && transceiver.iceTransport.getRemoteCandidates().length > 0) {
                console.warn('Timeout for addRemoteCandidate. Consider sending ' + 'an end-of-candidates notification');
                transceiver.iceTransport.addRemoteCandidate({});
              }
            });
          }, 4000);
          return Promise.resolve();
        };

        RTCPeerConnection.prototype.close = function () {
          this.transceivers.forEach(function (transceiver) {
            /* not yet
            if (transceiver.iceGatherer) {
              transceiver.iceGatherer.close();
            }
            */
            if (transceiver.iceTransport) {
              transceiver.iceTransport.stop();
            }

            if (transceiver.dtlsTransport) {
              transceiver.dtlsTransport.stop();
            }

            if (transceiver.rtpSender) {
              transceiver.rtpSender.stop();
            }

            if (transceiver.rtpReceiver) {
              transceiver.rtpReceiver.stop();
            }
          }); // FIXME: clean up tracks, local streams, remote streams, etc

          this._isClosed = true;

          this._updateSignalingState('closed');
        }; // Update the signaling state.


        RTCPeerConnection.prototype._updateSignalingState = function (newState) {
          this.signalingState = newState;
          var event = new Event('signalingstatechange');

          this._dispatchEvent('signalingstatechange', event);
        }; // Determine whether to fire the negotiationneeded event.


        RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function () {
          var pc = this;

          if (this.signalingState !== 'stable' || this.needNegotiation === true) {
            return;
          }

          this.needNegotiation = true;
          window.setTimeout(function () {
            if (pc.needNegotiation === false) {
              return;
            }

            pc.needNegotiation = false;
            var event = new Event('negotiationneeded');

            pc._dispatchEvent('negotiationneeded', event);
          }, 0);
        }; // Update the connection state.


        RTCPeerConnection.prototype._updateConnectionState = function () {
          var newState;
          var states = {
            'new': 0,
            closed: 0,
            connecting: 0,
            checking: 0,
            connected: 0,
            completed: 0,
            disconnected: 0,
            failed: 0
          };
          this.transceivers.forEach(function (transceiver) {
            states[transceiver.iceTransport.state]++;
            states[transceiver.dtlsTransport.state]++;
          }); // ICETransport.completed and connected are the same for this purpose.

          states.connected += states.completed;
          newState = 'new';

          if (states.failed > 0) {
            newState = 'failed';
          } else if (states.connecting > 0 || states.checking > 0) {
            newState = 'connecting';
          } else if (states.disconnected > 0) {
            newState = 'disconnected';
          } else if (states.new > 0) {
            newState = 'new';
          } else if (states.connected > 0 || states.completed > 0) {
            newState = 'connected';
          }

          if (newState !== this.iceConnectionState) {
            this.iceConnectionState = newState;
            var event = new Event('iceconnectionstatechange');

            this._dispatchEvent('iceconnectionstatechange', event);
          }
        };

        RTCPeerConnection.prototype.createOffer = function () {
          var pc = this;

          if (this._isClosed) {
            return Promise.reject(makeError('InvalidStateError', 'Can not call createOffer after close'));
          }

          var numAudioTracks = this.transceivers.filter(function (t) {
            return t.kind === 'audio';
          }).length;
          var numVideoTracks = this.transceivers.filter(function (t) {
            return t.kind === 'video';
          }).length; // Determine number of audio and video tracks we need to send/recv.

          var offerOptions = arguments[0];

          if (offerOptions) {
            // Reject Chrome legacy constraints.
            if (offerOptions.mandatory || offerOptions.optional) {
              throw new TypeError('Legacy mandatory/optional constraints not supported.');
            }

            if (offerOptions.offerToReceiveAudio !== undefined) {
              if (offerOptions.offerToReceiveAudio === true) {
                numAudioTracks = 1;
              } else if (offerOptions.offerToReceiveAudio === false) {
                numAudioTracks = 0;
              } else {
                numAudioTracks = offerOptions.offerToReceiveAudio;
              }
            }

            if (offerOptions.offerToReceiveVideo !== undefined) {
              if (offerOptions.offerToReceiveVideo === true) {
                numVideoTracks = 1;
              } else if (offerOptions.offerToReceiveVideo === false) {
                numVideoTracks = 0;
              } else {
                numVideoTracks = offerOptions.offerToReceiveVideo;
              }
            }
          }

          this.transceivers.forEach(function (transceiver) {
            if (transceiver.kind === 'audio') {
              numAudioTracks--;

              if (numAudioTracks < 0) {
                transceiver.wantReceive = false;
              }
            } else if (transceiver.kind === 'video') {
              numVideoTracks--;

              if (numVideoTracks < 0) {
                transceiver.wantReceive = false;
              }
            }
          }); // Create M-lines for recvonly streams.

          while (numAudioTracks > 0 || numVideoTracks > 0) {
            if (numAudioTracks > 0) {
              this._createTransceiver('audio');

              numAudioTracks--;
            }

            if (numVideoTracks > 0) {
              this._createTransceiver('video');

              numVideoTracks--;
            }
          }

          var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId, this._sdpSessionVersion++);
          this.transceivers.forEach(function (transceiver, sdpMLineIndex) {
            // For each track, create an ice gatherer, ice transport,
            // dtls transport, potentially rtpsender and rtpreceiver.
            var track = transceiver.track;
            var kind = transceiver.kind;
            var mid = SDPUtils.generateIdentifier();
            transceiver.mid = mid;

            if (!transceiver.iceGatherer) {
              transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, pc.usingBundle);
            }

            var localCapabilities = window.RTCRtpSender.getCapabilities(kind); // filter RTX until additional stuff needed for RTX is implemented
            // in adapter.js

            if (edgeVersion < 15019) {
              localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {
                return codec.name !== 'rtx';
              });
            }

            localCapabilities.codecs.forEach(function (codec) {
              // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
              // by adding level-asymmetry-allowed=1
              if (codec.name === 'H264' && codec.parameters['level-asymmetry-allowed'] === undefined) {
                codec.parameters['level-asymmetry-allowed'] = '1';
              }
            }); // generate an ssrc now, to be used later in rtpSender.send

            var sendEncodingParameters = transceiver.sendEncodingParameters || [{
              ssrc: (2 * sdpMLineIndex + 1) * 1001
            }];

            if (track) {
              // add RTX
              if (edgeVersion >= 15019 && kind === 'video' && !sendEncodingParameters[0].rtx) {
                sendEncodingParameters[0].rtx = {
                  ssrc: sendEncodingParameters[0].ssrc + 1
                };
              }
            }

            if (transceiver.wantReceive) {
              transceiver.rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);
            }

            transceiver.localCapabilities = localCapabilities;
            transceiver.sendEncodingParameters = sendEncodingParameters;
          }); // always offer BUNDLE and dispose on return if not supported.

          if (this._config.bundlePolicy !== 'max-compat') {
            sdp += 'a=group:BUNDLE ' + this.transceivers.map(function (t) {
              return t.mid;
            }).join(' ') + '\r\n';
          }

          sdp += 'a=ice-options:trickle\r\n';
          this.transceivers.forEach(function (transceiver, sdpMLineIndex) {
            sdp += writeMediaSection(transceiver, transceiver.localCapabilities, 'offer', transceiver.stream, pc._dtlsRole);
            sdp += 'a=rtcp-rsize\r\n';

            if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' && (sdpMLineIndex === 0 || !pc.usingBundle)) {
              transceiver.iceGatherer.getLocalCandidates().forEach(function (cand) {
                cand.component = 1;
                sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
              });

              if (transceiver.iceGatherer.state === 'completed') {
                sdp += 'a=end-of-candidates\r\n';
              }
            }
          });
          var desc = new window.RTCSessionDescription({
            type: 'offer',
            sdp: sdp
          });
          return Promise.resolve(desc);
        };

        RTCPeerConnection.prototype.createAnswer = function () {
          var pc = this;

          if (this._isClosed) {
            return Promise.reject(makeError('InvalidStateError', 'Can not call createAnswer after close'));
          }

          var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId, this._sdpSessionVersion++);

          if (this.usingBundle) {
            sdp += 'a=group:BUNDLE ' + this.transceivers.map(function (t) {
              return t.mid;
            }).join(' ') + '\r\n';
          }

          var mediaSectionsInOffer = SDPUtils.splitSections(this.remoteDescription.sdp).length - 1;
          this.transceivers.forEach(function (transceiver, sdpMLineIndex) {
            if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
              return;
            }

            if (transceiver.isDatachannel) {
              sdp += 'm=application 0 DTLS/SCTP 5000\r\n' + 'c=IN IP4 0.0.0.0\r\n' + 'a=mid:' + transceiver.mid + '\r\n';
              return;
            } // FIXME: look at direction.


            if (transceiver.stream) {
              var localTrack;

              if (transceiver.kind === 'audio') {
                localTrack = transceiver.stream.getAudioTracks()[0];
              } else if (transceiver.kind === 'video') {
                localTrack = transceiver.stream.getVideoTracks()[0];
              }

              if (localTrack) {
                // add RTX
                if (edgeVersion >= 15019 && transceiver.kind === 'video' && !transceiver.sendEncodingParameters[0].rtx) {
                  transceiver.sendEncodingParameters[0].rtx = {
                    ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
                  };
                }
              }
            } // Calculate intersection of capabilities.


            var commonCapabilities = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);
            var hasRtx = commonCapabilities.codecs.filter(function (c) {
              return c.name.toLowerCase() === 'rtx';
            }).length;

            if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
              delete transceiver.sendEncodingParameters[0].rtx;
            }

            sdp += writeMediaSection(transceiver, commonCapabilities, 'answer', transceiver.stream, pc._dtlsRole);

            if (transceiver.rtcpParameters && transceiver.rtcpParameters.reducedSize) {
              sdp += 'a=rtcp-rsize\r\n';
            }
          });
          var desc = new window.RTCSessionDescription({
            type: 'answer',
            sdp: sdp
          });
          return Promise.resolve(desc);
        };

        RTCPeerConnection.prototype.addIceCandidate = function (candidate) {
          var sections;

          if (!candidate || candidate.candidate === '') {
            for (var j = 0; j < this.transceivers.length; j++) {
              if (this.transceivers[j].isDatachannel) {
                continue;
              }

              this.transceivers[j].iceTransport.addRemoteCandidate({});
              sections = SDPUtils.splitSections(this.remoteDescription.sdp);
              sections[j + 1] += 'a=end-of-candidates\r\n';
              this.remoteDescription.sdp = sections.join('');

              if (this.usingBundle) {
                break;
              }
            }
          } else if (!(candidate.sdpMLineIndex !== undefined || candidate.sdpMid)) {
            throw new TypeError('sdpMLineIndex or sdpMid required');
          } else if (!this.remoteDescription) {
            return Promise.reject(makeError('InvalidStateError', 'Can not add ICE candidate without a remote description'));
          } else {
            var sdpMLineIndex = candidate.sdpMLineIndex;

            if (candidate.sdpMid) {
              for (var i = 0; i < this.transceivers.length; i++) {
                if (this.transceivers[i].mid === candidate.sdpMid) {
                  sdpMLineIndex = i;
                  break;
                }
              }
            }

            var transceiver = this.transceivers[sdpMLineIndex];

            if (transceiver) {
              if (transceiver.isDatachannel) {
                return Promise.resolve();
              }

              var cand = Object.keys(candidate.candidate).length > 0 ? SDPUtils.parseCandidate(candidate.candidate) : {}; // Ignore Chrome's invalid candidates since Edge does not like them.

              if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
                return Promise.resolve();
              } // Ignore RTCP candidates, we assume RTCP-MUX.


              if (cand.component && cand.component !== 1) {
                return Promise.resolve();
              } // when using bundle, avoid adding candidates to the wrong
              // ice transport. And avoid adding candidates added in the SDP.


              if (sdpMLineIndex === 0 || sdpMLineIndex > 0 && transceiver.iceTransport !== this.transceivers[0].iceTransport) {
                if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
                  return Promise.reject(makeError('OperationError', 'Can not add ICE candidate'));
                }
              } // update the remoteDescription.


              var candidateString = candidate.candidate.trim();

              if (candidateString.indexOf('a=') === 0) {
                candidateString = candidateString.substr(2);
              }

              sections = SDPUtils.splitSections(this.remoteDescription.sdp);
              sections[sdpMLineIndex + 1] += 'a=' + (cand.type ? candidateString : 'end-of-candidates') + '\r\n';
              this.remoteDescription.sdp = sections.join('');
            } else {
              return Promise.reject(makeError('OperationError', 'Can not add ICE candidate'));
            }
          }

          return Promise.resolve();
        };

        RTCPeerConnection.prototype.getStats = function () {
          var promises = [];
          this.transceivers.forEach(function (transceiver) {
            ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function (method) {
              if (transceiver[method]) {
                promises.push(transceiver[method].getStats());
              }
            });
          });

          var fixStatsType = function (stat) {
            return {
              inboundrtp: 'inbound-rtp',
              outboundrtp: 'outbound-rtp',
              candidatepair: 'candidate-pair',
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[stat.type] || stat.type;
          };

          return new Promise(function (resolve) {
            // shim getStats with maplike support
            var results = new Map();
            Promise.all(promises).then(function (res) {
              res.forEach(function (result) {
                Object.keys(result).forEach(function (id) {
                  result[id].type = fixStatsType(result[id]);
                  results.set(id, result[id]);
                });
              });
              resolve(results);
            });
          });
        }; // legacy callback shims. Should be moved to adapter.js some days.


        var methods = ['createOffer', 'createAnswer'];
        methods.forEach(function (method) {
          var nativeMethod = RTCPeerConnection.prototype[method];

          RTCPeerConnection.prototype[method] = function () {
            var args = arguments;

            if (typeof args[0] === 'function' || typeof args[1] === 'function') {
              // legacy
              return nativeMethod.apply(this, [arguments[2]]).then(function (description) {
                if (typeof args[0] === 'function') {
                  args[0].apply(null, [description]);
                }
              }, function (error) {
                if (typeof args[1] === 'function') {
                  args[1].apply(null, [error]);
                }
              });
            }

            return nativeMethod.apply(this, arguments);
          };
        });
        methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
        methods.forEach(function (method) {
          var nativeMethod = RTCPeerConnection.prototype[method];

          RTCPeerConnection.prototype[method] = function () {
            var args = arguments;

            if (typeof args[1] === 'function' || typeof args[2] === 'function') {
              // legacy
              return nativeMethod.apply(this, arguments).then(function () {
                if (typeof args[1] === 'function') {
                  args[1].apply(null);
                }
              }, function (error) {
                if (typeof args[2] === 'function') {
                  args[2].apply(null, [error]);
                }
              });
            }

            return nativeMethod.apply(this, arguments);
          };
        }); // getStats is special. It doesn't have a spec legacy method yet we support
        // getStats(something, cb) without error callbacks.

        ['getStats'].forEach(function (method) {
          var nativeMethod = RTCPeerConnection.prototype[method];

          RTCPeerConnection.prototype[method] = function () {
            var args = arguments;

            if (typeof args[1] === 'function') {
              return nativeMethod.apply(this, arguments).then(function () {
                if (typeof args[1] === 'function') {
                  args[1].apply(null);
                }
              });
            }

            return nativeMethod.apply(this, arguments);
          };
        });
        return RTCPeerConnection;
      };
    }, {
      "sdp": 2
    }],
    2: [function (require, module, exports) {
      /* eslint-env node */
      'use strict'; // SDP helpers.

      var SDPUtils = {}; // Generate an alphanumeric identifier for cname or mids.
      // TODO: use UUIDs instead? https://gist.github.com/jed/982883

      SDPUtils.generateIdentifier = function () {
        return Math.random().toString(36).substr(2, 10);
      }; // The RTCP CNAME used by all peerconnections from the same JS.


      SDPUtils.localCName = SDPUtils.generateIdentifier(); // Splits SDP into lines, dealing with both CRLF and LF.

      SDPUtils.splitLines = function (blob) {
        return blob.trim().split('\n').map(function (line) {
          return line.trim();
        });
      }; // Splits SDP into sessionpart and mediasections. Ensures CRLF.


      SDPUtils.splitSections = function (blob) {
        var parts = blob.split('\nm=');
        return parts.map(function (part, index) {
          return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
        });
      }; // Returns lines that start with a certain prefix.


      SDPUtils.matchPrefix = function (blob, prefix) {
        return SDPUtils.splitLines(blob).filter(function (line) {
          return line.indexOf(prefix) === 0;
        });
      }; // Parses an ICE candidate line. Sample input:
      // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
      // rport 55996"


      SDPUtils.parseCandidate = function (line) {
        var parts; // Parse both variants.

        if (line.indexOf('a=candidate:') === 0) {
          parts = line.substring(12).split(' ');
        } else {
          parts = line.substring(10).split(' ');
        }

        var candidate = {
          foundation: parts[0],
          component: parseInt(parts[1], 10),
          protocol: parts[2].toLowerCase(),
          priority: parseInt(parts[3], 10),
          ip: parts[4],
          port: parseInt(parts[5], 10),
          // skip parts[6] == 'typ'
          type: parts[7]
        };

        for (var i = 8; i < parts.length; i += 2) {
          switch (parts[i]) {
            case 'raddr':
              candidate.relatedAddress = parts[i + 1];
              break;

            case 'rport':
              candidate.relatedPort = parseInt(parts[i + 1], 10);
              break;

            case 'tcptype':
              candidate.tcpType = parts[i + 1];
              break;

            case 'ufrag':
              candidate.ufrag = parts[i + 1]; // for backward compability.

              candidate.usernameFragment = parts[i + 1];
              break;

            default:
              // extension handling, in particular ufrag
              candidate[parts[i]] = parts[i + 1];
              break;
          }
        }

        return candidate;
      }; // Translates a candidate object into SDP candidate attribute.


      SDPUtils.writeCandidate = function (candidate) {
        var sdp = [];
        sdp.push(candidate.foundation);
        sdp.push(candidate.component);
        sdp.push(candidate.protocol.toUpperCase());
        sdp.push(candidate.priority);
        sdp.push(candidate.ip);
        sdp.push(candidate.port);
        var type = candidate.type;
        sdp.push('typ');
        sdp.push(type);

        if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {
          sdp.push('raddr');
          sdp.push(candidate.relatedAddress); // was: relAddr

          sdp.push('rport');
          sdp.push(candidate.relatedPort); // was: relPort
        }

        if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
          sdp.push('tcptype');
          sdp.push(candidate.tcpType);
        }

        if (candidate.ufrag) {
          sdp.push('ufrag');
          sdp.push(candidate.ufrag);
        }

        return 'candidate:' + sdp.join(' ');
      }; // Parses an ice-options line, returns an array of option tags.
      // a=ice-options:foo bar


      SDPUtils.parseIceOptions = function (line) {
        return line.substr(14).split(' ');
      }; // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
      // a=rtpmap:111 opus/48000/2


      SDPUtils.parseRtpMap = function (line) {
        var parts = line.substr(9).split(' ');
        var parsed = {
          payloadType: parseInt(parts.shift(), 10) // was: id

        };
        parts = parts[0].split('/');
        parsed.name = parts[0];
        parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
        // was: channels

        parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
        return parsed;
      }; // Generate an a=rtpmap line from RTCRtpCodecCapability or
      // RTCRtpCodecParameters.


      SDPUtils.writeRtpMap = function (codec) {
        var pt = codec.payloadType;

        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }

        return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
      }; // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset


      SDPUtils.parseExtmap = function (line) {
        var parts = line.substr(9).split(' ');
        return {
          id: parseInt(parts[0], 10),
          direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
          uri: parts[1]
        };
      }; // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
      // RTCRtpHeaderExtension.


      SDPUtils.writeExtmap = function (headerExtension) {
        return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\r\n';
      }; // Parses an ftmp line, returns dictionary. Sample input:
      // a=fmtp:96 vbr=on;cng=on
      // Also deals with vbr=on; cng=on


      SDPUtils.parseFmtp = function (line) {
        var parsed = {};
        var kv;
        var parts = line.substr(line.indexOf(' ') + 1).split(';');

        for (var j = 0; j < parts.length; j++) {
          kv = parts[j].trim().split('=');
          parsed[kv[0].trim()] = kv[1];
        }

        return parsed;
      }; // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.


      SDPUtils.writeFmtp = function (codec) {
        var line = '';
        var pt = codec.payloadType;

        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }

        if (codec.parameters && Object.keys(codec.parameters).length) {
          var params = [];
          Object.keys(codec.parameters).forEach(function (param) {
            params.push(param + '=' + codec.parameters[param]);
          });
          line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
        }

        return line;
      }; // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
      // a=rtcp-fb:98 nack rpsi


      SDPUtils.parseRtcpFb = function (line) {
        var parts = line.substr(line.indexOf(' ') + 1).split(' ');
        return {
          type: parts.shift(),
          parameter: parts.join(' ')
        };
      }; // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.


      SDPUtils.writeRtcpFb = function (codec) {
        var lines = '';
        var pt = codec.payloadType;

        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }

        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
          // FIXME: special handling for trr-int?
          codec.rtcpFeedback.forEach(function (fb) {
            lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\r\n';
          });
        }

        return lines;
      }; // Parses an RFC 5576 ssrc media attribute. Sample input:
      // a=ssrc:3735928559 cname:something


      SDPUtils.parseSsrcMedia = function (line) {
        var sp = line.indexOf(' ');
        var parts = {
          ssrc: parseInt(line.substr(7, sp - 7), 10)
        };
        var colon = line.indexOf(':', sp);

        if (colon > -1) {
          parts.attribute = line.substr(sp + 1, colon - sp - 1);
          parts.value = line.substr(colon + 1);
        } else {
          parts.attribute = line.substr(sp + 1);
        }

        return parts;
      }; // Extracts the MID (RFC 5888) from a media section.
      // returns the MID or undefined if no mid line was found.


      SDPUtils.getMid = function (mediaSection) {
        var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];

        if (mid) {
          return mid.substr(6);
        }
      };

      SDPUtils.parseFingerprint = function (line) {
        var parts = line.substr(14).split(' ');
        return {
          algorithm: parts[0].toLowerCase(),
          // algorithm is case-sensitive in Edge.
          value: parts[1]
        };
      }; // Extracts DTLS parameters from SDP media section or sessionpart.
      // FIXME: for consistency with other functions this should only
      //   get the fingerprint line as input. See also getIceParameters.


      SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
        var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:'); // Note: a=setup line is ignored since we use the 'auto' role.
        // Note2: 'algorithm' is not case sensitive except in Edge.

        return {
          role: 'auto',
          fingerprints: lines.map(SDPUtils.parseFingerprint)
        };
      }; // Serializes DTLS parameters to SDP.


      SDPUtils.writeDtlsParameters = function (params, setupType) {
        var sdp = 'a=setup:' + setupType + '\r\n';
        params.fingerprints.forEach(function (fp) {
          sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
        });
        return sdp;
      }; // Parses ICE information from SDP media section or sessionpart.
      // FIXME: for consistency with other functions this should only
      //   get the ice-ufrag and ice-pwd lines as input.


      SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
        var lines = SDPUtils.splitLines(mediaSection); // Search in session part, too.

        lines = lines.concat(SDPUtils.splitLines(sessionpart));
        var iceParameters = {
          usernameFragment: lines.filter(function (line) {
            return line.indexOf('a=ice-ufrag:') === 0;
          })[0].substr(12),
          password: lines.filter(function (line) {
            return line.indexOf('a=ice-pwd:') === 0;
          })[0].substr(10)
        };
        return iceParameters;
      }; // Serializes ICE parameters to SDP.


      SDPUtils.writeIceParameters = function (params) {
        return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' + 'a=ice-pwd:' + params.password + '\r\n';
      }; // Parses the SDP media section and returns RTCRtpParameters.


      SDPUtils.parseRtpParameters = function (mediaSection) {
        var description = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: [],
          rtcp: []
        };
        var lines = SDPUtils.splitLines(mediaSection);
        var mline = lines[0].split(' ');

        for (var i = 3; i < mline.length; i++) {
          // find all codecs from mline[3..]
          var pt = mline[i];
          var rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];

          if (rtpmapline) {
            var codec = SDPUtils.parseRtpMap(rtpmapline);
            var fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' '); // Only the first a=fmtp:<pt> is considered.

            codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
            codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);
            description.codecs.push(codec); // parse FEC mechanisms from rtpmap lines.

            switch (codec.name.toUpperCase()) {
              case 'RED':
              case 'ULPFEC':
                description.fecMechanisms.push(codec.name.toUpperCase());
                break;

              default:
                // only RED and ULPFEC are recognized as FEC mechanisms.
                break;
            }
          }
        }

        SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function (line) {
          description.headerExtensions.push(SDPUtils.parseExtmap(line));
        }); // FIXME: parse rtcp.

        return description;
      }; // Generates parts of the SDP media section describing the capabilities /
      // parameters.


      SDPUtils.writeRtpDescription = function (kind, caps) {
        var sdp = ''; // Build the mline.

        sdp += 'm=' + kind + ' ';
        sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.

        sdp += ' UDP/TLS/RTP/SAVPF ';
        sdp += caps.codecs.map(function (codec) {
          if (codec.preferredPayloadType !== undefined) {
            return codec.preferredPayloadType;
          }

          return codec.payloadType;
        }).join(' ') + '\r\n';
        sdp += 'c=IN IP4 0.0.0.0\r\n';
        sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n'; // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.

        caps.codecs.forEach(function (codec) {
          sdp += SDPUtils.writeRtpMap(codec);
          sdp += SDPUtils.writeFmtp(codec);
          sdp += SDPUtils.writeRtcpFb(codec);
        });
        var maxptime = 0;
        caps.codecs.forEach(function (codec) {
          if (codec.maxptime > maxptime) {
            maxptime = codec.maxptime;
          }
        });

        if (maxptime > 0) {
          sdp += 'a=maxptime:' + maxptime + '\r\n';
        }

        sdp += 'a=rtcp-mux\r\n';
        caps.headerExtensions.forEach(function (extension) {
          sdp += SDPUtils.writeExtmap(extension);
        }); // FIXME: write fecMechanisms.

        return sdp;
      }; // Parses the SDP media section and returns an array of
      // RTCRtpEncodingParameters.


      SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
        var encodingParameters = [];
        var description = SDPUtils.parseRtpParameters(mediaSection);
        var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
        var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1; // filter a=ssrc:... cname:, ignore PlanB-msid

        var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
          return SDPUtils.parseSsrcMedia(line);
        }).filter(function (parts) {
          return parts.attribute === 'cname';
        });
        var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
        var secondarySsrc;
        var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(function (line) {
          var parts = line.split(' ');
          parts.shift();
          return parts.map(function (part) {
            return parseInt(part, 10);
          });
        });

        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
          secondarySsrc = flows[0][1];
        }

        description.codecs.forEach(function (codec) {
          if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
            var encParam = {
              ssrc: primarySsrc,
              codecPayloadType: parseInt(codec.parameters.apt, 10),
              rtx: {
                ssrc: secondarySsrc
              }
            };
            encodingParameters.push(encParam);

            if (hasRed) {
              encParam = JSON.parse(JSON.stringify(encParam));
              encParam.fec = {
                ssrc: secondarySsrc,
                mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
              };
              encodingParameters.push(encParam);
            }
          }
        });

        if (encodingParameters.length === 0 && primarySsrc) {
          encodingParameters.push({
            ssrc: primarySsrc
          });
        } // we support both b=AS and b=TIAS but interpret AS as TIAS.


        var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');

        if (bandwidth.length) {
          if (bandwidth[0].indexOf('b=TIAS:') === 0) {
            bandwidth = parseInt(bandwidth[0].substr(7), 10);
          } else if (bandwidth[0].indexOf('b=AS:') === 0) {
            // use formula from JSEP to convert b=AS to TIAS value.
            bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;
          } else {
            bandwidth = undefined;
          }

          encodingParameters.forEach(function (params) {
            params.maxBitrate = bandwidth;
          });
        }

        return encodingParameters;
      }; // parses http://draft.ortc.org/#rtcrtcpparameters*


      SDPUtils.parseRtcpParameters = function (mediaSection) {
        var rtcpParameters = {};
        var cname; // Gets the first SSRC. Note that with RTX there might be multiple
        // SSRCs.

        var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
          return SDPUtils.parseSsrcMedia(line);
        }).filter(function (obj) {
          return obj.attribute === 'cname';
        })[0];

        if (remoteSsrc) {
          rtcpParameters.cname = remoteSsrc.value;
          rtcpParameters.ssrc = remoteSsrc.ssrc;
        } // Edge uses the compound attribute instead of reducedSize
        // compound is !reducedSize


        var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
        rtcpParameters.reducedSize = rsize.length > 0;
        rtcpParameters.compound = rsize.length === 0; // parses the rtcp-mux attrіbute.
        // Note that Edge does not support unmuxed RTCP.

        var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
        rtcpParameters.mux = mux.length > 0;
        return rtcpParameters;
      }; // parses either a=msid: or a=ssrc:... msid lines and returns
      // the id of the MediaStream and MediaStreamTrack.


      SDPUtils.parseMsid = function (mediaSection) {
        var parts;
        var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');

        if (spec.length === 1) {
          parts = spec[0].substr(7).split(' ');
          return {
            stream: parts[0],
            track: parts[1]
          };
        }

        var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
          return SDPUtils.parseSsrcMedia(line);
        }).filter(function (parts) {
          return parts.attribute === 'msid';
        });

        if (planB.length > 0) {
          parts = planB[0].value.split(' ');
          return {
            stream: parts[0],
            track: parts[1]
          };
        }
      }; // Generate a session ID for SDP.
      // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
      // recommends using a cryptographically random +ve 64-bit value
      // but right now this should be acceptable and within the right range


      SDPUtils.generateSessionId = function () {
        return Math.random().toString().substr(2, 21);
      }; // Write boilder plate for start of SDP
      // sessId argument is optional - if not supplied it will
      // be generated randomly
      // sessVersion is optional and defaults to 2


      SDPUtils.writeSessionBoilerplate = function (sessId, sessVer) {
        var sessionId;
        var version = sessVer !== undefined ? sessVer : 2;

        if (sessId) {
          sessionId = sessId;
        } else {
          sessionId = SDPUtils.generateSessionId();
        } // FIXME: sess-id should be an NTP timestamp.


        return 'v=0\r\n' + 'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' + 's=-\r\n' + 't=0 0\r\n';
      };

      SDPUtils.writeMediaSection = function (transceiver, caps, type, stream) {
        var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps); // Map ICE parameters (ufrag, pwd) to SDP.

        sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters()); // Map DTLS parameters to SDP.

        sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : 'active');
        sdp += 'a=mid:' + transceiver.mid + '\r\n';

        if (transceiver.direction) {
          sdp += 'a=' + transceiver.direction + '\r\n';
        } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
          sdp += 'a=sendrecv\r\n';
        } else if (transceiver.rtpSender) {
          sdp += 'a=sendonly\r\n';
        } else if (transceiver.rtpReceiver) {
          sdp += 'a=recvonly\r\n';
        } else {
          sdp += 'a=inactive\r\n';
        }

        if (transceiver.rtpSender) {
          // spec.
          var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\r\n';
          sdp += 'a=' + msid; // for Chrome.

          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;

          if (transceiver.sendEncodingParameters[0].rtx) {
            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
            sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
          }
        } // FIXME: this should be written by writeRtpDescription.


        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';

        if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
        }

        return sdp;
      }; // Gets the direction from the mediaSection or the sessionpart.


      SDPUtils.getDirection = function (mediaSection, sessionpart) {
        // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
        var lines = SDPUtils.splitLines(mediaSection);

        for (var i = 0; i < lines.length; i++) {
          switch (lines[i]) {
            case 'a=sendrecv':
            case 'a=sendonly':
            case 'a=recvonly':
            case 'a=inactive':
              return lines[i].substr(2);

            default: // FIXME: What should happen here?

          }
        }

        if (sessionpart) {
          return SDPUtils.getDirection(sessionpart);
        }

        return 'sendrecv';
      };

      SDPUtils.getKind = function (mediaSection) {
        var lines = SDPUtils.splitLines(mediaSection);
        var mline = lines[0].split(' ');
        return mline[0].substr(2);
      };

      SDPUtils.isRejected = function (mediaSection) {
        return mediaSection.split(' ', 2)[1] === '0';
      };

      SDPUtils.parseMLine = function (mediaSection) {
        var lines = SDPUtils.splitLines(mediaSection);
        var mline = lines[0].split(' ');
        return {
          kind: mline[0].substr(2),
          port: parseInt(mline[1], 10),
          protocol: mline[2],
          fmt: mline.slice(3).join(' ')
        };
      }; // Expose public methods.


      if (typeof module === 'object') {
        module.exports = SDPUtils;
      }
    }, {}],
    3: [function (require, module, exports) {
      (function (global) {
        /*
        *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
        *
        *  Use of this source code is governed by a BSD-style license
        *  that can be found in the LICENSE file in the root of the source
        *  tree.
        */

        /* eslint-env node */
        'use strict';

        var adapterFactory = require('./adapter_factory.js');

        module.exports = adapterFactory({
          window: global.window
        });
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "./adapter_factory.js": 4
    }],
    4: [function (require, module, exports) {
      /*
      *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */

      /* eslint-env node */
      'use strict';

      var utils = require('./utils'); // Shimming starts here.


      module.exports = function (dependencies, opts) {
        var window = dependencies && dependencies.window;
        var options = {
          shimChrome: true,
          shimFirefox: true,
          shimEdge: true,
          shimSafari: true
        };

        for (var key in opts) {
          if (hasOwnProperty.call(opts, key)) {
            options[key] = opts[key];
          }
        } // Utils.


        var logging = utils.log;
        var browserDetails = utils.detectBrowser(window); // Uncomment the line below if you want logging to occur, including logging
        // for the switch statement below. Can also be turned on in the browser via
        // adapter.disableLog(false), but then logging from the switch statement below
        // will not appear.
        // require('./utils').disableLog(false);
        // Browser shims.

        var chromeShim = require('./chrome/chrome_shim') || null;
        var edgeShim = require('./edge/edge_shim') || null;
        var firefoxShim = require('./firefox/firefox_shim') || null;
        var safariShim = require('./safari/safari_shim') || null;
        var commonShim = require('./common_shim') || null; // Export to the adapter global object visible in the browser.

        var adapter = {
          browserDetails: browserDetails,
          commonShim: commonShim,
          extractVersion: utils.extractVersion,
          disableLog: utils.disableLog,
          disableWarnings: utils.disableWarnings
        }; // Shim browser if found.

        console.log(`browserDetails.browser--------000------",${browserDetails.browser}`);

        switch (browserDetails.browser) {
          case 'chrome':
            if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
              logging('Chrome shim is not included in this adapter release.');
              return adapter;
            }

            logging('adapter.js shimming chrome.'); // Export to the adapter global object visible in the browser.

            adapter.browserShim = chromeShim;
            commonShim.shimCreateObjectURL(window);
            chromeShim.shimGetUserMedia(window);
            chromeShim.shimMediaStream(window);
            chromeShim.shimSourceObject(window);
            chromeShim.shimPeerConnection(window);
            chromeShim.shimOnTrack(window);
            chromeShim.shimAddTrackRemoveTrack(window);
            chromeShim.shimGetSendersWithDtmf(window);
            commonShim.shimRTCIceCandidate(window);
            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            break;

          case 'firefox':
            if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
              logging('Firefox shim is not included in this adapter release.');
              return adapter;
            }

            logging('adapter.js shimming firefox.'); // Export to the adapter global object visible in the browser.

            adapter.browserShim = firefoxShim;
            commonShim.shimCreateObjectURL(window);
            firefoxShim.shimGetUserMedia(window);
            firefoxShim.shimSourceObject(window);
            firefoxShim.shimPeerConnection(window);
            firefoxShim.shimOnTrack(window);
            firefoxShim.shimRemoveStream(window);
            commonShim.shimRTCIceCandidate(window);
            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            break;

          case 'edge':
            if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
              logging('MS edge shim is not included in this adapter release.');
              return adapter;
            }

            logging('adapter.js shimming edge.'); // Export to the adapter global object visible in the browser.

            adapter.browserShim = edgeShim;
            commonShim.shimCreateObjectURL(window);
            edgeShim.shimGetUserMedia(window);
            edgeShim.shimPeerConnection(window);
            edgeShim.shimReplaceTrack(window); // the edge shim implements the full RTCIceCandidate object.

            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            break;

          case 'safari':
            if (!safariShim || !options.shimSafari) {
              logging('Safari shim is not included in this adapter release.');
              return adapter;
            }

            logging('adapter.js shimming safari.'); // Export to the adapter global object visible in the browser.

            adapter.browserShim = safariShim;
            commonShim.shimCreateObjectURL(window);
            safariShim.shimRTCIceServerUrls(window);
            safariShim.shimCallbacksAPI(window);
            safariShim.shimLocalStreamsAPI(window);
            safariShim.shimRemoteStreamsAPI(window);
            safariShim.shimTrackEventTransceiver(window);
            safariShim.shimGetUserMedia(window);
            safariShim.shimCreateOfferLegacy(window);
            commonShim.shimRTCIceCandidate(window);
            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            break;

          default:
            logging('Unsupported browser!');
            break;
        }

        return adapter;
      };
    }, {
      "./chrome/chrome_shim": 5,
      "./common_shim": 7,
      "./edge/edge_shim": 8,
      "./firefox/firefox_shim": 10,
      "./safari/safari_shim": 12,
      "./utils": 13
    }],
    5: [function (require, module, exports) {
      /*
      *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */

      /* eslint-env node */
      'use strict';

      var utils = require('../utils.js');

      var logging = utils.log;
      module.exports = {
        shimGetUserMedia: require('./getusermedia'),
        shimMediaStream: function (window) {
          window.MediaStream = window.MediaStream || window.webkitMediaStream;
        },
        shimOnTrack: function (window) {
          if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
              get: function () {
                return this._ontrack;
              },
              set: function (f) {
                if (this._ontrack) {
                  this.removeEventListener('track', this._ontrack);
                }

                this.addEventListener('track', this._ontrack = f);
              }
            });
            var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

            window.RTCPeerConnection.prototype.setRemoteDescription = function () {
              var pc = this;

              if (!pc._ontrackpoly) {
                pc._ontrackpoly = function (e) {
                  // onaddstream does not fire when a track is added to an existing
                  // stream. But stream.onaddtrack is implemented so we use that.
                  e.stream.addEventListener('addtrack', function (te) {
                    var receiver;

                    if (window.RTCPeerConnection.prototype.getReceivers) {
                      receiver = pc.getReceivers().find(function (r) {
                        return r.track && r.track.id === te.track.id;
                      });
                    } else {
                      receiver = {
                        track: te.track
                      };
                    }

                    var event = new Event('track');
                    event.track = te.track;
                    event.receiver = receiver;
                    event.transceiver = {
                      receiver: receiver
                    };
                    event.streams = [e.stream];
                    pc.dispatchEvent(event);
                  });
                  e.stream.getTracks().forEach(function (track) {
                    var receiver;

                    if (window.RTCPeerConnection.prototype.getReceivers) {
                      receiver = pc.getReceivers().find(function (r) {
                        return r.track && r.track.id === track.id;
                      });
                    } else {
                      receiver = {
                        track: track
                      };
                    }

                    var event = new Event('track');
                    event.track = track;
                    event.receiver = receiver;
                    event.transceiver = {
                      receiver: receiver
                    };
                    event.streams = [e.stream];
                    pc.dispatchEvent(event);
                  });
                };

                pc.addEventListener('addstream', pc._ontrackpoly);
              }

              return origSetRemoteDescription.apply(pc, arguments);
            };
          } else if (!('RTCRtpTransceiver' in window)) {
            utils.wrapPeerConnectionEvent(window, 'track', function (e) {
              if (!e.transceiver) {
                e.transceiver = {
                  receiver: e.receiver
                };
              }

              return e;
            });
          }
        },
        shimGetSendersWithDtmf: function (window) {
          // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
          if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
            var shimSenderWithDtmf = function (pc, track) {
              return {
                track: track,

                get dtmf() {
                  if (this._dtmf === undefined) {
                    if (track.kind === 'audio') {
                      this._dtmf = pc.createDTMFSender(track);
                    } else {
                      this._dtmf = null;
                    }
                  }

                  return this._dtmf;
                },

                _pc: pc
              };
            }; // augment addTrack when getSenders is not available.


            if (!window.RTCPeerConnection.prototype.getSenders) {
              window.RTCPeerConnection.prototype.getSenders = function () {
                this._senders = this._senders || [];
                return this._senders.slice(); // return a copy of the internal state.
              };

              var origAddTrack = window.RTCPeerConnection.prototype.addTrack;

              window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
                var pc = this;
                var sender = origAddTrack.apply(pc, arguments);

                if (!sender) {
                  sender = shimSenderWithDtmf(pc, track);

                  pc._senders.push(sender);
                }

                return sender;
              };

              var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;

              window.RTCPeerConnection.prototype.removeTrack = function (sender) {
                var pc = this;
                origRemoveTrack.apply(pc, arguments);

                var idx = pc._senders.indexOf(sender);

                if (idx !== -1) {
                  pc._senders.splice(idx, 1);
                }
              };
            }

            var origAddStream = window.RTCPeerConnection.prototype.addStream;

            window.RTCPeerConnection.prototype.addStream = function (stream) {
              var pc = this;
              pc._senders = pc._senders || [];
              origAddStream.apply(pc, [stream]);
              stream.getTracks().forEach(function (track) {
                pc._senders.push(shimSenderWithDtmf(pc, track));
              });
            };

            var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

            window.RTCPeerConnection.prototype.removeStream = function (stream) {
              var pc = this;
              pc._senders = pc._senders || [];
              origRemoveStream.apply(pc, [stream]);
              stream.getTracks().forEach(function (track) {
                var sender = pc._senders.find(function (s) {
                  return s.track === track;
                });

                if (sender) {
                  pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender

                }
              });
            };
          } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
            var origGetSenders = window.RTCPeerConnection.prototype.getSenders;

            window.RTCPeerConnection.prototype.getSenders = function () {
              var pc = this;
              var senders = origGetSenders.apply(pc, []);
              senders.forEach(function (sender) {
                sender._pc = pc;
              });
              return senders;
            };

            Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
              get: function () {
                if (this._dtmf === undefined) {
                  if (this.track.kind === 'audio') {
                    this._dtmf = this._pc.createDTMFSender(this.track);
                  } else {
                    this._dtmf = null;
                  }
                }

                return this._dtmf;
              }
            });
          }
        },
        shimSourceObject: function (window) {
          var URL = window && window.URL;

          if (typeof window === 'object') {
            if (window.HTMLMediaElement && !('srcObject' in window.HTMLMediaElement.prototype)) {
              // Shim the srcObject property, once, when HTMLMediaElement is found.
              Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
                get: function () {
                  return this._srcObject;
                },
                set: function (stream) {
                  var self = this; // Use _srcObject as a private property for this shim

                  this._srcObject = stream;

                  if (this.src) {
                    URL.revokeObjectURL(this.src);
                  }

                  if (!stream) {
                    this.src = '';
                    return undefined;
                  }

                  this.src = URL.createObjectURL(stream); // We need to recreate the blob url when a track is added or
                  // removed. Doing it manually since we want to avoid a recursion.

                  stream.addEventListener('addtrack', function () {
                    if (self.src) {
                      URL.revokeObjectURL(self.src);
                    }

                    self.src = URL.createObjectURL(stream);
                  });
                  stream.addEventListener('removetrack', function () {
                    if (self.src) {
                      URL.revokeObjectURL(self.src);
                    }

                    self.src = URL.createObjectURL(stream);
                  });
                }
              });
            }
          }
        },
        shimAddTrackRemoveTrackWithNative: function (window) {
          // shim addTrack/removeTrack with native variants in order to make
          // the interactions with legacy getLocalStreams behave as in other browsers.
          // Keeps a mapping stream.id => [stream, rtpsenders...]
          window.RTCPeerConnection.prototype.getLocalStreams = function () {
            var pc = this;
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
              return pc._shimmedLocalStreams[streamId][0];
            });
          };

          var origAddTrack = window.RTCPeerConnection.prototype.addTrack;

          window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
            if (!stream) {
              return origAddTrack.apply(this, arguments);
            }

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            var sender = origAddTrack.apply(this, arguments);

            if (!this._shimmedLocalStreams[stream.id]) {
              this._shimmedLocalStreams[stream.id] = [stream, sender];
            } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
              this._shimmedLocalStreams[stream.id].push(sender);
            }

            return sender;
          };

          var origAddStream = window.RTCPeerConnection.prototype.addStream;

          window.RTCPeerConnection.prototype.addStream = function (stream) {
            var pc = this;
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            stream.getTracks().forEach(function (track) {
              var alreadyExists = pc.getSenders().find(function (s) {
                return s.track === track;
              });

              if (alreadyExists) {
                throw new DOMException('Track already exists.', 'InvalidAccessError');
              }
            });
            var existingSenders = pc.getSenders();
            origAddStream.apply(this, arguments);
            var newSenders = pc.getSenders().filter(function (newSender) {
              return existingSenders.indexOf(newSender) === -1;
            });
            this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
          };

          var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

          window.RTCPeerConnection.prototype.removeStream = function (stream) {
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            delete this._shimmedLocalStreams[stream.id];
            return origRemoveStream.apply(this, arguments);
          };

          var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;

          window.RTCPeerConnection.prototype.removeTrack = function (sender) {
            var pc = this;
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};

            if (sender) {
              Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
                var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);

                if (idx !== -1) {
                  pc._shimmedLocalStreams[streamId].splice(idx, 1);
                }

                if (pc._shimmedLocalStreams[streamId].length === 1) {
                  delete pc._shimmedLocalStreams[streamId];
                }
              });
            }

            return origRemoveTrack.apply(this, arguments);
          };
        },
        shimAddTrackRemoveTrack: function (window) {
          var browserDetails = utils.detectBrowser(window); // shim addTrack and removeTrack.

          if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
            return this.shimAddTrackRemoveTrackWithNative(window);
          } // also shim pc.getLocalStreams when addTrack is shimmed
          // to return the original streams.


          var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;

          window.RTCPeerConnection.prototype.getLocalStreams = function () {
            var pc = this;
            var nativeStreams = origGetLocalStreams.apply(this);
            pc._reverseStreams = pc._reverseStreams || {};
            return nativeStreams.map(function (stream) {
              return pc._reverseStreams[stream.id];
            });
          };

          var origAddStream = window.RTCPeerConnection.prototype.addStream;

          window.RTCPeerConnection.prototype.addStream = function (stream) {
            var pc = this;
            pc._streams = pc._streams || {};
            pc._reverseStreams = pc._reverseStreams || {};
            stream.getTracks().forEach(function (track) {
              var alreadyExists = pc.getSenders().find(function (s) {
                return s.track === track;
              });

              if (alreadyExists) {
                throw new DOMException('Track already exists.', 'InvalidAccessError');
              }
            }); // Add identity mapping for consistency with addTrack.
            // Unless this is being used with a stream from addTrack.

            if (!pc._reverseStreams[stream.id]) {
              var newStream = new window.MediaStream(stream.getTracks());
              pc._streams[stream.id] = newStream;
              pc._reverseStreams[newStream.id] = stream;
              stream = newStream;
            }

            origAddStream.apply(pc, [stream]);
          };

          var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

          window.RTCPeerConnection.prototype.removeStream = function (stream) {
            var pc = this;
            pc._streams = pc._streams || {};
            pc._reverseStreams = pc._reverseStreams || {};
            origRemoveStream.apply(pc, [pc._streams[stream.id] || stream]);
            delete pc._reverseStreams[pc._streams[stream.id] ? pc._streams[stream.id].id : stream.id];
            delete pc._streams[stream.id];
          };

          window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
            var pc = this;

            if (pc.signalingState === 'closed') {
              throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
            }

            var streams = [].slice.call(arguments, 1);

            if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
              return t === track;
            })) {
              // this is not fully correct but all we can manage without
              // [[associated MediaStreams]] internal slot.
              throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
            }

            var alreadyExists = pc.getSenders().find(function (s) {
              return s.track === track;
            });

            if (alreadyExists) {
              throw new DOMException('Track already exists.', 'InvalidAccessError');
            }

            pc._streams = pc._streams || {};
            pc._reverseStreams = pc._reverseStreams || {};
            var oldStream = pc._streams[stream.id];

            if (oldStream) {
              // this is using odd Chrome behaviour, use with caution:
              // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
              // Note: we rely on the high-level addTrack/dtmf shim to
              // create the sender with a dtmf sender.
              oldStream.addTrack(track); // Trigger ONN async.

              Promise.resolve().then(function () {
                pc.dispatchEvent(new Event('negotiationneeded'));
              });
            } else {
              var newStream = new window.MediaStream([track]);
              pc._streams[stream.id] = newStream;
              pc._reverseStreams[newStream.id] = stream;
              pc.addStream(newStream);
            }

            return pc.getSenders().find(function (s) {
              return s.track === track;
            });
          }; // replace the internal stream id with the external one and
          // vice versa.


          function replaceInternalStreamId(pc, description) {
            var sdp = description.sdp;
            Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
              var externalStream = pc._reverseStreams[internalId];
              var internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
            });
            return new RTCSessionDescription({
              type: description.type,
              sdp: sdp
            });
          }

          function replaceExternalStreamId(pc, description) {
            var sdp = description.sdp;
            Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
              var externalStream = pc._reverseStreams[internalId];
              var internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
            });
            return new RTCSessionDescription({
              type: description.type,
              sdp: sdp
            });
          }

          ['createOffer', 'createAnswer'].forEach(function (method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];

            window.RTCPeerConnection.prototype[method] = function () {
              var pc = this;
              var args = arguments;
              var isLegacyCall = arguments.length && typeof arguments[0] === 'function';

              if (isLegacyCall) {
                return nativeMethod.apply(pc, [function (description) {
                  var desc = replaceInternalStreamId(pc, description);
                  args[0].apply(null, [desc]);
                }, function (err) {
                  if (args[1]) {
                    args[1].apply(null, err);
                  }
                }, arguments[2]]);
              }

              return nativeMethod.apply(pc, arguments).then(function (description) {
                return replaceInternalStreamId(pc, description);
              });
            };
          });
          var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;

          window.RTCPeerConnection.prototype.setLocalDescription = function () {
            var pc = this;

            if (!arguments.length || !arguments[0].type) {
              return origSetLocalDescription.apply(pc, arguments);
            }

            arguments[0] = replaceExternalStreamId(pc, arguments[0]);
            return origSetLocalDescription.apply(pc, arguments);
          }; // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier


          var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
          Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
            get: function () {
              var pc = this;
              var description = origLocalDescription.get.apply(this);

              if (description.type === '') {
                return description;
              }

              return replaceInternalStreamId(pc, description);
            }
          });

          window.RTCPeerConnection.prototype.removeTrack = function (sender) {
            var pc = this;

            if (pc.signalingState === 'closed') {
              throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
            } // We can not yet check for sender instanceof RTCRtpSender
            // since we shim RTPSender. So we check if sender._pc is set.


            if (!sender._pc) {
              throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
            }

            var isLocal = sender._pc === pc;

            if (!isLocal) {
              throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
            } // Search for the native stream the senders track belongs to.


            pc._streams = pc._streams || {};
            var stream;
            Object.keys(pc._streams).forEach(function (streamid) {
              var hasTrack = pc._streams[streamid].getTracks().find(function (track) {
                return sender.track === track;
              });

              if (hasTrack) {
                stream = pc._streams[streamid];
              }
            });

            if (stream) {
              if (stream.getTracks().length === 1) {
                // if this is the last track of the stream, remove the stream. This
                // takes care of any shimmed _senders.
                pc.removeStream(pc._reverseStreams[stream.id]);
              } else {
                // relying on the same odd chrome behaviour as above.
                stream.removeTrack(sender.track);
              }

              pc.dispatchEvent(new Event('negotiationneeded'));
            }
          };
        },
        shimPeerConnection: function (window) {
          var browserDetails = utils.detectBrowser(window); // The RTCPeerConnection object.

          if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
            window.RTCPeerConnection = function (pcConfig, pcConstraints) {
              // Translate iceTransportPolicy to iceTransports,
              // see https://code.google.com/p/webrtc/issues/detail?id=4869
              // this was fixed in M56 along with unprefixing RTCPeerConnection.
              logging('PeerConnection');

              if (pcConfig && pcConfig.iceTransportPolicy) {
                pcConfig.iceTransports = pcConfig.iceTransportPolicy;
              }

              return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
            };

            window.RTCPeerConnection.prototype = window.webkitRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate.

            if (window.webkitRTCPeerConnection.generateCertificate) {
              Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
                get: function () {
                  return window.webkitRTCPeerConnection.generateCertificate;
                }
              });
            }
          } else {
            // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
            var OrigPeerConnection = window.RTCPeerConnection;

            window.RTCPeerConnection = function (pcConfig, pcConstraints) {
              if (pcConfig && pcConfig.iceServers) {
                var newIceServers = [];

                for (var i = 0; i < pcConfig.iceServers.length; i++) {
                  var server = pcConfig.iceServers[i];

                  if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
                    utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                    server = JSON.parse(JSON.stringify(server));
                    server.urls = server.url;
                    newIceServers.push(server);
                  } else {
                    newIceServers.push(pcConfig.iceServers[i]);
                  }
                }

                pcConfig.iceServers = newIceServers;
              }

              return new OrigPeerConnection(pcConfig, pcConstraints);
            };

            window.RTCPeerConnection.prototype = OrigPeerConnection.prototype; // wrap static methods. Currently just generateCertificate.

            Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
              get: function () {
                return OrigPeerConnection.generateCertificate;
              }
            });
          }

          var origGetStats = window.RTCPeerConnection.prototype.getStats;

          window.RTCPeerConnection.prototype.getStats = function (selector, successCallback, errorCallback) {
            var pc = this;
            var args = arguments; // If selector is a function then we are in the old style stats so just
            // pass back the original getStats format to avoid breaking old users.

            if (arguments.length > 0 && typeof selector === 'function') {
              return origGetStats.apply(this, arguments);
            } // When spec-style getStats is supported, return those when called with
            // either no arguments or the selector argument is null.


            if (origGetStats.length === 0 && (arguments.length === 0 || typeof arguments[0] !== 'function')) {
              return origGetStats.apply(this, []);
            }

            var fixChromeStats_ = function (response) {
              var standardReport = {};
              var reports = response.result();
              reports.forEach(function (report) {
                var standardStats = {
                  id: report.id,
                  timestamp: report.timestamp,
                  type: {
                    localcandidate: 'local-candidate',
                    remotecandidate: 'remote-candidate'
                  }[report.type] || report.type
                };
                report.names().forEach(function (name) {
                  standardStats[name] = report.stat(name);
                });
                standardReport[standardStats.id] = standardStats;
              });
              return standardReport;
            }; // shim getStats with maplike support


            var makeMapStats = function (stats) {
              return new Map(Object.keys(stats).map(function (key) {
                return [key, stats[key]];
              }));
            };

            if (arguments.length >= 2) {
              var successCallbackWrapper_ = function (response) {
                args[1](makeMapStats(fixChromeStats_(response)));
              };

              return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]);
            } // promise-support


            return new Promise(function (resolve, reject) {
              origGetStats.apply(pc, [function (response) {
                resolve(makeMapStats(fixChromeStats_(response)));
              }, reject]);
            }).then(successCallback, errorCallback);
          }; // add promise support -- natively available in Chrome 51


          if (browserDetails.version < 51) {
            ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
              var nativeMethod = window.RTCPeerConnection.prototype[method];

              window.RTCPeerConnection.prototype[method] = function () {
                var args = arguments;
                var pc = this;
                var promise = new Promise(function (resolve, reject) {
                  nativeMethod.apply(pc, [args[0], resolve, reject]);
                });

                if (args.length < 2) {
                  return promise;
                }

                return promise.then(function () {
                  args[1].apply(null, []);
                }, function (err) {
                  if (args.length >= 3) {
                    args[2].apply(null, [err]);
                  }
                });
              };
            });
          } // promise support for createOffer and createAnswer. Available (without
          // bugs) since M52: crbug/619289


          if (browserDetails.version < 52) {
            ['createOffer', 'createAnswer'].forEach(function (method) {
              var nativeMethod = window.RTCPeerConnection.prototype[method];

              window.RTCPeerConnection.prototype[method] = function () {
                var pc = this;

                if (arguments.length < 1 || arguments.length === 1 && typeof arguments[0] === 'object') {
                  var opts = arguments.length === 1 ? arguments[0] : undefined;
                  return new Promise(function (resolve, reject) {
                    nativeMethod.apply(pc, [resolve, reject, opts]);
                  });
                }

                return nativeMethod.apply(this, arguments);
              };
            });
          } // shim implicit creation of RTCSessionDescription/RTCIceCandidate


          ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];

            window.RTCPeerConnection.prototype[method] = function () {
              arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
              return nativeMethod.apply(this, arguments);
            };
          }); // support for addIceCandidate(null or undefined)

          var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;

          window.RTCPeerConnection.prototype.addIceCandidate = function () {
            if (!arguments[0]) {
              if (arguments[1]) {
                arguments[1].apply(null);
              }

              return Promise.resolve();
            }

            return nativeAddIceCandidate.apply(this, arguments);
          };
        }
      };
    }, {
      "../utils.js": 13,
      "./getusermedia": 6
    }],
    6: [function (require, module, exports) {
      /*
      *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */

      /* eslint-env node */
      'use strict';

      var utils = require('../utils.js');

      var logging = utils.log; // Expose public methods.

      module.exports = function (window) {
        var browserDetails = utils.detectBrowser(window);
        var navigator = window && window.navigator;

        var constraintsToChrome_ = function (c) {
          if (typeof c !== 'object' || c.mandatory || c.optional) {
            return c;
          }

          var cc = {};
          Object.keys(c).forEach(function (key) {
            if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
              return;
            }

            var r = typeof c[key] === 'object' ? c[key] : {
              ideal: c[key]
            };

            if (r.exact !== undefined && typeof r.exact === 'number') {
              r.min = r.max = r.exact;
            }

            var oldname_ = function (prefix, name) {
              if (prefix) {
                return prefix + name.charAt(0).toUpperCase() + name.slice(1);
              }

              return name === 'deviceId' ? 'sourceId' : name;
            };

            if (r.ideal !== undefined) {
              cc.optional = cc.optional || [];
              var oc = {};

              if (typeof r.ideal === 'number') {
                oc[oldname_('min', key)] = r.ideal;
                cc.optional.push(oc);
                oc = {};
                oc[oldname_('max', key)] = r.ideal;
                cc.optional.push(oc);
              } else {
                oc[oldname_('', key)] = r.ideal;
                cc.optional.push(oc);
              }
            }

            if (r.exact !== undefined && typeof r.exact !== 'number') {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_('', key)] = r.exact;
            } else {
              ['min', 'max'].forEach(function (mix) {
                if (r[mix] !== undefined) {
                  cc.mandatory = cc.mandatory || {};
                  cc.mandatory[oldname_(mix, key)] = r[mix];
                }
              });
            }
          });

          if (c.advanced) {
            cc.optional = (cc.optional || []).concat(c.advanced);
          }

          return cc;
        };

        var shimConstraints_ = function (constraints, func) {
          if (browserDetails.version >= 61) {
            return func(constraints);
          }

          constraints = JSON.parse(JSON.stringify(constraints));

          if (constraints && typeof constraints.audio === 'object') {
            var remap = function (obj, a, b) {
              if (a in obj && !(b in obj)) {
                obj[b] = obj[a];
                delete obj[a];
              }
            };

            constraints = JSON.parse(JSON.stringify(constraints));
            remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
            remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
            constraints.audio = constraintsToChrome_(constraints.audio);
          }

          if (constraints && typeof constraints.video === 'object') {
            // Shim facingMode for mobile & surface pro.
            var face = constraints.video.facingMode;
            face = face && (typeof face === 'object' ? face : {
              ideal: face
            });
            var getSupportedFacingModeLies = browserDetails.version < 66;

            if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
              delete constraints.video.facingMode;
              var matches;

              if (face.exact === 'environment' || face.ideal === 'environment') {
                matches = ['back', 'rear'];
              } else if (face.exact === 'user' || face.ideal === 'user') {
                matches = ['front'];
              }

              if (matches) {
                // Look for matches in label, or use last cam for back (typical).
                return navigator.mediaDevices.enumerateDevices().then(function (devices) {
                  devices = devices.filter(function (d) {
                    return d.kind === 'videoinput';
                  });
                  var dev = devices.find(function (d) {
                    return matches.some(function (match) {
                      return d.label.toLowerCase().indexOf(match) !== -1;
                    });
                  });

                  if (!dev && devices.length && matches.indexOf('back') !== -1) {
                    dev = devices[devices.length - 1]; // more likely the back cam
                  }

                  if (dev) {
                    constraints.video.deviceId = face.exact ? {
                      exact: dev.deviceId
                    } : {
                      ideal: dev.deviceId
                    };
                  }

                  constraints.video = constraintsToChrome_(constraints.video);
                  logging('chrome: ' + JSON.stringify(constraints));
                  return func(constraints);
                });
              }
            }

            constraints.video = constraintsToChrome_(constraints.video);
          }

          logging('chrome: ' + JSON.stringify(constraints));
          return func(constraints);
        };

        var shimError_ = function (e) {
          return {
            name: {
              PermissionDeniedError: 'NotAllowedError',
              InvalidStateError: 'NotReadableError',
              DevicesNotFoundError: 'NotFoundError',
              ConstraintNotSatisfiedError: 'OverconstrainedError',
              TrackStartError: 'NotReadableError',
              MediaDeviceFailedDueToShutdown: 'NotReadableError',
              MediaDeviceKillSwitchOn: 'NotReadableError'
            }[e.name] || e.name,
            message: e.message,
            constraint: e.constraintName,
            toString: function () {
              return this.name + (this.message && ': ') + this.message;
            }
          };
        };

        var getUserMedia_ = function (constraints, onSuccess, onError) {
          shimConstraints_(constraints, function (c) {
            navigator.webkitGetUserMedia(c, onSuccess, function (e) {
              //getUserMedia_ webkitGetUserMedia
              if (onError) {
                onError(shimError_(e));
              }
            });
          });
        };

        navigator.getUserMedia = getUserMedia_; // Returns the result of getUserMedia as a Promise.

        var getUserMediaPromise_ = function (constraints) {
          return new Promise(function (resolve, reject) {
            navigator.getUserMedia(constraints, resolve, reject);
          });
        };

        if (!navigator.mediaDevices) {
          navigator.mediaDevices = {
            getUserMedia: getUserMediaPromise_,
            enumerateDevices: function () {
              return new Promise(function (resolve) {
                var kinds = {
                  audio: 'audioinput',
                  video: 'videoinput'
                };
                return window.MediaStreamTrack.getSources(function (devices) {
                  resolve(devices.map(function (device) {
                    return {
                      label: device.label,
                      kind: kinds[device.kind],
                      deviceId: device.id,
                      groupId: ''
                    };
                  }));
                });
              });
            },
            getSupportedConstraints: function () {
              return {
                deviceId: true,
                echoCancellation: true,
                facingMode: true,
                frameRate: true,
                height: true,
                width: true
              };
            }
          };
        } // A shim for getUserMedia method on the mediaDevices object.
        // TODO(KaptenJansson) remove once implemented in Chrome stable.


        if (!navigator.mediaDevices.getUserMedia) {
          navigator.mediaDevices.getUserMedia = function (constraints) {
            return getUserMediaPromise_(constraints);
          };
        } else {
          // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
          // function which returns a Promise, it does not accept spec-style
          // constraints.
          var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

          navigator.mediaDevices.getUserMedia = function (cs) {
            return shimConstraints_(cs, function (c) {
              return origGetUserMedia(c).then(function (stream) {
                if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
                  stream.getTracks().forEach(function (track) {
                    track.stop();
                  });
                  throw new DOMException('', 'NotFoundError');
                }

                return stream;
              }, function (e) {
                return Promise.reject(shimError_(e));
              });
            });
          };
        } // Dummy devicechange event methods.
        // TODO(KaptenJansson) remove once implemented in Chrome stable.


        if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
          navigator.mediaDevices.addEventListener = function () {
            logging('Dummy mediaDevices.addEventListener called.');
          };
        }

        if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
          navigator.mediaDevices.removeEventListener = function () {
            logging('Dummy mediaDevices.removeEventListener called.');
          };
        }
      };
    }, {
      "../utils.js": 13
    }],
    7: [function (require, module, exports) {
      /*
      *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */

      /* eslint-env node */
      'use strict';

      var SDPUtils = require('sdp');

      var utils = require('./utils');

      module.exports = {
        shimRTCIceCandidate: function (window) {
          // foundation is arbitrarily chosen as an indicator for full support for
          // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
          if (window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
            return;
          }

          var NativeRTCIceCandidate = window.RTCIceCandidate;

          window.RTCIceCandidate = function (args) {
            // Remove the a= which shouldn't be part of the candidate string.
            if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
              args = JSON.parse(JSON.stringify(args));
              args.candidate = args.candidate.substr(2);
            } // Augment the native candidate with the parsed fields.


            var nativeCandidate = new NativeRTCIceCandidate(args);
            var parsedCandidate = SDPUtils.parseCandidate(args.candidate);
            var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate); // Add a serializer that does not serialize the extra attributes.

            augmentedCandidate.toJSON = function () {
              return {
                candidate: augmentedCandidate.candidate,
                sdpMid: augmentedCandidate.sdpMid,
                sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
                usernameFragment: augmentedCandidate.usernameFragment
              };
            };

            return augmentedCandidate;
          }; // Hook up the augmented candidate in onicecandidate and
          // addEventListener('icecandidate', ...)


          utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
            if (e.candidate) {
              Object.defineProperty(e, 'candidate', {
                value: new window.RTCIceCandidate(e.candidate),
                writable: 'false'
              });
            }

            return e;
          });
        },
        // shimCreateObjectURL must be called before shimSourceObject to avoid loop.
        shimCreateObjectURL: function (window) {
          var URL = window && window.URL;

          if (!(typeof window === 'object' && window.HTMLMediaElement && 'srcObject' in window.HTMLMediaElement.prototype && URL.createObjectURL && URL.revokeObjectURL)) {
            // Only shim CreateObjectURL using srcObject if srcObject exists.
            return undefined;
          }

          var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
          var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
          var streams = new Map(),
              newId = 0;

          URL.createObjectURL = function (stream) {
            if ('getTracks' in stream) {
              var url = 'polyblob:' + ++newId;
              streams.set(url, stream);
              utils.deprecated('URL.createObjectURL(stream)', 'elem.srcObject = stream');
              return url;
            }

            return nativeCreateObjectURL(stream);
          };

          URL.revokeObjectURL = function (url) {
            nativeRevokeObjectURL(url);
            streams.delete(url);
          };

          var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype, 'src');
          Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {
            get: function () {
              return dsc.get.apply(this);
            },
            set: function (url) {
              this.srcObject = streams.get(url) || null;
              return dsc.set.apply(this, [url]);
            }
          });
          var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;

          window.HTMLMediaElement.prototype.setAttribute = function () {
            if (arguments.length === 2 && ('' + arguments[0]).toLowerCase() === 'src') {
              this.srcObject = streams.get(arguments[1]) || null;
            }

            return nativeSetAttribute.apply(this, arguments);
          };
        },
        shimMaxMessageSize: function (window) {
          if (window.RTCSctpTransport || !window.RTCPeerConnection) {
            return;
          }

          var browserDetails = utils.detectBrowser(window);

          if (!('sctp' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
              get: function () {
                return typeof this._sctp === 'undefined' ? null : this._sctp;
              }
            });
          }

          var sctpInDescription = function (description) {
            var sections = SDPUtils.splitSections(description.sdp);
            sections.shift();
            return sections.some(function (mediaSection) {
              var mLine = SDPUtils.parseMLine(mediaSection);
              return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
            });
          };

          var getRemoteFirefoxVersion = function (description) {
            // TODO: Is there a better solution for detecting Firefox?
            var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);

            if (match === null || match.length < 2) {
              return -1;
            }

            var version = parseInt(match[1], 10); // Test for NaN (yes, this is ugly)

            return version !== version ? -1 : version;
          };

          var getCanSendMaxMessageSize = function (remoteIsFirefox) {
            // Every implementation we know can send at least 64 KiB.
            // Note: Although Chrome is technically able to send up to 256 KiB, the
            //       data does not reach the other peer reliably.
            //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
            var canSendMaxMessageSize = 65536;

            if (browserDetails.browser === 'firefox') {
              if (browserDetails.version < 57) {
                if (remoteIsFirefox === -1) {
                  // FF < 57 will send in 16 KiB chunks using the deprecated PPID
                  // fragmentation.
                  canSendMaxMessageSize = 16384;
                } else {
                  // However, other FF (and RAWRTC) can reassemble PPID-fragmented
                  // messages. Thus, supporting ~2 GiB when sending.
                  canSendMaxMessageSize = 2147483637;
                }
              } else {
                // Currently, all FF >= 57 will reset the remote maximum message size
                // to the default value when a data channel is created at a later
                // stage. :(
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
              }
            }

            return canSendMaxMessageSize;
          };

          var getMaxMessageSize = function (description, remoteIsFirefox) {
            // Note: 65536 bytes is the default value from the SDP spec. Also,
            //       every implementation we know supports receiving 65536 bytes.
            var maxMessageSize = 65536; // FF 57 has a slightly incorrect default remote max message size, so
            // we need to adjust it here to avoid a failure when sending.
            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697

            if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
              maxMessageSize = 65535;
            }

            var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');

            if (match.length > 0) {
              maxMessageSize = parseInt(match[0].substr(19), 10);
            } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
              // If the maximum message size is not present in the remote SDP and
              // both local and remote are Firefox, the remote peer can receive
              // ~2 GiB.
              maxMessageSize = 2147483637;
            }

            return maxMessageSize;
          };

          var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

          window.RTCPeerConnection.prototype.setRemoteDescription = function () {
            var pc = this;
            pc._sctp = null;

            if (sctpInDescription(arguments[0])) {
              // Check if the remote is FF.
              var isFirefox = getRemoteFirefoxVersion(arguments[0]); // Get the maximum message size the local peer is capable of sending

              var canSendMMS = getCanSendMaxMessageSize(isFirefox); // Get the maximum message size of the remote peer.

              var remoteMMS = getMaxMessageSize(arguments[0], isFirefox); // Determine final maximum message size

              var maxMessageSize;

              if (canSendMMS === 0 && remoteMMS === 0) {
                maxMessageSize = Number.POSITIVE_INFINITY;
              } else if (canSendMMS === 0 || remoteMMS === 0) {
                maxMessageSize = Math.max(canSendMMS, remoteMMS);
              } else {
                maxMessageSize = Math.min(canSendMMS, remoteMMS);
              } // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
              // attribute.


              var sctp = {};
              Object.defineProperty(sctp, 'maxMessageSize', {
                get: function () {
                  return maxMessageSize;
                }
              });
              pc._sctp = sctp;
            }

            return origSetRemoteDescription.apply(pc, arguments);
          };
        },
        shimSendThrowTypeError: function (window) {
          // Note: Although Firefox >= 57 has a native implementation, the maximum
          //       message size can be reset for all data channels at a later stage.
          //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;

          window.RTCPeerConnection.prototype.createDataChannel = function () {
            var pc = this;
            var dataChannel = origCreateDataChannel.apply(pc, arguments);
            var origDataChannelSend = dataChannel.send; // Patch 'send' method

            dataChannel.send = function () {
              var dc = this;
              var data = arguments[0];
              var length = data.length || data.size || data.byteLength;

              if (length > pc.sctp.maxMessageSize) {
                throw new DOMException('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)', 'TypeError');
              }

              return origDataChannelSend.apply(dc, arguments);
            };

            return dataChannel;
          };
        }
      };
    }, {
      "./utils": 13,
      "sdp": 2
    }],
    8: [function (require, module, exports) {
      /*
      *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */

      /* eslint-env node */
      'use strict';

      var utils = require('../utils');

      var shimRTCPeerConnection = require('rtcpeerconnection-shim');

      module.exports = {
        shimGetUserMedia: require('./getusermedia'),
        shimPeerConnection: function (window) {
          var browserDetails = utils.detectBrowser(window);

          if (window.RTCIceGatherer) {
            // ORTC defines an RTCIceCandidate object but no constructor.
            // Not implemented in Edge.
            if (!window.RTCIceCandidate) {
              window.RTCIceCandidate = function (args) {
                return args;
              };
            } // ORTC does not have a session description object but
            // other browsers (i.e. Chrome) that will support both PC and ORTC
            // in the future might have this defined already.


            if (!window.RTCSessionDescription) {
              window.RTCSessionDescription = function (args) {
                return args;
              };
            } // this adds an additional event listener to MediaStrackTrack that signals
            // when a tracks enabled property was changed. Workaround for a bug in
            // addStream, see below. No longer required in 15025+


            if (browserDetails.version < 15025) {
              var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
              Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
                set: function (value) {
                  origMSTEnabled.set.call(this, value);
                  var ev = new Event('enabled');
                  ev.enabled = value;
                  this.dispatchEvent(ev);
                }
              });
            }
          } // ORTC defines the DTMF sender a bit different.
          // https://github.com/w3c/ortc/issues/714


          if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
            Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
              get: function () {
                if (this._dtmf === undefined) {
                  if (this.track.kind === 'audio') {
                    this._dtmf = new window.RTCDtmfSender(this);
                  } else if (this.track.kind === 'video') {
                    this._dtmf = null;
                  }
                }

                return this._dtmf;
              }
            });
          }

          window.RTCPeerConnection = shimRTCPeerConnection(window, browserDetails.version);
        },
        shimReplaceTrack: function (window) {
          // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
          if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
            window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
          }
        }
      };
    }, {
      "../utils": 13,
      "./getusermedia": 9,
      "rtcpeerconnection-shim": 1
    }],
    9: [function (require, module, exports) {
      /*
      *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */

      /* eslint-env node */
      'use strict'; // Expose public methods.

      module.exports = function (window) {
        var navigator = window && window.navigator;

        var shimError_ = function (e) {
          return {
            name: {
              PermissionDeniedError: 'NotAllowedError'
            }[e.name] || e.name,
            message: e.message,
            constraint: e.constraint,
            toString: function () {
              return this.name;
            }
          };
        }; // getUserMedia error shim.


        var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

        navigator.mediaDevices.getUserMedia = function (c) {
          return origGetUserMedia(c).catch(function (e) {
            return Promise.reject(shimError_(e));
          });
        };
      };
    }, {}],
    10: [function (require, module, exports) {
      /*
      *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */

      /* eslint-env node */
      'use strict';

      var utils = require('../utils');

      module.exports = {
        shimGetUserMedia: require('./getusermedia'),
        shimOnTrack: function (window) {
          if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
              get: function () {
                return this._ontrack;
              },
              set: function (f) {
                if (this._ontrack) {
                  this.removeEventListener('track', this._ontrack);
                  this.removeEventListener('addstream', this._ontrackpoly);
                }

                this.addEventListener('track', this._ontrack = f);
                this.addEventListener('addstream', this._ontrackpoly = function (e) {
                  e.stream.getTracks().forEach(function (track) {
                    var event = new Event('track');
                    event.track = track;
                    event.receiver = {
                      track: track
                    };
                    event.transceiver = {
                      receiver: event.receiver
                    };
                    event.streams = [e.stream];
                    this.dispatchEvent(event);
                  }.bind(this));
                }.bind(this));
              }
            });
          }

          if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
            Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
              get: function () {
                return {
                  receiver: this.receiver
                };
              }
            });
          }
        },
        shimSourceObject: function (window) {
          // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
          if (typeof window === 'object') {
            if (window.HTMLMediaElement && !('srcObject' in window.HTMLMediaElement.prototype)) {
              // Shim the srcObject property, once, when HTMLMediaElement is found.
              Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
                get: function () {
                  return this.mozSrcObject;
                },
                set: function (stream) {
                  this.mozSrcObject = stream;
                }
              });
            }
          }
        },
        shimPeerConnection: function (window) {
          var browserDetails = utils.detectBrowser(window);

          if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
            return; // probably media.peerconnection.enabled=false in about:config
          } // The RTCPeerConnection object.


          if (!window.RTCPeerConnection) {
            window.RTCPeerConnection = function (pcConfig, pcConstraints) {
              if (browserDetails.version < 38) {
                // .urls is not supported in FF < 38.
                // create RTCIceServers with a single url.
                if (pcConfig && pcConfig.iceServers) {
                  var newIceServers = [];

                  for (var i = 0; i < pcConfig.iceServers.length; i++) {
                    var server = pcConfig.iceServers[i];

                    if (server.hasOwnProperty('urls')) {
                      for (var j = 0; j < server.urls.length; j++) {
                        var newServer = {
                          url: server.urls[j]
                        };

                        if (server.urls[j].indexOf('turn') === 0) {
                          newServer.username = server.username;
                          newServer.credential = server.credential;
                        }

                        newIceServers.push(newServer);
                      }
                    } else {
                      newIceServers.push(pcConfig.iceServers[i]);
                    }
                  }

                  pcConfig.iceServers = newIceServers;
                }
              }

              return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
            };

            window.RTCPeerConnection.prototype = window.mozRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate.

            if (window.mozRTCPeerConnection.generateCertificate) {
              Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
                get: function () {
                  return window.mozRTCPeerConnection.generateCertificate;
                }
              });
            }

            window.RTCSessionDescription = window.mozRTCSessionDescription;
            window.RTCIceCandidate = window.mozRTCIceCandidate;
          } // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.


          ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];

            window.RTCPeerConnection.prototype[method] = function () {
              arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
              return nativeMethod.apply(this, arguments);
            };
          }); // support for addIceCandidate(null or undefined)

          var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;

          window.RTCPeerConnection.prototype.addIceCandidate = function () {
            if (!arguments[0]) {
              if (arguments[1]) {
                arguments[1].apply(null);
              }

              return Promise.resolve();
            }

            return nativeAddIceCandidate.apply(this, arguments);
          }; // shim getStats with maplike support


          var makeMapStats = function (stats) {
            var map = new Map();
            Object.keys(stats).forEach(function (key) {
              map.set(key, stats[key]);
              map[key] = stats[key];
            });
            return map;
          };

          var modernStatsTypes = {
            inboundrtp: 'inbound-rtp',
            outboundrtp: 'outbound-rtp',
            candidatepair: 'candidate-pair',
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          };
          var nativeGetStats = window.RTCPeerConnection.prototype.getStats;

          window.RTCPeerConnection.prototype.getStats = function (selector, onSucc, onErr) {
            return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
              if (browserDetails.version < 48) {
                stats = makeMapStats(stats);
              }

              if (browserDetails.version < 53 && !onSucc) {
                // Shim only promise getStats with spec-hyphens in type names
                // Leave callback version alone; misc old uses of forEach before Map
                try {
                  stats.forEach(function (stat) {
                    stat.type = modernStatsTypes[stat.type] || stat.type;
                  });
                } catch (e) {
                  if (e.name !== 'TypeError') {
                    throw e;
                  } // Avoid TypeError: "type" is read-only, in old versions. 34-43ish


                  stats.forEach(function (stat, i) {
                    stats.set(i, Object.assign({}, stat, {
                      type: modernStatsTypes[stat.type] || stat.type
                    }));
                  });
                }
              }

              return stats;
            }).then(onSucc, onErr);
          };
        },
        shimRemoveStream: function (window) {
          if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
            return;
          }

          window.RTCPeerConnection.prototype.removeStream = function (stream) {
            var pc = this;
            utils.deprecated('removeStream', 'removeTrack');
            this.getSenders().forEach(function (sender) {
              if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {
                pc.removeTrack(sender);
              }
            });
          };
        }
      };
    }, {
      "../utils": 13,
      "./getusermedia": 11
    }],
    11: [function (require, module, exports) {
      /*
      *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */

      /* eslint-env node */
      'use strict';

      var utils = require('../utils');

      var logging = utils.log; // Expose public methods.

      module.exports = function (window) {
        var browserDetails = utils.detectBrowser(window);
        var navigator = window && window.navigator;
        var MediaStreamTrack = window && window.MediaStreamTrack;

        var shimError_ = function (e) {
          return {
            name: {
              InternalError: 'NotReadableError',
              NotSupportedError: 'TypeError',
              PermissionDeniedError: 'NotAllowedError',
              SecurityError: 'NotAllowedError'
            }[e.name] || e.name,
            message: {
              'The operation is insecure.': 'The request is not allowed by the ' + 'user agent or the platform in the current context.'
            }[e.message] || e.message,
            constraint: e.constraint,
            toString: function () {
              return this.name + (this.message && ': ') + this.message;
            }
          };
        }; // getUserMedia constraints shim.


        var getUserMedia_ = function (constraints, onSuccess, onError) {
          var constraintsToFF37_ = function (c) {
            if (typeof c !== 'object' || c.require) {
              return c;
            }

            var require = [];
            Object.keys(c).forEach(function (key) {
              if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
                return;
              }

              var r = c[key] = typeof c[key] === 'object' ? c[key] : {
                ideal: c[key]
              };

              if (r.min !== undefined || r.max !== undefined || r.exact !== undefined) {
                require.push(key);
              }

              if (r.exact !== undefined) {
                if (typeof r.exact === 'number') {
                  r.min = r.max = r.exact;
                } else {
                  c[key] = r.exact;
                }

                delete r.exact;
              }

              if (r.ideal !== undefined) {
                c.advanced = c.advanced || [];
                var oc = {};

                if (typeof r.ideal === 'number') {
                  oc[key] = {
                    min: r.ideal,
                    max: r.ideal
                  };
                } else {
                  oc[key] = r.ideal;
                }

                c.advanced.push(oc);
                delete r.ideal;

                if (!Object.keys(r).length) {
                  delete c[key];
                }
              }
            });

            if (require.length) {
              c.require = require;
            }

            return c;
          };

          constraints = JSON.parse(JSON.stringify(constraints));

          if (browserDetails.version < 38) {
            logging('spec: ' + JSON.stringify(constraints));

            if (constraints.audio) {
              constraints.audio = constraintsToFF37_(constraints.audio);
            }

            if (constraints.video) {
              constraints.video = constraintsToFF37_(constraints.video);
            }

            logging('ff37: ' + JSON.stringify(constraints));
          }

          return navigator.mozGetUserMedia(constraints, onSuccess, function (e) {
            onError(shimError_(e));
          });
        }; // Returns the result of getUserMedia as a Promise.


        var getUserMediaPromise_ = function (constraints) {
          return new Promise(function (resolve, reject) {
            getUserMedia_(constraints, resolve, reject);
          });
        }; // Shim for mediaDevices on older versions.


        if (!navigator.mediaDevices) {
          navigator.mediaDevices = {
            getUserMedia: getUserMediaPromise_,
            addEventListener: function () {},
            removeEventListener: function () {}
          };
        }

        navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function () {
          return new Promise(function (resolve) {
            var infos = [{
              kind: 'audioinput',
              deviceId: 'default',
              label: '',
              groupId: ''
            }, {
              kind: 'videoinput',
              deviceId: 'default',
              label: '',
              groupId: ''
            }];
            resolve(infos);
          });
        };

        if (browserDetails.version < 41) {
          // Work around http://bugzil.la/1169665
          var orgEnumerateDevices = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);

          navigator.mediaDevices.enumerateDevices = function () {
            return orgEnumerateDevices().then(undefined, function (e) {
              if (e.name === 'NotFoundError') {
                return [];
              }

              throw e;
            });
          };
        }

        if (browserDetails.version < 49) {
          var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

          navigator.mediaDevices.getUserMedia = function (c) {
            return origGetUserMedia(c).then(function (stream) {
              // Work around https://bugzil.la/802326
              if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
                stream.getTracks().forEach(function (track) {
                  track.stop();
                });
                throw new DOMException('The object can not be found here.', 'NotFoundError');
              }

              return stream;
            }, function (e) {
              return Promise.reject(shimError_(e));
            });
          };
        }

        if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
          var remap = function (obj, a, b) {
            if (a in obj && !(b in obj)) {
              obj[b] = obj[a];
              delete obj[a];
            }
          };

          var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

          navigator.mediaDevices.getUserMedia = function (c) {
            if (typeof c === 'object' && typeof c.audio === 'object') {
              c = JSON.parse(JSON.stringify(c));
              remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
              remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
            }

            return nativeGetUserMedia(c);
          };

          if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
            var nativeGetSettings = MediaStreamTrack.prototype.getSettings;

            MediaStreamTrack.prototype.getSettings = function () {
              var obj = nativeGetSettings.apply(this, arguments);
              remap(obj, 'mozAutoGainControl', 'autoGainControl');
              remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
              return obj;
            };
          }

          if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
            var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;

            MediaStreamTrack.prototype.applyConstraints = function (c) {
              if (this.kind === 'audio' && typeof c === 'object') {
                c = JSON.parse(JSON.stringify(c));
                remap(c, 'autoGainControl', 'mozAutoGainControl');
                remap(c, 'noiseSuppression', 'mozNoiseSuppression');
              }

              return nativeApplyConstraints.apply(this, [c]);
            };
          }
        }

        navigator.getUserMedia = function (constraints, onSuccess, onError) {
          if (browserDetails.version < 44) {
            return getUserMedia_(constraints, onSuccess, onError);
          } // Replace Firefox 44+'s deprecation warning with unprefixed version.


          utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
          navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
        };
      };
    }, {
      "../utils": 13
    }],
    12: [function (require, module, exports) {
      /*
      *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */
      'use strict';

      var utils = require('../utils');

      module.exports = {
        shimLocalStreamsAPI: function (window) {
          if (typeof window !== 'object' || !window.RTCPeerConnection) {
            return;
          }

          if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getLocalStreams = function () {
              if (!this._localStreams) {
                this._localStreams = [];
              }

              return this._localStreams;
            };
          }

          if (!('getStreamById' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getStreamById = function (id) {
              var result = null;

              if (this._localStreams) {
                this._localStreams.forEach(function (stream) {
                  if (stream.id === id) {
                    result = stream;
                  }
                });
              }

              if (this._remoteStreams) {
                this._remoteStreams.forEach(function (stream) {
                  if (stream.id === id) {
                    result = stream;
                  }
                });
              }

              return result;
            };
          }

          if (!('addStream' in window.RTCPeerConnection.prototype)) {
            var _addTrack = window.RTCPeerConnection.prototype.addTrack;

            window.RTCPeerConnection.prototype.addStream = function (stream) {
              if (!this._localStreams) {
                this._localStreams = [];
              }

              if (this._localStreams.indexOf(stream) === -1) {
                this._localStreams.push(stream);
              }

              var pc = this;
              stream.getTracks().forEach(function (track) {
                _addTrack.call(pc, track, stream);
              });
            };

            window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
              if (stream) {
                if (!this._localStreams) {
                  this._localStreams = [stream];
                } else if (this._localStreams.indexOf(stream) === -1) {
                  this._localStreams.push(stream);
                }
              }

              return _addTrack.call(this, track, stream);
            };
          }

          if (!('removeStream' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.removeStream = function (stream) {
              if (!this._localStreams) {
                this._localStreams = [];
              }

              var index = this._localStreams.indexOf(stream);

              if (index === -1) {
                return;
              }

              this._localStreams.splice(index, 1);

              var pc = this;
              var tracks = stream.getTracks();
              this.getSenders().forEach(function (sender) {
                if (tracks.indexOf(sender.track) !== -1) {
                  pc.removeTrack(sender);
                }
              });
            };
          }
        },
        shimRemoteStreamsAPI: function (window) {
          if (typeof window !== 'object' || !window.RTCPeerConnection) {
            return;
          }

          if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getRemoteStreams = function () {
              return this._remoteStreams ? this._remoteStreams : [];
            };
          }

          if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
              get: function () {
                return this._onaddstream;
              },
              set: function (f) {
                var pc = this;

                if (this._onaddstream) {
                  this.removeEventListener('addstream', this._onaddstream);
                  this.removeEventListener('track', this._onaddstreampoly);
                }

                this.addEventListener('addstream', this._onaddstream = f);
                this.addEventListener('track', this._onaddstreampoly = function (e) {
                  e.streams.forEach(function (stream) {
                    if (!pc._remoteStreams) {
                      pc._remoteStreams = [];
                    }

                    if (pc._remoteStreams.indexOf(stream) >= 0) {
                      return;
                    }

                    pc._remoteStreams.push(stream);

                    var event = new Event('addstream');
                    event.stream = stream;
                    pc.dispatchEvent(event);
                  });
                });
              }
            });
          }
        },
        shimCallbacksAPI: function (window) {
          if (typeof window !== 'object' || !window.RTCPeerConnection) {
            return;
          }

          var prototype = window.RTCPeerConnection.prototype;
          var createOffer = prototype.createOffer;
          var createAnswer = prototype.createAnswer;
          var setLocalDescription = prototype.setLocalDescription;
          var setRemoteDescription = prototype.setRemoteDescription;
          var addIceCandidate = prototype.addIceCandidate;

          prototype.createOffer = function (successCallback, failureCallback) {
            var options = arguments.length >= 2 ? arguments[2] : arguments[0];
            var promise = createOffer.apply(this, [options]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.createAnswer = function (successCallback, failureCallback) {
            var options = arguments.length >= 2 ? arguments[2] : arguments[0];
            var promise = createAnswer.apply(this, [options]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          var withCallback = function (description, successCallback, failureCallback) {
            var promise = setLocalDescription.apply(this, [description]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.setLocalDescription = withCallback;

          withCallback = function (description, successCallback, failureCallback) {
            var promise = setRemoteDescription.apply(this, [description]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.setRemoteDescription = withCallback;

          withCallback = function (candidate, successCallback, failureCallback) {
            var promise = addIceCandidate.apply(this, [candidate]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.addIceCandidate = withCallback;
        },
        shimGetUserMedia: function (window) {
          var navigator = window && window.navigator;
          console.log(`browserDetails.browser--------11111------"`);

          if (!navigator.getUserMedia) {
            if (navigator.webkitGetUserMedia) {
              console.log(`browserDetails.browser--------2222------"`);
              navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
            } else if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
              console.log(`browserDetails.browser--------333------"`);

              navigator.getUserMedia = function (constraints, cb, errcb) {
                console.log(`browserDetails.browser--------4444------${constraints}`);
                navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
              }.bind(navigator);
            }
          }
        },
        shimRTCIceServerUrls: function (window) {
          // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
          var OrigPeerConnection = window.RTCPeerConnection;

          window.RTCPeerConnection = function (pcConfig, pcConstraints) {
            if (pcConfig && pcConfig.iceServers) {
              var newIceServers = [];

              for (var i = 0; i < pcConfig.iceServers.length; i++) {
                var server = pcConfig.iceServers[i];

                if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
                  utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                  server = JSON.parse(JSON.stringify(server));
                  server.urls = server.url;
                  delete server.url;
                  newIceServers.push(server);
                } else {
                  newIceServers.push(pcConfig.iceServers[i]);
                }
              }

              pcConfig.iceServers = newIceServers;
            }

            return new OrigPeerConnection(pcConfig, pcConstraints);
          };

          window.RTCPeerConnection.prototype = OrigPeerConnection.prototype; // wrap static methods. Currently just generateCertificate.

          if ('generateCertificate' in window.RTCPeerConnection) {
            Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
              get: function () {
                return OrigPeerConnection.generateCertificate;
              }
            });
          }
        },
        shimTrackEventTransceiver: function (window) {
          // Add event.transceiver member over deprecated event.receiver
          if (typeof window === 'object' && window.RTCPeerConnection && 'receiver' in window.RTCTrackEvent.prototype && // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
          // defined for some reason even when window.RTCTransceiver is not.
          !window.RTCTransceiver) {
            Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
              get: function () {
                return {
                  receiver: this.receiver
                };
              }
            });
          }
        },
        shimCreateOfferLegacy: function (window) {
          var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;

          window.RTCPeerConnection.prototype.createOffer = function (offerOptions) {
            var pc = this;

            if (offerOptions) {
              var audioTransceiver = pc.getTransceivers().find(function (transceiver) {
                return transceiver.sender.track && transceiver.sender.track.kind === 'audio';
              });

              if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
                if (audioTransceiver.direction === 'sendrecv') {
                  if (audioTransceiver.setDirection) {
                    audioTransceiver.setDirection('sendonly');
                  } else {
                    audioTransceiver.direction = 'sendonly';
                  }
                } else if (audioTransceiver.direction === 'recvonly') {
                  if (audioTransceiver.setDirection) {
                    audioTransceiver.setDirection('inactive');
                  } else {
                    audioTransceiver.direction = 'inactive';
                  }
                }
              } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
                pc.addTransceiver('audio');
              }

              var videoTransceiver = pc.getTransceivers().find(function (transceiver) {
                return transceiver.sender.track && transceiver.sender.track.kind === 'video';
              });

              if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
                if (videoTransceiver.direction === 'sendrecv') {
                  videoTransceiver.setDirection('sendonly');
                } else if (videoTransceiver.direction === 'recvonly') {
                  videoTransceiver.setDirection('inactive');
                }
              } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
                pc.addTransceiver('video');
              }
            }

            return origCreateOffer.apply(pc, arguments);
          };
        }
      };
    }, {
      "../utils": 13
    }],
    13: [function (require, module, exports) {
      /*
      *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
      *
      *  Use of this source code is governed by a BSD-style license
      *  that can be found in the LICENSE file in the root of the source
      *  tree.
      */

      /* eslint-env node */
      'use strict';

      var logDisabled_ = true;
      var deprecationWarnings_ = true;
      /**
      * Extract browser version out of the provided user agent string.
      *
      * @param {!string} uastring userAgent string.
      * @param {!string} expr Regular expression used as match criteria.
      * @param {!number} pos position in the version string to be returned.
      * @return {!number} browser version.
      */

      function extractVersion(uastring, expr, pos) {
        var match = uastring.match(expr);
        return match && match.length >= pos && parseInt(match[pos], 10);
      } // Wraps the peerconnection event eventNameToWrap in a function
      // which returns the modified event object.


      function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
        if (!window.RTCPeerConnection) {
          return;
        }

        var proto = window.RTCPeerConnection.prototype;
        var nativeAddEventListener = proto.addEventListener;

        proto.addEventListener = function (nativeEventName, cb) {
          if (nativeEventName !== eventNameToWrap) {
            return nativeAddEventListener.apply(this, arguments);
          }

          var wrappedCallback = function (e) {
            cb(wrapper(e));
          };

          this._eventMap = this._eventMap || {};
          this._eventMap[cb] = wrappedCallback;
          return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
        };

        var nativeRemoveEventListener = proto.removeEventListener;

        proto.removeEventListener = function (nativeEventName, cb) {
          if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
            return nativeRemoveEventListener.apply(this, arguments);
          }

          var unwrappedCb = this._eventMap[cb];
          delete this._eventMap[cb];
          return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
        };

        Object.defineProperty(proto, 'on' + eventNameToWrap, {
          get: function () {
            return this['_on' + eventNameToWrap];
          },
          set: function (cb) {
            if (this['_on' + eventNameToWrap]) {
              this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
              delete this['_on' + eventNameToWrap];
            }

            if (cb) {
              this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
            }
          }
        });
      } // Utility methods.


      module.exports = {
        extractVersion: extractVersion,
        wrapPeerConnectionEvent: wrapPeerConnectionEvent,
        disableLog: function (bool) {
          if (typeof bool !== 'boolean') {
            return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');
          }

          logDisabled_ = bool;
          return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
        },

        /**
         * Disable or enable deprecation warnings
         * @param {!boolean} bool set to true to disable warnings.
         */
        disableWarnings: function (bool) {
          if (typeof bool !== 'boolean') {
            return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');
          }

          deprecationWarnings_ = !bool;
          return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
        },
        log: function () {
          if (typeof window === 'object') {
            if (logDisabled_) {
              return;
            }

            if (typeof console !== 'undefined' && typeof console.log === 'function') {
              console.log.apply(console, arguments);
            }
          }
        },

        /**
         * Shows a deprecation warning suggesting the modern and spec-compatible API.
         */
        deprecated: function (oldMethod, newMethod) {
          if (!deprecationWarnings_) {
            return;
          }

          console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
        },

        /**
         * Browser detector.
         *
         * @return {object} result containing browser and version
         *     properties.
         */
        detectBrowser: function (window) {
          var navigator = window && window.navigator; // Returned result object.

          var result = {};
          result.browser = null;
          result.version = null; // Fail early if it's not a browser

          if (typeof window === 'undefined' || !window.navigator) {
            result.browser = 'Not a browser.';
            return result;
          }

          if (navigator.mozGetUserMedia) {
            // Firefox.
            result.browser = 'firefox';
            result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
          } else if (navigator.webkitGetUserMedia) {
            // Chrome, Chromium, Webview, Opera.
            // Version matches Chrome/WebRTC version.
            result.browser = 'chrome';
            result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
          } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
            // Edge.
            result.browser = 'edge';
            result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
          } else if (navigator.mediaDevices && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
            // Safari.
            result.browser = 'safari';
            result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
          } else {
            // Default fallthrough: not supported.
            result.browser = 'Not a supported browser.';
            return result;
          }

          return result;
        }
      };
    }, {}]
  }, {}, [3])(3);
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(175), __webpack_require__(37)))

/***/ }),

/***/ 3240:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 3241:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/592926db941cdc26a295b04fe73a0941.png";

/***/ }),

/***/ 3242:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/6fbba1ef0a773e527956f9432d66b6c8.png";

/***/ }),

/***/ 3243:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/26ef37d357cb33242c77cfb582ee93b8.png";

/***/ }),

/***/ 3244:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/89abb9191cbfc055b845df6fe529eef6.png";

/***/ }),

/***/ 3245:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/8f5a6181bf088c626368aa82e87cd892.gif";

/***/ }),

/***/ 3246:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/f9b9fa8cfe1095d0d9ee1742e865412f.png";

/***/ }),

/***/ 3247:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/28290356f1c9a40a89aeb6d4c6325e84.png";

/***/ }),

/***/ 3248:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/6e4fbc13f1746a0b955467f7ea2c676f.png";

/***/ }),

/***/ 3249:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/5be816be09516f862a7d06dff73d94db.png";

/***/ }),

/***/ 3250:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/b5f7bf7115fd4ab9e83402c742be280f.png";

/***/ }),

/***/ 3251:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/c52854e752fc48ee5d05d24866d9b064.png";

/***/ }),

/***/ 3252:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/8d69c9cd5a1d4141b7faf7c40ccb50b2.png";

/***/ }),

/***/ 3253:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/8ad48562da28aae870d0f1404a3f6176.png";

/***/ }),

/***/ 3254:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/916e0170ba8efd39ac6866c47f9c5571.png";

/***/ }),

/***/ 3255:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/d980dd93c5178099ac6acd1defdd37ac.png";

/***/ }),

/***/ 3256:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var utils_browser_history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(114);
/* harmony import */ var images_download_main_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3257);
/* harmony import */ var images_download_main_png__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(images_download_main_png__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var images_download_ao_logo_w_2x_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3258);
/* harmony import */ var images_download_ao_logo_w_2x_png__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(images_download_ao_logo_w_2x_png__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var api_upload_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2017);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







class App extends react__WEBPACK_IMPORTED_MODULE_0___default.a.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      info: {
        version: ""
      }
    });

    _defineProperty(this, "onClikDownMac", e => {
      window.open(`${document.location.protocol}//${window.location.host}/download/desktop?file_id=${this.state.info.mac_file_id}`);
    });

    _defineProperty(this, "onClikDownWindow", e => {
      window.open(`${document.location.protocol}//${window.location.host}/download/desktop?file_id=${this.state.info.win_file_id}`);
    });
  }

  //移除调用
  componentWillUnmount() {}

  componentDidMount() {
    Object(api_upload_js__WEBPACK_IMPORTED_MODULE_4__[/* getFile */ "a"])().then(data => {
      this.setState({
        info: data.data
      });
    });
  }

  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "download-page"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "header"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "left"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: images_download_ao_logo_w_2x_png__WEBPACK_IMPORTED_MODULE_3___default.a,
      width: "359px",
      height: "64px"
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      className: "desc-version"
    }, this.state.info.version), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "subtitle"
    }, "Make your IT team collaboration, ", react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      className: "green"
    }, "O"), "nclound,", react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      className: "green"
    }, "N"), "ogap,", react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
      className: "green"
    }, "E"), "fficient")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "right"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "mac icon-download"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "desc-download",
      onClick: this.onClikDownMac
    }, "Mac")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "win icon-download"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "desc-download",
      onClick: this.onClikDownWindow
    }, "Windows")))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "wrap-main"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
      src: images_download_main_png__WEBPACK_IMPORTED_MODULE_2___default.a,
      width: "100%"
    })));
  }

}

/* harmony default export */ __webpack_exports__["a"] = (App);

/***/ }),

/***/ 3257:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/7dbb7e5e389c6514a7c8f99b9c6496cf.png";

/***/ }),

/***/ 3258:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "files/bde34bf5262b73c56368af058cd82155.png";

/***/ }),

/***/ 3424:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/react-router/esm/react-router.js + 1 modules
var react_router = __webpack_require__(433);

// EXTERNAL MODULE: ./mattermost-redux/actions/users.js
var actions_users = __webpack_require__(35);

// EXTERNAL MODULE: ./mattermost-redux/actions/channels.js
var actions_channels = __webpack_require__(70);

// EXTERNAL MODULE: ./mattermost-redux/actions/teams.js
var actions_teams = __webpack_require__(299);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var entities_preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/general.js
var general = __webpack_require__(26);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var entities_users = __webpack_require__(10);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/teams.js
var entities_teams = __webpack_require__(32);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var entities_channels = __webpack_require__(15);

// EXTERNAL MODULE: ./actions/status_actions.jsx
var status_actions = __webpack_require__(246);

// EXTERNAL MODULE: ./actions/local_storage.jsx
var local_storage = __webpack_require__(678);

// EXTERNAL MODULE: ./actions/team_actions.jsx
var team_actions = __webpack_require__(1639);

// EXTERNAL MODULE: ./utils/route.jsx
var route = __webpack_require__(2009);

// EXTERNAL MODULE: ./actions/views/channel.js + 2 modules
var views_channel = __webpack_require__(1589);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/inobounce/inobounce.js
var inobounce = __webpack_require__(2392);
var inobounce_default = /*#__PURE__*/__webpack_require__.n(inobounce);

// EXTERNAL MODULE: ./actions/websocket_actions.jsx
var websocket_actions = __webpack_require__(1723);

// EXTERNAL MODULE: ./actions/global_actions.jsx
var global_actions = __webpack_require__(1567);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./utils/user_agent.jsx
var user_agent = __webpack_require__(39);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/async_load.jsx
var async_load = __webpack_require__(412);

// EXTERNAL MODULE: ./node_modules/bundle-loader?lazy!./components/backstage/index.js
var backstage = __webpack_require__(2393);
var backstage_default = /*#__PURE__*/__webpack_require__.n(backstage);

// EXTERNAL MODULE: ./components/announcement_bar/index.js + 9 modules
var announcement_bar = __webpack_require__(1664);

// EXTERNAL MODULE: ./plugins/pluggable/index.js + 1 modules
var pluggable = __webpack_require__(1647);

// EXTERNAL MODULE: ./components/system_notice/index.js + 2 modules
var system_notice = __webpack_require__(1965);

// EXTERNAL MODULE: ./mattermost-redux/actions/posts.js
var actions_posts = __webpack_require__(59);

// EXTERNAL MODULE: ./mattermost-redux/constants/index.js
var mattermost_redux_constants = __webpack_require__(17);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/roles.js
var roles = __webpack_require__(90);

// EXTERNAL MODULE: ./actions/views/modals.js
var modals = __webpack_require__(1578);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./actions/views/posts.js
var views_posts = __webpack_require__(1618);

// EXTERNAL MODULE: ./selectors/posts.js
var selectors_posts = __webpack_require__(415);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Modal.js
var Modal = __webpack_require__(1972);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./components/delete_post_modal/index.js + 1 modules
var delete_post_modal = __webpack_require__(2267);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Overlay.js
var Overlay = __webpack_require__(1852);

// EXTERNAL MODULE: ./utils/position_utils.jsx
var position_utils = __webpack_require__(2000);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tabs.js
var Tabs = __webpack_require__(2007);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tab.js
var Tab = __webpack_require__(2006);

// EXTERNAL MODULE: ./node_modules/react-addons-pure-render-mixin/index.js
var react_addons_pure_render_mixin = __webpack_require__(2395);
var react_addons_pure_render_mixin_default = /*#__PURE__*/__webpack_require__.n(react_addons_pure_render_mixin);

// EXTERNAL MODULE: ./mattermost-redux/actions/gifs.js
var actions_gifs = __webpack_require__(1655);

// EXTERNAL MODULE: ./mattermost-redux/utils/theme_utils.js
var theme_utils = __webpack_require__(4);

// CONCATENATED MODULE: ./components/gif_picker/utils/constants.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
/* harmony default export */ var utils_constants = ({
  ItemTapAction: {
    OPEN_EMBED_PAGE: 1,
    SHARE: 2
  },
  Tab: {
    TRENDING: 0,
    REACTIONS: 1
  },
  appName: {
    mattermost: 'aboutone'
  }
});
// CONCATENATED MODULE: ./components/svg/gif_search_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

class gif_search_icon_GifSearchIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement("svg", {
      width: "100%",
      height: "100%",
      viewBox: "-10 -10 40 40",
      version: "1.1"
    }, react_default.a.createElement("g", {
      id: "ic_search",
      transform: "matrix(0.959095,-9.6091e-18,-1.00189e-17,0.959095,-0.0633002,-0.777826)"
    }, react_default.a.createElement("path", {
      d: "M2.648,15.872C3.433,16.658 4.376,17.287 5.454,17.758C6.553,18.229 7.698,18.454 8.888,18.454C10.728,18.454 12.389,17.938 13.893,16.905L18.18,21.192C18.494,21.506 18.854,21.664 19.302,21.664C19.751,21.664 20.111,21.506 20.447,21.192C20.761,20.855 20.919,20.496 20.919,20.047C20.919,19.621 20.761,19.239 20.447,18.925L16.16,14.638C17.193,13.134 17.709,11.473 17.709,9.633C17.709,8.443 17.484,7.298 17.013,6.198C16.542,5.121 15.913,4.178 15.128,3.393C14.342,2.607 13.399,1.979 12.322,1.507C11.222,1.036 10.077,0.811 8.888,0.811C7.698,0.811 6.553,1.036 5.454,1.507C4.376,1.979 3.433,2.607 2.648,3.393C1.862,4.178 1.234,5.121 0.762,6.198C0.291,7.298 0.066,8.443 0.066,9.633C0.066,10.822 0.291,11.967 0.762,13.067C1.234,14.144 1.862,15.087 2.648,15.872ZM8.888,4.021C10.436,4.021 11.761,4.56 12.861,5.66C13.96,6.76 14.499,8.084 14.499,9.633C14.499,11.181 13.96,12.506 12.861,13.606C11.761,14.705 10.436,15.244 8.888,15.244C7.339,15.244 6.015,14.705 4.915,13.606C3.815,12.506 3.276,11.181 3.276,9.633C3.276,8.084 3.815,6.76 4.915,5.66C6.015,4.56 7.339,4.021 8.888,4.021Z",
      style: {
        fill: 'inherit'
      }
    }))));
  }

}
// CONCATENATED MODULE: ./components/svg/gif_search_clear_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

class gif_search_clear_icon_GifSearchClearIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement("svg", {
      width: "100%",
      height: "100%",
      viewBox: "-10 -10 40 40",
      enableBackground: "new 0 0 20 20",
      version: "1.1"
    }, react_default.a.createElement("g", {
      transform: "matrix(0.952381,0,0,1,0,0)"
    }, react_default.a.createElement("path", {
      fill: "inherit",
      d: "M10.5 11.7L2.2 19.8C2 19.9 1.9 20 1.7 20 1.6 20 1.4 19.9 1.3 19.8L0.2 18.8C0.1 18.7 0 18.5 0 18.3 0 18.2 0.1 18 0.2 17.9L8.3 10 0.2 2.1C0.1 2 0 1.8 0 1.7 0 1.5 0.1 1.3 0.2 1.2L1.3 0.2C1.4 0.1 1.6 0 1.7 0 1.9 0 2 0.1 2.2 0.2L10.5 8.3 18.8 0.2C19 0.1 19.1 0 19.3 0 19.4 0 19.6 0.1 19.7 0.2L20.8 1.2C20.9 1.3 21 1.5 21 1.7 21 1.8 20.9 2 20.8 2.1L12.7 10 20.8 17.9C20.9 18 21 18.2 21 18.3 21 18.5 20.9 18.7 20.8 18.8L19.7 19.8C19.6 19.9 19.4 20 19.3 20 19.1 20 19 19.9 18.8 19.8L10.5 11.7Z"
    }))));
  }

}
// EXTERNAL MODULE: ./components/localized_input/localized_input.jsx
var localized_input = __webpack_require__(1577);

// EXTERNAL MODULE: ./utils/i18n.jsx
var i18n = __webpack_require__(53);

// EXTERNAL MODULE: ./components/gif_picker/components/SearchBar/SearchBar.scss
var SearchBar_SearchBar = __webpack_require__(2399);

// CONCATENATED MODULE: ./components/gif_picker/components/SearchBar/index.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












function SearchBar_mapStateToProps(state) {
  return { ...state.entities.gifs.categories,
    ...state.entities.gifs.search,
    theme: Object(entities_preferences["getTheme"])(state),
    appProps: state.entities.gifs.app
  };
}

const mapDispatchToProps = {
  saveSearchBarText: actions_gifs["saveSearchBarText"],
  saveSearchScrollPosition: actions_gifs["saveSearchScrollPosition"],
  searchTextUpdate: actions_gifs["searchTextUpdate"]
};
const getStyle = Object(theme_utils["makeStyleFromTheme"])(theme => {
  return {
    background: {
      backgroundColor: theme.centerChannelBg
    },
    icon: {
      fill: Object(theme_utils["changeOpacity"])(theme.centerChannelColor, 0.4)
    },
    inputBackground: {
      backgroundColor: theme.centerChannelBg
    },
    input: {
      borderColor: Object(theme_utils["changeOpacity"])(theme.centerChannelColor, 0.12)
    }
  };
});
class components_SearchBar_SearchBar extends react["Component"] {
  constructor(props) {
    super(props);

    _defineProperty(this, "parseSearchText", searchText => {
      return searchText.trim().split(/ +/).join('-');
    });

    _defineProperty(this, "removeExtraSpaces", searchText => {
      return searchText.trim().split(/ +/).join(' ');
    });

    _defineProperty(this, "updateSearchInputValue", searchText => {
      this.searchInput.value = searchText;
      this.props.saveSearchBarText(searchText);
    });

    _defineProperty(this, "handleSubmit", event => {
      event.preventDefault();
      this.triggerSearch(this.searchInput.value);
      this.searchInput.blur();
    });

    _defineProperty(this, "triggerSearch", searchText => {
      const {
        onSearch
      } = this.props;
      this.props.searchTextUpdate(this.parseSearchText(searchText));
      onSearch();
      this.props.saveSearchScrollPosition(0);
    });

    _defineProperty(this, "handleChange", event => {
      clearTimeout(this.searchTimeout);
      const searchText = event.target.value;
      const {
        onCategories,
        action
      } = this.props;
      this.props.saveSearchBarText(searchText);

      if (searchText === '') {
        onCategories();
      } else if (action !== 'reactions' || !this.isFilteredTags(searchText)) {
        // not reactions page or there's no reactions for this search request
        this.searchTimeout = setTimeout(() => {
          this.triggerSearch(searchText);
        }, 500);
      }
    });

    _defineProperty(this, "focusInput", () => {
      this.setState({
        inputFocused: true
      });
    });

    _defineProperty(this, "blurInput", () => {
      this.setState({
        inputFocused: false
      });
    });

    _defineProperty(this, "isFilteredTags", searchText => {
      var text = this.removeExtraSpaces(searchText);
      const {
        tagsList
      } = this.props;
      const substr = text.toLowerCase();
      const filteredTags = tagsList && tagsList.length ? tagsList.filter(tag => {
        if (!text || tag.tagName.indexOf(substr) !== -1) {
          return tag;
        }

        return '';
      }) : [];
      return Boolean(filteredTags.length);
    });

    _defineProperty(this, "clearSearchHandle", () => {
      const {
        action,
        onTrending,
        onCategories
      } = this.props;
      this.updateSearchInputValue('');

      if (action === 'reactions') {
        onCategories();
      } else {
        onTrending();
      }
    });

    this.state = {
      inputFocused: false
    };
    this.searchTimeout = null;
    this.props.saveSearchBarText('');
    this.props.searchTextUpdate('');
  }

  componentDidUpdate(prevProps) {
    const {
      searchBarText
    } = this.props;

    if (searchBarText !== prevProps.searchBarText) {
      if (searchBarText === 'trending') {
        this.updateSearchInputValue('');
      } else {
        this.updateSearchInputValue(searchBarText);
      }
    }
  }
  /**
   * Returns text request with hyphens
   */


  shouldComponentUpdate(nextProps, nextState) {
    return !nextProps.searchBarText && this.props.searchBarText || nextProps.searchBarText && !this.props.searchBarText || nextState.inputFocused !== this.state.inputFocused;
  }

  render() {
    const style = getStyle(this.props.theme);
    const {
      searchBarText
    } = this.props;
    const clearSearchButton = searchBarText ? react_default.a.createElement(gif_search_clear_icon_GifSearchClearIcon, {
      className: "ic-clear-search",
      style: style.icon,
      onClick: this.clearSearchHandle
    }) : null;
    return react_default.a.createElement("form", {
      className: "gfycat-search",
      method: "get",
      target: "_top",
      noValidate: "",
      onSubmit: this.handleSubmit
    }, react_default.a.createElement("div", {
      className: "search-bar",
      style: style.background
    }, react_default.a.createElement("div", {
      className: "search-input-bg",
      style: style.inputBackground
    }), react_default.a.createElement(localized_input["a" /* default */], {
      className: "search-input",
      name: "searchText",
      autoFocus: true,
      placeholder: {
        id: Object(i18n["b" /* t */])('gif_picker.gfycat'),
        defaultMessage: 'Search Gfycat'
      },
      onChange: this.handleChange,
      autoComplete: "off",
      autoCapitalize: "off",
      onFocus: this.focusInput,
      onBlur: this.blurInput,
      ref: input => {
        this.searchInput = input;
        return input;
      },
      style: style.input
    }), react_default.a.createElement(gif_search_icon_GifSearchIcon, {
      className: "ic ic-search",
      style: style.icon
    }), clearSearchButton), react_default.a.createElement("button", {
      type: "submit",
      className: "submit-button"
    }));
  }

}

_defineProperty(components_SearchBar_SearchBar, "propTypes", {
  searchBarText: prop_types_default.a.string,
  tagsList: prop_types_default.a.array,
  theme: prop_types_default.a.object.isRequired,
  onTrending: prop_types_default.a.func,
  onSearch: prop_types_default.a.func,
  onCategories: prop_types_default.a.func,
  action: prop_types_default.a.string,
  saveSearchScrollPosition: prop_types_default.a.func,
  saveSearchBarText: prop_types_default.a.func,
  searchTextUpdate: prop_types_default.a.func
});

/* harmony default export */ var components_SearchBar = (Object(es["connect"])(SearchBar_mapStateToProps, mapDispatchToProps)(components_SearchBar_SearchBar));
// CONCATENATED MODULE: ./components/svg/gif_trending_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

class gif_trending_icon_GifTrendingIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement("svg", {
      className: "ic-svg ic-trending-svg",
      width: "11px",
      height: "15px",
      viewBox: "0 0 11 15",
      version: "1.1"
    }, react_default.a.createElement("g", {
      id: "Finalized-Design",
      stroke: "none",
      fill: "inherit"
    }, react_default.a.createElement("g", {
      id: "GfyCat---Gycat-Tab",
      transform: "translate(-1212.000000, -619.000000)",
      fill: "inherit"
    }, react_default.a.createElement("g", {
      id: "modal---emojis",
      transform: "translate(1147.000000, 542.000000)"
    }, react_default.a.createElement("g", {
      id: "tabs---gfycat",
      transform: "translate(1.000000, 68.000000)"
    }, react_default.a.createElement("g", {
      id: "tab---trending---selected"
    }, react_default.a.createElement("path", {
      d: "M69.90625,10.4062776 C69.90625,10.9531513 70.0976562,11.4909106 70.4804688,12.019555 C70.6992188,12.32945 71.1276043,12.7760638 71.765625,13.3593956 C72.3489582,13.9062693 72.7773438,14.3346538 73.0507812,14.6445488 C73.5065106,15.1731932 73.8528644,15.7109525 74.0898438,16.2578262 C74.3632812,16.9505327 74.5,17.6979271 74.5,18.5000083 C74.5,19.4479229 74.2630207,20.3229208 73.7890625,21.1250021 C73.3151043,21.9270834 72.6770832,22.565103 71.875,23.03906 C71.0729168,23.5130171 70.1979168,23.7499958 69.25,23.7499958 C68.3020832,23.7499958 67.4270832,23.5130171 66.625,23.03906 C65.8229168,22.565103 65.1848957,21.9270834 64.7109375,21.1250021 C64.2369793,20.3229208 64,19.4479229 64,18.5000083 C64,17.6432397 64.2005207,16.8320436 64.6015625,16.0664204 C65.0026043,15.3007972 65.5494793,14.6718925 66.2421875,14.1797061 C66.4609375,14.0338733 66.6888019,14.0247585 66.9257812,14.1523625 C67.1627606,14.2799665 67.28125,14.4713723 67.28125,14.7265798 L67.28125,17.6250104 C67.28125,17.9349054 67.3860676,18.1946704 67.5957031,18.4043054 C67.8053387,18.6139405 68.0651043,18.7187578 68.375,18.7187578 C68.6848957,18.7187578 68.9446613,18.6139405 69.1542969,18.4043054 C69.3639324,18.1946704 69.46875,17.9349054 69.46875,17.6250104 C69.46875,17.4427191 69.4049481,17.2330844 69.2773438,16.9961057 C69.2044269,16.8320436 69.0677082,16.576836 68.8671875,16.2304825 C68.4661457,15.5742341 68.1835938,15.0547041 68.0195312,14.6718925 C67.7643231,13.9791859 67.6640625,13.2955938 67.71875,12.6211161 C67.8098957,11.7825763 68.1380207,10.9258077 68.703125,10.0508097 C68.8125,9.86851837 68.9628906,9.76825847 69.1542969,9.75002921 C69.3457031,9.73179994 69.5188801,9.78648731 69.6738281,9.91409132 C69.8287762,10.0416953 69.90625,10.2057574 69.90625,10.4062776 Z M69.2499875,22.437499 C69.9609233,22.437499 70.6171717,22.259765 71.2187328,21.9042971 C71.8202939,21.5488292 72.2988083,21.0703147 72.6542762,20.4687537 C73.0097441,19.8671926 73.1874781,19.2109441 73.1874781,18.5000083 C73.1874781,17.880218 73.0781034,17.3060006 72.8593539,16.7773562 C72.6588337,16.3398572 72.376282,15.9023583 72.0116996,15.4648593 C71.7929502,15.1914225 71.4329248,14.8131683 70.9316241,14.3300964 C70.4303233,13.8470245 70.070298,13.4687703 69.8515485,13.1953335 C69.4869662,12.7760638 69.2135294,12.3567937 69.031238,11.937524 C68.8671759,12.5573143 68.8945196,13.1953335 69.1132691,13.8515819 C69.2408731,14.2343935 69.5143099,14.7812672 69.9335796,15.492203 C70.2252457,15.9661601 70.4166515,16.321628 70.507797,16.5586067 C70.6900884,16.9414183 70.7812338,17.2968862 70.7812338,17.6250104 C70.7812338,18.2812589 70.5442551,18.8463618 70.070298,19.3203189 C69.596341,19.794276 69.031238,20.0312547 68.3749896,20.0312547 C67.7187411,20.0312547 67.1536382,19.794276 66.6796811,19.3203189 C66.205724,18.8463618 65.9687453,18.2812589 65.9687453,17.6250104 L65.9687453,16.0937641 C65.7682251,16.403659 65.60872,16.7819136 65.4902308,17.228527 C65.3717417,17.6751404 65.3124969,18.0989675 65.3124969,18.5000083 C65.3124969,19.2109441 65.4902308,19.8671926 65.8456987,20.4687537 C66.2011666,21.0703147 66.6796811,21.5488292 67.2812422,21.9042971 C67.8828032,22.259765 68.5390517,22.437499 69.2499875,22.437499 Z",
      id: "icon---trending"
    }))))))));
  }

}
// CONCATENATED MODULE: ./components/svg/gif_reactions_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

class gif_reactions_icon_GifReactionsIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement("svg", {
      className: "ic-svg ic-reactions-svg",
      width: "14px",
      height: "14px",
      viewBox: "0 0 14 14",
      version: "1.1"
    }, react_default.a.createElement("g", {
      id: "Finalized-Design",
      stroke: "none",
      fill: "inherit"
    }, react_default.a.createElement("g", {
      id: "GfyCat---Gycat-Tab",
      transform: "translate(-1348.000000, -620.000000)",
      fill: "inherit"
    }, react_default.a.createElement("g", {
      id: "modal---emojis",
      transform: "translate(1147.000000, 542.000000)"
    }, react_default.a.createElement("g", {
      id: "tabs---gfycat",
      transform: "translate(1.000000, 68.000000)"
    }, react_default.a.createElement("g", {
      id: "tab---category---deselected",
      transform: "translate(138.000000, 0.000000)"
    }, react_default.a.createElement("path", {
      d: "M62,16 L62,10 L68,10 L68,16 L62,16 Z M64,12 L64,14 L66,14 L66,12 L64,12 Z M70,24 L70,18 L76,18 L76,24 L70,24 Z M72,20 L72,22 L74,22 L74,20 L72,20 Z M70,10 L76,10 L76,16 L70,16 L70,10 Z M74,14 L74,12 L72,12 L72,14 L74,14 Z M62,24 L62,18 L68,18 L68,24 L62,24 Z M64,20 L64,22 L66,22 L66,20 L64,20 Z",
      id: "icon---categories"
    }))))))));
  }

}
// EXTERNAL MODULE: ./components/gif_picker/components/Header/Header.scss
var Header_Header = __webpack_require__(2400);

// CONCATENATED MODULE: ./components/gif_picker/components/Header/index.jsx
function Header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












function Header_mapStateToProps(state) {
  return {
    theme: Object(entities_preferences["getTheme"])(state)
  };
}

const Header_mapDispatchToProps = {
  saveSearchBarText: actions_gifs["saveSearchBarText"],
  searchTextUpdate: actions_gifs["searchTextUpdate"]
};
const Header_getStyle = Object(theme_utils["makeStyleFromTheme"])(theme => {
  return {
    background: {
      backgroundColor: theme.centerChannelBg
    },
    header: {
      borderBottomColor: Object(theme_utils["changeOpacity"])(theme.centerChannelColor, 0.2)
    },
    icon: {
      fill: Object(theme_utils["changeOpacity"])(theme.centerChannelColor, 0.3)
    },
    iconActive: {
      fill: theme.centerChannelColor
    },
    iconHover: {
      fill: Object(theme_utils["changeOpacity"])(theme.centerChannelColor, 0.8)
    }
  };
});
class components_Header_Header extends react["PureComponent"] {
  constructor(props) {
    super(props);
    this.state = {
      hovering: ''
    };
  }

  render() {
    const style = Header_getStyle(this.props.theme);
    return react_default.a.createElement("header", {
      className: "header-container",
      style: style.background
    }, react_default.a.createElement(components_SearchBar, this.props), react_default.a.createElement("nav", {
      className: "nav-bar",
      style: style.header
    }, this.renderTabs(this.props, style)));
  }

  renderTabs(props, style) {
    const {
      appProps,
      onTrending,
      onCategories
    } = props;
    const {
      header
    } = appProps;
    return header.tabs.map((tab, index) => {
      let link;

      if (tab === utils_constants.Tab.TRENDING) {
        link = this.renderTab('trending', onTrending, gif_trending_icon_GifTrendingIcon, index, style);
      } else if (tab === utils_constants.Tab.REACTIONS) {
        link = this.renderTab('reactions', onCategories, gif_reactions_icon_GifReactionsIcon, index, style);
      }

      return link;
    });
  }

  renderTab(name, callback, Icon, index, style) {
    var props = this.props;
    const {
      action
    } = props;

    function callbackWrapper() {
      props.searchTextUpdate('');
      props.saveSearchBarText('');
      callback();
    }

    return react_default.a.createElement("a", {
      onClick: callbackWrapper,
      onMouseOver: () => {
        this.setState({
          hovering: name
        });
      },
      onMouseOut: () => {
        this.setState({
          hovering: ''
        });
      },
      style: {
        cursor: 'pointer'
      },
      key: index
    }, react_default.a.createElement("div", {
      style: {
        paddingTop: '2px'
      }
    }, react_default.a.createElement(Icon, {
      style: (() => {
        if (this.state.hovering === name) {
          return style.iconHover;
        }

        return action === name ? style.iconActive : style.icon;
      })()
    })));
  }

}

Header_defineProperty(components_Header_Header, "propTypes", {
  action: prop_types_default.a.string,
  appProps: prop_types_default.a.object,
  saveSearchBarText: prop_types_default.a.func,
  searchTextUpdate: prop_types_default.a.func,
  theme: prop_types_default.a.object.isRequired
});

/* harmony default export */ var components_Header = (Object(es["connect"])(Header_mapStateToProps, Header_mapDispatchToProps)(components_Header_Header));
// CONCATENATED MODULE: ./components/gif_picker/components/App/index.jsx
function App_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const App_mapDispatchToProps = {
  saveAppProps: actions_gifs["saveAppProps"]
};
class App_App extends react["PureComponent"] {
  constructor(props) {
    super(props);
    const {
      appProps
    } = this.props;
    this.props.saveAppProps(appProps);
  }

  render() {
    const {
      appProps,
      action,
      onCategories,
      onSearch,
      onTrending,
      children
    } = this.props;
    const appClassName = 'main-container ' + (appProps.appClassName || '');
    return react_default.a.createElement("div", {
      className: appClassName
    }, react_default.a.createElement(components_Header, {
      appProps: appProps,
      action: action,
      onCategories: onCategories,
      onSearch: onSearch,
      onTrending: onTrending
    }), react_default.a.createElement("div", {
      className: "component-container"
    }, children));
  }

}

App_defineProperty(App_App, "propTypes", {
  appProps: prop_types_default.a.object,
  action: prop_types_default.a.string,
  onCategories: prop_types_default.a.func,
  onSearch: prop_types_default.a.func,
  onTrending: prop_types_default.a.func,
  children: prop_types_default.a.object,
  saveAppProps: prop_types_default.a.func,
  authenticateSdk: prop_types_default.a.func
});

/* harmony default export */ var components_App = (Object(es["connect"])(null, App_mapDispatchToProps)(App_App));
// EXTERNAL MODULE: ./actions/diagnostics_actions.jsx
var diagnostics_actions = __webpack_require__(300);

// EXTERNAL MODULE: ./utils/post_utils.jsx + 1 modules
var post_utils = __webpack_require__(407);

// CONCATENATED MODULE: ./components/gif_picker/components/InfiniteScroll/index.js
function InfiniteScroll_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class InfiniteScroll_InfiniteScroll extends react["PureComponent"] {
  constructor(props) {
    super(props);
    this.scrollListener = this.scrollListener.bind(this);
  }

  componentDidMount() {
    this.pageLoaded = this.props.pageStart;
    this.attachScrollListener();
    this.setScrollPosition();
  }

  componentDidUpdate() {
    this.attachScrollListener();
  }

  render() {
    const {
      children,
      element,
      hasMore,
      initialLoad,
      // eslint-disable-line no-unused-vars
      loader,
      loadMore,
      // eslint-disable-line no-unused-vars
      pageStart,
      // eslint-disable-line no-unused-vars
      threshold,
      // eslint-disable-line no-unused-vars
      useWindow,
      // eslint-disable-line no-unused-vars
      isReverse,
      // eslint-disable-line no-unused-vars
      scrollPosition,
      // eslint-disable-line no-unused-vars
      containerHeight,
      ...props
    } = this.props;

    props.ref = node => {
      this.scrollComponent = node;
    };

    const elementProps = containerHeight ? { ...props,
      style: {
        height: containerHeight
      }
    } : props;
    return react_default.a.createElement(element, elementProps, children, hasMore && (loader || this.defaultLoader));
  }

  calculateTopPosition(el) {
    if (!el) {
      return 0;
    }

    return el.offsetTop + this.calculateTopPosition(el.offsetParent);
  }

  setScrollPosition() {
    const {
      scrollPosition
    } = this.props;

    if (scrollPosition !== null) {
      window.scrollTo(0, scrollPosition);
    }
  }

  scrollListener() {
    const el = this.scrollComponent;
    const scrollEl = window;
    let offset;

    if (this.props.useWindow) {
      var scrollTop = 'pageYOffset' in scrollEl ? scrollEl.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;

      if (this.props.isReverse) {
        offset = scrollTop;
      } else {
        offset = this.calculateTopPosition(el) + (el.offsetHeight - scrollTop - window.innerHeight);
      }
    } else if (this.props.isReverse) {
      offset = el.parentNode.scrollTop;
    } else {
      offset = el.scrollHeight - el.parentNode.scrollTop - el.parentNode.clientHeight;
    }

    if (offset < Number(this.props.threshold)) {
      this.detachScrollListener(); // Call loadMore after detachScrollListener to allow for non-async loadMore functions

      if (typeof this.props.loadMore === 'function') {
        this.props.loadMore(this.pageLoaded += 1);
      }
    }
  }

  attachScrollListener() {
    if (!this.props.hasMore) {
      return;
    }

    let scrollEl = window;

    if (this.props.useWindow === false) {
      scrollEl = this.scrollComponent.parentNode;
    }

    scrollEl.addEventListener('scroll', this.scrollListener);
    scrollEl.addEventListener('resize', this.scrollListener);

    if (this.props.initialLoad) {
      this.scrollListener();
    }
  }

  detachScrollListener() {
    var scrollEl = window;

    if (this.props.useWindow === false) {
      scrollEl = this.scrollComponent.parentNode;
    }

    scrollEl.removeEventListener('scroll', this.scrollListener);
    scrollEl.removeEventListener('resize', this.scrollListener);
  }

  componentWillUnmount() {
    this.detachScrollListener();
  } // Set a defaut loader for all your `InfiniteScroll` components


  setDefaultLoader(loader) {
    this.defaultLoader = loader;
  }

}

InfiniteScroll_defineProperty(InfiniteScroll_InfiniteScroll, "propTypes", {
  children: prop_types_default.a.array,
  element: prop_types_default.a.string,
  hasMore: prop_types_default.a.bool,
  initialLoad: prop_types_default.a.bool,
  loader: prop_types_default.a.object,
  loadMore: prop_types_default.a.func.isRequired,
  pageStart: prop_types_default.a.number,
  threshold: prop_types_default.a.number,
  useWindow: prop_types_default.a.bool,
  isReverse: prop_types_default.a.bool,
  containerHeight: prop_types_default.a.number,
  scrollPosition: prop_types_default.a.number
});

InfiniteScroll_defineProperty(InfiniteScroll_InfiniteScroll, "defaultProps", {
  element: 'div',
  hasMore: false,
  initialLoad: true,
  pageStart: 0,
  threshold: 250,
  useWindow: true,
  isReverse: false,
  containerHeight: null,
  scrollPosition: null
});
// EXTERNAL MODULE: ./components/gif_picker/components/Categories/Categories.scss
var Categories_Categories = __webpack_require__(2401);

// CONCATENATED MODULE: ./components/gif_picker/components/Categories/index.jsx
function Categories_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











function Categories_mapStateToProps(state) {
  return { ...state.entities.gifs.categories,
    ...state.entities.gifs.cache,
    theme: Object(entities_preferences["getTheme"])(state),
    appProps: state.entities.gifs.app,
    searchText: state.entities.gifs.search.searchText,
    searchBarText: state.entities.gifs.search.searchBarText,
    hasImageProxy: state.entities.general.config.HasImageProxy
  };
}

const Categories_mapDispatchToProps = {
  saveSearchBarText: actions_gifs["saveSearchBarText"],
  saveSearchScrollPosition: actions_gifs["saveSearchScrollPosition"],
  searchTextUpdate: actions_gifs["searchTextUpdate"],
  requestCategoriesList: actions_gifs["requestCategoriesList"],
  requestCategoriesListIfNeeded: actions_gifs["requestCategoriesListIfNeeded"]
};
const Categories_getStyle = Object(theme_utils["makeStyleFromTheme"])(theme => {
  return {
    background: {
      backgroundColor: Object(theme_utils["changeOpacity"])(theme.centerChannelColor, 0.05)
    }
  };
});
class components_Categories_Categories extends react["PureComponent"] {
  constructor(...args) {
    super(...args);

    Categories_defineProperty(this, "sendImpressions", () => {
      const {
        tagsList
      } = this.props;
      const gfycats = tagsList.map(tag => {
        return {
          gfyId: tag.gfyId
        };
      });

      if (gfycats.length) {
        Object(diagnostics_actions["d" /* trackEvent */])('gfycat', 'views', {
          context: 'category_list',
          count: gfycats.length
        });
      }
    });

    Categories_defineProperty(this, "filterTagsList", () => {
      const {
        searchBarText,
        tagsList
      } = this.props;
      const substr = searchBarText.toLowerCase().trim().split(/ +/).join(' ');
      return tagsList && tagsList.length ? tagsList.filter(tag => {
        if (!searchBarText || tag.tagName.indexOf(substr) !== -1) {
          return tag;
        }

        return '';
      }) : [];
    });

    Categories_defineProperty(this, "loadMore", () => {
      this.props.requestCategoriesList();
    });
  }

  componentDidMount() {
    window.scrollTo(0, 0);
    this.props.requestCategoriesListIfNeeded();
    this.sendImpressions();
  }

  componentWillUnmount() {
    this.props.saveSearchScrollPosition(0);
  }

  render() {
    const style = Categories_getStyle(this.props.theme);
    const {
      hasMore,
      tagsList,
      gifs,
      onSearch,
      onTrending,
      hasImageProxy
    } = this.props;
    const content = tagsList && tagsList.length ? this.filterTagsList(tagsList).map((item, index) => {
      const {
        tagName,
        gfyId
      } = item;

      if (!gifs[gfyId]) {
        return null;
      }

      const gfyItem = gifs[gfyId];
      const {
        max1mbGif,
        avgColor
      } = gfyItem;
      const url = post_utils["e" /* getImageSrc */](max1mbGif, hasImageProxy === 'true');
      const searchText = tagName.replace(/\s/g, '-');
      const backgroundImage = {
        backgroundImage: `url(${url}`
      };
      const backgroundColor = {
        backgroundColor: avgColor
      };
      const props = this.props;

      function callback() {
        props.searchTextUpdate(tagName);
        props.saveSearchBarText(tagName);

        if (searchText === 'trending') {
          onTrending();
        } else {
          onSearch();
        }
      }

      return react_default.a.createElement("a", {
        onClick: callback,
        key: index
      }, react_default.a.createElement("div", {
        className: "category-container"
      }, react_default.a.createElement("div", {
        className: "category",
        style: { ...backgroundImage,
          ...backgroundColor
        }
      }, react_default.a.createElement("div", {
        className: "category-name"
      }, tagName))));
    }) : [];
    return content && content.length ? react_default.a.createElement("div", {
      className: "categories-container",
      style: style.background
    }, react_default.a.createElement(InfiniteScroll_InfiniteScroll, {
      hasMore: hasMore,
      loadMore: this.loadMore,
      threshold: 1
    }, content)) : react_default.a.createElement("div", {
      className: "categories-container",
      style: style.background
    });
  }

}

Categories_defineProperty(components_Categories_Categories, "propTypes", {
  appProps: prop_types_default.a.object,
  gifs: prop_types_default.a.object,
  hasMore: prop_types_default.a.bool,
  onSearch: prop_types_default.a.func,
  onTrending: prop_types_default.a.func,
  requestCategoriesList: prop_types_default.a.func,
  requestCategoriesListIfNeeded: prop_types_default.a.func,
  saveSearchBarText: prop_types_default.a.func,
  saveSearchScrollPosition: prop_types_default.a.func,
  searchTextUpdate: prop_types_default.a.func,
  searchBarText: prop_types_default.a.string,
  tagsList: prop_types_default.a.array,
  hasImageProxy: prop_types_default.a.string,
  theme: prop_types_default.a.object.isRequired
});

/* harmony default export */ var components_Categories = (Object(es["connect"])(Categories_mapStateToProps, Categories_mapDispatchToProps)(components_Categories_Categories));
// EXTERNAL MODULE: ./components/gif_picker/components/SearchItem/SearchItem.scss
var SearchItem_SearchItem = __webpack_require__(2402);

// CONCATENATED MODULE: ./components/gif_picker/components/SearchItem/index.jsx
function SearchItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function SearchItem_mapStateToProps(state) {
  return {
    hasImageProxy: state.entities.general.config.HasImageProxy
  };
}

class components_SearchItem_SearchItem extends react["PureComponent"] {
  render() {
    const {
      gfyItem,
      top,
      left,
      itemWidth,
      itemClickHandler
    } = this.props;
    const {
      width,
      height,
      max1mbGif,
      avgColor
    } = gfyItem;
    const {
      hasImageProxy
    } = this.props;
    const url = post_utils["e" /* getImageSrc */](max1mbGif, hasImageProxy === 'true');
    const backgroundImage = {
      backgroundImage: `url(${url})`
    };
    const backgroundColor = {
      backgroundColor: avgColor
    };
    const paddingBottom = {
      paddingBottom: itemWidth / width * height + 'px'
    };
    return react_default.a.createElement("div", {
      className: "search-item-wrapper",
      style: {
        top,
        left,
        width: itemWidth ? `${itemWidth}px` : ''
      }
    }, react_default.a.createElement("div", {
      className: "search-item",
      style: { ...backgroundImage,
        ...backgroundColor,
        ...paddingBottom
      },
      onClick: () => itemClickHandler(gfyItem)
    }));
  }

}

SearchItem_defineProperty(components_SearchItem_SearchItem, "propTypes", {
  gfyItem: prop_types_default.a.object,
  top: prop_types_default.a.string,
  left: prop_types_default.a.string,
  itemWidth: prop_types_default.a.number,
  itemClickHandler: prop_types_default.a.func,
  hasImageProxy: prop_types_default.a.string
});

/* harmony default export */ var components_SearchItem = (Object(es["connect"])(SearchItem_mapStateToProps)(components_SearchItem_SearchItem));
// EXTERNAL MODULE: ./components/gif_picker/components/SearchGrid/SearchGrid.scss
var SearchGrid_SearchGrid = __webpack_require__(2403);

// CONCATENATED MODULE: ./components/gif_picker/components/SearchGrid/SearchGrid.jsx
function SearchGrid_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const ITEMS_PADDING = 8;
const NUMBER_OF_COLUMNS_PORTRAIT = 2;
const NUMBER_OF_COLUMNS_LANDSCAPE = 2;
const WEBKIT_SCROLLBAR_WIDTH = 8;

function SearchGrid_mapStateToProps(state) {
  return { ...state.entities.gifs.cache,
    ...state.entities.gifs.search,
    theme: Object(entities_preferences["getTheme"])(state),
    appProps: state.entities.gifs.app
  };
}

const SearchGrid_mapDispatchToProps = {
  saveSearchScrollPosition: actions_gifs["saveSearchScrollPosition"]
};
const SearchGrid_getStyle = Object(theme_utils["makeStyleFromTheme"])(theme => {
  return {
    background: {
      backgroundColor: Object(theme_utils["changeOpacity"])(theme.centerChannelColor, 0.05)
    }
  };
});
class SearchGrid_SearchGrid_SearchGrid extends react["PureComponent"] {
  constructor(props) {
    super(props);

    SearchGrid_defineProperty(this, "setNumberOfColumns", () => {
      if (window.matchMedia('(orientation: portrait)').matches) {
        this.numberOfColumns = NUMBER_OF_COLUMNS_PORTRAIT;
      } else {
        this.numberOfColumns = NUMBER_OF_COLUMNS_LANDSCAPE;
      }
    });

    SearchGrid_defineProperty(this, "itemClickHandler", gfyItem => {
      const {
        keyword,
        handleItemClick
      } = this.props;
      this.props.saveSearchScrollPosition(this.scrollPosition);
      Object(diagnostics_actions["d" /* trackEvent */])('gfycat', 'shares', {
        gfyid: gfyItem.gfyId,
        keyword
      });
      handleItemClick(gfyItem);
    });

    SearchGrid_defineProperty(this, "minHeightColumnIndex", () => {
      return this.columnsHeights.indexOf(Math.min(...this.columnsHeights));
    });

    SearchGrid_defineProperty(this, "maxHeightColumnIndex", () => {
      return this.columnsHeights.indexOf(Math.max(...this.columnsHeights));
    });

    SearchGrid_defineProperty(this, "maxColumnHeight", () => {
      return Math.max(...this.columnsHeights);
    });

    SearchGrid_defineProperty(this, "resizeHandler", () => {
      if (this.state.containerWidth !== this.container.offsetWidth - WEBKIT_SCROLLBAR_WIDTH) {
        this.setNumberOfColumns();
        this.setState({ ...this.state,
          containerWidth: this.container.offsetWidth - WEBKIT_SCROLLBAR_WIDTH
        });
        this.columnsHeights = Array(this.numberOfColumns).fill(0);
      }
    });

    SearchGrid_defineProperty(this, "scrollHandler", () => {
      this.scrollPosition = window.scrollY;
    });

    this.state = {
      containerWidth: null
    };
    this.scrollPosition = this.props.scrollPosition;
    this.setNumberOfColumns();
    /**
     * Inital values for columns heights
     */

    this.columnsHeights = Array(this.numberOfColumns).fill(0);
    /**
     * Items padding value
     */

    this.padding = ITEMS_PADDING;
  }

  componentDidMount() {
    this.container = document.getElementById('search-grid-container'); // eslint-disable-next-line react/no-did-mount-set-state

    this.setState({ ...this.state,
      containerWidth: this.container.offsetWidth - WEBKIT_SCROLLBAR_WIDTH
    });
    window.addEventListener('resize', this.resizeHandler);
    window.addEventListener('scroll', this.scrollHandler);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.keyword !== this.props.keyword) {
      window.scrollTo(0, 0);
    }
  }

  componentWillUnmount() {
    const {
      keyword
    } = this.props;

    if (keyword !== 'trending') {
      this.props.saveSearchScrollPosition(this.scrollPosition);
    }

    window.removeEventListener('resize', this.resizeHandler);
    window.removeEventListener('scroll', this.scrollHandler);
  }

  render() {
    const style = SearchGrid_getStyle(this.props.theme);
    const {
      containerClassName,
      gifs,
      keyword,
      resultsByTerm,
      scrollPosition,
      loadMore,
      onCategories
    } = this.props;
    const {
      containerWidth
    } = this.state;
    const {
      moreRemaining,
      items = [],
      isEmpty
    } = resultsByTerm[keyword] ? resultsByTerm[keyword] : {};
    /**
     * Columns 'left' values
     */

    const columnWidth = parseInt(containerWidth / this.numberOfColumns, 10);
    const leftPosition = Array(this.numberOfColumns).fill(0).map((item, index) => this.padding + (index * columnWidth - index * (this.padding / 2)));
    this.columnsHeights = Array(this.numberOfColumns).fill(this.padding); // Item width in %
    //const itemWidth = this.numberOfColumns === NUMBER_OF_COLUMNS_PORTRAIT ? 100 / NUMBER_OF_COLUMNS_PORTRAIT : 100 / this.numberOfColumns;

    const itemWidth = 140;
    const searchItems = containerWidth && items.length ? items.map((item, index) => {
      const gfyItem = gifs[item];
      const {
        gfyId
      } = gfyItem; // Position calculation

      const colIndex = this.minHeightColumnIndex();
      const top = this.columnsHeights[colIndex] + 'px';
      const left = leftPosition[colIndex] + 'px';
      const itemHeight = itemWidth / gfyItem.width * gfyItem.height + this.padding;
      this.columnsHeights[colIndex] += itemHeight;
      return react_default.a.createElement(components_SearchItem, {
        gfyItem: gfyItem,
        top: top,
        left: left,
        itemWidth: itemWidth,
        itemClickHandler: this.itemClickHandler,
        key: `${index}-${gfyId}`
      });
    }) : null;
    this.containerHeight = this.maxColumnHeight();
    const content = searchItems ? react_default.a.createElement(InfiniteScroll_InfiniteScroll, {
      className: "search-grid-infinite-scroll",
      pageStart: 0,
      loadMore: loadMore,
      initialLoad: false,
      hasMore: moreRemaining,
      threshold: 1,
      containerHeight: this.containerHeight,
      scrollPosition: scrollPosition,
      useWindow: false
    }, searchItems) : null;
    const emptySearch = isEmpty ? react_default.a.createElement("div", {
      className: "empty-search"
    }, react_default.a.createElement("div", {
      className: "empty-search-image"
    }), react_default.a.createElement("p", null, '0 Gifs found for ', react_default.a.createElement("strong", null, keyword)), react_default.a.createElement("a", {
      onClick: onCategories
    }, react_default.a.createElement("div", {
      className: "empty-search-button"
    }, 'Go to Reactions'))) : null;
    return react_default.a.createElement("div", {
      id: "search-grid-container",
      className: `search-grid-container ${containerClassName}`,
      style: style.background
    }, content, emptySearch);
  }

}

SearchGrid_defineProperty(SearchGrid_SearchGrid_SearchGrid, "propTypes", {
  appProps: prop_types_default.a.object,
  gifs: prop_types_default.a.object,
  resultsByTerm: prop_types_default.a.object,
  containerClassName: prop_types_default.a.string,
  keyword: prop_types_default.a.string,
  // searchText, tagName
  handleItemClick: prop_types_default.a.func,
  onCategories: prop_types_default.a.func,
  loadMore: prop_types_default.a.func,
  numberOfColumns: prop_types_default.a.number,
  scrollPosition: prop_types_default.a.number,
  saveSearchScrollPosition: prop_types_default.a.func,
  theme: prop_types_default.a.object.isRequired
});

/* harmony default export */ var components_SearchGrid_SearchGrid = (Object(es["connect"])(SearchGrid_mapStateToProps, SearchGrid_mapDispatchToProps)(SearchGrid_SearchGrid_SearchGrid));
// CONCATENATED MODULE: ./components/gif_picker/components/SearchGrid/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function components_SearchGrid_mapStateToProps(state) {
  return { ...state.entities.gifs.cache,
    ...state.entities.gifs.search,
    appProps: state.entities.gifs.app
  };
}

function components_SearchGrid_mapDispatchToProps() {
  return {
    saveSearchScrollPosition: actions_gifs["saveSearchScrollPosition"]
  };
}

/* harmony default export */ var components_SearchGrid = (Object(es["connect"])(components_SearchGrid_mapStateToProps, components_SearchGrid_mapDispatchToProps)(components_SearchGrid_SearchGrid));
// CONCATENATED MODULE: ./components/gif_picker/components/Search/index.jsx
function Search_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function Search_mapStateToProps(state) {
  return { ...state.entities.gifs.search
  };
}

const Search_mapDispatchToProps = {
  searchGfycat: actions_gifs["searchGfycat"],
  searchIfNeededInitial: actions_gifs["searchIfNeededInitial"]
};
class Search_Search extends react["PureComponent"] {
  constructor(...args) {
    super(...args);

    Search_defineProperty(this, "loadMore", () => {
      const {
        searchText
      } = this.props;
      this.props.searchGfycat({
        searchText
      });
    });
  }

  componentDidMount() {
    const {
      searchText
    } = this.props;
    this.props.searchIfNeededInitial(searchText.split('-').join(' '));
  }

  componentDidUpdate(prevProps) {
    const {
      searchText
    } = this.props;

    if (prevProps.searchText !== searchText) {
      this.props.searchIfNeededInitial(searchText.split('-').join(' '));
    }
  }

  render() {
    const {
      handleItemClick,
      searchText,
      onCategories
    } = this.props;
    return react_default.a.createElement(components_SearchGrid, {
      keyword: searchText,
      handleItemClick: handleItemClick,
      onCategories: onCategories,
      loadMore: this.loadMore
    });
  }

}

Search_defineProperty(Search_Search, "propTypes", {
  handleItemClick: prop_types_default.a.func,
  onCategories: prop_types_default.a.func,
  searchText: prop_types_default.a.string,
  searchIfNeededInitial: prop_types_default.a.func,
  searchGfycat: prop_types_default.a.func
});

/* harmony default export */ var components_Search = (Object(es["connect"])(Search_mapStateToProps, Search_mapDispatchToProps)(Search_Search));
// CONCATENATED MODULE: ./components/gif_picker/components/Trending/index.jsx
function Trending_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const Trending_mapDispatchToProps = {
  searchCategory: actions_gifs["searchCategory"],
  searchIfNeededInitial: actions_gifs["searchIfNeededInitial"],
  saveSearchScrollPosition: actions_gifs["saveSearchScrollPosition"]
};
class Trending_Trending extends react["PureComponent"] {
  constructor(...args) {
    super(...args);

    Trending_defineProperty(this, "loadMore", () => {
      this.props.searchCategory({
        tagName: 'trending'
      });
    });
  }

  componentDidMount() {
    this.props.searchIfNeededInitial('trending');
  }

  componentWillUnmount() {
    this.props.saveSearchScrollPosition(0);
  }

  render() {
    const {
      handleItemClick,
      onCategories
    } = this.props;
    return react_default.a.createElement(components_SearchGrid, {
      keyword: "trending",
      handleItemClick: handleItemClick,
      onCategories: onCategories,
      loadMore: this.loadMore
    });
  }

}

Trending_defineProperty(Trending_Trending, "propTypes", {
  handleItemClick: prop_types_default.a.func,
  onCategories: prop_types_default.a.func,
  searchCategory: prop_types_default.a.func,
  searchIfNeededInitial: prop_types_default.a.func,
  saveSearchScrollPosition: prop_types_default.a.func
});

/* harmony default export */ var components_Trending = (Object(es["connect"])(null, Trending_mapDispatchToProps)(Trending_Trending));
// CONCATENATED MODULE: ./components/gif_picker/gif_picker.jsx
function gif_picker_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








const gif_picker_appProps = {
  appName: utils_constants.appName.mattermost,
  basePath: '/mattermost',
  itemTapType: utils_constants.ItemTapAction.SHARE,
  appClassName: 'gfycat',
  shareEvent: 'shareMattermost',
  appId: 'mattermostwebviews',
  enableHistory: true,
  header: {
    tabs: [utils_constants.Tab.TRENDING, utils_constants.Tab.REACTIONS],
    displayText: false
  }
};
class gif_picker_GifPicker extends react_default.a.Component {
  constructor(props) {
    super(props); // All props are primitives or treated as immutable

    this.shouldComponentUpdate = react_addons_pure_render_mixin_default.a.shouldComponentUpdate.bind(this);
    this.handleTrending = this.handleTrending.bind(this);
    this.handleCategories = this.handleCategories.bind(this);
    this.handleSearch = this.handleSearch.bind(this);
    this.handleItemClick = this.handleItemClick.bind(this);
    this.state = {
      action: 'trending'
    };
  }

  handleTrending() {
    this.setState({
      action: 'trending'
    });
  }

  handleCategories() {
    this.setState({
      action: 'reactions'
    });
  }

  handleSearch() {
    this.setState({
      action: 'search'
    });
  }

  handleItemClick(gif) {
    this.props.onGifClick(gif.max5mbGif);
  }

  render() {
    const {
      action
    } = this.state;
    let component;

    switch (action) {
      case 'reactions':
        component = react_default.a.createElement(components_Categories, {
          appProps: gif_picker_appProps,
          onTrending: this.handleTrending,
          onSearch: this.handleSearch
        });
        break;

      case 'search':
        component = react_default.a.createElement(components_Search, {
          appProps: gif_picker_appProps,
          onCategories: this.handleCategories,
          handleItemClick: this.handleItemClick
        });
        break;

      case 'trending':
        component = react_default.a.createElement(components_Trending, {
          appProps: gif_picker_appProps,
          onCategories: this.handleCategories,
          handleItemClick: this.handleItemClick
        });
        break;
    }

    return react_default.a.createElement("div", null, react_default.a.createElement(components_App, {
      appProps: gif_picker_appProps,
      action: action,
      onTrending: this.handleTrending,
      onCategories: this.handleCategories,
      onSearch: this.handleSearch
    }, component));
  }

}

gif_picker_defineProperty(gif_picker_GifPicker, "propTypes", {
  onGifClick: prop_types_default.a.func.isRequired
});
// CONCATENATED MODULE: ./components/svg/emoji_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

class emoji_icon_EmojiIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement("svg", {
      width: "16px",
      height: "16px",
      viewBox: "0 0 15 15",
      role: "icon",
      "aria-label": "Emoji icon"
    }, react_default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react_default.a.createElement("g", {
      transform: "translate(-1071.000000, -954.000000)",
      fill: "inherit"
    }, react_default.a.createElement("g", {
      transform: "translate(25.000000, 937.000000)"
    }, react_default.a.createElement("g", {
      transform: "translate(1046.000000, 17.000000)"
    }, react_default.a.createElement("path", {
      d: "M7.5,0.0852272727 C3.405,0.0852272727 0.0852272727,3.405 0.0852272727,7.5 C0.0852272727,11.595 3.405,14.9147727 7.5,14.9147727 C11.595,14.9147727 14.9147727,11.595 14.9147727,7.5 C14.9147727,3.405 11.595,0.0852272727 7.5,0.0852272727 Z M7.5,14.0663436 C3.87926951,14.0663436 0.933656417,11.1207305 0.933656417,7.5 C0.933656417,3.87926951 3.87926951,0.933656417 7.5,0.933656417 C11.1207305,0.933656417 14.0663436,3.87926951 14.0663436,7.5 C14.0663436,11.1207305 11.1207305,14.0663436 7.5,14.0663436 Z"
    }), react_default.a.createElement("path", {
      d: "M11.7732955,8.95397727 C12.0119318,8.90488636 12.2159659,9.11778409 12.1684091,9.35676136 C11.8063636,11.1790909 9.85346591,12.5710227 7.49846591,12.5710227 C5.15096591,12.5710227 3.20284091,11.1877841 2.83193182,9.37397727 C2.78181818,9.129375 2.99267045,8.911875 3.23744318,8.96198864 C4.85369318,9.29232955 10.1786932,9.28142045 11.7732955,8.95397727 Z"
    }), react_default.a.createElement("ellipse", {
      cx: "4.94318182",
      cy: "5.50431818",
      rx: "1",
      ry: "1.06534091"
    }), react_default.a.createElement("ellipse", {
      cx: "10.0568182",
      cy: "5.50431818",
      rx: "1",
      ry: "1.06534091"
    })))))));
  }

}
// CONCATENATED MODULE: ./components/svg/gfycat_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

class gfycat_icon_GfycatIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement("svg", {
      width: "22px",
      height: "14px",
      viewBox: "0 0 22 14"
    }, react_default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react_default.a.createElement("g", {
      transform: "translate(-1344.000000, -552.000000)",
      fill: "inherit"
    }, react_default.a.createElement("g", {
      transform: "translate(1147.000000, 542.000000)"
    }, react_default.a.createElement("g", {
      transform: "translate(1.000000, 1.000000)"
    }, react_default.a.createElement("g", {
      transform: "translate(138.000000, 0.000000)"
    }, react_default.a.createElement("path", {
      d: "M63.6748519,23 L62.2292481,23 C61.8176589,23 61.4619872,22.8510143 61.1631497,22.5539741 C60.8633954,22.2569338 60.71306,21.8993681 60.71306,21.4831393 C60.71306,21.0678417 60.8597287,20.710276 61.1539829,20.4132358 C61.4473204,20.1161955 61.800242,19.9672098 62.2118312,19.9672098 L63.6565183,19.9672098 C64.0681075,19.9672098 64.4182791,19.8219488 64.7061166,19.5304955 C64.993954,19.2390422 65.1378727,18.8917193 65.1378727,18.4866644 L65.1378727,15.4371134 C65.1378727,15.0208846 64.993954,14.6670436 64.7061166,14.3755903 C64.4182791,14.084137 64.0745243,13.938876 63.6748519,13.938876 C63.2632628,13.938876 62.9103411,14.0869305 62.6170036,14.3849019 C62.3227494,14.6819421 62.1760807,15.0329897 62.1760807,15.4371134 C62.1760807,15.7294978 62.3016658,16.0563352 62.5519193,16.4185567 L62.575753,16.4530096 C62.8269232,16.8143 62.9515917,17.1420685 62.9515917,17.4344529 C62.9515917,17.8506817 62.8049229,18.2073163 62.5115854,18.5043565 C62.2173313,18.8023279 61.8653263,18.9503824 61.4537371,18.9503824 C60.7836443,18.9503824 60.2198863,18.5164616 59.7615465,17.6486199 C59.373791,16.9232458 59.1794549,16.1857665 59.1794549,15.4371134 C59.1794549,14.188427 59.6176278,13.1213169 60.4930568,12.234852 C61.3684859,11.3493183 62.4226675,10.9060858 63.6565183,10.9060858 C64.8912858,10.9060858 65.9482175,11.3493183 66.8300633,12.234852 C67.7109925,13.1213169 68.1519154,14.188427 68.1519154,15.4371134 L68.1519154,18.4866644 C68.1519154,19.7353508 67.7137425,20.7996674 66.8383134,21.6796142 C65.9628844,22.559561 64.9087028,23 63.6748519,23 Z M80,15.9269039 C80,16.3068174 79.8689148,16.6317925 79.6076611,16.9027602 C79.3454907,17.173728 79.0319863,17.3096774 78.6653144,17.3096774 L76.8438719,17.3096774 L76.8438719,18.6589292 C76.8438719,19.0388427 76.7127867,19.3638178 76.4506164,19.6347855 C76.1893627,19.9057532 75.8749415,20.0417027 75.5082697,20.0417027 C75.1315143,20.0417027 74.8125098,19.9057532 74.5503394,19.6347855 C74.2890857,19.3638178 74.1580005,19.0388427 74.1580005,18.6589292 L74.1580005,13.1464583 C74.1580005,12.00858 74.5485061,11.0355171 75.3276838,10.2272697 C76.1077782,9.41995344 77.0473748,9.01582973 78.1473904,9.01582973 L78.6653144,9.01582973 C79.0319863,9.01582973 79.3454907,9.15177918 79.6076611,9.42274692 C79.8689148,9.69371467 80,10.0186897 80,10.3986033 C80,10.7775856 79.8689148,11.1034919 79.6076611,11.3744596 C79.3454907,11.6454273 79.0319863,11.7804456 78.6653144,11.7804456 L78.162974,11.7804456 C77.7963021,11.7804456 77.481881,11.9163951 77.2206273,12.1873628 C76.9584569,12.4583306 76.8282884,12.7777187 76.8282884,13.1464583 L76.8282884,14.5450615 L78.6653144,14.5450615 C79.0319863,14.5450615 79.3454907,14.681011 79.6076611,14.9519787 C79.8689148,15.2229465 80,15.5479215 80,15.9269039 Z M72.6344789,18.6589292 C72.6344789,19.0388427 72.5043104,19.3638178 72.24214,19.6347855 C71.9808863,19.9057532 71.6664652,20.0417027 71.2997933,20.0417027 C70.9340382,20.0417027 70.616867,19.9057532 70.3501132,19.6347855 C70.0833594,19.3638178 69.9495242,19.0388427 69.9495242,18.6589292 L69.9495242,14.170735 C69.9495242,13.7917526 70.0806094,13.4667775 70.3418631,13.1958098 C70.6040335,12.9239109 70.9175379,12.7888926 71.2842098,12.7888926 C71.6508817,12.7888926 71.9671361,12.9239109 72.2348066,13.1958098 C72.5015604,13.4667775 72.6344789,13.7917526 72.6344789,14.170735 L72.6344789,18.6589292 Z M58.3370263,12.5356169 C58.1023563,11.7441304 58.0042716,10.9163286 58.0042716,10.9163286 C57.9721878,10.6937812 58.1243566,10.547589 58.3425264,10.5904223 C58.3425264,10.5904223 58.5350291,10.6267376 58.8017829,10.6807449 C59.0767868,10.7375457 59.4324585,10.8139009 59.7404628,10.8921184 C60.3473048,11.0448287 60.95323,11.2720319 60.95323,11.2720319 C60.95323,11.2720319 60.2904706,11.6621882 59.7239626,12.3018956 C59.1565379,12.9406718 58.8650338,13.8420353 58.8650338,13.8420353 C58.8650338,13.8420353 58.5716963,13.3280346 58.3370263,12.5356169 Z M69.088762,12.5356169 C69.323432,11.7441304 69.4224334,10.9163286 69.4224334,10.9163286 C69.4536005,10.6937812 69.3014317,10.547589 69.0832619,10.5904223 C69.0832619,10.5904223 68.2921674,10.7384769 67.6853254,10.8921184 C67.0794002,11.0448287 66.4725583,11.2720319 66.4725583,11.2720319 C66.4725583,11.2720319 67.1353177,11.6621882 67.7027424,12.3018956 C68.2692504,12.9406718 68.5616712,13.8420353 68.5616712,13.8420353 C68.5616712,13.8420353 68.8550087,13.3280346 69.088762,12.5356169 Z M72.6344789,10.3818424 C72.6344789,10.7617559 72.5043104,11.086731 72.24214,11.3576987 C71.9808863,11.6286664 71.6664652,11.7646159 71.2997933,11.7646159 C70.9340382,11.7646159 70.616867,11.6286664 70.3501132,11.3576987 C70.0833594,11.086731 69.9495242,10.7617559 69.9495242,10.3818424 C69.9495242,10.00286 70.0806094,9.67788494 70.3418631,9.40691719 C70.6040335,9.13594945 70.9175379,9 71.2842098,9 C71.6508817,9 71.9671361,9.13594945 72.2348066,9.40691719 C72.5015604,9.67788494 72.6344789,10.00286 72.6344789,10.3818424 Z"
    }))))))));
  }

}
// CONCATENATED MODULE: ./components/emoji_picker/components/emoji_picker_header.jsx
function emoji_picker_header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class emoji_picker_header_EmojiPickerHeader extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("div", {
      className: "emoji-picker__header modal-header"
    }, react_default.a.createElement("button", {
      type: "button",
      className: "close emoji-picker__header-close-button",
      onClick: this.props.handleEmojiPickerClose
    }, react_default.a.createElement("span", {
      "aria-hidden": "true"
    }, '×'), react_default.a.createElement("span", {
      className: "sr-only"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: 'emoji_picker.close',
      defaultMessage: 'Close'
    }))), react_default.a.createElement("h4", {
      className: "modal-title emoji-picker__header-title"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: 'emoji_picker.header',
      defaultMessage: 'Emoji Picker'
    })));
  }

}

emoji_picker_header_defineProperty(emoji_picker_header_EmojiPickerHeader, "propTypes", {
  handleEmojiPickerClose: prop_types_default.a.func.isRequired
});
// EXTERNAL MODULE: ./mattermost-redux/actions/emojis.js
var actions_emojis = __webpack_require__(208);

// EXTERNAL MODULE: ./actions/emoji_actions.jsx
var emoji_actions = __webpack_require__(374);

// EXTERNAL MODULE: ./selectors/emojis.js + 1 modules
var selectors_emojis = __webpack_require__(119);

// EXTERNAL MODULE: ./node_modules/lodash/throttle.js
var throttle = __webpack_require__(2011);
var throttle_default = /*#__PURE__*/__webpack_require__.n(throttle);

// EXTERNAL MODULE: ./utils/emoji.jsx
var utils_emoji = __webpack_require__(100);

// CONCATENATED MODULE: ./utils/emoji_utils.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
function compareEmojis(emojiA, emojiB, searchedName) {
  const aName = emojiA.name || emojiA.aliases[0];
  const bName = emojiB.name || emojiB.aliases[0]; // Have the emojis that contain the search appear first

  const aPrefix = aName.startsWith(searchedName);
  const bPrefix = bName.startsWith(searchedName);

  if (aPrefix === bPrefix) {
    return aName.localeCompare(bName);
  } else if (aPrefix) {
    return -1;
  }

  return 1;
}
// EXTERNAL MODULE: ./images/img_trans.gif
var img_trans = __webpack_require__(1860);
var img_trans_default = /*#__PURE__*/__webpack_require__.n(img_trans);

// CONCATENATED MODULE: ./components/emoji_picker/components/emoji_picker_category.jsx
function emoji_picker_category_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class emoji_picker_category_EmojiPickerCategory extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }

  shouldComponentUpdate(nextProps) {
    return nextProps.selected !== this.props.selected || nextProps.enable !== this.props.enable;
  }

  handleClick(e) {
    e.preventDefault();
    this.props.onCategoryClick(this.props.category);
  }

  render() {
    let className = 'emoji-picker__category';

    if (this.props.selected) {
      className += ' emoji-picker__category--selected';
    }

    if (!this.props.enable) {
      className += ' disable';
    }

    return react_default.a.createElement("a", {
      className: className,
      href: "#",
      onClick: this.handleClick
    }, this.props.icon);
  }

}

emoji_picker_category_defineProperty(emoji_picker_category_EmojiPickerCategory, "propTypes", {
  category: prop_types_default.a.string.isRequired,
  icon: prop_types_default.a.node.isRequired,
  onCategoryClick: prop_types_default.a.func.isRequired,
  selected: prop_types_default.a.bool.isRequired,
  enable: prop_types_default.a.bool.isRequired
});
// EXTERNAL MODULE: ./node_modules/lodash/debounce.js
var debounce = __webpack_require__(1599);
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);

// EXTERNAL MODULE: ./mattermost-redux/utils/emoji_utils.js
var emoji_utils = __webpack_require__(250);

// CONCATENATED MODULE: ./components/emoji_picker/components/emoji_picker_item.jsx
function emoji_picker_item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const SCROLLING_ADDITIONAL_VISUAL_SPACING = 10; // to make give the emoji some visual 'breathing room'

const EMOJI_LAZY_LOAD_SCROLL_THROTTLE = 150;
class emoji_picker_item_EmojiPickerItem extends react_default.a.Component {
  constructor(...args) {
    super(...args);

    emoji_picker_item_defineProperty(this, "emojiItemRef", emojiItem => {
      this.emojiItem = emojiItem;
    });

    emoji_picker_item_defineProperty(this, "handleMouseOver", () => {
      if (!this.props.isSelected) {
        this.props.onItemOver(this.props.categoryIndex, this.props.emojiIndex);
      }
    });

    emoji_picker_item_defineProperty(this, "handleMouseOverThrottle", debounce_default()(this.handleMouseOver, EMOJI_LAZY_LOAD_SCROLL_THROTTLE, {
      leading: true,
      trailing: true
    }));

    emoji_picker_item_defineProperty(this, "handleClick", () => {
      this.props.onItemClick(this.props.emoji);
    });
  }

  shouldComponentUpdate(nextProps) {
    return nextProps.isSelected !== this.props.isSelected;
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (!this.props.isSelected && nextProps.isSelected) {
      const topOfTheEmojiItem = this.emojiItem.offsetTop;
      const bottomOfTheEmojiItem = topOfTheEmojiItem + this.emojiItem.offsetHeight;
      const {
        containerRef,
        containerTop,
        containerBottom
      } = nextProps;

      if (topOfTheEmojiItem < containerTop) {
        containerRef.scrollTop = topOfTheEmojiItem - SCROLLING_ADDITIONAL_VISUAL_SPACING;
      } else if (bottomOfTheEmojiItem > containerBottom) {
        containerRef.scrollTop = bottomOfTheEmojiItem - containerRef.offsetHeight + SCROLLING_ADDITIONAL_VISUAL_SPACING;
      }
    }
  }

  render() {
    const {
      emoji
    } = this.props;
    let itemClassName = 'emoji-picker__item';

    if (this.props.isSelected) {
      itemClassName += ' selected';
    }

    let spriteClassName = 'emojisprite';
    spriteClassName += ' emoji-category-' + emoji.category + '-' + emoji.batch;
    spriteClassName += ' emoji-' + emoji.filename;
    let image;

    if (emoji.category && emoji.batch) {
      image = react_default.a.createElement("img", {
        alt: 'emoji image',
        onMouseOver: this.handleMouseOverThrottle,
        src: img_trans_default.a,
        className: spriteClassName,
        onClick: this.handleClick,
        id: 'emoji-' + emoji.filename
      });
    } else {
      image = react_default.a.createElement("img", {
        alt: 'custom emoji image',
        onMouseOver: this.handleMouseOver,
        src: Object(emoji_utils["getEmojiImageUrl"])(emoji),
        className: 'emoji-category--custom',
        onClick: this.handleClick
      });
    }

    return react_default.a.createElement("div", {
      className: itemClassName,
      ref: this.emojiItemRef
    }, react_default.a.createElement("div", null, image));
  }

}

emoji_picker_item_defineProperty(emoji_picker_item_EmojiPickerItem, "propTypes", {
  emoji: prop_types_default.a.object.isRequired,
  onItemOver: prop_types_default.a.func.isRequired,
  onItemClick: prop_types_default.a.func.isRequired,
  category: prop_types_default.a.string.isRequired,
  isSelected: prop_types_default.a.bool,
  categoryIndex: prop_types_default.a.number.isRequired,
  emojiIndex: prop_types_default.a.number.isRequired,
  containerRef: prop_types_default.a.any,
  containerTop: prop_types_default.a.number.isRequired,
  containerBottom: prop_types_default.a.number.isRequired
});
// CONCATENATED MODULE: ./components/emoji_picker/emoji_picker_category_section.jsx
function emoji_picker_category_section_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class emoji_picker_category_section_EmojiPickerCategorySection extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    emoji_picker_category_section_defineProperty(this, "divRef", div => {
      this.div = div;
    });
  }

  componentDidMount() {
    this.props.updateCategoryOffset(this.props.categoryName, this.div.offsetTop);
  }

  render() {
    return react_default.a.createElement("div", {
      ref: this.divRef
    }, react_default.a.createElement("div", {
      className: "emoji-picker-items__container"
    }, react_default.a.createElement("div", {
      className: "emoji-picker__category-header",
      id: `emojipickercat-${this.props.categoryName}`
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: 'emoji_picker.' + this.props.categoryName
    }))), react_default.a.createElement("div", {
      className: "emoji-picker-items__container"
    }, this.props.children));
  }

}

emoji_picker_category_section_defineProperty(emoji_picker_category_section_EmojiPickerCategorySection, "propTypes", {
  categoryName: prop_types_default.a.string.isRequired,
  children: prop_types_default.a.any,
  updateCategoryOffset: prop_types_default.a.func.isRequired
});
// CONCATENATED MODULE: ./components/emoji_picker/components/emoji_picker_preview.jsx
function emoji_picker_preview_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class emoji_picker_preview_EmojiPickerPreview extends react_default.a.Component {
  render() {
    const emoji = this.props.emoji;

    if (emoji) {
      let name;
      let aliases;
      let previewImage;

      if (emoji.aliases && emoji.category && emoji.batch) {
        // This is a system emoji which only has a list of aliases
        name = emoji.aliases[0];
        aliases = emoji.aliases;
        previewImage = react_default.a.createElement("span", {
          className: "sprite-preview"
        }, react_default.a.createElement("img", {
          alt: 'emoji category image',
          src: img_trans_default.a,
          className: 'emojisprite-preview emoji-category-' + emoji.category + '-' + emoji.batch + ' emoji-' + emoji.filename
        }));
      } else {
        // This is a custom emoji that matches the model on the server
        name = emoji.name;
        aliases = [emoji.name];
        previewImage = react_default.a.createElement("img", {
          alt: 'emoji preview image',
          className: "emoji-picker__preview-image",
          src: Object(emoji_utils["getEmojiImageUrl"])(emoji)
        });
      }

      return react_default.a.createElement("div", {
        className: "emoji-picker__preview"
      }, react_default.a.createElement("div", {
        className: "emoji-picker__preview-image-box"
      }, previewImage), react_default.a.createElement("div", {
        className: "emoji-picker__preview-image-label-box"
      }, react_default.a.createElement("span", {
        className: "emoji-picker__preview-name"
      }, name), react_default.a.createElement("span", {
        className: "emoji-picker__preview-aliases"
      }, ':' + aliases[0] + ':')));
    }

    return react_default.a.createElement("div", {
      className: "emoji-picker__preview emoji-picker__preview-placeholder"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "emoji_picker.emojiPicker",
      defaultMessage: "Emoji Picker"
    }));
  }

}

emoji_picker_preview_defineProperty(emoji_picker_preview_EmojiPickerPreview, "propTypes", {
  emoji: prop_types_default.a.object
});
// CONCATENATED MODULE: ./components/emoji_picker/emoji_picker.jsx
function emoji_picker_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













const CATEGORY_SEARCH_RESULTS = 'searchResults';
Object(i18n["b" /* t */])('emoji_picker.searchResults');
const EMOJI_HEIGHT = 27; // If this changes, the spaceRequiredAbove and spaceRequiredBelow props passed to the EmojiPickerOverlay must be updated

const EMOJI_CONTAINER_HEIGHT = 290;
const EMOJI_CONTAINER_STYLE = {
  height: EMOJI_CONTAINER_HEIGHT
};
const EMOJI_LAZY_LOAD_BUFFER = 75;
const EMOJI_PER_ROW = 9; // needs to match variable `$emoji-per-row` in _variables.scss

const EMOJI_TO_LOAD_PER_UPDATE = 135;
const SYSTEM_EMOJIS_COUNT = 1476;
const emoji_picker_EMOJI_LAZY_LOAD_SCROLL_THROTTLE = 100;
const CATEGORIES = {
  recent: {
    name: 'recent',
    className: 'fa fa-clock-o',
    id: Object(i18n["b" /* t */])('emoji_picker.recent'),
    message: 'Recently Used',
    offset: 0
  },
  people: {
    name: 'people',
    className: 'fa fa-smile-o',
    id: Object(i18n["b" /* t */])('emoji_picker.people'),
    message: 'People',
    offset: 0
  },
  nature: {
    name: 'nature',
    className: 'fa fa-leaf',
    id: Object(i18n["b" /* t */])('emoji_picker.nature'),
    message: 'Nature',
    offset: 0
  },
  foods: {
    name: 'foods',
    className: 'fa fa-cutlery',
    id: Object(i18n["b" /* t */])('emoji_picker.foods'),
    message: 'Foods',
    offset: 0
  },
  activity: {
    name: 'activity',
    className: 'fa fa-futbol-o',
    id: Object(i18n["b" /* t */])('emoji_picker.activity'),
    message: 'Activity',
    offset: 0
  },
  places: {
    name: 'places',
    className: 'fa fa-plane',
    id: Object(i18n["b" /* t */])('emoji_picker.places'),
    message: 'Places',
    offset: 0
  },
  objects: {
    name: 'objects',
    className: 'fa fa-lightbulb-o',
    id: Object(i18n["b" /* t */])('emoji_picker.objects'),
    message: 'Objects',
    offset: 0
  },
  symbols: {
    name: 'symbols',
    className: 'fa fa-heart-o',
    id: Object(i18n["b" /* t */])('emoji_picker.symbols'),
    message: 'Symbols',
    offset: 0
  },
  flags: {
    name: 'flags',
    className: 'fa fa-flag-o',
    id: Object(i18n["b" /* t */])('emoji_picker.flags'),
    message: 'Flags',
    offset: 0
  },
  custom: {
    name: 'custom',
    className: 'fa fa-at',
    id: Object(i18n["b" /* t */])('emoji_picker.custom'),
    message: 'Custom',
    offset: 0
  }
};

function getEmojiFilename(emoji) {
  return emoji.filename || emoji.id;
}

const EMOJIS_PER_PAGE = 200;
const LOAD_MORE_AT_PIXELS_FROM_BOTTOM = 500;
class emoji_picker_EmojiPicker extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    emoji_picker_defineProperty(this, "loadMoreCustomEmojis", async () => {
      if (!this.props.customEmojisEnabled || this.loadingMoreEmojis) {
        return;
      }

      this.loadingMoreEmojis = true;
      const {
        data
      } = await this.props.actions.getCustomEmojis(this.props.customEmojiPage, EMOJIS_PER_PAGE);

      if (!data) {
        this.loadingMoreEmojis = false;
        return;
      }

      if (data.length < EMOJIS_PER_PAGE) {
        this.missingPages = false;
        this.loadingMoreEmojis = false;
        return;
      }

      await this.props.actions.incrementEmojiPickerPage();
      this.loadingMoreEmojis = false;
    });

    emoji_picker_defineProperty(this, "lastVisibleEmojiRef", lastVisibleEmoji => {
      this.lastVisibleEmoji = lastVisibleEmoji;
    });

    emoji_picker_defineProperty(this, "emojiPickerContainerRef", emojiPickerContainer => {
      this.emojiPickerContainer = emojiPickerContainer;
    });

    emoji_picker_defineProperty(this, "emojiSearchInput", input => {
      this.searchInput = input;
    });

    emoji_picker_defineProperty(this, "emojiCurrentResultsItems", (categoryIndex, emojis, currentEmojiLoadedCount) => {
      const {
        cursor,
        emojisToShow
      } = this.state;
      let numEmojisLoaded = currentEmojiLoadedCount;
      return emojis.map((emoji, emojiIndex) => {
        numEmojisLoaded++; // set ref on first unloaded emoji

        let ref;

        if (numEmojisLoaded === emojisToShow) {
          ref = this.lastVisibleEmojiRef;
        }

        if (numEmojisLoaded >= emojisToShow) {
          return react_default.a.createElement("div", {
            key: numEmojisLoaded,
            className: "emoji-picker__item",
            ref: ref
          }, react_default.a.createElement("img", {
            alt: 'emoji image',
            src: img_trans_default.a,
            className: "emojisprite"
          }));
        }

        return react_default.a.createElement(emoji_picker_item_EmojiPickerItem, {
          key: emoji.filename + ':' + emojiIndex,
          emoji: emoji,
          onItemOver: this.handleItemOver,
          onItemClick: this.handleItemClick,
          onItemUnmount: emoji,
          category: emoji.category,
          isSelected: cursor[0] === categoryIndex && cursor[1] === emojiIndex,
          categoryIndex: categoryIndex,
          emojiIndex: emojiIndex,
          containerRef: this.emojiPickerContainer,
          containerTop: this.state.divTopOffset,
          containerBottom: this.state.divTopOffset + this.divHeight
        });
      });
    });

    this.handleCategoryClick = this.handleCategoryClick.bind(this);
    this.handleFilterChange = this.handleFilterChange.bind(this);
    this.handleItemOver = this.handleItemOver.bind(this);
    this.handleItemClick = this.handleItemClick.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.handleScrollThrottle = throttle_default()(this.handleScroll, emoji_picker_EMOJI_LAZY_LOAD_SCROLL_THROTTLE, {
      leading: false,
      trailing: true
    });
    this.updateCategoryOffset = this.updateCategoryOffset.bind(this);
    this.divHeight = 0;
    this.missingPages = true;
    this.loadingMoreEmojis = false;
    this.state = {
      allEmojis: {},
      categories: CATEGORIES,
      filter: '',
      cursor: [0, 0],
      // categoryIndex, emojiIndex
      divTopOffset: 0,
      emojisToShow: SYSTEM_EMOJIS_COUNT
    };
  }

  UNSAFE_componentWillMount() {
    // eslint-disable-line camelcase
    if (this.props.customEmojiPage === 0) {
      this.loadMoreCustomEmojis();
    }

    this.getEmojis();
  }

  componentDidMount() {
    // Delay taking focus because this briefly renders offscreen when using an Overlay
    // so focusing it immediately on mount can cause weird scrolling
    requestAnimationFrame(() => {
      if (this.searchInput) {
        this.searchInput.focus();
      }
    });
    this.divHeight = this.emojiPickerContainer.offsetHeight;
  }

  UNSAFE_componentWillUpdate(nextProps, nextState) {
    // eslint-disable-line camelcase
    if (this.state.divTopOffset === nextState.divTopOffset) {
      return;
    }

    if (this.lastVisibleEmoji) {
      const difference = this.lastVisibleEmoji.offsetTop - (nextState.divTopOffset + EMOJI_CONTAINER_HEIGHT + EMOJI_LAZY_LOAD_BUFFER);

      if (difference <= 0) {
        const numToLoad = EMOJI_TO_LOAD_PER_UPDATE + Math.ceil(difference / EMOJI_HEIGHT * EMOJI_PER_ROW * -1);
        this.setState(state => ({
          emojisToShow: state.emojisToShow + numToLoad
        }));
      }
    }

    if (!this.missingPages || !this.emojiPickerContainer) {
      return;
    }

    const pixelsFromBottom = this.emojiPickerContainer.scrollHeight - nextState.divTopOffset - this.emojiPickerContainer.clientHeight;

    if (pixelsFromBottom <= LOAD_MORE_AT_PIXELS_FROM_BOTTOM) {
      this.loadMoreCustomEmojis();
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.emojiMap !== nextProps.emojiMap) {
      this.getEmojis(nextProps);
    }
  }

  componentDidUpdate(prevProps) {
    if (this.props.visible && !prevProps.visible) {
      this.searchInput.focus();
    }
  }

  handleCategoryClick(categoryName) {
    this.emojiPickerContainer.scrollTop = this.state.categories[categoryName].offset;
  }

  handleFilterChange(e) {
    e.preventDefault();
    const filter = e.target.value.toLowerCase();

    if (this.props.customEmojisEnabled && filter && filter.trim() !== '') {
      this.props.actions.searchCustomEmojis(filter);
    }

    this.setState(() => ({
      filter,
      cursor: [0, 0]
    }));
  }

  handleItemOver(categoryIndex, emojiIndex) {
    this.setState({
      cursor: [categoryIndex, emojiIndex]
    });
  }

  handleItemClick(emoji) {
    this.props.onEmojiClick(emoji);
  }

  handleKeyDown(e) {
    switch (e.key) {
      case 'ArrowRight':
        e.preventDefault();
        this.selectNextEmoji();
        break;

      case 'ArrowLeft':
        e.preventDefault();
        this.selectPrevEmoji();
        break;

      case 'ArrowUp':
        e.preventDefault();
        this.selectPrevEmoji(EMOJI_PER_ROW);
        break;

      case 'ArrowDown':
        e.preventDefault();
        this.selectNextEmoji(EMOJI_PER_ROW);
        break;

      case 'Enter':
        e.preventDefault();

        if (this.getCurrentEmojiByCursor(this.state.cursor)) {
          this.props.onEmojiClick(this.getCurrentEmojiByCursor(this.state.cursor));
        }

        break;
    }
  }

  handleScroll() {
    if (this.emojiPickerContainer) {
      this.setState({
        divTopOffset: this.emojiPickerContainer.scrollTop
      });
    }
  }

  selectNextEmoji(offset = 1) {
    const {
      cursor
    } = this.state; // try moving to next emoji in index

    let newCursor = [cursor[0], cursor[1] + offset];

    if (this.getCurrentEmojiByCursor(newCursor)) {
      this.setState({
        cursor: newCursor
      });
      return;
    } // try moving to next category


    newCursor = [cursor[0] + 1, 0];

    if (this.getCurrentEmojiByCursor(newCursor)) {
      this.setState({
        cursor: newCursor
      });
    }
  }

  selectPrevEmoji(offset = 1) {
    const {
      cursor
    } = this.state; // try moving to prev emoji in index

    let newCursor = [cursor[0], cursor[1] - offset];

    if (this.getCurrentEmojiByCursor(newCursor)) {
      this.setState({
        cursor: newCursor
      });
      return;
    } // try moving to end of prev category


    if (cursor[0] !== 0) {
      const newCategory = this.getCategoryByIndex(cursor[0] - 1);
      const lastVisibleEmojiInNewCategory = this.state.categories[newCategory.name].emojiIds.length - 1;
      newCursor = [cursor[0] - 1, lastVisibleEmojiInNewCategory];

      if (this.getCurrentEmojiByCursor(newCursor)) {
        this.setState({
          cursor: newCursor
        });
      }
    }
  }

  getCategoryByIndex(index) {
    if (this.state.filter && index !== 0) {
      return null;
    }

    return this.getCategoriesByKey(Object.keys(this.state.categories)[index]);
  }

  getCurrentEmojiByCursor(cursor) {
    const category = this.getCategoryByIndex(cursor[0]);

    if (!category) {
      return null;
    }

    return this.getEmojisByCategory(category)[cursor[1]];
  }

  getCategoriesByKey(key) {
    return this.state.filter ? {
      id: CATEGORY_SEARCH_RESULTS,
      name: CATEGORY_SEARCH_RESULTS
    } : this.state.categories[key];
  }

  sortEmojis(emojis) {
    const {
      recentEmojis: recentEmojisProps
    } = this.props;
    const recentEmojis = [];
    const emojisMinusRecent = [];
    Object.values(emojis).forEach(emoji => {
      let emojiArray = emojisMinusRecent;

      for (let i = 0; i < emoji.aliases.length; i++) {
        if (recentEmojisProps.includes(emoji.aliases[i].toLowerCase())) {
          emojiArray = recentEmojis;
        }
      }

      emojiArray.push(emoji);
    });

    const sortEmojisHelper = (a, b) => {
      return compareEmojis(a, b, this.state.filter);
    };

    recentEmojis.sort(sortEmojisHelper);
    emojisMinusRecent.sort(sortEmojisHelper);
    return [...recentEmojis, ...emojisMinusRecent];
  }

  getEmojisByCategory(category) {
    if (this.state.filter) {
      const emojis = Object.values(this.state.allEmojis).filter(emoji => {
        for (let i = 0; i < emoji.aliases.length; i++) {
          if (emoji.aliases[i].toLowerCase().includes(this.state.filter)) {
            return true;
          }
        }

        return false;
      });
      return this.sortEmojis(emojis);
    }

    return this.state.categories[category.name].emojiIds.map(emojiId => this.state.allEmojis[emojiId]);
  }

  getEmojis(props = this.props) {
    const {
      categories,
      allEmojis
    } = this.state;
    const emojiMap = props.emojiMap;
    const customEmojiMap = emojiMap.customEmojis;

    for (const category of Object.keys(categories)) {
      let categoryEmojis = [];

      if (category === 'recent') {
        const recentEmojis = [...this.props.recentEmojis].reverse();
        categoryEmojis = recentEmojis.filter(name => {
          return emojiMap.has(name);
        }).map(name => {
          return emojiMap.get(name);
        });
      } else {
        const indices = utils_emoji["b" /* EmojiIndicesByCategory */].get(category) || [];
        categoryEmojis = indices.map(index => utils_emoji["d" /* Emojis */][index]);

        if (category === 'custom') {
          categoryEmojis = categoryEmojis.concat([...customEmojiMap.values()]);
        }
      }

      categories[category].emojiIds = categoryEmojis.map(emoji => getEmojiFilename(emoji));

      for (let i = 0; i < categoryEmojis.length; i++) {
        const currentEmoji = categoryEmojis[i];
        const fileName = getEmojiFilename(currentEmoji);
        allEmojis[fileName] = { ...currentEmoji,
          visible: false,
          offset: null
        };

        if (!currentEmoji.filename) {
          // if custom emoji, set proper attributes
          allEmojis[fileName] = { ...allEmojis[fileName],
            aliases: [currentEmoji.name],
            category: 'custom',
            filename: fileName
          };
        }
      }
    }

    this.setState({
      categories,
      allEmojis
    });
  }

  getCurrentEmojiCategoryName() {
    const categories = Object.keys(this.state.categories);
    let currentCategoryName = '';

    for (let i = categories.length - 1; i >= 0; i--) {
      // go through in reverse so that you get the last category that matches
      const category = this.state.categories[categories[i]];

      if (this.state.divTopOffset > category.offset - 20) {
        currentCategoryName = categories[i];
        break;
      }
    }

    return currentCategoryName;
  }

  emojiCategories() {
    const categories = this.state.categories;
    const categoryKeys = Object.keys(categories);
    const currentCategoryName = this.state.filter ? categoryKeys[0] : this.getCurrentEmojiCategoryName();
    const emojiPickerCategories = categoryKeys.map(categoryName => {
      const category = categories[categoryName];
      return react_default.a.createElement(emoji_picker_category_EmojiPickerCategory, {
        key: 'header-' + category.name,
        category: category.name,
        icon: react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: category.id,
          defaultMessage: category.message
        }, title => react_default.a.createElement("i", {
          className: category.className,
          title: title
        })),
        onCategoryClick: this.handleCategoryClick,
        selected: currentCategoryName === category.name,
        enable: !this.state.filter
      });
    });
    return react_default.a.createElement("div", {
      className: "emoji-picker__categories"
    }, emojiPickerCategories);
  }

  emojiSearch() {
    return react_default.a.createElement("div", {
      className: "emoji-picker__search-container"
    }, react_default.a.createElement("span", {
      className: "fa fa-search emoji-picker__search-icon"
    }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "emoji_picker.search_emoji",
      defaultMessage: "Search for an emoji"
    }, ariaLabel => react_default.a.createElement(localized_input["a" /* default */], {
      "aria-label": ariaLabel,
      ref: this.emojiSearchInput,
      className: "emoji-picker__search",
      type: "text",
      onChange: this.handleFilterChange,
      onKeyDown: this.handleKeyDown,
      placeholder: {
        id: Object(i18n["b" /* t */])('emoji_picker.search'),
        defaultMessage: 'Search Emoji'
      }
    })));
  }

  emojiCurrentResults() {
    const {
      filter
    } = this.state;
    const categories = filter ? [CATEGORY_SEARCH_RESULTS] : Object.keys(this.state.categories);
    let numEmojisLoaded = 0;
    let categoryComponents = [];

    for (let i = 0; i < categories.length; i++) {
      const category = this.getCategoriesByKey(categories[i]);
      const emojis = this.getEmojisByCategory(category);
      const items = this.emojiCurrentResultsItems(i, emojis, numEmojisLoaded);
      numEmojisLoaded += items.length;
      categoryComponents = [...categoryComponents, react_default.a.createElement(emoji_picker_category_section_EmojiPickerCategorySection, {
        key: category.id,
        categoryName: category.name,
        updateCategoryOffset: this.updateCategoryOffset
      }, items)];
    }

    return react_default.a.createElement("div", {
      ref: this.emojiPickerContainerRef,
      onScroll: this.handleScrollThrottle,
      className: "emoji-picker__items",
      style: EMOJI_CONTAINER_STYLE
    }, react_default.a.createElement("div", {
      className: "emoji-picker__container"
    }, categoryComponents));
  }

  updateCategoryOffset(categoryName, offset) {
    if (categoryName !== CATEGORY_SEARCH_RESULTS) {
      this.setState(state => ({
        categories: { ...state.categories,
          [categoryName]: { ...state.categories[categoryName],
            offset
          }
        }
      }));
    }
  }

  render() {
    return react_default.a.createElement("div", {
      className: "emoji-picker__inner"
    }, this.emojiSearch(), this.emojiCategories(), this.emojiCurrentResults(), react_default.a.createElement(emoji_picker_preview_EmojiPickerPreview, {
      emoji: this.getCurrentEmojiByCursor(this.state.cursor)
    }));
  }

}

emoji_picker_defineProperty(emoji_picker_EmojiPicker, "propTypes", {
  listHeight: prop_types_default.a.number,
  onEmojiClose: prop_types_default.a.func.isRequired,
  onEmojiClick: prop_types_default.a.func.isRequired,
  customEmojisEnabled: prop_types_default.a.bool,
  emojiMap: prop_types_default.a.object.isRequired,
  recentEmojis: prop_types_default.a.array.isRequired,
  customEmojiPage: prop_types_default.a.number.isRequired,
  visible: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    getCustomEmojis: prop_types_default.a.func.isRequired,
    searchCustomEmojis: prop_types_default.a.func.isRequired,
    incrementEmojiPickerPage: prop_types_default.a.func.isRequired
  }).isRequired
});

emoji_picker_defineProperty(emoji_picker_EmojiPicker, "defaultProps", {
  listHeight: 245,
  customEmojiPage: 0,
  customEmojisEnabled: false
});
// CONCATENATED MODULE: ./components/emoji_picker/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function emoji_picker_mapStateToProps(state) {
  return {
    customEmojisEnabled: state.entities.general.config.EnableCustomEmoji === 'true',
    customEmojiPage: state.views.emoji.emojiPickerCustomPage,
    emojiMap: Object(selectors_emojis["a" /* getEmojiMap */])(state),
    recentEmojis: Object(selectors_emojis["b" /* getRecentEmojis */])(state)
  };
}

function emoji_picker_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getCustomEmojis: actions_emojis["getCustomEmojis"],
      searchCustomEmojis: actions_emojis["searchCustomEmojis"],
      incrementEmojiPickerPage: emoji_actions["b" /* incrementEmojiPickerPage */]
    }, dispatch)
  };
}

/* harmony default export */ var emoji_picker = (Object(es["connect"])(emoji_picker_mapStateToProps, emoji_picker_mapDispatchToProps)(emoji_picker_EmojiPicker));
// CONCATENATED MODULE: ./components/emoji_picker/emoji_picker_tabs.jsx
function emoji_picker_tabs_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class emoji_picker_tabs_EmojiPickerTabs extends react["PureComponent"] {
  constructor(props) {
    super(props);

    emoji_picker_tabs_defineProperty(this, "handleEnterEmojiTab", () => {
      this.setState({
        emojiTabVisible: true
      });
    });

    emoji_picker_tabs_defineProperty(this, "handleExitEmojiTab", () => {
      this.setState({
        emojiTabVisible: false
      });
    });

    emoji_picker_tabs_defineProperty(this, "handleEmojiPickerClose", () => {
      this.props.onEmojiClose();
    });

    this.state = {
      emojiTabVisible: true
    };
  }

  render() {
    let pickerStyle;

    if (this.props.style && !(this.props.style.left === 0 && this.props.style.top === 0)) {
      if (this.props.placement === 'top' || this.props.placement === 'bottom') {
        // Only take the top/bottom position passed by React Bootstrap since we want to be right-aligned
        pickerStyle = {
          top: this.props.style.top,
          bottom: this.props.style.bottom,
          right: this.props.rightOffset
        };
      } else {
        pickerStyle = { ...this.props.style
        };
      }

      if (pickerStyle.top) {
        pickerStyle.top += this.props.topOffset;
      }
    }

    let pickerClass = 'emoji-picker';

    if (this.props.placement === 'bottom') {
      pickerClass += ' bottom';
    }

    if (this.props.enableGifPicker && typeof this.props.onGifClick != 'undefined') {
      return react_default.a.createElement(Tabs["a" /* default */], {
        defaultActiveKey: 1,
        id: "emoji-picker-tabs",
        style: pickerStyle,
        className: pickerClass,
        justified: true
      }, react_default.a.createElement(emoji_picker_header_EmojiPickerHeader, {
        handleEmojiPickerClose: this.handleEmojiPickerClose
      }), react_default.a.createElement(Tab["a" /* default */], {
        eventKey: 1,
        onEnter: this.handleEnterEmojiTab,
        onExit: this.handleExitEmojiTab,
        title: react_default.a.createElement(emoji_icon_EmojiIcon, null)
      }, react_default.a.createElement(emoji_picker, {
        style: this.props.style,
        onEmojiClose: this.props.onEmojiClose,
        onEmojiClick: this.props.onEmojiClick,
        customEmojis: this.props.customEmojis,
        visible: this.state.emojiTabVisible
      })), react_default.a.createElement(Tab["a" /* default */], {
        eventKey: 2,
        title: react_default.a.createElement(gfycat_icon_GfycatIcon, null),
        mountOnEnter: true,
        unmountOnExit: true
      }, react_default.a.createElement(gif_picker_GifPicker, {
        onGifClick: this.props.onGifClick
      })));
    }

    return react_default.a.createElement("div", {
      id: "emojiPicker",
      style: pickerStyle,
      className: pickerClass + ' emoji-picker--single'
    }, react_default.a.createElement(emoji_picker_header_EmojiPickerHeader, {
      handleEmojiPickerClose: this.handleEmojiPickerClose
    }), react_default.a.createElement(emoji_picker, {
      style: this.props.style,
      onEmojiClose: this.props.onEmojiClose,
      onEmojiClick: this.props.onEmojiClick,
      customEmojis: this.props.customEmojis
    }));
  }

}

emoji_picker_tabs_defineProperty(emoji_picker_tabs_EmojiPickerTabs, "propTypes", {
  style: prop_types_default.a.object,
  rightOffset: prop_types_default.a.number,
  topOffset: prop_types_default.a.number,
  placement: prop_types_default.a.oneOf(['top', 'bottom', 'left']),
  customEmojis: prop_types_default.a.object,
  onEmojiClose: prop_types_default.a.func.isRequired,
  onEmojiClick: prop_types_default.a.func.isRequired,
  onGifClick: prop_types_default.a.func,
  enableGifPicker: prop_types_default.a.bool
});

emoji_picker_tabs_defineProperty(emoji_picker_tabs_EmojiPickerTabs, "defaultProps", {
  rightOffset: 0,
  topOffset: 0
});
// CONCATENATED MODULE: ./components/emoji_picker/emoji_picker_overlay.jsx
function emoji_picker_overlay_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class emoji_picker_overlay_EmojiPickerOverlay extends react_default.a.PureComponent {
  // An emoji picker in the center channel is contained within the post list, so it needs space
  // above for the channel header and below for the post textbox
  // An emoji picker in the RHS isn't constrained by the RHS, so it just needs space to fit
  // the emoji picker itself
  // Reasonable defaults calculated from from the center channel
  constructor(props) {
    super(props);
    this.state = {
      placement: 'top',
      rightOffset: constants["g" /* Constants */].DEFAULT_EMOJI_PICKER_RIGHT_OFFSET
    };
  }

  UNSAFE_componentWillUpdate(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.show && !this.props.show) {
      const targetBounds = nextProps.target().getBoundingClientRect();
      const placement = Object(position_utils["a" /* popOverOverlayPosition */])(targetBounds, window.innerHeight, {
        above: nextProps.spaceRequiredAbove,
        below: nextProps.spaceRequiredBelow
      });
      this.setState({
        placement,
        rightOffset: this.emojiPickerPosition()
      });
    }
  }

  emojiPickerPosition() {
    const emojiTrigger = this.props.target();
    let rightOffset = constants["g" /* Constants */].DEFAULT_EMOJI_PICKER_RIGHT_OFFSET;

    if (emojiTrigger) {
      rightOffset = window.innerWidth - emojiTrigger.getBoundingClientRect().left - constants["g" /* Constants */].DEFAULT_EMOJI_PICKER_LEFT_OFFSET;

      if (rightOffset < constants["g" /* Constants */].DEFAULT_EMOJI_PICKER_RIGHT_OFFSET) {
        rightOffset = constants["g" /* Constants */].DEFAULT_EMOJI_PICKER_RIGHT_OFFSET;
      }
    }

    return rightOffset;
  }

  render() {
    return react_default.a.createElement(Overlay["a" /* default */], {
      show: this.props.show,
      placement: this.state.placement,
      rootClose: true,
      container: this.props.container,
      onHide: this.props.onHide,
      target: this.props.target,
      animation: false
    }, react_default.a.createElement(emoji_picker_tabs_EmojiPickerTabs, {
      enableGifPicker: this.props.enableGifPicker,
      onEmojiClose: this.props.onHide,
      onEmojiClick: this.props.onEmojiClick,
      onGifClick: this.props.onGifClick,
      rightOffset: this.state.rightOffset,
      topOffset: this.props.topOffset
    }));
  }

}

emoji_picker_overlay_defineProperty(emoji_picker_overlay_EmojiPickerOverlay, "CENTER_SPACE_REQUIRED_ABOVE", 476);

emoji_picker_overlay_defineProperty(emoji_picker_overlay_EmojiPickerOverlay, "CENTER_SPACE_REQUIRED_BELOW", 497);

emoji_picker_overlay_defineProperty(emoji_picker_overlay_EmojiPickerOverlay, "RHS_SPACE_REQUIRED_ABOVE", 420);

emoji_picker_overlay_defineProperty(emoji_picker_overlay_EmojiPickerOverlay, "RHS_SPACE_REQUIRED_BELOW", 420);

emoji_picker_overlay_defineProperty(emoji_picker_overlay_EmojiPickerOverlay, "propTypes", {
  show: prop_types_default.a.bool.isRequired,
  container: prop_types_default.a.func,
  target: prop_types_default.a.func.isRequired,
  onEmojiClick: prop_types_default.a.func.isRequired,
  onGifClick: prop_types_default.a.func,
  onHide: prop_types_default.a.func.isRequired,
  topOffset: prop_types_default.a.number,
  spaceRequiredAbove: prop_types_default.a.number,
  spaceRequiredBelow: prop_types_default.a.number,
  enableGifPicker: prop_types_default.a.bool
});

emoji_picker_overlay_defineProperty(emoji_picker_overlay_EmojiPickerOverlay, "defaultProps", {
  spaceRequiredAbove: emoji_picker_overlay_EmojiPickerOverlay.CENTER_SPACE_REQUIRED_ABOVE,
  spaceRequiredBelow: emoji_picker_overlay_EmojiPickerOverlay.CENTER_SPACE_REQUIRED_BELOW,
  enableGifPicker: false
});
// EXTERNAL MODULE: ./components/autosize_textarea.jsx
var autosize_textarea = __webpack_require__(2014);

// EXTERNAL MODULE: ./components/post_markdown/index.js + 7 modules
var post_markdown = __webpack_require__(2252);

// EXTERNAL MODULE: ./node_modules/xregexp/lib/index.js
var lib = __webpack_require__(143);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// EXTERNAL MODULE: ./mattermost-redux/utils/user_utils.js
var user_utils = __webpack_require__(104);

// EXTERNAL MODULE: ./components/suggestion/provider.jsx
var provider = __webpack_require__(1597);

// EXTERNAL MODULE: ./components/widgets/badges/bot_badge.jsx
var bot_badge = __webpack_require__(1588);

// EXTERNAL MODULE: ./components/suggestion/suggestion.jsx
var suggestion = __webpack_require__(1598);

// CONCATENATED MODULE: ./components/suggestion/at_mention_provider/at_mention_suggestion.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class at_mention_suggestion_AtMentionSuggestion extends suggestion["a" /* default */] {
  render() {
    const isSelection = this.props.isSelection;
    const user = this.props.item;
    let username;
    let description;
    let icon;

    if (user.username === 'all') {
      username = 'all';
      description = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "suggestion.mention.all",
        defaultMessage: "Notifies everyone in this channel"
      });
      icon = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "generic_icons.member",
        defaultMessage: "Member Icon"
      }, title => react_default.a.createElement("i", {
        className: "mention__image fa fa-users fa-2x",
        title: title
      }));
    } else if (user.username === 'channel') {
      username = 'channel';
      description = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "suggestion.mention.channel",
        defaultMessage: "Notifies everyone in this channel"
      });
      icon = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "generic_icons.member",
        defaultMessage: "Member Icon"
      }, title => react_default.a.createElement("i", {
        className: "mention__image fa fa-users fa-2x",
        title: title
      }));
    } else if (user.username === 'here') {
      username = 'here';
      description = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "suggestion.mention.here",
        defaultMessage: "Notifies everyone online in this channel"
      });
      icon = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "generic_icons.member",
        defaultMessage: "Member Icon"
      }, title => react_default.a.createElement("i", {
        className: "mention__image fa fa-users fa-2x",
        title: title
      }));
    } else {
      username = user.username;

      if ((user.first_name || user.last_name) && user.nickname) {
        description = `- ${utils["A" /* getFullName */](user)} (${user.nickname})`;
      } else if (user.nickname) {
        description = `- (${user.nickname})`;
      } else if (user.first_name || user.last_name) {
        description = `- ${utils["A" /* getFullName */](user)}`;
      }

      icon = react_default.a.createElement("img", {
        alt: "mention image",
        className: "mention__image",
        src: utils["K" /* imageURLForUser */](user)
      });
    }

    let className = 'mentions__name';

    if (isSelection) {
      className += ' suggestion--selected';
    }

    return react_default.a.createElement("div", _extends({
      className: className,
      onClick: this.handleClick
    }, suggestion["a" /* default */].baseProps), icon, react_default.a.createElement("span", {
      className: "mention--align"
    }, '@' + username), react_default.a.createElement(bot_badge["a" /* default */], {
      show: Boolean(user.is_bot),
      className: "badge-autocomplete"
    }), react_default.a.createElement("span", {
      className: "mention__fullname"
    }, ' ', description));
  }

}
// CONCATENATED MODULE: ./components/suggestion/at_mention_provider/at_mention_provider.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




 // The AtMentionProvider provides matches for at mentions, including @here, @channel, @all,
// users in the channel and users not in the channel. It mixes together results from the local
// store with results fetch from the server.

class at_mention_provider_AtMentionProvider extends provider["a" /* default */] {
  constructor(props) {
    super();
    this.setProps(props);
    this.data = null;
  } // setProps gives the provider additional context for matching pretexts. Ideally this would
  // just be something akin to a connected component with access to the store itself.


  setProps({
    currentUserId,
    profilesInChannel,
    profilesNotInChannel,
    autocompleteUsersInChannel
  }) {
    this.currentUserId = currentUserId;
    this.profilesInChannel = profilesInChannel;
    this.profilesNotInChannel = profilesNotInChannel;
    this.autocompleteUsersInChannel = autocompleteUsersInChannel;
  } // specialMentions matches one of @here, @channel or @all, unless using /msg.


  specialMentions() {
    if (this.latestPrefix.startsWith('/msg')) {
      return [];
    }

    return ['here', 'channel', 'all'].filter(item => item.startsWith(this.latestPrefix)).map(name => ({
      username: name,
      type: constants["g" /* Constants */].MENTION_SPECIAL
    }));
  } // retrieves the parts of the profile that should be checked
  // against the term


  getProfileSuggestions(profile) {
    const profileSuggestions = [];

    if (!profile) {
      return profileSuggestions;
    }

    if (profile.username) {
      const usernameSuggestions = Object(user_utils["getSuggestionsSplitByMultiple"])(profile.username.toLowerCase(), constants["g" /* Constants */].AUTOCOMPLETE_SPLIT_CHARACTERS);
      profileSuggestions.push(...usernameSuggestions);
    }

    [profile.first_name, profile.last_name, profile.nickname].forEach(property => {
      const suggestions = Object(user_utils["getSuggestionsSplitBy"])(property.toLowerCase(), ' ');
      profileSuggestions.push(...suggestions);
    });
    return profileSuggestions;
  } // filterProfile constrains profiles to those matching the latest prefix.


  filterProfile(profile) {
    if (!profile) {
      return false;
    }

    if (profile.id === this.currentUserId) {
      return false;
    }

    const prefixLower = this.latestPrefix.toLowerCase();
    const profileSuggestions = this.getProfileSuggestions(profile);
    return profileSuggestions.some(suggestion => suggestion.startsWith(prefixLower));
  } // localMembers matches up to 25 local results from the store before the server has responded.


  localMembers() {
    const localMembers = this.profilesInChannel.filter(profile => this.filterProfile(profile)).map(profile => ({
      type: constants["g" /* Constants */].MENTION_MEMBERS,
      ...profile
    })).sort((a, b) => a.username.localeCompare(b.username)).splice(0, 25);
    return localMembers;
  } // remoteMembers matches the users listed in the channel by the server.


  remoteMembers() {
    if (!this.data) {
      return [];
    }

    return (this.data.users || []).filter(profile => this.filterProfile(profile)).map(profile => ({
      type: constants["g" /* Constants */].MENTION_MEMBERS,
      ...profile
    }));
  } // remoteNonMembers matches users listed as not in the channel by the server.
  // listed in the channel from local results.


  remoteNonMembers() {
    if (!this.data) {
      return [];
    }

    return (this.data.out_of_channel || []).filter(profile => this.filterProfile(profile)).map(profile => ({
      type: constants["g" /* Constants */].MENTION_NONMEMBERS,
      ...profile
    }));
  }

  users() {
    const specialMentions = this.specialMentions();
    const localMembers = this.localMembers();
    const localUserIds = {};
    localMembers.forEach(item => {
      localUserIds[item.id] = true;
    });
    const remoteMembers = this.remoteMembers().filter(item => !localUserIds[item.id]); // Combine the local and remote members, sorting to mix the results together.

    const localAndRemoteMembers = localMembers.concat(remoteMembers).sort((a, b) => a.username.localeCompare(b.username));
    const remoteNonMembers = this.remoteNonMembers().filter(item => !localUserIds[item.id]);
    return localAndRemoteMembers.concat(specialMentions).concat(remoteNonMembers);
  } // updateMatches invokes the resultCallback with the metadata for rendering at mentions


  updateMatches(resultCallback, users) {
    const mentions = users.map(user => {
      if (user.username) {
        return '@' + user.username;
      }

      return '';
    });
    resultCallback({
      matchedPretext: `@${this.latestPrefix}`,
      terms: mentions,
      items: users,
      component: at_mention_suggestion_AtMentionSuggestion
    });
  }

  handlePretextChanged(pretext, resultCallback) {
    const captured = lib_default.a.cache('(?:^|\\W)@([\\pL\\d\\-_.]*)$', 'i').exec(pretext.toLowerCase());

    if (!captured) {
      return false;
    }

    const prefix = captured[1];
    this.startNewRequest(prefix);
    this.updateMatches(resultCallback, this.users()); // If we haven't gotten server-side results in 500 ms, add the loading indicator.

    let showLoadingIndicator = setTimeout(() => {
      if (this.shouldCancelDispatch(prefix)) {
        return;
      }

      this.updateMatches(resultCallback, this.users().concat([{
        type: constants["g" /* Constants */].MENTION_MORE_MEMBERS,
        loading: true
      }]));
      showLoadingIndicator = null;
    }, 500); // Query the server for remote results to add to the local results.

    this.autocompleteUsersInChannel(prefix).then(({
      data
    }) => {
      if (showLoadingIndicator) {
        clearTimeout(showLoadingIndicator);
      }

      if (this.shouldCancelDispatch(prefix)) {
        return;
      }

      this.data = data;
      this.updateMatches(resultCallback, this.users());
    });
    return true;
  }

}
// CONCATENATED MODULE: ./components/suggestion/at_mention_provider/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* harmony default export */ var at_mention_provider = (at_mention_provider_AtMentionProvider);
// EXTERNAL MODULE: ./mattermost-redux/utils/channel_utils.js
var channel_utils = __webpack_require__(178);

// EXTERNAL MODULE: ./mattermost-redux/action_types/index.js
var action_types = __webpack_require__(8);

// EXTERNAL MODULE: ./actions/channel_actions.jsx
var channel_actions = __webpack_require__(1593);

// EXTERNAL MODULE: ./stores/redux_store.jsx + 3 modules
var redux_store = __webpack_require__(14);

// CONCATENATED MODULE: ./components/suggestion/channel_mention_provider.jsx
function channel_mention_provider_extends() { channel_mention_provider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return channel_mention_provider_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










class channel_mention_provider_ChannelMentionSuggestion extends suggestion["a" /* default */] {
  render() {
    const isSelection = this.props.isSelection;
    const item = this.props.item;
    const channelName = item.channel.display_name;
    const purpose = item.channel.purpose;
    let className = 'mentions__name no-flex';

    if (isSelection) {
      className += ' suggestion--selected';
    }

    const description = '(~' + item.channel.name + ')';
    return react_default.a.createElement("div", channel_mention_provider_extends({
      className: className,
      onClick: this.handleClick
    }, suggestion["a" /* default */].baseProps), react_default.a.createElement("div", {
      className: "mention__align"
    }, react_default.a.createElement("span", null, channelName), react_default.a.createElement("span", {
      className: "mention__channelname"
    }, ' ', description)), react_default.a.createElement("div", {
      className: "mention__purpose"
    }, purpose));
  }

}

class channel_mention_provider_ChannelMentionProvider extends provider["a" /* default */] {
  constructor() {
    super();
    this.lastPrefixTrimmed = '';
    this.lastPrefixWithNoResults = '';
    this.lastCompletedWord = '';
  }

  handlePretextChanged(pretext, resultCallback) {
    this.resetRequest();
    const captured = /\B(~([^~\r\n]*))$/i.exec(pretext.toLowerCase());

    if (!captured) {
      // Not a channel mention
      return false;
    }

    if (captured.index > 0 && pretext[captured.index - 1] === '~') {
      // Multiple ~'s in a row so let's return and not show the autocomplete
      return false;
    }

    const prefix = captured[2];

    if (this.lastPrefixTrimmed && prefix.trim() === this.lastPrefixTrimmed) {
      // Don't keep searching if the user keeps typing spaces
      return true;
    }

    this.lastPrefixTrimmed = prefix.trim();

    if (this.lastPrefixWithNoResults && prefix.startsWith(this.lastPrefixWithNoResults)) {
      // Just give up since we know it won't return any results
      return false;
    }

    if (this.lastCompletedWord && captured[0].startsWith(this.lastCompletedWord)) {
      // It appears we're still matching a channel handle that we already completed
      return false;
    } // Clear the last completed word since we've started to match new text


    this.lastCompletedWord = '';
    this.startNewRequest(prefix);
    const words = prefix.toLowerCase().split(/\s+/);
    const wrappedChannelIds = {};
    var wrappedChannels = [];
    Object(entities_channels["getMyChannels"])(redux_store["a" /* default */].getState()).forEach(item => {
      if (item.type !== 'O' || item.delete_at > 0) {
        return;
      }

      const nameWords = item.name.toLowerCase().split(/\s+/).concat(item.display_name.toLowerCase().split(/\s+/));
      var matched = true;

      for (var j = 0; matched && j < words.length; j++) {
        if (!words[j]) {
          continue;
        }

        var wordMatched = false;

        for (var i = 0; i < nameWords.length; i++) {
          if (nameWords[i].startsWith(words[j])) {
            wordMatched = true;
            break;
          }
        }

        if (!wordMatched) {
          matched = false;
          break;
        }
      }

      if (!matched) {
        return;
      }

      wrappedChannelIds[item.id] = true;
      wrappedChannels.push({
        type: constants["g" /* Constants */].MENTION_CHANNELS,
        channel: item
      });
    });
    wrappedChannels = wrappedChannels.sort((a, b) => {
      //
      // MM-12677 When this is migrated this needs to be fixed to pull the user's locale
      //
      return Object(channel_utils["sortChannelsByTypeAndDisplayName"])('en', a.channel, b.channel);
    });
    const channelMentions = wrappedChannels.map(item => '~' + item.channel.name);
    resultCallback({
      terms: channelMentions.concat([' ']),
      items: wrappedChannels.concat([{
        type: constants["g" /* Constants */].MENTION_MORE_CHANNELS,
        loading: true
      }]),
      component: channel_mention_provider_ChannelMentionSuggestion,
      matchedPretext: captured[1]
    });
    Object(channel_actions["b" /* autocompleteChannels */])(prefix, channels => {
      const myMembers = Object(entities_channels["getMyChannelMemberships"])(redux_store["a" /* default */].getState());

      if (this.shouldCancelDispatch(prefix)) {
        return;
      }

      if (channels.length === 0) {
        this.lastPrefixWithNoResults = prefix;
      } // Wrap channels in an outer object to avoid overwriting the 'type' property.


      const wrappedMoreChannels = [];
      const moreChannels = [];
      channels.forEach(item => {
        if (item.delete_at > 0 && !myMembers[item.id]) {
          return;
        }

        if (Object(entities_channels["getChannel"])(redux_store["a" /* default */].getState(), item.id)) {
          if (!wrappedChannelIds[item.id]) {
            wrappedChannelIds[item.id] = true;
            wrappedChannels.push({
              type: constants["g" /* Constants */].MENTION_CHANNELS,
              channel: item
            });
          }

          return;
        }

        wrappedMoreChannels.push({
          type: constants["g" /* Constants */].MENTION_MORE_CHANNELS,
          channel: item
        });
        moreChannels.push(item);
      });
      wrappedChannels = wrappedChannels.sort((a, b) => {
        //
        // MM-12677 When this is migrated this needs to be fixed to pull the user's locale
        //
        return Object(channel_utils["sortChannelsByTypeAndDisplayName"])('en', a.channel, b.channel);
      });
      const wrapped = wrappedChannels.concat(wrappedMoreChannels);
      const mentions = wrapped.map(item => '~' + item.channel.name);
      redux_store["a" /* default */].dispatch({
        type: action_types["ChannelTypes"].RECEIVED_CHANNELS,
        data: moreChannels
      });
      resultCallback({
        matchedPretext: captured[1],
        terms: mentions,
        items: wrapped,
        component: channel_mention_provider_ChannelMentionSuggestion
      });
    });
    return true;
  }

  handleCompleteWord(term) {
    this.lastCompletedWord = term;
    this.lastPrefixWithNoResults = '';
  }

}
// EXTERNAL MODULE: ./mattermost-redux/client/index.js
var client = __webpack_require__(27);

// CONCATENATED MODULE: ./components/suggestion/command_provider.jsx
function command_provider_extends() { command_provider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return command_provider_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class command_provider_CommandSuggestion extends suggestion["a" /* default */] {
  render() {
    const {
      item,
      isSelection
    } = this.props;
    let className = 'command';

    if (isSelection) {
      className += ' suggestion--selected';
    }

    return react_default.a.createElement("div", command_provider_extends({
      className: className,
      onClick: this.handleClick
    }, suggestion["a" /* default */].baseProps), react_default.a.createElement("div", {
      className: "command__title"
    }, item.suggestion + ' ' + item.hint), react_default.a.createElement("div", {
      className: "command__desc"
    }, item.description));
  }

}
class command_provider_CommandProvider extends provider["a" /* default */] {
  handlePretextChanged(pretext, resultCallback) {
    if (pretext.startsWith('/')) {
      const command = pretext.toLowerCase();
      client["Client4"].getCommandsList(Object(entities_teams["getCurrentTeamId"])(redux_store["a" /* default */].getState())).then(data => {
        let matches = [];
        data.forEach(cmd => {
          if (!cmd.auto_complete) {
            return;
          }

          if (cmd.trigger !== 'shortcuts' || !user_agent["m" /* isMobile */]()) {
            if (('/' + cmd.trigger).indexOf(command) === 0) {
              const s = '/' + cmd.trigger;
              let hint = '';

              if (cmd.auto_complete_hint && cmd.auto_complete_hint.length !== 0) {
                hint = cmd.auto_complete_hint;
              }

              matches.push({
                suggestion: s,
                hint,
                description: cmd.auto_complete_desc
              });
            }
          }
        });
        matches = matches.sort((a, b) => a.suggestion.localeCompare(b.suggestion)); // pull out the suggested commands from the returned data

        const terms = matches.map(suggestion => suggestion.suggestion);
        resultCallback({
          matchedPretext: command,
          terms,
          items: matches,
          component: command_provider_CommandSuggestion
        });
      }).catch(() => {} //eslint-disable-line no-empty-function
      );
      return true;
    }

    return false;
  }

}
// EXTERNAL MODULE: ./utils/emoticons.jsx
var emoticons = __webpack_require__(294);

// CONCATENATED MODULE: ./components/suggestion/emoticon_provider.jsx
function emoticon_provider_extends() { emoticon_provider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return emoticon_provider_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









const MIN_EMOTICON_LENGTH = 2;
const EMOJI_CATEGORY_SUGGESTION_BLACKLIST = ['skintone'];

class emoticon_provider_EmoticonSuggestion extends suggestion["a" /* default */] {
  render() {
    const text = this.props.term;
    const emoji = this.props.item.emoji;
    let className = 'emoticon-suggestion';

    if (this.props.isSelection) {
      className += ' suggestion--selected';
    }

    return react_default.a.createElement("div", emoticon_provider_extends({
      className: className,
      onClick: this.handleClick
    }, suggestion["a" /* default */].baseProps), react_default.a.createElement("div", {
      className: "pull-left"
    }, react_default.a.createElement("img", {
      alt: text,
      className: "emoticon-suggestion__image",
      src: Object(emoji_utils["getEmojiImageUrl"])(emoji),
      title: text
    })), react_default.a.createElement("div", {
      className: "pull-left"
    }, text));
  }

}

class emoticon_provider_EmoticonProvider extends provider["a" /* default */] {
  handlePretextChanged(pretext, resultsCallback) {
    // Look for the potential emoticons at the start of the text, after whitespace, and at the start of emoji reaction commands
    const captured = /(^|\s|^\+|^-)(:([^:\s]*))$/g.exec(pretext);

    if (!captured) {
      return false;
    }

    const prefix = captured[1];
    const text = captured[2];
    const partialName = captured[3];

    if (partialName.length < MIN_EMOTICON_LENGTH) {
      return false;
    } // Check for text emoticons if this isn't for an emoji reaction


    if (prefix !== '-' && prefix !== '+') {
      for (const emoticon of Object.keys(emoticons["b" /* emoticonPatterns */])) {
        if (emoticons["b" /* emoticonPatterns */][emoticon].test(text)) {
          // Don't show the autocomplete for text emoticons
          return false;
        }
      }
    }

    if (redux_store["a" /* default */].getState().entities.general.config.EnableCustomEmoji === 'true') {
      redux_store["a" /* default */].dispatch(Object(actions_emojis["autocompleteCustomEmojis"])(partialName)).then(() => this.findAndSuggestEmojis(text, partialName, resultsCallback));
    } else {
      this.findAndSuggestEmojis(text, partialName, resultsCallback);
    }

    return true;
  }

  formatEmojis(emojis) {
    return emojis.map(item => ':' + item.name + ':');
  }

  findAndSuggestEmojis(text, partialName, resultsCallback) {
    const recentMatched = [];
    const matched = [];
    const emojiMap = Object(selectors_emojis["a" /* getEmojiMap */])(redux_store["a" /* default */].getState());
    const recentEmojis = Object(selectors_emojis["b" /* getRecentEmojis */])(redux_store["a" /* default */].getState()); // Check for named emoji

    for (const [name, emoji] of emojiMap) {
      if (EMOJI_CATEGORY_SUGGESTION_BLACKLIST.includes(emoji.category)) {
        continue;
      }

      if (emoji.aliases) {
        // This is a system emoji so it may have multiple names
        for (const alias of emoji.aliases) {
          if (alias.indexOf(partialName) !== -1) {
            const matchedArray = recentEmojis.includes(alias) || recentEmojis.includes(name) ? recentMatched : matched;
            matchedArray.push({
              name: alias,
              emoji
            });
            break;
          }
        }
      } else if (name.indexOf(partialName) !== -1) {
        // This is a custom emoji so it only has one name
        if (emojiMap.hasSystemEmoji(name)) {
          // System emojis take precedence over custom ones
          continue;
        }

        const matchedArray = recentEmojis.includes(name) ? recentMatched : matched;
        matchedArray.push({
          name,
          emoji
        });
      }
    }

    const sortEmojisHelper = (a, b) => {
      return compareEmojis(a, b, partialName);
    };

    recentMatched.sort(sortEmojisHelper);
    matched.sort(sortEmojisHelper);
    const terms = [...this.formatEmojis(recentMatched), ...this.formatEmojis(matched)];
    const items = [...recentMatched, ...matched]; // Required to get past the dispatch during dispatch error

    resultsCallback({
      matchedPretext: text,
      terms,
      items,
      component: emoticon_provider_EmoticonSuggestion
    });
  }

}
// EXTERNAL MODULE: ./components/suggestion/suggestion_box.jsx
var suggestion_box = __webpack_require__(1652);

// EXTERNAL MODULE: ./components/suggestion/suggestion_list.jsx
var suggestion_list = __webpack_require__(1667);

// CONCATENATED MODULE: ./components/textbox/textbox.jsx
function textbox_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.














const PreReleaseFeatures = constants["N" /* default */].PRE_RELEASE_FEATURES;
class textbox_Textbox extends react_default.a.Component {
  constructor(props) {
    super(props);

    textbox_defineProperty(this, "handleChange", e => {
      this.props.onChange(e);
    });

    textbox_defineProperty(this, "checkMessageLength", message => {
      if (this.props.handlePostError) {
        if (message.length > this.props.characterLimit) {
          const errorMessage = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "create_post.error_message",
            defaultMessage: "Your message is too long. Character count: {length}/{limit}",
            values: {
              length: message.length,
              limit: this.props.characterLimit
            }
          });
          this.props.handlePostError(errorMessage);
        } else {
          this.props.handlePostError(null);
        }
      }
    });

    textbox_defineProperty(this, "handleKeyDown", e => {
      if (this.props.onKeyDown) {
        this.props.onKeyDown(e);
      }
    });

    textbox_defineProperty(this, "handleBlur", e => {
      if (this.props.onBlur) {
        this.props.onBlur(e);
      }
    });

    textbox_defineProperty(this, "handleHeightChange", (height, maxHeight) => {
      if (this.props.onHeightChange) {
        this.props.onHeightChange(height, maxHeight);
      }

      if (utils["k" /* disableVirtList */]()) {
        this.props.actions.scrollPostList();
      }
    });

    textbox_defineProperty(this, "focus", () => {
      const textbox = this.refs.message.getTextbox();
      textbox.focus();
      utils["kb" /* placeCaretAtEnd */](textbox); // reset character count warning

      this.checkMessageLength(textbox.value);
    });

    textbox_defineProperty(this, "blur", () => {
      const textbox = this.refs.message.getTextbox();
      textbox.blur();
    });

    textbox_defineProperty(this, "recalculateSize", () => {
      this.refs.message.recalculateSize();
    });

    textbox_defineProperty(this, "togglePreview", e => {
      e.preventDefault();
      e.target.blur();
      this.setState(prevState => {
        return {
          preview: !prevState.preview
        };
      });
    });

    textbox_defineProperty(this, "hidePreview", () => {
      this.setState({
        preview: false
      });
    });

    this.state = {};
    this.suggestionProviders = [new at_mention_provider({
      currentUserId: this.props.currentUserId,
      profilesInChannel: this.props.profilesInChannel,
      profilesNotInChannel: this.props.profilesNotInChannel,
      autocompleteUsersInChannel: prefix => this.props.actions.autocompleteUsersInChannel(prefix, props.channelId)
    }), new channel_mention_provider_ChannelMentionProvider(), new emoticon_provider_EmoticonProvider()];

    if (props.supportsCommands) {
      this.suggestionProviders.push(new command_provider_CommandProvider());
    }

    this.checkMessageLength(props.value);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.channelId !== this.props.channelId || nextProps.currentUserId !== this.props.currentUserId || nextProps.profilesInChannel !== this.props.profilesInChannel || nextProps.profilesNotInChannel !== this.props.profilesNotInChannel) {
      // Update channel id for AtMentionProvider.
      const providers = this.suggestionProviders;

      for (let i = 0; i < providers.length; i++) {
        if (providers[i] instanceof at_mention_provider) {
          providers[i].setProps({
            currentUserId: nextProps.currentUserId,
            profilesInChannel: nextProps.profilesInChannel,
            profilesNotInChannel: nextProps.profilesNotInChannel,
            autocompleteUsersInChannel: prefix => nextProps.actions.autocompleteUsersInChannel(prefix, nextProps.channelId)
          });
        }
      }
    }

    if (this.props.value !== nextProps.value) {
      this.checkMessageLength(nextProps.value);
    }
  }

  render() {
    const hasText = this.props.value && this.props.value.length > 0;
    let editHeader;
    let helpTextClass = '';

    if (this.props.value && this.props.value.length > this.props.characterLimit) {
      helpTextClass = 'hidden';
    }

    if (this.props.previewMessageLink) {
      editHeader = react_default.a.createElement("span", null, this.props.previewMessageLink);
    } else {
      editHeader = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "textbox.edit",
        defaultMessage: "Edit message"
      });
    }

    let previewLink = null;

    if (utils["R" /* isFeatureEnabled */](PreReleaseFeatures.MARKDOWN_PREVIEW)) {
      previewLink = react_default.a.createElement("a", {
        id: "previewLink",
        onClick: this.togglePreview,
        className: "textbox-preview-link"
      }, this.state.preview ? editHeader : react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "textbox.preview",
        defaultMessage: "Preview"
      }));
    }

    const helpText = react_default.a.createElement("div", {
      id: "helpText",
      style: {
        visibility: hasText ? 'visible' : 'hidden',
        opacity: hasText ? '0.45' : '0'
      },
      className: "help__format-text"
    }, react_default.a.createElement("b", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "textbox.bold",
      defaultMessage: "**bold**"
    })), react_default.a.createElement("i", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "textbox.italic",
      defaultMessage: "_italic_"
    })), react_default.a.createElement("span", null, '~~', react_default.a.createElement("strike", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "textbox.strike",
      defaultMessage: "strike"
    })), '~~ '), react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "textbox.inlinecode",
      defaultMessage: "`inline code`"
    })), react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "textbox.preformatted",
      defaultMessage: "```preformatted```"
    })), react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "textbox.quote",
      defaultMessage: ">quote"
    })));
    let preview = null;
    let textboxClassName = 'form-control custom-textarea';
    let textWrapperClass = 'textarea-wrapper';

    if (this.props.emojiEnabled) {
      textboxClassName += ' custom-textarea--emoji-picker';
    }

    if (this.props.badConnection) {
      textboxClassName += ' bad-connection';
    }

    if (this.state.preview) {
      textboxClassName += ' custom-textarea--preview';
      textWrapperClass += ' textarea-wrapper--preview';
      preview = react_default.a.createElement("div", {
        ref: "preview",
        className: "form-control custom-textarea textbox-preview-area"
      }, react_default.a.createElement(post_markdown["a" /* default */], {
        isRHS: this.props.isRHS,
        message: this.props.value
      }));
    }

    return react_default.a.createElement("div", {
      ref: "wrapper",
      className: textWrapperClass
    }, react_default.a.createElement(suggestion_box["a" /* default */], {
      id: this.props.id,
      ref: "message",
      className: textboxClassName,
      spellCheck: "true",
      placeholder: this.props.createMessage,
      onChange: this.handleChange,
      onKeyPress: this.props.onKeyPress,
      onKeyDown: this.handleKeyDown,
      onComposition: this.props.onComposition,
      onBlur: this.handleBlur,
      onHeightChange: this.handleHeightChange,
      style: {
        visibility: this.state.preview ? 'hidden' : 'visible'
      },
      inputComponent: autosize_textarea["a" /* default */],
      listComponent: suggestion_list["a" /* default */],
      listStyle: this.props.suggestionListStyle,
      providers: this.suggestionProviders,
      channelId: this.props.channelId,
      value: this.props.value,
      renderDividers: true,
      isRHS: this.props.isRHS,
      disabled: this.props.disabled,
      contextId: this.props.channelId,
      listenForMentionKeyClick: this.props.listenForMentionKeyClick
    }), preview, react_default.a.createElement("div", {
      className: 'help__text ' + helpTextClass
    }, helpText));
  }

}

textbox_defineProperty(textbox_Textbox, "propTypes", {
  id: prop_types_default.a.string.isRequired,
  channelId: prop_types_default.a.string,
  value: prop_types_default.a.string.isRequired,
  onChange: prop_types_default.a.func.isRequired,
  onKeyPress: prop_types_default.a.func.isRequired,
  onComposition: prop_types_default.a.func,
  onHeightChange: prop_types_default.a.func,
  createMessage: prop_types_default.a.string.isRequired,
  previewMessageLink: prop_types_default.a.string,
  onKeyDown: prop_types_default.a.func,
  onBlur: prop_types_default.a.func,
  supportsCommands: prop_types_default.a.bool.isRequired,
  handlePostError: prop_types_default.a.func,
  suggestionListStyle: prop_types_default.a.string,
  emojiEnabled: prop_types_default.a.bool,
  isRHS: prop_types_default.a.bool,
  characterLimit: prop_types_default.a.number.isRequired,
  disabled: prop_types_default.a.bool,
  badConnection: prop_types_default.a.bool,
  listenForMentionKeyClick: prop_types_default.a.bool,
  currentUserId: prop_types_default.a.string.isRequired,
  profilesInChannel: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,
  profilesNotInChannel: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,
  actions: prop_types_default.a.shape({
    autocompleteUsersInChannel: prop_types_default.a.func.isRequired,
    scrollPostList: prop_types_default.a.func.isRequired
  })
});

textbox_defineProperty(textbox_Textbox, "defaultProps", {
  supportsCommands: true,
  isRHS: false,
  listenForMentionKeyClick: false
});
// CONCATENATED MODULE: ./components/textbox/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const makeMapStateToProps = () => {
  const getProfilesInChannel = Object(entities_users["makeGetProfilesInChannel"])();
  const getProfilesNotInChannel = Object(entities_users["makeGetProfilesNotInChannel"])();
  return (state, ownProps) => ({
    currentUserId: Object(entities_users["getCurrentUserId"])(state),
    profilesInChannel: getProfilesInChannel(state, ownProps.channelId, true),
    profilesNotInChannel: getProfilesNotInChannel(state, ownProps.channelId, true)
  });
};

const textbox_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    autocompleteUsersInChannel: views_channel["a" /* autocompleteUsersInChannel */],
    scrollPostList: views_channel["h" /* scrollPostList */]
  }, dispatch)
});

/* harmony default export */ var components_textbox = (Object(es["connect"])(makeMapStateToProps, textbox_mapDispatchToProps, null, {
  withRef: true
})(textbox_Textbox));
// CONCATENATED MODULE: ./components/edit_post_modal/edit_post_modal.jsx
function edit_post_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











const KeyCodes = constants["g" /* Constants */].KeyCodes;
class edit_post_modal_EditPostModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    edit_post_modal_defineProperty(this, "getContainer", () => {
      return this.refs.editModalBody;
    });

    edit_post_modal_defineProperty(this, "toggleEmojiPicker", () => {
      this.setState({
        showEmojiPicker: !this.state.showEmojiPicker
      });

      if (!this.state.showEmojiPicker && this.editbox) {
        this.editbox.focus();
      }
    });

    edit_post_modal_defineProperty(this, "hideEmojiPicker", () => {
      this.setState({
        showEmojiPicker: false
      });

      if (this.editbox) {
        this.editbox.focus();
      }
    });

    edit_post_modal_defineProperty(this, "handleEmojiClick", emoji => {
      const emojiAlias = emoji && (emoji.name || emoji.aliases && emoji.aliases[0]);

      if (!emojiAlias) {
        //Oops.. There went something wrong
        return;
      }

      if (this.state.editText === '') {
        this.setState({
          editText: ':' + emojiAlias + ': '
        });
      } else {
        //check whether there is already a blank at the end of the current message
        const newMessage = /\s+$/.test(this.state.editText) ? this.state.editText + ':' + emojiAlias + ': ' : this.state.editText + ' :' + emojiAlias + ': ';
        this.setState({
          editText: newMessage
        });
      }

      this.setState({
        showEmojiPicker: false
      });

      if (this.editbox) {
        this.editbox.focus();
      }
    });

    edit_post_modal_defineProperty(this, "handleGifClick", gif => {
      if (this.state.editText === '') {
        this.setState({
          editText: gif
        });
      } else {
        const newMessage = /\s+$/.test(this.state.editText) ? this.state.editText + gif : this.state.editText + ' ' + gif;
        this.setState({
          editText: newMessage
        });
      }

      this.setState({
        showEmojiPicker: false
      });
      this.editbox.focus();
    });

    edit_post_modal_defineProperty(this, "getEditPostControls", () => {
      return this.refs.editPostEmoji;
    });

    edit_post_modal_defineProperty(this, "handlePostError", postError => {
      if (this.state.postError !== postError) {
        this.setState({
          postError
        });
      }
    });

    edit_post_modal_defineProperty(this, "handleEdit", async () => {
      if (this.isSaveDisabled()) {
        return;
      }

      const {
        actions,
        editingPost
      } = this.props;
      const updatedPost = {
        message: this.state.editText,
        id: editingPost.postId,
        channel_id: editingPost.post.channel_id
      };

      if (this.state.postError) {
        this.setState({
          errorClass: 'animation--highlight'
        });
        setTimeout(() => {
          this.setState({
            errorClass: null
          });
        }, constants["g" /* Constants */].ANIMATION_TIMEOUT);
        return;
      }

      if (updatedPost.message === (editingPost.post.message_source || editingPost.post.message)) {
        // no changes so just close the modal
        this.handleHide();
        return;
      }

      const hasAttachment = editingPost.post.file_ids && editingPost.post.file_ids.length > 0;

      if (updatedPost.message.trim().length === 0 && !hasAttachment) {
        this.handleHide(false);
        const deletePostModalData = {
          ModalId: constants["p" /* ModalIdentifiers */].DELETE_POST,
          dialogType: delete_post_modal["a" /* default */],
          dialogProps: {
            post: editingPost.post,
            commentCount: editingPost.commentCount,
            isRHS: editingPost.isRHS
          }
        };
        this.props.actions.openModal(deletePostModalData);
        return;
      }

      actions.addMessageIntoHistory(updatedPost.message);
      const data = await actions.editPost(updatedPost);

      if (data) {
        window.scrollTo(0, 0);
      }

      this.handleHide();
    });

    edit_post_modal_defineProperty(this, "handleChange", e => {
      const message = e.target.value;
      this.setState({
        editText: message
      });
    });

    edit_post_modal_defineProperty(this, "handleEditKeyPress", e => {
      if (!user_agent["m" /* isMobile */]() && !this.props.ctrlSend && utils["V" /* isKeyPressed */](e, KeyCodes.ENTER) && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        this.editbox.blur();
        this.handleEdit();
      } else if (this.props.ctrlSend && e.ctrlKey && utils["V" /* isKeyPressed */](e, KeyCodes.ENTER)) {
        e.preventDefault();
        this.editbox.blur();
        this.handleEdit();
      }
    });

    edit_post_modal_defineProperty(this, "handleKeyDown", e => {
      if (this.props.ctrlSend && utils["V" /* isKeyPressed */](e, KeyCodes.ENTER) && e.ctrlKey === true) {
        this.handleEdit();
      } else if (utils["V" /* isKeyPressed */](e, KeyCodes.ESCAPE) && !this.state.showEmojiPicker) {
        this.handleHide();
      }
    });

    edit_post_modal_defineProperty(this, "handleHide", (doRefocus = true) => {
      this.refocusId = doRefocus ? this.props.editingPost.refocusId : null;
      this.props.actions.hideEditPostModal();
    });

    edit_post_modal_defineProperty(this, "handleEntered", () => {
      if (this.editbox) {
        this.editbox.focus();
        this.editbox.recalculateSize();
      }
    });

    edit_post_modal_defineProperty(this, "handleExit", () => {
      if (this.editbox) {
        this.editbox.hidePreview();
      }
    });

    edit_post_modal_defineProperty(this, "handleExited", () => {
      const refocusId = this.refocusId;

      if (refocusId) {
        setTimeout(() => {
          const element = document.getElementById(refocusId);

          if (element) {
            element.focus();
          }
        });
      }

      this.refocusId = null;
      this.setState({
        editText: '',
        postError: '',
        errorClass: null,
        showEmojiPicker: false
      });
    });

    edit_post_modal_defineProperty(this, "setEditboxRef", ref => {
      if (ref && ref.getWrappedInstance) {
        this.editbox = ref.getWrappedInstance();
      }

      if (this.editbox) {
        this.editbox.focus();
      }
    });

    edit_post_modal_defineProperty(this, "isSaveDisabled", () => {
      const post = this.props.editingPost.post;
      const hasAttachments = post && post.file_ids && post.file_ids.length > 0;

      if (hasAttachments) {
        return !this.props.canEditPost;
      }

      if (this.state.editText !== '') {
        return !this.props.canEditPost;
      }

      return !this.props.canDeletePost;
    });

    this.state = {
      editText: '',
      postError: '',
      errorClass: null,
      showEmojiPicker: false
    };
  }

  UNSAFE_componentWillUpdate(nextProps) {
    // eslint-disable-line camelcase
    if (!this.props.editingPost.show && nextProps.editingPost.show) {
      this.setState({
        editText: nextProps.editingPost.post.message_source || nextProps.editingPost.post.message
      });
    }
  }

  render() {
    const errorBoxClass = 'edit-post-footer' + (this.state.postError ? ' has-error' : '');
    let postError = null;

    if (this.state.postError) {
      const postErrorClass = 'post-error' + (this.state.errorClass ? ' ' + this.state.errorClass : '');
      postError = react_default.a.createElement("label", {
        className: postErrorClass
      }, this.state.postError);
    }

    let emojiPicker = null;

    if (this.props.config.EnableEmojiPicker === 'true') {
      emojiPicker = react_default.a.createElement("span", {
        className: "emoji-picker__container"
      }, react_default.a.createElement(emoji_picker_overlay_EmojiPickerOverlay, {
        show: this.state.showEmojiPicker,
        container: this.getContainer,
        target: this.getEditPostControls,
        onHide: this.hideEmojiPicker,
        onEmojiClick: this.handleEmojiClick,
        onGifClick: this.handleGifClick,
        enableGifPicker: this.props.config.EnableGifPicker === 'true',
        topOffset: -20
      }), react_default.a.createElement(emoji_icon_EmojiIcon, {
        className: "icon icon--emoji",
        onClick: this.toggleEmojiPicker
      }));
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      id: "editPostModal",
      dialogClassName: "edit-modal",
      show: this.props.editingPost.show,
      onKeyDown: this.handleKeyDown,
      onHide: this.handleHide,
      onEntered: this.handleEntered,
      onExit: this.handleExit,
      onExited: this.handleExited,
      keyboard: false,
      role: "dialog",
      "aria-labelledby": "editPostModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "editPostModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "edit_post.edit",
      defaultMessage: "Edit {title}",
      values: {
        title: this.props.editingPost.title
      }
    }))), react_default.a.createElement(Modal["a" /* default */].Body, {
      bsClass: `modal-body edit-modal-body${this.state.showEmojiPicker ? ' edit-modal-body--add-reaction' : ''}`,
      ref: "editModalBody"
    }, react_default.a.createElement(components_textbox, {
      onChange: this.handleChange,
      onKeyPress: this.handleEditKeyPress,
      onKeyDown: this.handleKeyDown,
      handlePostError: this.handlePostError,
      value: this.state.editText,
      channelId: this.props.editingPost.post && this.props.editingPost.post.channel_id,
      emojiEnabled: this.props.config.EnableEmojiPicker === 'true',
      createMessage: utils["gb" /* localizeMessage */]('edit_post.editPost', 'Edit the post...'),
      supportsCommands: false,
      suggestionListStyle: "bottom",
      id: "edit_textbox",
      ref: this.setEditboxRef,
      characterLimit: this.props.maxPostSize
    }), react_default.a.createElement("span", {
      id: "editPostEmoji",
      ref: "editPostEmoji",
      className: "edit-post__actions"
    }, emojiPicker), react_default.a.createElement("div", {
      className: errorBoxClass
    }, postError)), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-link",
      onClick: this.handleHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "edit_post.cancel",
      defaultMessage: "Cancel"
    })), react_default.a.createElement("button", {
      id: "editButton",
      type: "button",
      className: "btn btn-primary",
      disabled: this.isSaveDisabled(),
      onClick: this.handleEdit
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "edit_post.save",
      defaultMessage: "Save"
    }))));
  }

}

edit_post_modal_defineProperty(edit_post_modal_EditPostModal, "propTypes", {
  canEditPost: prop_types_default.a.bool,
  canDeletePost: prop_types_default.a.bool,
  ctrlSend: prop_types_default.a.bool,
  config: prop_types_default.a.object.isRequired,
  maxPostSize: prop_types_default.a.number.isRequired,
  editingPost: prop_types_default.a.shape({
    post: prop_types_default.a.object,
    postId: prop_types_default.a.string,
    refocusId: prop_types_default.a.string,
    show: prop_types_default.a.bool.isRequired,
    title: prop_types_default.a.string,
    isRHS: prop_types_default.a.bool
  }).isRequired,
  actions: prop_types_default.a.shape({
    addMessageIntoHistory: prop_types_default.a.func.isRequired,
    editPost: prop_types_default.a.func.isRequired,
    hideEditPostModal: prop_types_default.a.func.isRequired,
    openModal: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/edit_post_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

















function edit_post_modal_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const editingPost = Object(selectors_posts["a" /* getEditingPost */])(state);
  const currentUserId = Object(entities_users["getCurrentUserId"])(state);
  let canDeletePost = false;
  let canEditPost = false;

  if (editingPost && editingPost.post && editingPost.post.user_id === currentUserId) {
    canDeletePost = Object(roles["haveIChannelPermission"])(state, {
      channel: Object(entities_channels["getCurrentChannelId"])(state),
      team: Object(entities_teams["getCurrentTeamId"])(state),
      permission: mattermost_redux_constants["Permissions"].DELETE_POST
    });
    canEditPost = Object(roles["haveIChannelPermission"])(state, {
      channel: Object(entities_channels["getCurrentChannelId"])(state),
      team: Object(entities_teams["getCurrentTeamId"])(state),
      permission: mattermost_redux_constants["Permissions"].EDIT_POST
    });
  } else {
    canDeletePost = Object(roles["haveIChannelPermission"])(state, {
      channel: Object(entities_channels["getCurrentChannelId"])(state),
      team: Object(entities_teams["getCurrentTeamId"])(state),
      permission: mattermost_redux_constants["Permissions"].DELETE_OTHERS_POSTS
    });
    canEditPost = Object(roles["haveIChannelPermission"])(state, {
      channel: Object(entities_channels["getCurrentChannelId"])(state),
      team: Object(entities_teams["getCurrentTeamId"])(state),
      permission: mattermost_redux_constants["Permissions"].EDIT_OTHERS_POSTS
    });
  }

  return {
    canEditPost,
    canDeletePost,
    ctrlSend: Object(entities_preferences["getBool"])(state, mattermost_redux_constants["Preferences"].CATEGORY_ADVANCED_SETTINGS, 'send_on_ctrl_enter'),
    config,
    editingPost,
    maxPostSize: parseInt(config.MaxPostSize, 10) || constants["N" /* default */].DEFAULT_CHARACTER_LIMIT
  };
}

function edit_post_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      addMessageIntoHistory: actions_posts["addMessageIntoHistory"],
      editPost: views_posts["a" /* editPost */],
      hideEditPostModal: post_actions["j" /* hideEditPostModal */],
      openModal: modals["b" /* openModal */]
    }, dispatch)
  };
}

/* harmony default export */ var edit_post_modal = (Object(es["connect"])(edit_post_modal_mapStateToProps, edit_post_modal_mapDispatchToProps)(edit_post_modal_EditPostModal));
// EXTERNAL MODULE: ./utils/url.jsx + 1 modules
var utils_url = __webpack_require__(298);

// EXTERNAL MODULE: ./node_modules/events/events.js
var events = __webpack_require__(313);
var events_default = /*#__PURE__*/__webpack_require__.n(events);

// EXTERNAL MODULE: ./dispatcher/app_dispatcher.jsx
var app_dispatcher = __webpack_require__(1845);

// CONCATENATED MODULE: ./stores/modal_store.jsx
function modal_store_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



const ActionTypes = constants["N" /* default */].ActionTypes;

class modal_store_ModalStoreClass extends events_default.a {
  constructor() {
    super();

    modal_store_defineProperty(this, "addModalListener", (action, callback) => {
      this.on(action, callback);
    });

    modal_store_defineProperty(this, "removeModalListener", (action, callback) => {
      this.removeListener(action, callback);
    });

    modal_store_defineProperty(this, "handleEventPayload", payload => {
      // toggle event handlers should accept a boolean show/hide value and can accept a map of arguments
      const {
        type,
        value,
        ...args
      } = payload.action; //eslint-disable-line no-use-before-define

      switch (type) {
        case ActionTypes.TOGGLE_SHORTCUTS_MODAL:
        case ActionTypes.TOGGLE_IMPORT_THEME_MODAL:
        case ActionTypes.TOGGLE_DELETE_POST_MODAL:
        case ActionTypes.TOGGLE_GET_POST_LINK_MODAL:
        case ActionTypes.TOGGLE_GET_TEAM_INVITE_LINK_MODAL:
        case ActionTypes.TOGGLE_GET_PUBLIC_LINK_MODAL:
        case ActionTypes.TOGGLE_QUICK_SWITCH_MODAL:
        case ActionTypes.TOGGLE_CHANNEL_PURPOSE_UPDATE_MODAL:
        case ActionTypes.TOGGLE_CHANNEL_NAME_UPDATE_MODAL:
        case ActionTypes.TOGGLE_LEAVE_PRIVATE_CHANNEL_MODAL:
          this.emit(type, value, args);
          break;
      }
    });

    this.dispatchToken = app_dispatcher["a" /* default */].register(this.handleEventPayload);
  }

}

const ModalStore = new modal_store_ModalStoreClass();
/* harmony default export */ var modal_store = (ModalStore);
// EXTERNAL MODULE: ./components/icon/success_icon.jsx
var success_icon = __webpack_require__(1695);

// CONCATENATED MODULE: ./components/get_link_modal.jsx
function get_link_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class get_link_modal_GetLinkModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    get_link_modal_defineProperty(this, "onHide", () => {
      this.setState({
        copiedLink: false
      });
      this.props.onHide();
    });

    get_link_modal_defineProperty(this, "copyLink", () => {
      const textarea = this.refs.textarea;
      textarea.focus();
      textarea.setSelectionRange(0, this.props.link.length);

      try {
        if (document.execCommand('copy')) {
          this.setState({
            copiedLink: true
          });
        } else {
          this.setState({
            copiedLink: false
          });
        }
      } catch (err) {
        this.setState({
          copiedLink: false
        });
      }
    });

    this.state = {
      copiedLink: false
    };
  }

  render() {
    let helpText = null;

    if (this.props.helpText) {
      helpText = react_default.a.createElement("p", null, this.props.helpText, react_default.a.createElement("br", null), react_default.a.createElement("br", null));
    }

    let copyLink = null;

    if (document.queryCommandSupported('copy')) {
      copyLink = react_default.a.createElement("button", {
        id: "linkModalCopyLink",
        "data-copy-btn": "true",
        type: "button",
        className: "btn btn-primary pull-left",
        onClick: this.copyLink
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "get_link.copy",
        defaultMessage: "Copy Link"
      }));
    }

    const linkText = react_default.a.createElement("textarea", {
      id: "linkModalTextArea",
      className: "form-control no-resize min-height",
      ref: "textarea",
      value: this.props.link,
      onClick: this.copyLink,
      readOnly: true
    });
    let copyLinkConfirm = null;

    if (this.state.copiedLink) {
      copyLinkConfirm = react_default.a.createElement("p", {
        className: "alert alert-success alert--confirm"
      }, react_default.a.createElement(success_icon["a" /* default */], null), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "get_link.clipboard",
        defaultMessage: " Link copied"
      }));
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      show: this.props.show,
      onHide: this.onHide,
      role: "dialog",
      "aria-labelledby": "getLinkModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      id: "getLinkModalLabel",
      closeButton: true
    }, react_default.a.createElement("h4", {
      className: "modal-title"
    }, this.props.title)), react_default.a.createElement(Modal["a" /* default */].Body, null, helpText, linkText), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      id: "linkModalCloseButton",
      type: "button",
      className: "btn btn-link",
      onClick: this.onHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "get_link.close",
      defaultMessage: "Close"
    })), copyLink, copyLinkConfirm));
  }

}

get_link_modal_defineProperty(get_link_modal_GetLinkModal, "propTypes", {
  show: prop_types_default.a.bool.isRequired,
  onHide: prop_types_default.a.func.isRequired,
  title: prop_types_default.a.string.isRequired,
  helpText: prop_types_default.a.string,
  link: prop_types_default.a.string.isRequired
});

get_link_modal_defineProperty(get_link_modal_GetLinkModal, "defaultProps", {
  helpText: null
});
// CONCATENATED MODULE: ./components/get_post_link_modal/get_post_link_modal.jsx
function get_post_link_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class get_post_link_modal_GetPostLinkModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.handleToggle = this.handleToggle.bind(this);
    this.hide = this.hide.bind(this);
    this.state = {
      show: false,
      post: {}
    };
  }

  componentDidMount() {
    modal_store.addModalListener(constants["N" /* default */].ActionTypes.TOGGLE_GET_POST_LINK_MODAL, this.handleToggle);
  }

  componentWillUnmount() {
    modal_store.removeModalListener(constants["N" /* default */].ActionTypes.TOGGLE_GET_POST_LINK_MODAL, this.handleToggle);
  }

  handleToggle(value, args) {
    this.setState({
      show: value,
      post: args.post
    });
  }

  hide() {
    this.setState({
      show: false
    });
  }

  render() {
    const postUrl = this.props.currentTeamUrl + '/pl/' + this.state.post.id;
    return react_default.a.createElement(get_link_modal_GetLinkModal, {
      show: this.state.show,
      onHide: this.hide,
      title: utils["gb" /* localizeMessage */]('get_post_link_modal.title', 'Copy Permalink'),
      helpText: utils["gb" /* localizeMessage */]('get_post_link_modal.help', 'The link below allows authorized users to see your post.'),
      link: postUrl
    });
  }

}

get_post_link_modal_defineProperty(get_post_link_modal_GetPostLinkModal, "propTypes", {
  /**
   * URL of current team
   */
  currentTeamUrl: prop_types_default.a.string.isRequired
});
// CONCATENATED MODULE: ./components/get_post_link_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function get_post_link_modal_mapStateToProps(state) {
  const currentTeam = Object(entities_teams["getCurrentTeam"])(state) || {};
  const currentTeamUrl = `${Object(utils_url["e" /* getSiteURL */])()}/${currentTeam.name}`;
  return {
    currentTeamUrl
  };
}

/* harmony default export */ var get_post_link_modal = (Object(es["connect"])(get_post_link_modal_mapStateToProps)(get_post_link_modal_GetPostLinkModal));
// CONCATENATED MODULE: ./components/get_team_invite_link_modal/get_team_invite_link_modal.jsx
function get_team_invite_link_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class get_team_invite_link_modal_GetTeamInviteLinkModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    get_team_invite_link_modal_defineProperty(this, "handleToggle", value => {
      this.setState({
        show: value
      });
    });

    get_team_invite_link_modal_defineProperty(this, "onHide", () => {
      this.handleToggle(false);
    });

    this.state = {
      show: false
    };
  }

  componentDidMount() {
    modal_store.addModalListener(constants["N" /* default */].ActionTypes.TOGGLE_GET_TEAM_INVITE_LINK_MODAL, this.handleToggle);
  }

  componentWillUnmount() {
    modal_store.removeModalListener(constants["N" /* default */].ActionTypes.TOGGLE_GET_TEAM_INVITE_LINK_MODAL, this.handleToggle);
  }

  render() {
    const inviteUrl = Object(utils_url["e" /* getSiteURL */])() + '/signup_user_complete/?id=' + this.props.currentTeam.invite_id;
    let helpText;

    if (this.props.config.EnableUserCreation === 'true') {
      helpText = utils["gb" /* localizeMessage */]('get_team_invite_link_modal.help', 'Send teammates the link below for them to sign-up to this team site. The Team Invite Link can be shared with multiple teammates as it does not change unless it\'s regenerated in Team Settings by a Team Admin.');
    } else {
      helpText = utils["gb" /* localizeMessage */]('get_team_invite_link_modal.helpDisabled', 'User creation has been disabled for your team. Please ask your team administrator for details.');
    }

    return react_default.a.createElement(get_link_modal_GetLinkModal, {
      show: this.state.show,
      onHide: this.onHide,
      title: utils["gb" /* localizeMessage */]('get_team_invite_link_modal.title', 'Team Invite Link'),
      helpText: helpText,
      link: inviteUrl
    });
  }

}

get_team_invite_link_modal_defineProperty(get_team_invite_link_modal_GetTeamInviteLinkModal, "propTypes", {
  /**
   * Current team object
   */
  currentTeam: prop_types_default.a.object.isRequired,

  /**
   * Global config object
   */
  config: prop_types_default.a.object.isRequired
});

get_team_invite_link_modal_defineProperty(get_team_invite_link_modal_GetTeamInviteLinkModal, "defaultProps", {
  currentTeam: {}
});
// CONCATENATED MODULE: ./components/get_team_invite_link_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function get_team_invite_link_modal_mapStateToProps(state) {
  return {
    currentTeam: Object(entities_teams["getCurrentTeam"])(state),
    config: Object(general["getConfig"])(state)
  };
}

/* harmony default export */ var get_team_invite_link_modal = (Object(es["connect"])(get_team_invite_link_modal_mapStateToProps)(get_team_invite_link_modal_GetTeamInviteLinkModal));
// EXTERNAL MODULE: ./mattermost-redux/actions/files.js
var actions_files = __webpack_require__(2407);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/files.js
var entities_files = __webpack_require__(1861);

// CONCATENATED MODULE: ./components/get_public_link_modal/get_public_link_modal.jsx
function get_public_link_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class get_public_link_modal_GetPublicLinkModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    get_public_link_modal_defineProperty(this, "handleToggle", (value, args) => {
      this.setState({
        show: value,
        fileId: args.fileId
      });
    });

    get_public_link_modal_defineProperty(this, "onHide", () => {
      this.setState({
        show: false
      });
    });

    this.state = {
      show: false,
      fileId: ''
    };
  }

  componentWillUnmount() {
    modal_store.removeModalListener(constants["N" /* default */].ActionTypes.TOGGLE_GET_PUBLIC_LINK_MODAL, this.handleToggle);
  }

  componentDidMount() {
    modal_store.addModalListener(constants["N" /* default */].ActionTypes.TOGGLE_GET_PUBLIC_LINK_MODAL, this.handleToggle);
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.state.show && !prevState.show) {
      this.props.actions.getFilePublicLink(this.state.fileId);
    }
  }

  render() {
    return react_default.a.createElement(get_link_modal_GetLinkModal, {
      show: this.state.show,
      onHide: this.onHide,
      title: utils["gb" /* localizeMessage */]('get_public_link_modal.title', 'Copy Public Link'),
      helpText: utils["gb" /* localizeMessage */]('get_public_link_modal.help', 'The link below allows anyone to see this file without being registered on this server.'),
      link: this.props.link
    });
  }

}

get_public_link_modal_defineProperty(get_public_link_modal_GetPublicLinkModal, "propTypes", {
  /**
   * Public link of the file
   */
  link: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    /**
     * An action to get public link
     */
    getFilePublicLink: prop_types_default.a.func.isRequired
  }).isRequired
});

get_public_link_modal_defineProperty(get_public_link_modal_GetPublicLinkModal, "defaultProps", {
  link: ''
});
// CONCATENATED MODULE: ./components/get_public_link_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function get_public_link_modal_mapStateToProps(state) {
  return {
    link: entities_files["getFilePublicLink"](state).link
  };
}

function get_public_link_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getFilePublicLink: actions_files["getFilePublicLink"]
    }, dispatch)
  };
}

/* harmony default export */ var get_public_link_modal = (Object(es["connect"])(get_public_link_modal_mapStateToProps, get_public_link_modal_mapDispatchToProps)(get_public_link_modal_GetPublicLinkModal));
// EXTERNAL MODULE: ./components/confirm_modal.jsx
var confirm_modal = __webpack_require__(1576);

// CONCATENATED MODULE: ./components/leave_private_channel_modal/leave_private_channel_modal.jsx
function leave_private_channel_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class leave_private_channel_modal_LeavePrivateChannelModal extends react_default.a.Component {
  constructor(props) {
    super(props);

    leave_private_channel_modal_defineProperty(this, "handleKeyPress", e => {
      if (e.key === 'Enter' && this.state.show) {
        this.handleSubmit();
      }
    });

    leave_private_channel_modal_defineProperty(this, "handleSubmit", () => {
      const {
        actions
      } = this.props;
      const {
        channel
      } = this.state;

      if (channel) {
        const channelId = channel.id;
        actions.leaveChannel(channelId).then(result => {
          if (result.data) {
            this.handleHide();
          }
        });
      }
    });

    leave_private_channel_modal_defineProperty(this, "handleToggle", value => {
      this.setState({
        channel: value,
        show: value !== null
      });
    });

    leave_private_channel_modal_defineProperty(this, "handleHide", () => {
      this.setState({
        show: false,
        channel: null
      });
    });

    this.state = {
      show: false,
      channel: null
    };
  }

  componentDidMount() {
    modal_store.addModalListener(constants["N" /* default */].ActionTypes.TOGGLE_LEAVE_PRIVATE_CHANNEL_MODAL, this.handleToggle);
  }

  componentWillUnmount() {
    modal_store.removeModalListener(constants["N" /* default */].ActionTypes.TOGGLE_LEAVE_PRIVATE_CHANNEL_MODAL, this.handleToggle);
  }

  render() {
    let title = '';
    let message = '';

    if (this.state.channel) {
      title = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "leave_private_channel_modal.title",
        defaultMessage: "Leave Private Channel {channel}",
        values: {
          channel: react_default.a.createElement("b", null, this.state.channel.display_name)
        }
      });
      message = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "leave_private_channel_modal.message",
        defaultMessage: "Are you sure you wish to leave the private channel {channel}? You must be re-invited in order to re-join this channel in the future.",
        values: {
          channel: react_default.a.createElement("b", null, this.state.channel.display_name)
        }
      });
    }

    const buttonClass = 'btn btn-danger';
    const button = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "leave_private_channel_modal.leave",
      defaultMessage: "Yes, leave channel"
    });
    return react_default.a.createElement(confirm_modal["a" /* default */], {
      show: this.state.show,
      title: title,
      message: message,
      confirmButtonClass: buttonClass,
      confirmButtonText: button,
      onConfirm: this.handleSubmit,
      onCancel: this.handleHide
    });
  }

}

leave_private_channel_modal_defineProperty(leave_private_channel_modal_LeavePrivateChannelModal, "propTypes", {
  actions: prop_types_default.a.shape({
    leaveChannel: prop_types_default.a.func.isRequired
  }).isRequired,
  intl: index_es["i" /* intlShape */].isRequired
});

/* harmony default export */ var leave_private_channel_modal = (Object(index_es["h" /* injectIntl */])(leave_private_channel_modal_LeavePrivateChannelModal));
// CONCATENATED MODULE: ./components/leave_private_channel_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function leave_private_channel_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      leaveChannel: views_channel["f" /* leaveChannel */]
    }, dispatch)
  };
}

/* harmony default export */ var components_leave_private_channel_modal = (Object(es["connect"])(null, leave_private_channel_modal_mapDispatchToProps)(leave_private_channel_modal));
// EXTERNAL MODULE: ./mattermost-redux/actions/preferences.js
var actions_preferences = __webpack_require__(128);

// EXTERNAL MODULE: ./actions/user_actions.jsx
var user_actions = __webpack_require__(304);

// CONCATENATED MODULE: ./components/reset_status_modal/reset_status_modal.jsx
function reset_status_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class reset_status_modal_ResetStatusModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    reset_status_modal_defineProperty(this, "hideModal", () => {
      this.setState({
        show: false
      });
    });

    reset_status_modal_defineProperty(this, "onConfirm", checked => {
      this.hideModal();
      const newStatus = { ...this.state.currentUserStatus
      };
      newStatus.status = this.state.newStatus;
      this.props.actions.setStatus(newStatus);

      if (checked) {
        const pref = {
          category: mattermost_redux_constants["Preferences"].CATEGORY_AUTO_RESET_MANUAL_STATUS,
          user_id: newStatus.user_id,
          name: newStatus.user_id,
          value: 'true'
        };
        this.props.actions.savePreferences(pref.user_id, [pref]);
      }
    });

    reset_status_modal_defineProperty(this, "onCancel", checked => {
      this.hideModal();

      if (checked) {
        const status = { ...this.state.currentUserStatus
        };
        const pref = {
          category: mattermost_redux_constants["Preferences"].CATEGORY_AUTO_RESET_MANUAL_STATUS,
          user_id: status.user_id,
          name: status.user_id,
          value: 'false'
        };
        this.props.actions.savePreferences(pref.user_id, [pref]);
      }
    });

    reset_status_modal_defineProperty(this, "renderModalMessage", () => {
      if (this.props.currentUserStatus === constants["L" /* UserStatuses */].OUT_OF_OFFICE) {
        return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: `modal.manual_status.auto_responder.message_${this.state.newStatus}`,
          defaultMessage: "Would you like to switch your status to \"{status}\" and disable Automatic Replies?",
          values: {
            status: Object(utils["qb" /* toTitleCase */])(this.state.newStatus)
          }
        });
      }

      return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: `modal.manual_status.message_${this.state.newStatus}`,
        defaultMessage: "Would you like to switch your status to \"{status}\"?",
        values: {
          status: Object(utils["qb" /* toTitleCase */])(this.state.newStatus)
        }
      });
    });

    this.state = {
      show: false,
      currentUserStatus: {},
      newStatus: props.newStatus || 'online'
    };
  }

  componentDidMount() {
    this.props.actions.autoResetStatus().then(status => {
      const statusIsManual = status.manual;
      const autoResetPrefNotSet = this.props.autoResetPref === '';
      this.setState({
        currentUserStatus: status,
        // Set in state until status refactor where we store 'manual' field in redux
        show: Boolean(status.status === constants["L" /* UserStatuses */].OUT_OF_OFFICE || statusIsManual && autoResetPrefNotSet)
      });
    });
  }

  render() {
    const userStatus = this.state.currentUserStatus.status || '';
    const userStatusId = 'modal.manual_status.title_' + userStatus;
    const manualStatusTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: userStatusId,
      defaultMessage: "Your status is set to \"{status}\"",
      values: {
        status: Object(utils["qb" /* toTitleCase */])(userStatus)
      }
    });
    const manualStatusMessage = this.renderModalMessage();
    const manualStatusButton = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: `modal.manual_status.button_${this.state.newStatus}`,
      defaultMessage: "Yes, set my status to \"{status}\"",
      values: {
        status: Object(utils["qb" /* toTitleCase */])(this.state.newStatus)
      }
    });
    const manualStatusId = 'modal.manual_status.cancel_' + userStatus;
    const manualStatusCancel = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: manualStatusId,
      defaultMessage: "No, keep it as \"{status}\"",
      values: {
        status: Object(utils["qb" /* toTitleCase */])(userStatus)
      }
    });
    const manualStatusCheckbox = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "modal.manual_status.ask",
      defaultMessage: "Do not ask me again"
    });
    const showCheckbox = this.props.currentUserStatus !== constants["L" /* UserStatuses */].OUT_OF_OFFICE;
    return react_default.a.createElement(confirm_modal["a" /* default */], {
      show: this.state.show,
      title: manualStatusTitle,
      message: manualStatusMessage,
      confirmButtonText: manualStatusButton,
      onConfirm: this.onConfirm,
      cancelButtonText: manualStatusCancel,
      onCancel: this.onCancel,
      onExited: this.props.onHide,
      showCheckbox: showCheckbox,
      checkboxText: manualStatusCheckbox
    });
  }

}

reset_status_modal_defineProperty(reset_status_modal_ResetStatusModal, "propTypes", {
  /*
   * The user's preference for whether their status is automatically reset
   */
  autoResetPref: prop_types_default.a.string,

  /*
   * Props value is used to update currentUserStatus
   */
  currentUserStatus: prop_types_default.a.string,

  /*
   * Props value is used to reset status from status_dropdown
   */
  newStatus: prop_types_default.a.string,

  /**
   * Function called when modal is dismissed
   */
  onHide: prop_types_default.a.func,
  actions: prop_types_default.a.shape({
    /*
     * Function to get and then reset the user's status if needed
     */
    autoResetStatus: prop_types_default.a.func.isRequired,

    /*
     * Function to set the status for a user
     */
    setStatus: prop_types_default.a.func.isRequired,

    /*
     * Function to save user preferences
     */
    savePreferences: prop_types_default.a.func.isRequired
  }).isRequired
});

Object(i18n["b" /* t */])('modal.manual_status.auto_responder.message_');
Object(i18n["b" /* t */])('modal.manual_status.auto_responder.message_away');
Object(i18n["b" /* t */])('modal.manual_status.auto_responder.message_dnd');
Object(i18n["b" /* t */])('modal.manual_status.auto_responder.message_offline');
Object(i18n["b" /* t */])('modal.manual_status.auto_responder.message_online');
Object(i18n["b" /* t */])('modal.manual_status.button_');
Object(i18n["b" /* t */])('modal.manual_status.button_away');
Object(i18n["b" /* t */])('modal.manual_status.button_dnd');
Object(i18n["b" /* t */])('modal.manual_status.button_offline');
Object(i18n["b" /* t */])('modal.manual_status.button_online');
Object(i18n["b" /* t */])('modal.manual_status.cancel_');
Object(i18n["b" /* t */])('modal.manual_status.cancel_away');
Object(i18n["b" /* t */])('modal.manual_status.cancel_dnd');
Object(i18n["b" /* t */])('modal.manual_status.cancel_offline');
Object(i18n["b" /* t */])('modal.manual_status.cancel_ooo');
Object(i18n["b" /* t */])('modal.manual_status.message_');
Object(i18n["b" /* t */])('modal.manual_status.message_away');
Object(i18n["b" /* t */])('modal.manual_status.message_dnd');
Object(i18n["b" /* t */])('modal.manual_status.message_offline');
Object(i18n["b" /* t */])('modal.manual_status.message_online');
Object(i18n["b" /* t */])('modal.manual_status.title_');
Object(i18n["b" /* t */])('modal.manual_status.title_away');
Object(i18n["b" /* t */])('modal.manual_status.title_dnd');
Object(i18n["b" /* t */])('modal.manual_status.title_offline');
Object(i18n["b" /* t */])('modal.manual_status.title_ooo');
// CONCATENATED MODULE: ./components/reset_status_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function reset_status_modal_mapStateToProps(state) {
  const {
    currentUserId
  } = state.entities.users;
  return {
    autoResetPref: Object(entities_preferences["get"])(state, mattermost_redux_constants["Preferences"].CATEGORY_AUTO_RESET_MANUAL_STATUS, currentUserId, ''),
    currentUserStatus: Object(entities_users["getStatusForUserId"])(state, currentUserId)
  };
}

function reset_status_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      autoResetStatus: user_actions["a" /* autoResetStatus */],
      setStatus: actions_users["setStatus"],
      savePreferences: actions_preferences["savePreferences"]
    }, dispatch)
  };
}

/* harmony default export */ var reset_status_modal = (Object(es["connect"])(reset_status_modal_mapStateToProps, reset_status_modal_mapDispatchToProps)(reset_status_modal_ResetStatusModal));
// EXTERNAL MODULE: ./node_modules/antd/es/modal/index.js + 3 modules
var es_modal = __webpack_require__(1552);

// EXTERNAL MODULE: ./node_modules/antd/es/icon/index.js + 3 modules
var es_icon = __webpack_require__(93);

// CONCATENATED MODULE: ./components/shortcuts_modal.jsx
function shortcuts_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const allShortcuts = Object(index_es["g" /* defineMessages */])({
  mainHeader: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.header'),
      defaultMessage: 'Keyboard Shortcuts\tCtrl|/'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.header.mac'),
      defaultMessage: 'Keyboard Shortcuts\t⌘|/'
    }
  },
  navHeader: {
    id: Object(i18n["b" /* t */])('shortcuts.nav.header'),
    defaultMessage: 'Navigation'
  },
  navPrev: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.prev'),
      defaultMessage: 'Previous channel:\tAlt|Up'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.prev.mac'),
      defaultMessage: 'Previous channel:\t⌥|Up'
    }
  },
  navNext: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.next'),
      defaultMessage: 'Next channel:\tAlt|Down'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.next.mac'),
      defaultMessage: 'Next channel:\t⌥|Down'
    }
  },
  navUnreadPrev: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.unread_prev'),
      defaultMessage: 'Previous unread channel:\tAlt|Shift|Up'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.unread_prev.mac'),
      defaultMessage: 'Previous unread channel:\t⌥|Shift|Up'
    }
  },
  navUnreadNext: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.unread_next'),
      defaultMessage: 'Next unread channel:\tAlt|Shift|Down'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.unread_next.mac'),
      defaultMessage: 'Next unread channel:\t⌥|Shift|Down'
    }
  },
  navSwitcher: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.switcher'),
      defaultMessage: 'Quick channel switcher:\tCtrl|K'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.switcher.mac'),
      defaultMessage: 'Quick channel switcher:\t⌘|K'
    }
  },
  navDMMenu: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.direct_messages_menu'),
      defaultMessage: 'Direct messages menu:\tCtrl|Shift|K'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.direct_messages_menu.mac'),
      defaultMessage: 'Direct messages menu:\t⌘|Shift|K'
    }
  },
  navSettings: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.settings'),
      defaultMessage: 'Account settings:\tCtrl|Shift|A'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.settings.mac'),
      defaultMessage: 'Account settings:\t⌘|Shift|A'
    }
  },
  navMentions: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.recent_mentions'),
      defaultMessage: 'Recent mentions:\tCtrl|Shift|M'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.recent_mentions.mac'),
      defaultMessage: 'Recent mentions:\t⌘|Shift|M'
    }
  },
  navFocusCenter: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.focus_center'),
      defaultMessage: 'Set focus to input field:\tCtrl|Shift|L'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.nav.focus_center.mac'),
      defaultMessage: 'Set focus to input field:\t⌘|Shift|L'
    }
  },
  msgHeader: {
    id: Object(i18n["b" /* t */])('shortcuts.msgs.header'),
    defaultMessage: 'Messages'
  },
  msgInputHeader: {
    id: Object(i18n["b" /* t */])('shortcuts.msgs.input.header'),
    defaultMessage: 'Works inside an empty input field'
  },
  msgEdit: {
    id: Object(i18n["b" /* t */])('shortcuts.msgs.edit'),
    defaultMessage: 'Edit last message in channel:\tUp'
  },
  msgReply: {
    id: Object(i18n["b" /* t */])('shortcuts.msgs.reply'),
    defaultMessage: 'Reply to last message in channel:\tShift|Up'
  },
  msgReprintPrev: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.msgs.reprint_prev'),
      defaultMessage: 'Reprint previous message:\tCtrl|Up'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.msgs.reprint_prev.mac'),
      defaultMessage: 'Reprint previous message:\t⌘|Up'
    }
  },
  msgReprintNext: {
    default: {
      id: Object(i18n["b" /* t */])('shortcuts.msgs.reprint_next'),
      defaultMessage: 'Reprint next message:\tCtrl|Down'
    },
    mac: {
      id: Object(i18n["b" /* t */])('shortcuts.msgs.reprint_next.mac'),
      defaultMessage: 'Reprint next message:\t⌘|Down'
    }
  },
  msgCompHeader: {
    id: Object(i18n["b" /* t */])('shortcuts.msgs.comp.header'),
    defaultMessage: 'Autocomplete'
  },
  msgCompUsername: {
    id: Object(i18n["b" /* t */])('shortcuts.msgs.comp.username'),
    defaultMessage: 'Username:\t@|[a-z]|Tab'
  },
  msgCompChannel: {
    id: Object(i18n["b" /* t */])('shortcuts.msgs.comp.channel'),
    defaultMessage: 'Channel:\t~|[a-z]|Tab'
  },
  msgCompEmoji: {
    id: Object(i18n["b" /* t */])('shortcuts.msgs.comp.emoji'),
    defaultMessage: 'Emoji:\t:|[a-z]|Tab'
  },
  // filesHeader: {
  //     id: t('shortcuts.files.header'),
  //     defaultMessage: 'Files',
  // },
  // filesUpload: {
  //     default: {
  //         id: t('shortcuts.files.upload'),
  //         defaultMessage: 'Upload files:\tCtrl|U',
  //     },
  //     mac: {
  //         id: t('shortcuts.files.upload.mac'),
  //         defaultMessage: 'Upload files:\t⌘|U',
  //     },
  // },
  // browserHeader: {
  //     id: t('shortcuts.browser.header'),
  //     defaultMessage: 'Built-in Browser Commands',
  // },
  // browserChannelPrev: {
  //     default: {
  //         id: t('shortcuts.browser.channel_prev'),
  //         defaultMessage: 'Back in history:\tAlt|Left',
  //     },
  //     mac: {
  //         id: t('shortcuts.browser.channel_prev.mac'),
  //         defaultMessage: 'Back in history:\t⌘|[',
  //     },
  // },
  // browserChannelNext: {
  //     default: {
  //         id: t('shortcuts.browser.channel_next'),
  //         defaultMessage: 'Forward in history:\tAlt|Right',
  //     },
  //     mac: {
  //         id: t('shortcuts.browser.channel_next.mac'),
  //         defaultMessage: 'Forward in history:\t⌘|]',
  //     },
  // },
  // browserFontIncrease: {
  //     default: {
  //         id: t('shortcuts.browser.font_increase'),
  //         defaultMessage: 'Zoom in:\tCtrl|+',
  //     },
  //     mac: {
  //         id: t('shortcuts.browser.font_increase.mac'),
  //         defaultMessage: 'Zoom in:\t⌘|+',
  //     },
  // },
  // browserFontDecrease: {
  //     default: {
  //         id: t('shortcuts.browser.font_decrease'),
  //         defaultMessage: 'Zoom out:\tCtrl|-',
  //     },
  //     mac: {
  //         id: t('shortcuts.browser.font_decrease.mac'),
  //         defaultMessage: 'Zoom out:\t⌘|-',
  //     },
  // },
  // browserInputHeader: {
  //     id: t('shortcuts.browser.input.header'),
  //     defaultMessage: 'Works inside an input field',
  // },
  // browserHighlightPrev: {
  //     id: t('shortcuts.browser.highlight_prev'),
  //     defaultMessage: 'Highlight text to the previous line:\tShift|Up',
  // },
  // browserHighlightNext: {
  //     id: t('shortcuts.browser.highlight_next'),
  //     defaultMessage: 'Highlight text to the next line:\tShift|Down',
  // },
  // browserNewline: {
  //     id: t('shortcuts.browser.newline'),
  //     defaultMessage: 'Create a new line:\tShift|Enter',
  // },
  info: {
    id: Object(i18n["b" /* t */])('shortcuts.info'),
    defaultMessage: 'Begin a message with / for a list of all the commands at your disposal.'
  }
});

class shortcuts_modal_ShortcutsModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    shortcuts_modal_defineProperty(this, "handleToggle", () => {
      //toggles the state of shortcut dialog
      this.setState({
        show: !this.state.show
      });
    });

    shortcuts_modal_defineProperty(this, "handleHide", () => {
      this.setState({
        show: false
      });
    });

    this.state = {
      show: false
    };
  }

  componentDidMount() {
    modal_store.addModalListener(constants["N" /* default */].ActionTypes.TOGGLE_SHORTCUTS_MODAL, this.handleToggle);
  }

  componentWillUnmount() {
    modal_store.removeModalListener(constants["N" /* default */].ActionTypes.TOGGLE_SHORTCUTS_MODAL, this.handleToggle);
  }

  getShortcuts() {
    const {
      isMac
    } = this.props;
    const shortcuts = {};
    Object.keys(allShortcuts).forEach(s => {
      if (isMac && allShortcuts[s].mac) {
        shortcuts[s] = allShortcuts[s].mac;
      } else if (!isMac && allShortcuts[s].default) {
        shortcuts[s] = allShortcuts[s].default;
      } else {
        shortcuts[s] = allShortcuts[s];
      }
    });
    return shortcuts;
  }

  render() {
    const shortcuts = this.getShortcuts();
    const {
      formatMessage
    } = this.props.intl;
    return react_default.a.createElement(es_modal["a" /* default */], {
      title: formatMessage(shortcuts.mainHeader),
      className: "shortcuts-modal",
      closeIcon: react_default.a.createElement(es_icon["a" /* default */], {
        type: "close-circle",
        theme: "filled"
      }),
      visible: this.state.show,
      onCancel: this.handleHide,
      role: "dialog",
      footer: null,
      mask: false,
      maskClosable: false,
      centered: true,
      width: '660px'
    }, react_default.a.createElement("div", {
      className: "shortcuts-content"
    }, react_default.a.createElement("div", {
      className: "row",
      ref: "modalBody"
    }, react_default.a.createElement("div", {
      className: "col-sm-6"
    }, react_default.a.createElement("div", {
      className: "section"
    }, react_default.a.createElement("div", null, react_default.a.createElement("h4", {
      className: "section-title"
    }, react_default.a.createElement("strong", null, formatMessage(shortcuts.navHeader))), renderShortcut(formatMessage(shortcuts.navPrev)), renderShortcut(formatMessage(shortcuts.navNext)), renderShortcut(formatMessage(shortcuts.navUnreadPrev)), renderShortcut(formatMessage(shortcuts.navUnreadNext)), renderShortcut(formatMessage(shortcuts.navSwitcher)), renderShortcut(formatMessage(shortcuts.navDMMenu)), renderShortcut(formatMessage(shortcuts.navSettings)), renderShortcut(formatMessage(shortcuts.navMentions)), renderShortcut(formatMessage(shortcuts.navFocusCenter))))), react_default.a.createElement("div", {
      className: "col-sm-6"
    }, react_default.a.createElement("div", {
      className: "section"
    }, react_default.a.createElement("div", null, react_default.a.createElement("h4", {
      className: "section-title"
    }, react_default.a.createElement("strong", null, formatMessage(shortcuts.msgHeader))), react_default.a.createElement("span", null, react_default.a.createElement("strong", null, formatMessage(shortcuts.msgInputHeader))), react_default.a.createElement("div", {
      className: "subsection"
    }, renderShortcut(formatMessage(shortcuts.msgEdit)), renderShortcut(formatMessage(shortcuts.msgReply)), renderShortcut(formatMessage(shortcuts.msgReprintPrev)), renderShortcut(formatMessage(shortcuts.msgReprintNext))), react_default.a.createElement("span", null, react_default.a.createElement("strong", null, formatMessage(shortcuts.msgCompHeader))), react_default.a.createElement("div", {
      className: "subsection"
    }, renderShortcut(formatMessage(shortcuts.msgCompUsername)), renderShortcut(formatMessage(shortcuts.msgCompChannel)), renderShortcut(formatMessage(shortcuts.msgCompEmoji))))))), react_default.a.createElement("div", {
      className: "info__label"
    }, formatMessage(shortcuts.info))));
  }

}

shortcuts_modal_defineProperty(shortcuts_modal_ShortcutsModal, "propTypes", {
  intl: index_es["i" /* intlShape */].isRequired,
  isMac: prop_types_default.a.bool.isRequired
});

function renderShortcut(text) {
  if (!text) {
    return null;
  }

  const shortcut = text.split('\t');
  const description = react_default.a.createElement("span", null, shortcut[0]);
  let keys = null;

  if (shortcut.length > 1) {
    keys = shortcut[1].split('|').map(key => react_default.a.createElement("span", {
      className: "shortcut-key",
      key: key
    }, key));
  }

  return react_default.a.createElement("div", {
    className: "shortcut-line"
  }, description, keys);
}

/* harmony default export */ var shortcuts_modal = (Object(index_es["h" /* injectIntl */])(shortcuts_modal_ShortcutsModal));
// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/posts.js
var entities_posts = __webpack_require__(61);

// EXTERNAL MODULE: ./actions/views/rhs.js
var rhs = __webpack_require__(116);

// EXTERNAL MODULE: ./selectors/rhs.jsx
var selectors_rhs = __webpack_require__(60);

// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(66);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ./images/filesOverlay.png
var filesOverlay = __webpack_require__(2410);
var filesOverlay_default = /*#__PURE__*/__webpack_require__.n(filesOverlay);

// EXTERNAL MODULE: ./images/logoWhite.png
var logoWhite = __webpack_require__(2411);
var logoWhite_default = /*#__PURE__*/__webpack_require__.n(logoWhite);

// CONCATENATED MODULE: ./components/file_upload_overlay.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function FileUploadOverlay(props) {
  var overlayClass = 'file-overlay hidden';

  if (props.overlayType === 'right') {
    overlayClass += ' right-file-overlay';
  } else if (props.overlayType === 'center') {
    overlayClass += ' center-file-overlay';
  }

  return react_default.a.createElement("div", {
    className: overlayClass
  }, react_default.a.createElement("div", {
    className: "overlay__indent"
  }, react_default.a.createElement("div", {
    className: "overlay__circle"
  }, react_default.a.createElement("img", {
    className: "overlay__files",
    src: filesOverlay_default.a,
    alt: "Files"
  }), react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "generic_icons.upload",
    defaultMessage: "Upload Icon"
  }, title => react_default.a.createElement("i", {
    className: "fa fa-upload",
    title: title
  })), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "upload_overlay.info",
    defaultMessage: "Drop a file to upload it."
  })), react_default.a.createElement("img", {
    className: "overlay__logo",
    src: logoWhite_default.a,
    width: "100",
    alt: "Logo"
  }))));
}
FileUploadOverlay.propTypes = {
  overlayType: prop_types_default.a.string
};
// EXTERNAL MODULE: ./node_modules/jquery/src/jquery.js
var jquery = __webpack_require__(175);
var jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);

// EXTERNAL MODULE: ./node_modules/react-custom-scrollbars/lib/index.js
var react_custom_scrollbars_lib = __webpack_require__(1729);
var react_custom_scrollbars_lib_default = /*#__PURE__*/__webpack_require__.n(react_custom_scrollbars_lib);

// EXTERNAL MODULE: ./utils/delayed_action.jsx
var delayed_action = __webpack_require__(1671);

// EXTERNAL MODULE: ./components/post_view/date_separator/index.js + 1 modules
var date_separator = __webpack_require__(1827);

// EXTERNAL MODULE: ./mattermost-redux/utils/post_utils.js
var utils_post_utils = __webpack_require__(57);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tooltip.js
var Tooltip = __webpack_require__(1998);

// EXTERNAL MODULE: ./components/dot_menu/index.js + 1 modules
var dot_menu = __webpack_require__(1969);

// EXTERNAL MODULE: ./components/file_attachment_list/index.js + 7 modules
var file_attachment_list = __webpack_require__(1718);

// EXTERNAL MODULE: ./components/post_profile_picture/index.jsx + 1 modules
var post_profile_picture = __webpack_require__(1758);

// CONCATENATED MODULE: ./components/post_view/failed_post_options/failed_post_options.jsx
function failed_post_options_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class failed_post_options_FailedPostOptions extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    failed_post_options_defineProperty(this, "retryPost", e => {
      e.preventDefault();
      const post = { ...this.props.post
      };
      Reflect.deleteProperty(post, 'id');
      this.props.actions.createPost(post);
    });

    failed_post_options_defineProperty(this, "cancelPost", e => {
      e.preventDefault();
      this.props.actions.removePost(this.props.post);
    });
  }

  render() {
    return react_default.a.createElement("span", {
      className: "pending-post-actions"
    }, react_default.a.createElement("a", {
      className: "post-retry",
      href: "#",
      onClick: this.retryPost
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "pending_post_actions.retry",
      defaultMessage: "Retry"
    })), ' - ', react_default.a.createElement("a", {
      className: "post-cancel",
      href: "#",
      onClick: this.cancelPost
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "pending_post_actions.cancel",
      defaultMessage: "Cancel"
    })));
  }

}

failed_post_options_defineProperty(failed_post_options_FailedPostOptions, "propTypes", {
  post: prop_types_default.a.object.isRequired,
  actions: prop_types_default.a.shape({
    createPost: prop_types_default.a.func.isRequired,
    removePost: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/post_view/failed_post_options/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function failed_post_options_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      createPost: post_actions["c" /* createPost */],
      removePost: actions_posts["removePost"]
    }, dispatch)
  };
}

/* harmony default export */ var failed_post_options = (Object(es["connect"])(null, failed_post_options_mapDispatchToProps)(failed_post_options_FailedPostOptions));
// EXTERNAL MODULE: ./components/post_view/post_flag_icon/index.js + 1 modules
var post_flag_icon = __webpack_require__(1760);

// EXTERNAL MODULE: ./components/post_view/post_time/index.js + 1 modules
var post_time = __webpack_require__(1970);

// EXTERNAL MODULE: ./mattermost-redux/constants/permissions.js
var permissions = __webpack_require__(5);
var permissions_default = /*#__PURE__*/__webpack_require__.n(permissions);

// EXTERNAL MODULE: ./components/permissions_gates/channel_permission_gate/index.js + 1 modules
var channel_permission_gate = __webpack_require__(1721);

// CONCATENATED MODULE: ./components/post_view/post_reaction/post_reaction.jsx
function post_reaction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









const TOP_OFFSET = -7;
class post_reaction_PostReaction extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    post_reaction_defineProperty(this, "handleAddEmoji", emoji => {
      this.setState({
        showEmojiPicker: false
      });
      const emojiName = emoji.name || emoji.aliases[0];
      this.props.actions.addReaction(this.props.postId, emojiName);
      this.props.toggleEmojiPicker();
    });
  }

  render() {
    const {
      channelId,
      location,
      postId,
      showEmojiPicker,
      teamId
    } = this.props;
    let spaceRequiredAbove;
    let spaceRequiredBelow;

    if (location === constants["o" /* Locations */].RHS_ROOT || location === constants["o" /* Locations */].RHS_COMMENT) {
      spaceRequiredAbove = emoji_picker_overlay_EmojiPickerOverlay.RHS_SPACE_REQUIRED_ABOVE;
      spaceRequiredBelow = emoji_picker_overlay_EmojiPickerOverlay.RHS_SPACE_REQUIRED_BELOW;
    }

    return react_default.a.createElement(channel_permission_gate["a" /* default */], {
      channelId: channelId,
      teamId: teamId,
      permissions: [permissions_default.a.ADD_REACTION]
    }, react_default.a.createElement("div", null, react_default.a.createElement(emoji_picker_overlay_EmojiPickerOverlay, {
      show: showEmojiPicker,
      target: this.props.getDotMenuRef,
      onHide: this.props.toggleEmojiPicker,
      onEmojiClose: this.props.toggleEmojiPicker,
      onEmojiClick: this.handleAddEmoji,
      topOffset: TOP_OFFSET,
      spaceRequiredAbove: spaceRequiredAbove,
      spaceRequiredBelow: spaceRequiredBelow
    }), react_default.a.createElement(OverlayTrigger["a" /* default */], {
      className: "hidden-xs",
      delayShow: 500,
      placement: "top",
      overlay: react_default.a.createElement(Tooltip["a" /* default */], {
        id: "reaction-icon-tooltip",
        className: "hidden-xs"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "post_info.tooltip.add_reactions",
        defaultMessage: "Add Reaction"
      }))
    }, react_default.a.createElement("button", {
      id: `${location}_reaction_${postId}`,
      className: "reacticon__container color--link style--none",
      onClick: this.props.toggleEmojiPicker
    }, react_default.a.createElement(emoji_icon_EmojiIcon, {
      className: "icon icon--emoji"
    })))));
  }

}

post_reaction_defineProperty(post_reaction_PostReaction, "propTypes", {
  channelId: prop_types_default.a.string,
  postId: prop_types_default.a.string.isRequired,
  teamId: prop_types_default.a.string.isRequired,
  getDotMenuRef: prop_types_default.a.func.isRequired,
  location: prop_types_default.a.oneOf([constants["o" /* Locations */].CENTER, constants["o" /* Locations */].RHS_ROOT, constants["o" /* Locations */].RHS_COMMENT]).isRequired,
  showEmojiPicker: prop_types_default.a.bool.isRequired,
  toggleEmojiPicker: prop_types_default.a.func.isRequired,
  actions: prop_types_default.a.shape({
    addReaction: prop_types_default.a.func.isRequired
  }).isRequired
});

post_reaction_defineProperty(post_reaction_PostReaction, "defaultProps", {
  location: constants["o" /* Locations */].CENTER,
  showEmojiPicker: false
});
// CONCATENATED MODULE: ./components/post_view/post_reaction/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function post_reaction_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      addReaction: post_actions["b" /* addReaction */]
    }, dispatch)
  };
}

/* harmony default export */ var post_reaction = (Object(es["connect"])(null, post_reaction_mapDispatchToProps)(post_reaction_PostReaction));
// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/emojis.js
var entities_emojis = __webpack_require__(258);

// EXTERNAL MODULE: ./mattermost-redux/constants/general.js
var constants_general = __webpack_require__(985);
var constants_general_default = /*#__PURE__*/__webpack_require__.n(constants_general);

// CONCATENATED MODULE: ./components/post_view/reaction/reaction.jsx
function reaction_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class reaction_Reaction extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    reaction_defineProperty(this, "handleAddReaction", e => {
      e.preventDefault();
      const {
        actions,
        post,
        emojiName
      } = this.props;
      actions.addReaction(post.id, emojiName);
    });

    reaction_defineProperty(this, "handleRemoveReaction", e => {
      e.preventDefault();
      this.props.actions.removeReaction(this.props.post.id, this.props.emojiName);
    });

    reaction_defineProperty(this, "loadMissingProfiles", () => {
      const ids = this.props.reactions.map(reaction => reaction.user_id);
      this.props.actions.getMissingProfilesByIds(ids);
    });
  }

  render() {
    if (!this.props.emojiImageUrl) {
      return null;
    }

    let currentUserReacted = false;
    const users = [];
    const otherUsersCount = this.props.otherUsersCount;

    for (const user of this.props.profiles) {
      if (user.id === this.props.currentUserId) {
        currentUserReacted = true;
      } else {
        users.push(utils["w" /* getDisplayNameByUser */](user));
      }
    } // Sort users in alphabetical order with "you" being first if the current user reacted


    users.sort();

    if (currentUserReacted) {
      users.unshift(utils["gb" /* localizeMessage */]('reaction.you', 'You'));
    }

    let names;

    if (otherUsersCount > 0) {
      if (users.length > 0) {
        names = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "reaction.usersAndOthersReacted",
          defaultMessage: "{users} and {otherUsers, number} other {otherUsers, plural, one {user} other {users}}",
          values: {
            users: users.join(', '),
            otherUsers: otherUsersCount
          }
        });
      } else {
        names = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "reaction.othersReacted",
          defaultMessage: "{otherUsers, number} {otherUsers, plural, one {user} other {users}}",
          values: {
            otherUsers: otherUsersCount
          }
        });
      }
    } else if (users.length > 1) {
      names = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "reaction.usersReacted",
        defaultMessage: "{users} and {lastUser}",
        values: {
          users: users.slice(0, -1).join(', '),
          lastUser: users[users.length - 1]
        }
      });
    } else {
      names = users[0];
    }

    let reactionVerb;

    if (users.length + otherUsersCount > 1) {
      if (currentUserReacted) {
        reactionVerb = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "reaction.reactionVerb.youAndUsers",
          defaultMessage: "reacted"
        });
      } else {
        reactionVerb = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "reaction.reactionVerb.users",
          defaultMessage: "reacted"
        });
      }
    } else if (currentUserReacted) {
      reactionVerb = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "reaction.reactionVerb.you",
        defaultMessage: "reacted"
      });
    } else {
      reactionVerb = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "reaction.reactionVerb.user",
        defaultMessage: "reacted"
      });
    }

    const tooltip = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "reaction.reacted",
      defaultMessage: "{users} {reactionVerb} with {emoji}",
      values: {
        users: react_default.a.createElement("b", null, names),
        reactionVerb,
        emoji: react_default.a.createElement("b", null, ':' + this.props.emojiName + ':')
      }
    });
    let handleClick;
    let clickTooltip;
    let className = 'post-reaction';

    if (currentUserReacted) {
      if (this.props.canRemoveReaction) {
        handleClick = this.handleRemoveReaction;
        clickTooltip = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "reaction.clickToRemove",
          defaultMessage: "(click to remove)"
        });
      } else {
        className += ' post-reaction--read-only';
      }

      className += ' post-reaction--current-user';
    } else if (!currentUserReacted && this.props.canAddReaction) {
      handleClick = this.handleAddReaction;
      clickTooltip = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "reaction.clickToAdd",
        defaultMessage: "(click to add)"
      });
    } else {
      className += ' post-reaction--read-only';
    }

    return react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: 1000,
      placement: "top",
      shouldUpdatePosition: true,
      overlay: react_default.a.createElement(Tooltip["a" /* default */], {
        id: `${this.props.post.id}-${this.props.emojiName}-reaction`
      }, tooltip, react_default.a.createElement("br", null), clickTooltip),
      onEnter: this.loadMissingProfiles
    }, react_default.a.createElement("div", {
      id: `postReaction-${this.props.post.id}-${this.props.emojiName}`,
      className: className,
      onClick: handleClick
    }, react_default.a.createElement("span", {
      className: "post-reaction__emoji emoticon",
      style: {
        backgroundImage: 'url(' + this.props.emojiImageUrl + ')'
      }
    }), react_default.a.createElement("span", {
      className: "post-reaction__count"
    }, this.props.reactionCount)));
  }

}

reaction_defineProperty(reaction_Reaction, "propTypes", {
  /*
   * The post to render the reaction for
   */
  post: prop_types_default.a.object.isRequired,

  /*
   * The user id of the logged in user
   */
  currentUserId: prop_types_default.a.string.isRequired,

  /*
   * The name of the emoji for the reaction
   */
  emojiName: prop_types_default.a.string.isRequired,

  /*
   * The number of reactions to this post for this emoji
   */
  reactionCount: prop_types_default.a.number.isRequired,

  /*
   * Array of users who reacted to this post
   */
  profiles: prop_types_default.a.array.isRequired,

  /*
   * The number of users not in the profile list who have reacted with this emoji
   */
  otherUsersCount: prop_types_default.a.number.isRequired,

  /*
   * Array of reactions by user
   */
  reactions: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,

  /*
   * True if the user has the permission to add a reaction in this channel
   */
  canAddReaction: prop_types_default.a.bool.isRequired,

  /*
   * True if user has the permission to remove his own reactions in this channel
   */
  canRemoveReaction: prop_types_default.a.bool.isRequired,

  /*
   * The URL of the emoji image
   */
  emojiImageUrl: prop_types_default.a.string.isRequired,
  actions: prop_types_default.a.shape({
    /*
     * Function to add a reaction to a post
     */
    addReaction: prop_types_default.a.func.isRequired,

    /*
     * Function to get non-loaded profiles by id
     */
    getMissingProfilesByIds: prop_types_default.a.func.isRequired,

    /*
     * Function to remove a reaction from a post
     */
    removeReaction: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/post_view/reaction/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
















function reaction_makeMapStateToProps() {
  const getProfilesForReactions = Object(entities_users["makeGetProfilesForReactions"])();
  return function mapStateToProps(state, ownProps) {
    const config = Object(general["getConfig"])(state);
    const license = Object(general["getLicense"])(state);
    const me = Object(entities_users["getCurrentUser"])(state);
    const profiles = getProfilesForReactions(state, ownProps.reactions);
    let emoji;

    if (utils_emoji["a" /* EmojiIndicesByAlias */].has(ownProps.emojiName)) {
      emoji = utils_emoji["d" /* Emojis */][utils_emoji["a" /* EmojiIndicesByAlias */].get(ownProps.emojiName)];
    } else {
      const emojis = Object(entities_emojis["getCustomEmojisByName"])(state);
      emoji = emojis.get(ownProps.emojiName);
    }

    let emojiImageUrl = '';

    if (emoji) {
      emojiImageUrl = Object(emoji_utils["getEmojiImageUrl"])(emoji);
    }

    const channel = Object(entities_channels["getChannel"])(state, ownProps.post.channel_id) || {};
    const channelIsArchived = channel.delete_at !== 0;
    const teamId = channel.team_id;
    let canAddReaction = false;
    let canRemoveReaction = false;

    if (!channelIsArchived) {
      canAddReaction = checkReactionAction(state, teamId, ownProps.post.channel_id, channel.name, config, license, me, permissions_default.a.REMOVE_REACTION);
      canRemoveReaction = checkReactionAction(state, teamId, ownProps.post.channel_id, channel.name, config, license, me, permissions_default.a.ADD_REACTION);
    }

    return {
      profiles,
      otherUsersCount: ownProps.reactions.length - profiles.length,
      currentUserId: Object(entities_users["getCurrentUserId"])(state),
      reactionCount: ownProps.reactions.length,
      canAddReaction,
      canRemoveReaction,
      emojiImageUrl
    };
  };
}

function reaction_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      addReaction: post_actions["b" /* addReaction */],
      removeReaction: actions_posts["removeReaction"],
      getMissingProfilesByIds: actions_users["getMissingProfilesByIds"]
    }, dispatch)
  };
}

function checkReactionAction(state, teamId, channelId, channelName, config, license, user, permission) {
  if (!Object(roles["haveIChannelPermission"])(state, {
    team: teamId,
    channel: channelId,
    permission
  })) {
    return false;
  }

  if (channelName === constants_general_default.a.DEFAULT_CHANNEL && config.ExperimentalTownSquareIsReadOnly === 'true' && license.IsLicensed === 'true' && !user.roles.includes('system_admin')) {
    return false;
  }

  return true;
}

/* harmony default export */ var reaction = (Object(es["connect"])(reaction_makeMapStateToProps, reaction_mapDispatchToProps)(reaction_Reaction));
// CONCATENATED MODULE: ./components/post_view/reaction_list/reaction_list.jsx
function reaction_list_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const DEFAULT_EMOJI_PICKER_RIGHT_OFFSET = 15;
const EMOJI_PICKER_WIDTH_OFFSET = 260;
class reaction_list_ReactionList extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    reaction_list_defineProperty(this, "getTarget", () => {
      return this.refs.addReactionButton;
    });

    reaction_list_defineProperty(this, "handleEmojiClick", emoji => {
      this.setState({
        showEmojiPicker: false
      });
      const emojiName = emoji.name || emoji.aliases[0];
      this.props.actions.addReaction(this.props.post.id, emojiName);
    });

    reaction_list_defineProperty(this, "hideEmojiPicker", () => {
      this.setState({
        showEmojiPicker: false
      });
    });

    reaction_list_defineProperty(this, "toggleEmojiPicker", () => {
      this.setState({
        showEmojiPicker: !this.state.showEmojiPicker
      });
    });

    this.state = {
      showEmojiPicker: false
    };
  }

  componentDidUpdate(prevProps) {
    if (this.props.reactions !== prevProps.reactions && Object(utils["k" /* disableVirtList */])()) {
      this.props.actions.scrollPostList();
    }
  }

  render() {
    const reactionsByName = new Map();
    const emojiNames = [];

    if (this.props.reactions) {
      for (const reaction of Object.values(this.props.reactions)) {
        const emojiName = reaction.emoji_name;

        if (reactionsByName.has(emojiName)) {
          reactionsByName.get(emojiName).push(reaction);
        } else {
          emojiNames.push(emojiName);
          reactionsByName.set(emojiName, [reaction]);
        }
      }
    }

    if (reactionsByName.size === 0) {
      return null;
    }

    const reactions = emojiNames.map(emojiName => {
      return react_default.a.createElement(reaction, {
        key: emojiName,
        post: this.props.post,
        emojiName: emojiName,
        reactions: reactionsByName.get(emojiName) || []
      });
    });
    const addReactionButton = this.getTarget();
    let rightOffset = DEFAULT_EMOJI_PICKER_RIGHT_OFFSET;

    if (addReactionButton) {
      rightOffset = window.innerWidth - addReactionButton.getBoundingClientRect().right - EMOJI_PICKER_WIDTH_OFFSET;

      if (rightOffset < 0) {
        rightOffset = DEFAULT_EMOJI_PICKER_RIGHT_OFFSET;
      }
    }

    let emojiPicker = null;

    if (this.props.enableEmojiPicker) {
      const addReactionTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "addReactionTooltip"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "reaction_list.addReactionTooltip",
        defaultMessage: "Add reaction"
      }));
      emojiPicker = react_default.a.createElement("span", {
        className: "emoji-picker__container"
      }, react_default.a.createElement(emoji_picker_overlay_EmojiPickerOverlay, {
        show: this.state.showEmojiPicker,
        target: this.getTarget,
        onHide: this.hideEmojiPicker,
        onEmojiClose: this.hideEmojiPicker,
        onEmojiClick: this.handleEmojiClick,
        rightOffset: rightOffset,
        topOffset: -5
      }), react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        placement: "top",
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        overlay: addReactionTooltip
      }, react_default.a.createElement(channel_permission_gate["a" /* default */], {
        channelId: this.props.post.channel_id,
        teamId: this.props.teamId,
        permissions: [permissions_default.a.ADD_REACTION]
      }, react_default.a.createElement("div", {
        className: "post-reaction",
        onClick: this.toggleEmojiPicker
      }, react_default.a.createElement("span", {
        id: `addReaction-${this.props.post.id}`,
        className: "post-reaction__add",
        ref: "addReactionButton"
      }, '+')))));
    }

    let addReactionClassName = 'post-add-reaction';

    if (this.state.showEmojiPicker) {
      addReactionClassName += ' post-add-reaction-emoji-picker-open';
    }

    return react_default.a.createElement("div", {
      className: "post-reaction-list"
    }, reactions, react_default.a.createElement("div", {
      className: addReactionClassName
    }, emojiPicker));
  }

}

reaction_list_defineProperty(reaction_list_ReactionList, "propTypes", {
  /**
   * The post to render reactions for
   */
  post: prop_types_default.a.object.isRequired,

  /*
   * The id of the team which belongs the post
   */
  teamId: prop_types_default.a.string,

  /**
   * The reactions to render
   */
  reactions: prop_types_default.a.object,

  /**
   * Whether to show the emoji picker.
   */
  enableEmojiPicker: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    /**
     * Function to add a reaction to the post
     */
    addReaction: prop_types_default.a.func.isRequired,

    /**
     * Function used for correcting scroll when component is updated with first reaction
     */
    scrollPostList: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/post_view/reaction_list/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









function reaction_list_makeMapStateToProps() {
  const getReactionsForPost = Object(entities_posts["makeGetReactionsForPost"])();
  return function mapStateToProps(state, ownProps) {
    const config = Object(general["getConfig"])(state);
    const enableEmojiPicker = config.EnableEmojiPicker === 'true' && !ownProps.isReadOnly;
    const channel = Object(entities_channels["getChannel"])(state, ownProps.post.channel_id) || {};
    const teamId = channel.team_id;
    return {
      teamId,
      reactions: getReactionsForPost(state, ownProps.post.id),
      enableEmojiPicker
    };
  };
}

function reaction_list_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      addReaction: post_actions["b" /* addReaction */],
      scrollPostList: views_channel["h" /* scrollPostList */]
    }, dispatch)
  };
}

/* harmony default export */ var reaction_list = (Object(es["connect"])(reaction_list_makeMapStateToProps, reaction_list_mapDispatchToProps)(reaction_list_ReactionList));
// EXTERNAL MODULE: ./components/post_view/post_body_additional_content/index.js + 15 modules
var post_body_additional_content = __webpack_require__(1960);

// EXTERNAL MODULE: ./components/post_view/post_message_view/index.js + 1 modules
var post_message_view = __webpack_require__(1759);

// CONCATENATED MODULE: ./components/message_with_additional_content.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function MessageWithAdditionalContent({
  post,
  previewCollapsed,
  previewEnabled,
  isEmbedVisible,
  pluginPostTypes
}) {
  const hasPlugin = post.type && pluginPostTypes.hasOwnProperty(post.type);
  let msg;
  const messageWrapper = react_default.a.createElement(post_message_view["a" /* default */], {
    post: post,
    isRHS: true,
    hasMention: true
  });

  if (post.state === mattermost_redux_constants["Posts"].POST_DELETED || hasPlugin) {
    msg = messageWrapper;
  } else {
    msg = react_default.a.createElement(post_body_additional_content["a" /* default */], {
      post: post,
      previewCollapsed: previewCollapsed,
      previewEnabled: previewEnabled,
      isEmbedVisible: isEmbedVisible
    }, messageWrapper);
  }

  return msg;
}
// EXTERNAL MODULE: ./components/widgets/badges/badge.jsx
var badges_badge = __webpack_require__(1765);

// EXTERNAL MODULE: ./components/svg/info_small_icon.jsx
var info_small_icon = __webpack_require__(1883);

// EXTERNAL MODULE: ./components/user_profile/index.js + 1 modules
var user_profile = __webpack_require__(1720);

// CONCATENATED MODULE: ./components/rhs_comment/rhs_comment.jsx
function rhs_comment_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





















class rhs_comment_RhsComment extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    rhs_comment_defineProperty(this, "removePost", () => {
      this.props.removePost(this.props.post);
    });

    rhs_comment_defineProperty(this, "createRemovePostButton", () => {
      return react_default.a.createElement("button", {
        className: "post__remove theme color--link style--none",
        type: "button",
        onClick: this.removePost
      }, '×');
    });

    rhs_comment_defineProperty(this, "renderPostTime", () => {
      const post = this.props.post;
      const isPermalink = !(mattermost_redux_constants["Posts"].POST_DELETED === post.state || Object(utils_post_utils["isPostPendingOrFailed"])(post));
      return react_default.a.createElement(post_time["a" /* default */], {
        isPermalink: isPermalink,
        eventTime: post.create_at,
        postId: post.id,
        location: constants["o" /* Locations */].RHS_COMMENT
      });
    });

    rhs_comment_defineProperty(this, "toggleEmojiPicker", () => {
      const showEmojiPicker = !this.state.showEmojiPicker;
      this.setState({
        showEmojiPicker
      });
    });

    rhs_comment_defineProperty(this, "getClassName", (post, isSystemMessage) => {
      let className = 'post post--thread same--root post--comment';

      if (this.props.currentUserId === post.user_id) {
        className += ' current--user';
      }

      if (isSystemMessage) {
        className += ' post--system';
      }

      if (this.props.compactDisplay) {
        className += ' post--compact';
      }

      if (post.is_pinned) {
        className += ' post--pinned';
      }

      if (this.state.dropdownOpened || this.state.showEmojiPicker) {
        className += ' post--hovered';
      }

      if (this.props.isConsecutivePost) {
        className += ' same--user';
      }

      return className;
    });

    rhs_comment_defineProperty(this, "handleDropdownOpened", isOpened => {
      this.setState({
        dropdownOpened: isOpened
      });
    });

    rhs_comment_defineProperty(this, "getDotMenuRef", () => {
      return this.refs.dotMenu;
    });

    rhs_comment_defineProperty(this, "setHover", () => {
      this.setState({
        hover: true
      });
    });

    rhs_comment_defineProperty(this, "unsetHover", () => {
      this.setState({
        hover: false
      });
    });

    this.state = {
      showEmojiPicker: false,
      dropdownOpened: false
    };
  }

  render() {
    const {
      post,
      isConsecutivePost,
      isReadOnly,
      channelIsArchived
    } = this.props;
    const isEphemeral = Object(utils_post_utils["isPostEphemeral"])(post);
    const isSystemMessage = post_utils["l" /* isSystemMessage */](post);
    const fromAutoResponder = post_utils["d" /* fromAutoResponder */](post);
    let botIndicator;
    let profilePicture;
    let visibleMessage;
    let userProfile = null;

    if (this.props.compactDisplay) {
      userProfile = react_default.a.createElement(user_profile["a" /* default */], {
        userId: post.user_id,
        isBusy: this.props.isBusy,
        isRHS: true,
        hasMention: true
      });
    }

    if (!isConsecutivePost) {
      userProfile = react_default.a.createElement(user_profile["a" /* default */], {
        userId: post.user_id,
        isBusy: this.props.isBusy,
        isRHS: true,
        hasMention: true
      });
      profilePicture = react_default.a.createElement(post_profile_picture["a" /* default */], {
        compactDisplay: this.props.compactDisplay,
        isBusy: this.props.isBusy,
        isRHS: true,
        post: post,
        userId: post.user_id
      });

      if (post.props && post.props.from_webhook) {
        if (post.props.override_username && this.props.enablePostUsernameOverride) {
          userProfile = react_default.a.createElement(user_profile["a" /* default */], {
            userId: post.user_id,
            hideStatus: true,
            overwriteName: post.props.override_username,
            disablePopover: true
          });
        } else {
          userProfile = react_default.a.createElement(user_profile["a" /* default */], {
            userId: post.user_id,
            hideStatus: true,
            disablePopover: true
          });
        }

        botIndicator = react_default.a.createElement(bot_badge["a" /* default */], {
          className: "col col__name"
        });
      } else if (fromAutoResponder) {
        userProfile = react_default.a.createElement("span", {
          className: "auto-responder"
        }, react_default.a.createElement(user_profile["a" /* default */], {
          userId: post.user_id,
          hideStatus: true,
          isBusy: this.props.isBusy,
          isRHS: true,
          hasMention: true
        }));
        botIndicator = react_default.a.createElement(badges_badge["a" /* default */], {
          className: "col col__name"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "post_info.auto_responder",
          defaultMessage: "AUTOMATIC REPLY"
        }));
      } else if (isSystemMessage) {
        userProfile = react_default.a.createElement(user_profile["a" /* default */], {
          overwriteName: react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "post_info.system",
            defaultMessage: "System"
          }),
          overwriteImage: constants["N" /* default */].SYSTEM_MESSAGE_PROFILE_IMAGE,
          disablePopover: true
        });
        visibleMessage = react_default.a.createElement("span", {
          className: "post__visibility"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "post_info.message.visible",
          defaultMessage: "(Only visible to you)"
        }));
      }
    }

    let failedPostOptions;
    let postClass = '';

    if (post.failed) {
      postClass += ' post-failed';
      failedPostOptions = react_default.a.createElement(failed_post_options, {
        post: this.props.post
      });
    }

    if (post_utils["i" /* isEdited */](this.props.post)) {
      postClass += ' post--edited';
    }

    let fileAttachment = null;

    if (post.file_ids && post.file_ids.length > 0) {
      fileAttachment = react_default.a.createElement(file_attachment_list["a" /* default */], {
        post: post,
        compactDisplay: this.props.compactDisplay
      });
    }

    let postReaction;

    if (!isReadOnly && !isEphemeral && !post.failed && !isSystemMessage && this.props.enableEmojiPicker && !channelIsArchived) {
      postReaction = react_default.a.createElement(post_reaction, {
        channelId: post.channel_id,
        postId: post.id,
        teamId: this.props.teamId,
        getDotMenuRef: this.getDotMenuRef,
        location: constants["o" /* Locations */].RHS_COMMENT,
        showEmojiPicker: this.state.showEmojiPicker,
        toggleEmojiPicker: this.toggleEmojiPicker
      });
    }

    let options;

    if (isEphemeral) {
      options = react_default.a.createElement("div", {
        className: "col col__remove"
      }, this.createRemovePostButton());
    } else if (!isSystemMessage && (this.state.hover || this.state.dropdownOpened || this.state.showEmojiPicker)) {
      const dotMenu = react_default.a.createElement(dot_menu["a" /* default */], {
        post: this.props.post,
        location: constants["o" /* Locations */].RHS_COMMENT,
        isFlagged: this.props.isFlagged,
        handleDropdownOpened: this.handleDropdownOpened,
        handleAddReactionClick: this.toggleEmojiPicker,
        isReadOnly: isReadOnly || channelIsArchived,
        enableEmojiPicker: this.props.enableEmojiPicker
      });
      options = react_default.a.createElement("div", {
        ref: "dotMenu",
        className: "col col__reply"
      }, dotMenu, postReaction);
    }

    let pinnedBadge;

    if (post.is_pinned) {
      pinnedBadge = react_default.a.createElement("span", {
        className: "post__pinned-badge"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "post_info.pinned",
        defaultMessage: "Pinned"
      }));
    }

    let flagIcon = null;

    if (this.state.hover || this.state.dropdownOpened || this.state.showEmojiPicker || this.props.isFlagged) {
      flagIcon = react_default.a.createElement(post_flag_icon["a" /* default */], {
        location: constants["o" /* Locations */].RHS_COMMENT,
        postId: post.id,
        isFlagged: this.props.isFlagged,
        isEphemeral: isEphemeral
      });
    }

    const postTime = this.renderPostTime();
    let postInfoIcon;

    if (post.props && post.props.card) {
      postInfoIcon = react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        placement: "top",
        overlay: react_default.a.createElement(Tooltip["a" /* default */], null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "post_info.info.view_additional_info",
          defaultMessage: "View additional info"
        }))
      }, react_default.a.createElement("button", {
        className: "card-icon__container icon--show style--none",
        onClick: e => {
          e.preventDefault();
          this.props.handleCardClick(this.props.post);
        }
      }, react_default.a.createElement(info_small_icon["a" /* default */], {
        className: "icon icon__info",
        "aria-hidden": "true"
      })));
    }

    return react_default.a.createElement("div", {
      role: "listitem",
      ref: 'post_body_' + post.id,
      id: 'rhsPost_' + post.id,
      tabIndex: "-1",
      className: this.getClassName(post, isSystemMessage),
      onMouseOver: this.setHover,
      onMouseLeave: this.unsetHover
    }, react_default.a.createElement("div", {
      className: "post__content"
    }, react_default.a.createElement("div", {
      className: "post__img"
    }, profilePicture), react_default.a.createElement("div", null, react_default.a.createElement("div", {
      className: "post__header"
    }, react_default.a.createElement("div", {
      className: "col col__name"
    }, userProfile, botIndicator), react_default.a.createElement("div", {
      className: "col"
    }, postTime, pinnedBadge, postInfoIcon, flagIcon, visibleMessage), options), react_default.a.createElement("div", {
      className: "post__body"
    }, react_default.a.createElement("div", {
      className: postClass
    }, failedPostOptions, react_default.a.createElement(MessageWithAdditionalContent, {
      post: post,
      previewCollapsed: this.props.previewCollapsed,
      previewEnabled: this.props.previewEnabled,
      isEmbedVisible: this.props.isEmbedVisible,
      pluginPostTypes: this.props.pluginPostTypes
    })), fileAttachment, react_default.a.createElement(reaction_list, {
      post: post,
      isReadOnly: isReadOnly || channelIsArchived
    })))));
  }

}

rhs_comment_defineProperty(rhs_comment_RhsComment, "propTypes", {
  post: prop_types_default.a.object,
  teamId: prop_types_default.a.string.isRequired,
  currentUserId: prop_types_default.a.string.isRequired,
  compactDisplay: prop_types_default.a.bool,
  isFlagged: prop_types_default.a.bool,
  isBusy: prop_types_default.a.bool,
  removePost: prop_types_default.a.func.isRequired,
  previewCollapsed: prop_types_default.a.string.isRequired,
  previewEnabled: prop_types_default.a.bool.isRequired,
  isEmbedVisible: prop_types_default.a.bool,
  enableEmojiPicker: prop_types_default.a.bool.isRequired,
  enablePostUsernameOverride: prop_types_default.a.bool.isRequired,
  isReadOnly: prop_types_default.a.bool.isRequired,
  pluginPostTypes: prop_types_default.a.object,
  channelIsArchived: prop_types_default.a.bool.isRequired,
  isConsecutivePost: prop_types_default.a.bool,
  handleCardClick: prop_types_default.a.func
});
// CONCATENATED MODULE: ./components/rhs_comment/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












function rhs_comment_isConsecutivePost(state, ownProps) {
  const post = ownProps.post;
  const previousPost = ownProps.previousPostId && Object(entities_posts["getPost"])(state, ownProps.previousPostId);
  let consecutivePost = false;

  if (previousPost) {
    const postFromWebhook = Boolean(post.props && post.props.from_webhook);
    const prevPostFromWebhook = Boolean(previousPost.props && previousPost.props.from_webhook);

    if (previousPost && previousPost.user_id === post.user_id && post.create_at - previousPost.create_at <= mattermost_redux_constants["Posts"].POST_COLLAPSE_TIMEOUT && !postFromWebhook && !prevPostFromWebhook && !Object(utils_post_utils["isSystemMessage"])(post) && !Object(utils_post_utils["isSystemMessage"])(previousPost) && (previousPost.root_id === post.root_id || previousPost.id === post.root_id)) {
      // The last post and this post were made by the same user within some time
      consecutivePost = true;
    }
  }

  return consecutivePost;
}

function rhs_comment_mapStateToProps(state, ownProps) {
  const config = Object(general["getConfig"])(state);
  const enableEmojiPicker = config.EnableEmojiPicker === 'true';
  const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
  const teamId = ownProps.teamId || Object(entities_teams["getCurrentTeamId"])(state);
  const channel = state.entities.channels.channels[ownProps.post.channel_id];
  return {
    enableEmojiPicker,
    enablePostUsernameOverride,
    isEmbedVisible: Object(selectors_posts["b" /* isEmbedVisible */])(state, ownProps.post.id),
    isReadOnly: Object(entities_channels["isChannelReadOnlyById"])(state, ownProps.post.channel_id),
    teamId,
    pluginPostTypes: state.plugins.postTypes,
    channelIsArchived: channel.delete_at !== 0,
    isConsecutivePost: rhs_comment_isConsecutivePost(state, ownProps),
    isFlagged: Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_FLAGGED_POST, ownProps.post.id, null) != null,
    compactDisplay: Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].MESSAGE_DISPLAY, constants["w" /* Preferences */].MESSAGE_DISPLAY_DEFAULT) === constants["w" /* Preferences */].MESSAGE_DISPLAY_COMPACT
  };
}

/* harmony default export */ var rhs_comment = (Object(es["connect"])(rhs_comment_mapStateToProps)(rhs_comment_RhsComment));
// EXTERNAL MODULE: ./node_modules/moment-timezone/index.js
var moment_timezone = __webpack_require__(260);
var moment_timezone_default = /*#__PURE__*/__webpack_require__.n(moment_timezone);

// EXTERNAL MODULE: ./node_modules/antd/es/message/index.js
var es_message = __webpack_require__(3478);

// EXTERNAL MODULE: ./node_modules/antd/es/menu/index.js + 7 modules
var es_menu = __webpack_require__(3485);

// EXTERNAL MODULE: ./node_modules/antd/es/tooltip/index.js + 1 modules
var es_tooltip = __webpack_require__(3456);

// EXTERNAL MODULE: ./node_modules/antd/es/dropdown/index.js + 2 modules
var dropdown = __webpack_require__(3490);

// CONCATENATED MODULE: ./components/icons/reply_icon.jsx
function reply_icon_extends() { reply_icon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return reply_icon_extends.apply(this, arguments); }

/* harmony default export */ var reply_icon = (({
  fill = "#909090",
  ...rest
}) => React.createElement("svg", reply_icon_extends({
  height: "16",
  viewBox: "0 0 16 16",
  width: "16",
  xmlns: "http://www.w3.org/2000/svg"
}, rest), React.createElement("g", {
  fill: "none",
  fillRule: "evenodd",
  stroke: fill,
  strokeWidth: "1.5"
}, React.createElement("path", {
  d: "m1.57299805 1.64016504v10.88937596h2.42480468v1.830294l3.58030677-1.830294h7.2614901v-10.88937596z"
}), React.createElement("g", {
  strokeLinecap: "square"
}, React.createElement("path", {
  d: "m5.52001953 5.5h5.20770267"
}), React.createElement("path", {
  d: "m5.52001953 8.5h2.60385132"
})))));
// CONCATENATED MODULE: ./components/icons/dot_icon.jsx
function dot_icon_extends() { dot_icon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return dot_icon_extends.apply(this, arguments); }

/* harmony default export */ var dot_icon = (({
  fill = '#909090',
  ...rest
}) => React.createElement("svg", dot_icon_extends({
  height: "2",
  viewBox: "0 0 10 2",
  width: "10",
  xmlns: "http://www.w3.org/2000/svg"
}, rest), React.createElement("g", {
  fill: fill,
  fillRule: "evenodd"
}, React.createElement("path", {
  d: "m0 0h2v2h-2z"
}), React.createElement("path", {
  d: "m4 0h2v2h-2z"
}), React.createElement("path", {
  d: "m8 0h2v2h-2z"
}))));
// EXTERNAL MODULE: ./components/icons/forward_icon.jsx
var forward_icon = __webpack_require__(2181);

// CONCATENATED MODULE: ./components/icons/recall_icon.jsx
function recall_icon_extends() { recall_icon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return recall_icon_extends.apply(this, arguments); }

/* harmony default export */ var recall_icon = (({
  fill = "#909090",
  ...rest
}) => React.createElement("svg", recall_icon_extends({
  height: "13",
  viewBox: "0 0 14 13",
  width: "14",
  xmlns: "http://www.w3.org/2000/svg"
}, rest), React.createElement("g", {
  fill: "none",
  fillRule: "evenodd",
  transform: "translate(-1 -1)"
}, React.createElement("path", {
  d: "m0 0h16v16h-16z",
  fillRule: "nonzero",
  opacity: "0"
}), React.createElement("g", {
  fill: fill
}, React.createElement("path", {
  d: "m3 12.5h7c1.9329966 0 3.5-1.5670034 3.5-3.5 0-1.93299662-1.5670034-3.5-3.5-3.5h-5v-1.5h5c2.7614237 0 5 2.23857625 5 5 0 2.7614237-2.2385763 5-5 5h-7z",
  fillRule: "nonzero"
}), React.createElement("path", {
  d: "m3 2.5 3.5 4h-7z",
  transform: "matrix(0 -1 1 0 -1.5 7.5)"
})))));
// CONCATENATED MODULE: ./components/icons/mulit_select_icon.jsx
function mulit_select_icon_extends() { mulit_select_icon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return mulit_select_icon_extends.apply(this, arguments); }

/* harmony default export */ var mulit_select_icon = (({
  fill = "#909090",
  ...rest
}) => React.createElement("svg", mulit_select_icon_extends({
  height: "13",
  viewBox: "0 0 13 13",
  width: "13",
  xmlns: "http://www.w3.org/2000/svg",
  fill: fill
}, rest), React.createElement("g", {
  fill: "none",
  fillRule: "evenodd",
  transform: "translate(-1 -3)"
}, React.createElement("path", {
  d: "m0 0h16v16h-16z",
  fillRule: "nonzero",
  opacity: "0"
}), React.createElement("g", {
  fill: fill
}, React.createElement("path", {
  d: "m1 3h12v1.5h-12z"
}), React.createElement("path", {
  d: "m1 8h12v1.5h-12z"
}), React.createElement("path", {
  d: "m1 13h5v1.5h-5z"
})), React.createElement("path", {
  d: "m8.74264069 9.03553391h3.00000001v4.99999999",
  stroke: fill,
  strokeWidth: "1.5",
  transform: "matrix(.70710678 .70710678 .70710678 -.70710678 -5.156854 12.449747)"
}))));
// CONCATENATED MODULE: ./components/dot_new_menu/flag_btn/flag_btn.jsx
function flag_btn_extends() { flag_btn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return flag_btn_extends.apply(this, arguments); }




/* harmony default export */ var flag_btn = (props => {
  const {
    post,
    ...rest
  } = props;
  const isEphemeral = utils["Z" /* isPostEphemeral */](post);
  return react_default.a.createElement(post_flag_icon["a" /* default */], flag_btn_extends({
    postId: post.id,
    isFlagged: props.isFlagged,
    isEphemeral: false
  }, rest));
});
// CONCATENATED MODULE: ./components/dot_new_menu/flag_btn/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function flag_btn_mapStateToProps(state, ownProps) {
  return {
    isFlagged: Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_FLAGGED_POST, ownProps.post.id, null) != null
  };
}

/* harmony default export */ var dot_new_menu_flag_btn = (Object(es["connect"])(flag_btn_mapStateToProps)(flag_btn));
// EXTERNAL MODULE: ./components/dot_new_menu/index.scss
var dot_new_menu = __webpack_require__(2951);

// CONCATENATED MODULE: ./components/dot_new_menu/dot_new_menu.jsx









 // import * as Utils from 'utils/utils';
// import {get} from 'mattermost-redux/selectors/entities/preferences';
// isFlagged: get(state, Preferences.CATEGORY_FLAGGED_POST, ownProps.post.id, null) != null,
// Locations.RHS_ROOT ==> 回复：右侧根消息
// Locations.RHS_COMMENT ==> 回复：右侧消息体
// import {
//   Locations,
//   ModalIdentifiers,
//   UNSET_POST_EDIT_TIME_LIMIT
// } from 'utils/constants.jsx';


/* harmony default export */ var dot_new_menu_dot_new_menu = (props => {
  const {
    // onClick,
    className,
    text,
    channelId,
    rootId,
    post,
    commentCount,
    dispatch,
    channelMsgReply,
    hasFlag,
    hasForward,
    hasRecall,
    hasMulitSelect,
    actions,
    defaultBtn,
    isMe,
    hasMenu = true
  } = props;

  const handleDeleteMenuItemActivated = async e => {
    if (Date.now() - post.create_at < 120000) {
      await actions.deleteAndRemovePost(post);
      es_message["a" /* default */].success('撤回成功');
    } else {
      es_message["a" /* default */].warn('消息发送已超过2分钟，无法撤回');
    }
  };

  const handleClick = ({
    key
  }) => {
    switch (key) {
      case 'recall':
        if (isMe) {
          console.log('recall');
          handleDeleteMenuItemActivated();
        }

        break;

      case 'forward':
        console.log('forward');
        actions.setChannelPostSelect({
          type: constants["f" /* ChannelPostSelectType */].SINGLE,
          visibleSelectMember: true,
          postId: post.id
        });
        break;

      case 'mulitSelect':
        actions.setChannelPostSelect({
          type: constants["f" /* ChannelPostSelectType */].MERGE,
          visibleSelectMember: false,
          visibleCheckbox: true
        });
        break;
      // setChannelPostSelect
      // ActionTypes.CHANNEL_POST_SELECT

      default:
        break;
    }
  }; // 120000
  // TODO: no menu item


  const menu = hasMenu ? react_default.a.createElement(es_menu["a" /* default */], {
    onClick: handleClick
  }, hasFlag && react_default.a.createElement(es_menu["a" /* default */].Item, {
    key: "flag",
    className: "flag"
  }, react_default.a.createElement(dot_new_menu_flag_btn, {
    post: post,
    title: "\u6536\u85CF"
  })), hasForward && react_default.a.createElement(es_menu["a" /* default */].Item, {
    key: "forward",
    className: "forward"
  }, react_default.a.createElement(forward_icon["a" /* default */], null), " \u8F6C\u53D1"), hasRecall && isMe && react_default.a.createElement(es_menu["a" /* default */].Item, {
    key: "recall"
  }, react_default.a.createElement(recall_icon, null), " \u64A4\u56DE"), hasMulitSelect && react_default.a.createElement(es_menu["a" /* default */].Item, {
    key: "mulitSelect"
  }, react_default.a.createElement(mulit_select_icon, null), " \u591A\u9009")) : react_default.a.createElement("span", null);

  const handleBtnClick = () => {
    if (defaultBtn === 'flag') {
      // flag 收藏
      console.log('flag');
    } else {
      // reply 回复
      dispatch({
        type: constants["b" /* ActionTypes */].CHANNEL_MESSAGE_REPLY,
        data: {
          isReply: true,
          channelId,
          rootId,
          msg: text
        }
      });
    }
  };

  const prefixCls = `post_${post.id}`; // console.log('reply', channelMsgReply)

  return react_default.a.createElement("div", {
    className: classnames_default()('dot__new__menu', className)
  }, react_default.a.createElement("span", {
    onClick: handleBtnClick
  }, defaultBtn === 'flag' ? react_default.a.createElement(es_tooltip["a" /* default */], {
    title: "\u6536\u85CF"
  }, react_default.a.createElement(dot_new_menu_flag_btn, {
    post: post
  })) : react_default.a.createElement(es_tooltip["a" /* default */], {
    title: "\u56DE\u590D"
  }, react_default.a.createElement(reply_icon, {
    fill: "#616161",
    className: "reply"
  }))), react_default.a.createElement("span", null, react_default.a.createElement(dropdown["a" /* default */], {
    overlay: menu,
    overlayClassName: "dot__menu__dropdown" // onVisibleChange={handleDorpdown}

  }, react_default.a.createElement("i", null, react_default.a.createElement(dot_icon, {
    fill: "#616161"
  })))));
});
// CONCATENATED MODULE: ./components/dot_new_menu/index.js



 // import { dispatch } from 'stores/redux_store.jsx';



function dot_new_menu_mapStateToProps(state) {
  const channelMsgReply = state.views.channel.channelMsgReply;
  return {
    channelMsgReply // postEditTimeLimit: getConfig(state).PostEditTimeLimit,
    // isLicensed: getLicense(state).IsLicensed === 'true',
    // teamId: getCurrentTeamId(state),
    // pluginMenuItems: state.plugins.components.PostDropdownMenu,

  };
}

function dot_new_menu_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      // flagPost,
      // unflagPost,
      // setEditingPost,
      // pinPost,
      // unpinPost,
      deleteAndRemovePost: post_actions["d" /* deleteAndRemovePost */],
      setChannelPostSelect: views_posts["c" /* setChannelPostSelect */],
      setMessageMergeForward: views_posts["d" /* setMessageMergeForward */]
    }, dispatch),
    dispatch
  };
}

/* harmony default export */ var components_dot_new_menu = (Object(es["connect"])(dot_new_menu_mapStateToProps, dot_new_menu_mapDispatchToProps)(dot_new_menu_dot_new_menu));
// EXTERNAL MODULE: ./components/rhs_new_comment/index.scss
var rhs_new_comment = __webpack_require__(2952);

// CONCATENATED MODULE: ./components/rhs_new_comment/rhs_new_comment.jsx
















const formatDate = time => moment_timezone_default()(time).format('YYYY-MM-DD hh:mm');

/* harmony default export */ var rhs_new_comment_rhs_new_comment = (Object(react["forwardRef"])((props, ref) => {
  const {
    post,
    isConsecutivePost,
    isReadOnly,
    channelIsArchived,
    isRoot,
    commentCount
  } = props;
  const [isHover, setHover] = Object(react["useState"])(false);
  const isEphemeral = Object(utils_post_utils["isPostEphemeral"])(post);
  const isSystemMessage = post_utils["l" /* isSystemMessage */](post);
  const fromAutoResponder = post_utils["d" /* fromAutoResponder */](post);
  let userProfile = null;
  let profilePicture;
  let botIndicator;

  if (props.compactDisplay) {
    userProfile = react_default.a.createElement(user_profile["a" /* default */], {
      userId: post.user_id,
      isBusy: props.isBusy,
      isRHS: true,
      hasMention: true
    });
  }

  if (!isConsecutivePost || true) {
    userProfile = react_default.a.createElement(user_profile["a" /* default */], {
      userId: post.user_id,
      isBusy: props.isBusy,
      isRHS: true,
      hasMention: true
    });
    profilePicture = react_default.a.createElement(post_profile_picture["a" /* default */], {
      compactDisplay: props.compactDisplay,
      isBusy: props.isBusy,
      isRHS: true,
      post: post,
      userId: post.user_id
    });

    if (post.props && post.props.from_webhook) {
      if (post.props.override_username && props.enablePostUsernameOverride) {
        userProfile = react_default.a.createElement(user_profile["a" /* default */], {
          userId: post.user_id,
          hideStatus: true,
          overwriteName: post.props.override_username,
          disablePopover: true
        });
      } else {
        userProfile = react_default.a.createElement(user_profile["a" /* default */], {
          userId: post.user_id,
          hideStatus: true,
          disablePopover: true
        });
      }

      botIndicator = react_default.a.createElement(bot_badge["a" /* default */], {
        className: "col col__name"
      });
    } else if (fromAutoResponder) {
      userProfile = react_default.a.createElement("span", {
        className: "auto-responder"
      }, react_default.a.createElement(user_profile["a" /* default */], {
        userId: post.user_id,
        hideStatus: true,
        isBusy: props.isBusy,
        isRHS: true,
        hasMention: true
      }));
      botIndicator = react_default.a.createElement(badges_badge["a" /* default */], {
        className: "col col__name"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "post_info.auto_responder",
        defaultMessage: "AUTOMATIC REPLY"
      }));
    } else if (isSystemMessage) {
      userProfile = react_default.a.createElement(user_profile["a" /* default */], {
        overwriteName: react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "post_info.system",
          defaultMessage: "System"
        }),
        overwriteImage: constants["N" /* default */].SYSTEM_MESSAGE_PROFILE_IMAGE,
        disablePopover: true
      });
      visibleMessage = react_default.a.createElement("span", {
        className: "post__visibility"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "post_info.message.visible",
        defaultMessage: "(Only visible to you)"
      }));
    }
  }

  const getClassName = () => {
    let className = 'post'; // 自己的消息显示在右侧
    // if (props.currentUserId === post.user_id) {
    //     className += ' current__user';
    // }

    if (isSystemMessage) {
      className += ' post__system';
    }

    if (props.compactDisplay) {
      className += ' post__compact';
    }

    if (post.is_pinned) {
      className += ' post__pinned';
    }

    if (props.isConsecutivePost) {
      className += ' same__user';
    }

    return className;
  };

  let fileAttachment = null;

  if (post.file_ids && post.file_ids.length > 0) {
    fileAttachment = react_default.a.createElement(file_attachment_list["a" /* default */], {
      post: post,
      compactDisplay: props.compactDisplay
    });
  }

  const isMe = props.currentUserId === post.user_id;
  return post.state !== 'DELETED' ? react_default.a.createElement("div", {
    className: `right__sidebar__comment-item ${getClassName()}${isRoot ? ' root__post' : ''}`,
    onMouseOver: () => setHover(true),
    onMouseLeave: () => setHover(false)
  }, react_default.a.createElement("div", null, react_default.a.createElement("div", {
    className: "post-img"
  }, profilePicture), react_default.a.createElement("div", {
    className: "post-content post__body"
  }, react_default.a.createElement("div", {
    className: "post__info"
  }, userProfile, react_default.a.createElement("time", null, formatDate(post.create_at))), react_default.a.createElement("div", {
    className: "post__msg"
  }, react_default.a.createElement("span", null, react_default.a.createElement(post_message_view["a" /* default */], {
    post: props.post,
    compactDisplay: true,
    hasMention: true
  }), post.card_type ? '' : fileAttachment)), isHover && react_default.a.createElement(components_dot_new_menu, {
    defaultBtn: "flag",
    post: post,
    hasRecall: true,
    hasForward: true,
    isMe: isMe // hasMenu={isMe}
    // hasFlag
    // className={cls}
    // {...dotMenuProps}
    // hasMulitSelect

  })))) : null;
}));
// CONCATENATED MODULE: ./components/rhs_new_comment/index.js













function rhs_new_comment_isConsecutivePost(state, ownProps) {
  const post = ownProps.post;
  const previousPost = ownProps.previousPostId && Object(entities_posts["getPost"])(state, ownProps.previousPostId);
  let consecutivePost = false;

  if (previousPost) {
    const postFromWebhook = Boolean(post.props && post.props.from_webhook);
    const prevPostFromWebhook = Boolean(previousPost.props && previousPost.props.from_webhook);

    if (previousPost && previousPost.user_id === post.user_id && post.create_at - previousPost.create_at <= mattermost_redux_constants["Posts"].POST_COLLAPSE_TIMEOUT && !postFromWebhook && !prevPostFromWebhook && !Object(utils_post_utils["isSystemMessage"])(post) && !Object(utils_post_utils["isSystemMessage"])(previousPost) && (previousPost.root_id === post.root_id || previousPost.id === post.root_id)) {
      // The last post and this post were made by the same user within some time
      consecutivePost = true;
    }
  }

  return consecutivePost;
}

function rhs_new_comment_mapStateToProps(state, ownProps) {
  const config = Object(general["getConfig"])(state);
  const enableEmojiPicker = config.EnableEmojiPicker === 'true';
  const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
  const teamId = ownProps.teamId || Object(entities_teams["getCurrentTeamId"])(state);
  const channel = state.entities.channels.channels[ownProps.post.channel_id];
  const emojiMap = Object(selectors_emojis["a" /* getEmojiMap */])(state);
  return {
    emojiMap,
    enableEmojiPicker,
    enablePostUsernameOverride,
    isEmbedVisible: Object(selectors_posts["b" /* isEmbedVisible */])(state, ownProps.post.id),
    isReadOnly: Object(entities_channels["isChannelReadOnlyById"])(state, ownProps.post.channel_id),
    teamId,
    pluginPostTypes: state.plugins.postTypes,
    channelIsArchived: channel.delete_at !== 0,
    isConsecutivePost: rhs_new_comment_isConsecutivePost(state, ownProps),
    isFlagged: Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_FLAGGED_POST, ownProps.post.id, null) != null,
    compactDisplay: Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].MESSAGE_DISPLAY, constants["w" /* Preferences */].MESSAGE_DISPLAY_DEFAULT) === constants["w" /* Preferences */].MESSAGE_DISPLAY_COMPACT
  };
}

/* harmony default export */ var components_rhs_new_comment = (Object(es["connect"])(rhs_new_comment_mapStateToProps)(rhs_new_comment_rhs_new_comment));
// CONCATENATED MODULE: ./components/rhs_header_post/rhs_header_post.jsx
function rhs_header_post_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class rhs_header_post_RhsHeaderPost extends react_default.a.Component {
  constructor(...args) {
    super(...args);

    rhs_header_post_defineProperty(this, "handleBack", e => {
      e.preventDefault();

      switch (this.props.previousRhsState) {
        case constants["x" /* RHSStates */].SEARCH:
          this.props.actions.showSearchResults();
          break;

        case constants["x" /* RHSStates */].MENTION:
          this.props.actions.showMentions();
          break;

        case constants["x" /* RHSStates */].FLAG:
          this.props.actions.showFlaggedPosts();
          break;

        case constants["x" /* RHSStates */].PIN:
          this.props.actions.showPinnedPosts();
          break;

        case constants["x" /* RHSStates */].CLOUD:
          this.props.actions.showCloud();
          break;

        default:
          break;
      }
    });
  }

  render() {
    let back;
    const closeSidebarTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "closeSidebarTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.closeSidebarTooltip",
      defaultMessage: "Close Sidebar"
    }));
    let backToResultsTooltip;

    switch (this.props.previousRhsState) {
      case constants["x" /* RHSStates */].SEARCH:
      case constants["x" /* RHSStates */].MENTION:
        backToResultsTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
          id: "backToResultsTooltip"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "rhs_header.backToResultsTooltip",
          defaultMessage: "Back to Search Results"
        }));
        break;

      case constants["x" /* RHSStates */].FLAG:
        backToResultsTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
          id: "backToResultsTooltip"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "rhs_header.backToFlaggedTooltip",
          defaultMessage: "Back to Flagged Posts"
        }));
        break;

      case constants["x" /* RHSStates */].PIN:
        backToResultsTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
          id: "backToResultsTooltip"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "rhs_header.backToPinnedTooltip",
          defaultMessage: "Back to Pinned Posts"
        }));
        break;
    }

    const expandSidebarTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "expandSidebarTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.expandSidebarTooltip",
      defaultMessage: "Expand Sidebar"
    }));
    const shrinkSidebarTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "shrinkSidebarTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.shrinkSidebarTooltip",
      defaultMessage: "Shrink Sidebar"
    }));

    if (backToResultsTooltip) {
      back = react_default.a.createElement("a", {
        href: "#",
        onClick: this.handleBack,
        className: "sidebar--right__back"
      }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        placement: "top",
        overlay: backToResultsTooltip
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "generic_icons.back",
        defaultMessage: "Back Icon"
      }, ariaLabel => react_default.a.createElement("i", {
        className: "fa fa-angle-left",
        "aria-label": ariaLabel
      }))));
    }

    return react_default.a.createElement("div", {
      className: "sidebar--right__header"
    }, react_default.a.createElement("span", {
      className: "sidebar--right__title"
    }, back, "\u56DE\u590D\u8BE6\u60C5 (", this.props.commentCount || 0, "\u6761)"), react_default.a.createElement("div", {
      className: "pull-right"
    }, react_default.a.createElement("button", {
      type: "button",
      className: "sidebar--right__expand",
      "aria-label": "Expand",
      onClick: this.props.actions.toggleRhsExpanded
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: expandSidebarTooltip
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.expandSidebarTooltip.icon",
      defaultMessage: "Expand Sidebar Icon"
    }, ariaLabel => react_default.a.createElement("i", {
      className: "expand-sidebar",
      "aria-label": ariaLabel
    }))), react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: shrinkSidebarTooltip
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.expandTooltip.icon",
      defaultMessage: "Shrink Sidebar Icon"
    }, ariaLabel => react_default.a.createElement("i", {
      className: "compress-sidebar",
      "aria-label": ariaLabel
    })))), react_default.a.createElement("button", {
      id: "rhsCloseButton",
      type: "button",
      className: "sidebar--right__close",
      "aria-label": "Close",
      onClick: this.props.actions.closeRightHandSide
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: closeSidebarTooltip
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.closeTooltip.icon",
      defaultMessage: "Close Sidebar Icon"
    }, ariaLabel => react_default.a.createElement("i", {
      className: "close-sidebar",
      "aria-label": ariaLabel
    }))))));
  }

}

rhs_header_post_defineProperty(rhs_header_post_RhsHeaderPost, "propTypes", {
  previousRhsState: prop_types_default.a.oneOf(Object.values(constants["x" /* RHSStates */])),
  actions: prop_types_default.a.shape({
    showMentions: prop_types_default.a.func,
    showSearchResults: prop_types_default.a.func,
    showFlaggedPosts: prop_types_default.a.func,
    showPinnedPosts: prop_types_default.a.func,
    showCloud: prop_types_default.a.func,
    closeRightHandSide: prop_types_default.a.func,
    toggleRhsExpanded: prop_types_default.a.func
  })
});
// CONCATENATED MODULE: ./components/rhs_header_post/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function rhs_header_post_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      showSearchResults: rhs["s" /* showSearchResults */],
      showMentions: rhs["p" /* showMentions */],
      showFlaggedPosts: rhs["n" /* showFlaggedPosts */],
      showPinnedPosts: rhs["q" /* showPinnedPosts */],
      showCloud: rhs["m" /* showCloud */],
      closeRightHandSide: rhs["b" /* closeRightHandSide */],
      toggleRhsExpanded: rhs["u" /* toggleRhsExpanded */]
    }, dispatch)
  };
}

/* harmony default export */ var rhs_header_post = (Object(es["connect"])(null, rhs_header_post_mapDispatchToProps)(rhs_header_post_RhsHeaderPost));
// EXTERNAL MODULE: ./components/formatted_markdown_message.jsx
var formatted_markdown_message = __webpack_require__(1564);

// CONCATENATED MODULE: ./components/rhs_thread/rhs_thread.jsx
function rhs_thread_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function rhs_thread_extends() { rhs_thread_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return rhs_thread_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









 // import CreateComment from 'components/create_comment';

 // import FloatingTimestamp from 'components/post_view/floating_timestamp';



 // import RhsRootPost from 'components/rhs_root_post';
// import RhsNewRootPost from 'components/rhs_new_root_post';


function renderView(props) {
  return react_default.a.createElement("div", rhs_thread_extends({}, props, {
    className: "scrollbar--view"
  }));
}
function renderThumbHorizontal(props) {
  return react_default.a.createElement("div", rhs_thread_extends({}, props, {
    className: "scrollbar--horizontal"
  }));
}
function renderThumbVertical(props) {
  return react_default.a.createElement("div", rhs_thread_extends({}, props, {
    className: "scrollbar--vertical"
  }));
}
class rhs_thread_RhsThread extends react_default.a.Component {
  constructor(props) {
    super(props);

    rhs_thread_defineProperty(this, "handleResize", () => {
      this.setState({
        windowWidth: utils["sb" /* windowWidth */](),
        windowHeight: utils["rb" /* windowHeight */]()
      });

      if (user_agent["m" /* isMobile */]() && document.activeElement.id === 'reply_textbox') {
        this.scrollToBottom();
      }
    });

    rhs_thread_defineProperty(this, "handleCardClick", post => {
      if (!post) {
        return;
      }

      this.props.actions.selectPostCard(post);
    });

    rhs_thread_defineProperty(this, "handleCardClickPost", post => {
      if (!post) {
        return;
      }

      this.props.actions.selectPostCard(post);
    });

    rhs_thread_defineProperty(this, "onBusy", isBusy => {
      this.setState({
        isBusy
      });
    });

    rhs_thread_defineProperty(this, "filterPosts", (posts, selected, openTime) => {
      const postsArray = [];
      posts.forEach(cpost => {
        // Do not show empherals created before sidebar has been opened
        if (cpost.type === 'system_ephemeral' && cpost.create_at < openTime) {
          return;
        }

        if (cpost.root_id === selected.id) {
          postsArray.unshift(cpost);
        }
      });
      return postsArray;
    });

    rhs_thread_defineProperty(this, "scrollToBottom", () => {
      if (jquery_default()('.post-right__scroll')[0]) {
        jquery_default()('.post-right__scroll').parent().scrollTop(jquery_default()('.post-right__scroll')[0].scrollHeight);
      }
    });

    rhs_thread_defineProperty(this, "updateFloatingTimestamp", () => {
      // skip this in non-mobile view since that's when the timestamp is visible
      if (!utils["Y" /* isMobile */]()) {
        return;
      }

      if (this.props.posts) {
        const childNodes = this.refs.rhspostlist.childNodes;
        const viewPort = this.refs.rhspostlist.getBoundingClientRect();
        let topRhsPostId = '';
        const offset = 100; // determine the top rhs comment assuming that childNodes and postsArray are of same length

        for (let i = 0; i < childNodes.length; i++) {
          if (childNodes[i].offsetTop + viewPort.top - offset > 0) {
            topRhsPostId = this.props.posts[i].id;
            break;
          }
        }

        if (topRhsPostId !== this.state.topRhsPostId) {
          this.setState({
            topRhsPostId
          });
        }
      }
    });

    rhs_thread_defineProperty(this, "handleScroll", () => {
      this.updateFloatingTimestamp();

      if (!this.state.isScrolling) {
        this.setState({
          isScrolling: true
        });
      }

      this.scrollStopAction.fireAfter(constants["N" /* default */].SCROLL_DELAY);
    });

    rhs_thread_defineProperty(this, "handleScrollStop", () => {
      this.setState({
        isScrolling: false
      });
    });

    rhs_thread_defineProperty(this, "getSidebarBody", () => {
      return this.refs.sidebarbody;
    });

    this.scrollStopAction = new delayed_action["a" /* default */](this.handleScrollStop);

    const _openTime = new Date().getTime();

    this.state = {
      windowWidth: utils["sb" /* windowWidth */](),
      windowHeight: utils["rb" /* windowHeight */](),
      isScrolling: false,
      topRhsPostId: 0,
      openTime: _openTime
    };
  }

  componentDidMount() {
    this.scrollToBottom();
    window.addEventListener('resize', this.handleResize);
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (!this.props.selected || !nextProps.selected) {
      return;
    }

    if (this.props.selected.id !== nextProps.selected.id) {
      this.setState({
        openTime: new Date().getTime()
      });
    }
  }

  componentDidUpdate(prevProps) {
    const prevPostsArray = prevProps.posts || [];
    const curPostsArray = this.props.posts || [];

    if (prevPostsArray.length >= curPostsArray.length) {
      return;
    }

    const curLastPost = curPostsArray[curPostsArray.length - 1];

    if (curLastPost.user_id === this.props.currentUserId) {
      this.scrollToBottom();
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    if (!utils["c" /* areObjectsEqual */](nextState.postsArray, this.props.posts)) {
      return true;
    }

    if (!utils["c" /* areObjectsEqual */](nextState.selected, this.props.selected)) {
      return true;
    }

    if (nextProps.previewEnabled !== this.props.previewEnabled) {
      return true;
    }

    if (nextState.isBusy !== this.state.isBusy) {
      return true;
    }

    if (nextState.isScrolling !== this.state.isScrolling) {
      return true;
    }

    if (nextState.topRhsPostId !== this.state.topRhsPostId) {
      return true;
    }

    return false;
  }

  render() {
    if (this.props.posts == null || this.props.selected == null) {
      return react_default.a.createElement("div", null);
    }

    const postsArray = this.filterPosts(this.props.posts, this.props.selected, this.state.openTime);
    const {
      selected,
      currentUserId
    } = this.props;
    let createAt = selected.create_at;

    if (!createAt && this.props.posts.length > 0) {
      createAt = this.props.posts[this.props.posts.length - 1].create_at;
    }

    const rootPostDay = utils["t" /* getDateForUnixTicks */](createAt);
    let previousPostDay = rootPostDay;
    const commentsLists = [];
    const postsLength = postsArray.length;

    for (let i = 0; i < postsLength; i++) {
      const comPost = postsArray[i];
      const previousPostId = i > 0 ? postsArray[i - 1].id : ''; // const currentPostDay = Utils.getDateForUnixTicks(comPost.create_at);
      // if (currentPostDay.toDateString() !== previousPostDay.toDateString()) {
      //     previousPostDay = currentPostDay;
      //     commentsLists.push(
      //         <DateSeparator
      //             key={currentPostDay}
      //             date={currentPostDay}
      //         />);
      // }

      const keyPrefix = comPost.id ? comPost.id : comPost.pending_post_id;
      commentsLists.push( // <RhsComment
      //     key={keyPrefix + 'commentKey'}
      //     ref={comPost.id}
      //     post={comPost}
      //     previousPostId={previousPostId}
      //     teamId={this.props.channel.team_id}
      //     currentUserId={currentUserId}
      //     isBusy={this.state.isBusy}
      //     removePost={this.props.actions.removePost}
      //     previewCollapsed={this.props.previewCollapsed}
      //     previewEnabled={this.props.previewEnabled}
      //     handleCardClick={this.handleCardClickPost}
      // />
      react_default.a.createElement(components_rhs_new_comment, {
        key: keyPrefix + 'commentKey',
        ref: comPost.id,
        post: comPost,
        previousPostId: previousPostId,
        teamId: this.props.channel.team_id,
        currentUserId: currentUserId,
        isBusy: this.state.isBusy,
        removePost: this.props.actions.removePost,
        previewCollapsed: this.props.previewCollapsed,
        previewEnabled: this.props.previewEnabled,
        handleCardClick: this.handleCardClickPost
      }));
    } // let createComment;


    const isFakeDeletedPost = selected.type === constants["N" /* default */].PostTypes.FAKE_PARENT_DELETED; // const channelIsArchived = this.props.channel.delete_at !== 0;
    // if (!isFakeDeletedPost) {
    //     if (channelIsArchived) {
    //         createComment = (
    //             <div className='channel-archived-warning'>
    //                 <FormattedMarkdownMessage
    //                     id='archivedChannelMessage'
    //                     defaultMessage='You are viewing an **archived channel**. New messages cannot be posted.'
    //                 />
    //             </div>
    //         );
    //     } else {
    //         createComment = (
    //             <div className='post-create__container'>
    //                 <CreateComment
    //                     channelId={selected.channel_id}
    //                     rootId={selected.id}
    //                     rootDeleted={selected.state === Posts.POST_DELETED}
    //                     latestPostId={postsLength > 0 ? postsArray[postsLength - 1].id : selected.id}
    //                     getSidebarBody={this.getSidebarBody}
    //                 />
    //             </div>
    //         );
    //     }
    // }
    // if (this.props.channel.type === Constants.DM_CHANNEL) {
    //     const teammate = Utils.getDirectTeammate(this.props.channel.id);
    //     if (teammate && teammate.delete_at) {
    //         createComment = (
    //             <div
    //                 className='post-create-message'
    //             >
    //                 <FormattedMessage
    //                     id='create_post.deactivated'
    //                     defaultMessage='You are viewing an archived channel with a deactivated user.'
    //                 />
    //             </div>
    //         );
    //     }
    // }

    const delLen = postsArray.filter(item => item.state === 'DELETED').length; // console.log(commentsLists, postsArray, delLen, '----post')

    return react_default.a.createElement("div", {
      id: "rhsContainer",
      className: "sidebar-right__body",
      ref: "sidebarbody"
    }, react_default.a.createElement(rhs_header_post, {
      previousRhsState: this.props.previousRhsState,
      commentCount: postsLength - delLen
    }), react_default.a.createElement(react_custom_scrollbars_lib_default.a, {
      className: "post__right__scrollbars",
      autoHide: true,
      autoHideTimeout: 500,
      autoHideDuration: 500,
      renderThumbHorizontal: renderThumbHorizontal,
      renderThumbVertical: renderThumbVertical,
      renderView: renderView,
      onScroll: this.handleScroll
    }, react_default.a.createElement("div", {
      className: "post-right__scroll"
    }, react_default.a.createElement("div", {
      id: "rhsContent",
      "aria-label": utils["gb" /* localizeMessage */]('accessibility.sections.rhsContent', 'message details complimentary region'),
      className: "post-right__content"
    }, react_default.a.createElement(components_rhs_new_comment, {
      isRoot: true,
      ref: selected.id,
      post: selected,
      commentCount: postsLength - delLen,
      teamId: this.props.channel.team_id,
      currentUserId: this.props.currentUserId,
      previewCollapsed: this.props.previewCollapsed,
      previewEnabled: this.props.previewEnabled,
      isBusy: this.state.isBusy,
      handleCardClick: this.handleCardClick
    }), react_default.a.createElement("div", {
      ref: "rhspostlist",
      className: "post-right-comments-container"
    }, commentsLists)))));
  }

}

rhs_thread_defineProperty(rhs_thread_RhsThread, "propTypes", {
  posts: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,
  channel: prop_types_default.a.object.isRequired,
  selected: prop_types_default.a.object.isRequired,
  previousRhsState: prop_types_default.a.string,
  currentUserId: prop_types_default.a.string.isRequired,
  previewCollapsed: prop_types_default.a.string.isRequired,
  previewEnabled: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    removePost: prop_types_default.a.func.isRequired,
    selectPostCard: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/rhs_thread/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











function rhs_thread_makeMapStateToProps() {
  const getPostsForThread = Object(entities_posts["makeGetPostsForThread"])();
  return function mapStateToProps(state) {
    const selected = Object(selectors_rhs["q" /* getSelectedPost */])(state);
    let channel = null;
    let posts = [];

    if (selected) {
      posts = getPostsForThread(state, {
        rootId: selected.id
      });
      channel = Object(entities_channels["getChannel"])(state, selected.channel_id);
    }

    const previewCollapsed = Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].COLLAPSE_DISPLAY, constants["w" /* Preferences */].COLLAPSE_DISPLAY_DEFAULT);
    return {
      selected,
      channel,
      posts,
      previewCollapsed,
      previewEnabled: Object(entities_preferences["getBool"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].LINK_PREVIEW_DISPLAY, constants["w" /* Preferences */].LINK_PREVIEW_DISPLAY_DEFAULT)
    };
  };
}

function rhs_thread_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      removePost: actions_posts["removePost"],
      selectPostCard: rhs["h" /* selectPostCard */]
    }, dispatch)
  };
}

/* harmony default export */ var rhs_thread = (Object(es["connect"])(rhs_thread_makeMapStateToProps, rhs_thread_mapDispatchToProps)(rhs_thread_RhsThread));
// EXTERNAL MODULE: ./node_modules/react-router-dom/esm/react-router-dom.js + 1 modules
var react_router_dom = __webpack_require__(1553);

// CONCATENATED MODULE: ./components/rhs_card_header/rhs_card_header.jsx
function rhs_card_header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class rhs_card_header_RhsCardHeader extends react_default.a.Component {
  constructor(...args) {
    super(...args);

    rhs_card_header_defineProperty(this, "handleBack", e => {
      e.preventDefault();

      switch (this.props.previousRhsState) {
        case constants["x" /* RHSStates */].SEARCH:
          this.props.actions.showSearchResults();
          break;

        case constants["x" /* RHSStates */].MENTION:
          this.props.actions.showMentions();
          break;

        case constants["x" /* RHSStates */].FLAG:
          this.props.actions.showFlaggedPosts();
          break;

        case constants["x" /* RHSStates */].PIN:
          this.props.actions.showPinnedPosts();
          break;

        default:
          break;
      }
    });
  }

  render() {
    let back;
    let backToResultsTooltip;

    switch (this.props.previousRhsState) {
      case constants["x" /* RHSStates */].SEARCH:
      case constants["x" /* RHSStates */].MENTION:
        backToResultsTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
          id: "backToResultsTooltip"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "rhs_header.backToResultsTooltip",
          defaultMessage: "Back to Search Results"
        }));
        break;

      case constants["x" /* RHSStates */].FLAG:
        backToResultsTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
          id: "backToResultsTooltip"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "rhs_header.backToFlaggedTooltip",
          defaultMessage: "Back to Flagged Posts"
        }));
        break;

      case constants["x" /* RHSStates */].PIN:
        backToResultsTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
          id: "backToResultsTooltip"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "rhs_header.backToPinnedTooltip",
          defaultMessage: "Back to Pinned Posts"
        }));
        break;
    }

    const closeSidebarTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "closeSidebarTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.closeSidebarTooltip",
      defaultMessage: "Close Sidebar"
    }));
    const expandSidebarTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "expandSidebarTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.expandSidebarTooltip",
      defaultMessage: "Expand Sidebar"
    }));
    const shrinkSidebarTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "shrinkSidebarTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.shrinkSidebarTooltip",
      defaultMessage: "Shrink Sidebar"
    }));

    if (backToResultsTooltip) {
      back = react_default.a.createElement("a", {
        href: "#",
        onClick: this.handleBack,
        className: "sidebar--right__back"
      }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        placement: "top",
        overlay: backToResultsTooltip
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "generic_icons.back",
        defaultMessage: "Back Icon"
      }, ariaLabel => react_default.a.createElement("i", {
        className: "fa fa-angle-left",
        "aria-label": ariaLabel
      }))));
    }

    return react_default.a.createElement("div", {
      className: "sidebar--right__header"
    }, react_default.a.createElement("span", {
      className: "sidebar--right__title"
    }, back, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_header.title5",
      defaultMessage: "Extra information"
    })), react_default.a.createElement("div", {
      className: "pull-right"
    }, react_default.a.createElement("button", {
      type: "button",
      className: "sidebar--right__expand",
      "aria-label": "Expand",
      onClick: this.props.actions.toggleRhsExpanded
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: expandSidebarTooltip
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.expandSidebarTooltip.icon",
      defaultMessage: "Expand Sidebar Icon"
    }, ariaLabel => react_default.a.createElement("i", {
      className: "expand-sidebar",
      "aria-label": ariaLabel
    }))), react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: shrinkSidebarTooltip
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.expandTooltip.icon",
      defaultMessage: "Shrink Sidebar Icon"
    }, ariaLabel => react_default.a.createElement("i", {
      className: "compress-sidebar",
      "aria-label": ariaLabel
    })))), react_default.a.createElement("button", {
      type: "button",
      className: "sidebar--right__close",
      "aria-label": "Close",
      onClick: this.props.actions.closeRightHandSide
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: closeSidebarTooltip
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_header.closeTooltip.icon",
      defaultMessage: "Close Sidebar Icon"
    }, ariaLabel => react_default.a.createElement("i", {
      className: "close-sidebar",
      "aria-label": ariaLabel
    }))))));
  }

}

rhs_card_header_defineProperty(rhs_card_header_RhsCardHeader, "propTypes", {
  previousRhsState: prop_types_default.a.oneOf(Object.values(constants["x" /* RHSStates */])),
  actions: prop_types_default.a.shape({
    showMentions: prop_types_default.a.func,
    showSearchResults: prop_types_default.a.func,
    showFlaggedPosts: prop_types_default.a.func,
    showPinnedPosts: prop_types_default.a.func,
    closeRightHandSide: prop_types_default.a.func,
    toggleRhsExpanded: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/rhs_card_header/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function rhs_card_header_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      showMentions: rhs["p" /* showMentions */],
      showSearchResults: rhs["s" /* showSearchResults */],
      showFlaggedPosts: rhs["n" /* showFlaggedPosts */],
      showPinnedPosts: rhs["q" /* showPinnedPosts */],
      closeRightHandSide: rhs["b" /* closeRightHandSide */],
      toggleRhsExpanded: rhs["u" /* toggleRhsExpanded */]
    }, dispatch)
  };
}

/* harmony default export */ var rhs_card_header = (Object(es["connect"])(null, rhs_card_header_mapDispatchToProps)(rhs_card_header_RhsCardHeader));
// EXTERNAL MODULE: ./components/markdown/index.js + 1 modules
var markdown = __webpack_require__(1624);

// CONCATENATED MODULE: ./components/rhs_card/rhs_card.jsx
function rhs_card_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function rhs_card_extends() { rhs_card_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return rhs_card_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













function rhs_card_renderView(props) {
  return react_default.a.createElement("div", rhs_card_extends({}, props, {
    className: "scrollbar--view"
  }));
}
function rhs_card_renderThumbHorizontal(props) {
  return react_default.a.createElement("div", rhs_card_extends({}, props, {
    className: "scrollbar--horizontal"
  }));
}
function rhs_card_renderThumbVertical(props) {
  return react_default.a.createElement("div", rhs_card_extends({}, props, {
    className: "scrollbar--vertical"
  }));
}
class rhs_card_RhsCard extends react_default.a.Component {
  constructor(props) {
    super(props);

    rhs_card_defineProperty(this, "handleScroll", () => {
      if (!this.state.isScrolling) {
        this.setState({
          isScrolling: true
        });
      }

      this.scrollStopAction.fireAfter(constants["N" /* default */].SCROLL_DELAY);
    });

    rhs_card_defineProperty(this, "handleScrollStop", () => {
      this.setState({
        isScrolling: false
      });
    });

    rhs_card_defineProperty(this, "getSidebarBody", () => {
      return this.refs.sidebarbody;
    });

    rhs_card_defineProperty(this, "handleClick", () => {
      if (utils["Y" /* isMobile */]()) {
        global_actions["c" /* emitCloseRightHandSide */]();
      }
    });

    this.scrollStopAction = new delayed_action["a" /* default */](this.handleScrollStop);
    this.state = {
      isScrolling: false,
      topRhsPostCreateAt: 0
    };
  }

  shouldComponentUpdate(nextProps, nextState) {
    if (!utils["c" /* areObjectsEqual */](nextState.selected, this.props.selected)) {
      return true;
    }

    if (nextState.isScrolling !== this.state.isScrolling) {
      return true;
    }

    return false;
  }

  render() {
    if (this.props.selected == null) {
      return react_default.a.createElement("div", null);
    }

    const {
      selected,
      pluginPostCardTypes,
      teamUrl
    } = this.props;
    const postType = selected.type;
    let content = null;

    if (pluginPostCardTypes.hasOwnProperty(postType)) {
      const PluginComponent = pluginPostCardTypes[postType].component;
      content = react_default.a.createElement(PluginComponent, {
        post: selected
      });
    }

    if (!content) {
      content = react_default.a.createElement("div", {
        className: "info-card"
      }, react_default.a.createElement(markdown["a" /* default */], {
        message: selected.props && selected.props.card
      }));
    }

    let user = react_default.a.createElement(user_profile["a" /* default */], {
      userId: selected.user_id,
      hideStatus: true,
      disablePopover: true
    });

    if (selected.props.override_username && this.props.enablePostUsernameOverride) {
      user = react_default.a.createElement(user_profile["a" /* default */], {
        userId: selected.user_id,
        hideStatus: true,
        disablePopover: true,
        overwriteName: selected.props.override_username
      });
    }

    const avatar = react_default.a.createElement(post_profile_picture["a" /* default */], {
      compactDisplay: false,
      post: selected,
      userId: selected.user_id
    });
    return react_default.a.createElement("div", {
      className: "sidebar-right__body sidebar-right__card",
      ref: "sidebarbody"
    }, react_default.a.createElement(rhs_card_header, {
      previousRhsState: this.props.previousRhsState
    }), react_default.a.createElement(react_custom_scrollbars_lib_default.a, {
      autoHide: true,
      autoHideTimeout: 500,
      autoHideDuration: 500,
      renderThumbHorizontal: rhs_card_renderThumbHorizontal,
      renderThumbVertical: rhs_card_renderThumbVertical,
      renderView: rhs_card_renderView,
      onScroll: this.handleScroll
    }, react_default.a.createElement("div", {
      className: "post-right__scroll"
    }, content, react_default.a.createElement("div", {
      className: "d-flex post-card--info"
    }, react_default.a.createElement("div", {
      className: "post-card--post-by overflow--ellipsis"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_card.message_by",
      defaultMessage: "Message by {avatar} {user}",
      values: {
        user,
        avatar
      }
    })), react_default.a.createElement("div", {
      className: "post-card--view-post"
    }, react_default.a.createElement(react_router_dom["a" /* Link */], {
      to: `${teamUrl}/pl/${selected.id}`,
      className: "post__permalink",
      onClick: this.handleClick
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rhs_card.jump",
      defaultMessage: "Jump"
    })))))));
  }

}

rhs_card_defineProperty(rhs_card_RhsCard, "propTypes", {
  selected: prop_types_default.a.object,
  pluginPostCardTypes: prop_types_default.a.object,
  previousRhsState: prop_types_default.a.oneOf(Object.values(constants["x" /* RHSStates */])),
  enablePostUsernameOverride: prop_types_default.a.bool,
  teamUrl: prop_types_default.a.string
});

rhs_card_defineProperty(rhs_card_RhsCard, "defaultProps", {
  pluginPostCardTypes: {}
});
// CONCATENATED MODULE: ./components/rhs_card/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function rhs_card_mapStateToProps(state) {
  const selected = Object(selectors_rhs["r" /* getSelectedPostCard */])(state);
  const config = Object(general["getConfig"])(state);
  const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
  return {
    enablePostUsernameOverride,
    selected,
    pluginPostCardTypes: state.plugins.postCardTypes,
    teamUrl: Object(entities_teams["getCurrentRelativeTeamUrl"])(state)
  };
}

/* harmony default export */ var rhs_card = (Object(es["connect"])(rhs_card_mapStateToProps)(rhs_card_RhsCard));
// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Popover.js
var Popover = __webpack_require__(1999);

// CONCATENATED MODULE: ./components/icon/select_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class select_icon_SelectIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.select",
      defaultMessage: "Select Icon"
    }, title => react_default.a.createElement("i", {
      className: "fa fa fa-plus-square",
      title: title
    }));
  }

}
// CONCATENATED MODULE: ./components/suggestion/search_channel_provider.jsx
function search_channel_provider_extends() { search_channel_provider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return search_channel_provider_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function itemToName(item) {
  if (item.type === constants["N" /* default */].DM_CHANNEL) {
    return '@' + item.display_name;
  }

  if (item.type === constants["N" /* default */].GM_CHANNEL) {
    return '@' + item.display_name.replace(/ /g, '');
  }

  return item.name;
}

class search_channel_provider_SearchChannelSuggestion extends suggestion["a" /* default */] {
  render() {
    const {
      item,
      isSelection
    } = this.props;
    let className = 'search-autocomplete__item';

    if (isSelection) {
      className += ' selected keyboard-focus';
    }

    const name = itemToName(item);
    let tag = null;

    if (item.type === constants["N" /* default */].DM_CHANNEL) {
      const teammate = Object(utils["v" /* getDirectTeammate */])(item.id);
      tag = react_default.a.createElement(bot_badge["a" /* default */], {
        show: Boolean(teammate && teammate.is_bot),
        className: "badge-popoverlist"
      });
    }

    return react_default.a.createElement("div", search_channel_provider_extends({
      onClick: this.handleClick,
      className: className
    }, suggestion["a" /* default */].baseProps), react_default.a.createElement(select_icon_SelectIcon, null), react_default.a.createElement("span", {
      className: "search-autocomplete__name"
    }, name), tag);
  }

}

class search_channel_provider_SearchChannelProvider extends provider["a" /* default */] {
  handlePretextChanged(pretext, resultsCallback) {
    const captured = /\b(?:in|channel):\s*(\S*)$/i.exec(pretext.toLowerCase());

    if (captured) {
      const channelPrefix = captured[1];
      this.startNewRequest(channelPrefix);
      Object(channel_actions["c" /* autocompleteChannelsForSearch */])(channelPrefix, data => {
        if (this.shouldCancelDispatch(channelPrefix)) {
          return;
        } //
        // MM-12677 When this is migrated this needs to be fixed to pull the user's locale
        //


        const channels = data.sort(channel_utils["sortChannelsByTypeAndDisplayName"].bind(null, 'en'));
        const channelNames = channels.map(itemToName);
        resultsCallback({
          matchedPretext: channelPrefix,
          terms: channelNames,
          items: channels,
          component: search_channel_provider_SearchChannelSuggestion
        });
      });
    }

    return Boolean(captured);
  }

}
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(33);
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// CONCATENATED MODULE: ./components/suggestion/search_suggestion_list.jsx
function search_suggestion_list_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class search_suggestion_list_SearchSuggestionList extends suggestion_list["a" /* default */] {
  constructor(props) {
    super(props);
    this.suggestionReadOut = react_default.a.createRef();
    this.currentLabel = '';
  }

  announceLabel() {
    const suggestionReadOut = this.suggestionReadOut.current;

    if (suggestionReadOut) {
      suggestionReadOut.innerHTML = this.currentLabel;
    }
  }

  getContent() {
    return jquery_default()(react_dom_default.a.findDOMNode(this.refs.popover)).find('.popover-content');
  }

  renderChannelDivider(type) {
    let text;

    if (type === constants["N" /* default */].OPEN_CHANNEL) {
      text = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "suggestion.search.public",
        defaultMessage: "Public Channels"
      });
    } else if (type === constants["N" /* default */].PRIVATE_CHANNEL) {
      text = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "suggestion.search.private",
        defaultMessage: "Private Channels"
      });
    } else {
      text = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "suggestion.search.direct",
        defaultMessage: "Direct Messages"
      });
    }

    return react_default.a.createElement("div", {
      key: type + '-divider',
      className: "search-autocomplete__divider"
    }, react_default.a.createElement("span", null, text));
  }

  render() {
    if (this.props.items.length === 0) {
      return null;
    }

    const items = [];

    for (let i = 0; i < this.props.items.length; i++) {
      const item = this.props.items[i];
      const term = this.props.terms[i];
      const isSelection = term === this.props.selection; // ReactComponent names need to be upper case when used in JSX

      const Component = this.props.components[i]; // temporary hack to add dividers between public and private channels in the search suggestion list

      if (this.props.renderDividers) {
        if (i === 0 || item.type !== this.props.items[i - 1].type) {
          if (item.type === constants["N" /* default */].OPEN_CHANNEL) {
            items.push(this.renderChannelDivider(constants["N" /* default */].OPEN_CHANNEL));
          } else if (item.type === constants["N" /* default */].PRIVATE_CHANNEL) {
            items.push(this.renderChannelDivider(constants["N" /* default */].PRIVATE_CHANNEL));
          } else if (i === 0 || this.props.items[i - 1].type === constants["N" /* default */].OPEN_CHANNEL || this.props.items[i - 1].type === constants["N" /* default */].PRIVATE_CHANNEL) {
            items.push(this.renderChannelDivider(constants["N" /* default */].DM_CHANNEL));
          }
        }
      }

      if (isSelection) {
        if (item.type === constants["N" /* default */].DM_CHANNEL || item.type === constants["N" /* default */].GM_CHANNEL) {
          this.currentLabel = item.display_name;
        } else if (item.username) {
          this.currentLabel = item.username;
        } else {
          this.currentLabel = item.name;
        } // Pause the event loop and Wait for the aria-live element to be up


        setTimeout(() => {
          this.announceLabel();
        }, constants["N" /* default */].OVERLAY_TIME_DELAY_SMALL);
      }

      items.push(react_default.a.createElement(Component, {
        key: term,
        ref: term,
        item: item,
        term: term,
        matchedPretext: this.props.matchedPretext[i],
        isSelection: isSelection,
        onClick: this.props.onCompleteWord
      }));
    }

    return react_default.a.createElement(Popover["a" /* default */], {
      ref: "popover",
      id: "search-autocomplete__popover",
      className: "search-help-popover autocomplete visible",
      placement: "bottom"
    }, react_default.a.createElement("div", {
      ref: this.suggestionReadOut,
      "aria-live": "polite",
      className: "hidden-label"
    }), items);
  }

}

search_suggestion_list_defineProperty(search_suggestion_list_SearchSuggestionList, "propTypes", { ...suggestion_list["a" /* default */].propTypes
});
// CONCATENATED MODULE: ./components/suggestion/suggestion_date.jsx
function suggestion_date_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class suggestion_date_SuggestionDate extends react_default.a.PureComponent {
  render() {
    if (this.props.items.length === 0) {
      return null;
    }

    const item = this.props.items[0];
    const term = this.props.terms[0]; // ReactComponent names need to be upper case when used in JSX

    const Component = this.props.components[0];
    const itemComponent = react_default.a.createElement(Component, {
      key: term,
      ref: term,
      item: item,
      term: term,
      matchedPretext: this.props.matchedPretext[0],
      isSelection: false,
      onClick: this.props.onCompleteWord
    });
    return react_default.a.createElement(Popover["a" /* default */], {
      ref: "popover",
      id: "search-autocomplete__popover",
      className: "search-help-popover autocomplete visible",
      placement: "bottom"
    }, itemComponent);
  }

}

suggestion_date_defineProperty(suggestion_date_SuggestionDate, "propTypes", {
  onCompleteWord: prop_types_default.a.func.isRequired,
  items: prop_types_default.a.array.isRequired,
  terms: prop_types_default.a.array.isRequired,
  components: prop_types_default.a.array.isRequired,
  matchedPretext: prop_types_default.a.array.isRequired
});
// CONCATENATED MODULE: ./components/suggestion/search_user_provider.jsx
function search_user_provider_extends() { search_user_provider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return search_user_provider_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class search_user_provider_SearchUserSuggestion extends suggestion["a" /* default */] {
  render() {
    const {
      item,
      isSelection
    } = this.props;
    let className = 'search-autocomplete__item';

    if (isSelection) {
      className += ' selected keyboard-focus';
    }

    const username = item.username;
    let description = '';

    if ((item.first_name || item.last_name) && item.nickname) {
      description = `- ${utils["A" /* getFullName */](item)} (${item.nickname})`;
    } else if (item.nickname) {
      description = `- (${item.nickname})`;
    } else if (item.first_name || item.last_name) {
      description = `- ${utils["A" /* getFullName */](item)}`;
    }

    return react_default.a.createElement("div", search_user_provider_extends({
      className: className,
      onClick: this.handleClick
    }, suggestion["a" /* default */].baseProps), react_default.a.createElement(select_icon_SelectIcon, null), react_default.a.createElement("img", {
      alt: '',
      className: "profile-img rounded",
      src: utils["K" /* imageURLForUser */](item)
    }), react_default.a.createElement("div", {
      className: "mention--align"
    }, react_default.a.createElement("span", null, username), react_default.a.createElement(bot_badge["a" /* default */], {
      show: Boolean(item.is_bot),
      className: "badge-autocomplete"
    }), react_default.a.createElement("span", {
      className: "mention__fullname"
    }, ' ', description)));
  }

}

class search_user_provider_SearchUserProvider extends provider["a" /* default */] {
  handlePretextChanged(pretext, resultsCallback) {
    const captured = /\bfrom:\s*(\S*)$/i.exec(pretext.toLowerCase());

    if (captured) {
      const usernamePrefix = captured[1];
      this.startNewRequest(usernamePrefix);
      Object(user_actions["c" /* autocompleteUsersInTeam */])(usernamePrefix, data => {
        if (this.shouldCancelDispatch(usernamePrefix)) {
          return;
        }

        const users = Object.assign([], data.users);
        const mentions = users.map(user => user.username);
        resultsCallback({
          matchedPretext: usernamePrefix,
          terms: mentions,
          items: users,
          component: search_user_provider_SearchUserSuggestion
        });
      });
    }

    return Boolean(captured);
  }

  allowDividers() {
    return false;
  }

}
// EXTERNAL MODULE: ./node_modules/react-day-picker/DayPicker.js
var DayPicker = __webpack_require__(2953);
var DayPicker_default = /*#__PURE__*/__webpack_require__.n(DayPicker);

// EXTERNAL MODULE: ./node_modules/react-day-picker/lib/style.css
var lib_style = __webpack_require__(2960);

// CONCATENATED MODULE: ./components/suggestion/search_date_provider.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class search_date_provider_SearchDateSuggestion extends suggestion["a" /* default */] {
  constructor(props) {
    super(props);
    this.handleDayClick = this.handleDayClick.bind(this);
  }

  handleDayClick(day) {
    const dayString = day.toISOString().split('T')[0];
    this.props.onClick(dayString, this.props.matchedPretext);
  }

  render() {
    return react_default.a.createElement(DayPicker_default.a, {
      onDayClick: this.handleDayClick,
      showOutsideDays: true
    });
  }

}

class search_date_provider_SearchDateProvider extends provider["a" /* default */] {
  handlePretextChanged(pretext, resultsCallback) {
    const captured = /\b(?:on|before|after):\s*(\S*)$/i.exec(pretext.toLowerCase());

    if (captured) {
      const datePrefix = captured[1];
      this.startNewRequest(datePrefix);
      const dates = Object.assign([], [{
        label: 'Selected Date',
        date: datePrefix
      }]);
      const terms = dates.map(date => date.date);
      resultsCallback({
        matchedPretext: datePrefix,
        terms,
        items: dates,
        component: search_date_provider_SearchDateSuggestion
      });
    }

    return Boolean(captured);
  }

  allowDividers() {
    return false;
  }

  presentationType() {
    return 'date';
  }

}
// CONCATENATED MODULE: ./components/channel_header/components/header_icon_wrapper.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function HeaderIconWrapper({
  iconComponent,
  ariaLabel,
  buttonClass,
  buttonId,
  onClick,
  tooltipKey,
  tooltipText
}) {
  const toolTips = {
    flaggedPosts: {
      class: 'text-nowrap',
      id: 'flaggedTooltip',
      messageID: Object(i18n["b" /* t */])('channel_header.flagged'),
      message: 'Flagged Posts'
    },
    pinnedPosts: {
      class: '',
      id: 'pinnedPostTooltip',
      messageID: Object(i18n["b" /* t */])('channel_header.pinnedPosts'),
      message: 'Pinned Posts'
    },
    recentMentions: {
      class: '',
      id: 'recentMentionsTooltip',
      messageID: Object(i18n["b" /* t */])('channel_header.messageNotification'),
      message: 'Message Notifications'
    },
    // recentMentions: {
    //     class: '',
    //     id: 'recentMentionsTooltip',
    //     messageID: t('channel_header.recentMentions'),
    //     message: 'Recent Mentions',
    // },
    search: {
      class: '',
      id: 'searchTooltip',
      messageID: Object(i18n["b" /* t */])('channel_header.search'),
      message: 'Search'
    },
    cloudPosts: {
      class: '',
      id: 'cloudTooltip',
      messageID: Object(i18n["b" /* t */])('channel_header.cloudPosts'),
      message: 'Cloud Disk'
    },
    workPosts: {
      class: '',
      id: 'workTooltip',
      messageID: Object(i18n["b" /* t */])('channel_header.workPosts'),
      message: 'Workbench'
    }
  };

  function getTooltip(key) {
    if (toolTips[key] == null) {
      return null;
    }

    return react_default.a.createElement(Tooltip["a" /* default */], {
      id: toolTips[key].id,
      className: toolTips[key].class
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: toolTips[key].messageID,
      defaultMessage: toolTips[key].message
    }));
  }

  let tooltip;

  if (tooltipKey === 'plugin' && tooltipText) {
    tooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "pluginTooltip",
      className: ""
    }, react_default.a.createElement("span", null, tooltipText));
  } else {
    tooltip = getTooltip(tooltipKey);
  }

  let ariaLabelText;

  if (ariaLabel) {
    ariaLabelText = `${Object(utils["gb" /* localizeMessage */])(toolTips[tooltipKey].messageID, toolTips[tooltipKey].message)}`;
  }

  if (tooltip) {
    return react_default.a.createElement("div", {
      className: "flex-child"
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover'],
      delayShow: constants["g" /* Constants */].OVERLAY_TIME_DELAY,
      placement: "bottom",
      overlay: tooltip
    }, react_default.a.createElement("button", {
      id: buttonId,
      "aria-label": ariaLabelText,
      className: buttonClass || 'channel-header__icon icon--hidden style--none',
      onClick: onClick
    }, iconComponent)));
  }

  return react_default.a.createElement("div", {
    className: "flex-child"
  }, react_default.a.createElement("button", {
    id: buttonId,
    className: buttonClass || 'channel-header__icon icon--hidden style--none',
    onClick: onClick
  }, iconComponent));
}
HeaderIconWrapper.propTypes = {
  ariaLabel: prop_types_default.a.bool,
  buttonClass: prop_types_default.a.string,
  buttonId: prop_types_default.a.string.isRequired,
  iconComponent: prop_types_default.a.element.isRequired,
  onClick: prop_types_default.a.func.isRequired,
  tooltipKey: prop_types_default.a.string,
  tooltipText: prop_types_default.a.string
};
// EXTERNAL MODULE: ./components/search_hint/search_hint.jsx
var search_hint = __webpack_require__(1884);

// EXTERNAL MODULE: ./components/widgets/loading/loading_spinner.jsx
var loading_spinner = __webpack_require__(1651);

// EXTERNAL MODULE: ./components/status_icon.jsx + 8 modules
var status_icon = __webpack_require__(1754);

// EXTERNAL MODULE: ./components/widgets/menu/menu.jsx
var menu_menu = __webpack_require__(1619);

// EXTERNAL MODULE: ./components/widgets/menu/menu_wrapper.jsx + 1 modules
var menu_wrapper = __webpack_require__(1606);

// EXTERNAL MODULE: ./components/widgets/menu/menu_group.jsx
var menu_group = __webpack_require__(1807);

// EXTERNAL MODULE: ./components/widgets/menu/menu_items/menu_item_action.jsx
var menu_item_action = __webpack_require__(1600);

// CONCATENATED MODULE: ./components/status_dropdown/status_dropdown.jsx
function status_dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











class status_dropdown_StatusDropdown extends react_default.a.Component {
  constructor(...args) {
    super(...args);

    status_dropdown_defineProperty(this, "isUserOutOfOffice", () => {
      return this.props.status === constants["L" /* UserStatuses */].OUT_OF_OFFICE;
    });

    status_dropdown_defineProperty(this, "setStatus", status => {
      this.props.actions.setStatus({
        user_id: this.props.userId,
        status
      });
    });

    status_dropdown_defineProperty(this, "setOnline", event => {
      event.preventDefault();
      this.setStatus(constants["L" /* UserStatuses */].ONLINE);
    });

    status_dropdown_defineProperty(this, "setOffline", event => {
      event.preventDefault();
      this.setStatus(constants["L" /* UserStatuses */].OFFLINE);
    });

    status_dropdown_defineProperty(this, "setAway", event => {
      event.preventDefault();
      this.setStatus(constants["L" /* UserStatuses */].AWAY);
    });

    status_dropdown_defineProperty(this, "setDnd", event => {
      event.preventDefault();
      this.setStatus(constants["L" /* UserStatuses */].DND);
    });

    status_dropdown_defineProperty(this, "showStatusChangeConfirmation", status => {
      const resetStatusModalData = {
        ModalId: constants["p" /* ModalIdentifiers */].RESET_STATUS,
        dialogType: reset_status_modal,
        dialogProps: {
          newStatus: status
        }
      };
      this.props.actions.openModal(resetStatusModalData);
    });

    status_dropdown_defineProperty(this, "renderProfilePicture", () => {
      if (!this.props.profilePicture) {
        return null;
      }

      return react_default.a.createElement("img", {
        alt: '',
        className: "user__picture",
        src: this.props.profilePicture
      });
    });

    status_dropdown_defineProperty(this, "renderDropdownIcon", () => {
      return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "generic_icons.dropdown",
        defaultMessage: "Dropdown Icon"
      }, title => react_default.a.createElement("i", {
        className: 'fa fa-caret-down',
        title: title
      }));
    });
  }

  render() {
    const needsConfirm = this.isUserOutOfOffice() && this.props.autoResetPref === '';
    const profilePicture = this.renderProfilePicture();
    const dropdownIcon = this.renderDropdownIcon();
    const setOnline = needsConfirm ? () => this.showStatusChangeConfirmation('online') : this.setOnline;
    const setDnd = needsConfirm ? () => this.showStatusChangeConfirmation('dnd') : this.setDnd;
    const setAway = needsConfirm ? () => this.showStatusChangeConfirmation('away') : this.setAway;
    const setOffline = needsConfirm ? () => this.showStatusChangeConfirmation('offline') : this.setOffline;
    return react_default.a.createElement(menu_wrapper["a" /* default */], {
      onToggle: this.onToggle,
      style: this.props.style
    }, react_default.a.createElement("div", {
      className: "status-wrapper status-selector"
    }, profilePicture, react_default.a.createElement("span", {
      className: 'status-icon status-icon-' + this.props.status
    })), react_default.a.createElement(menu_menu["a" /* default */], {
      ariaLabel: Object(utils["gb" /* localizeMessage */])('status_dropdown.menuAriaLabel', 'set status')
    }, react_default.a.createElement(menu_group["a" /* default */], null, react_default.a.createElement(menu_item_action["a" /* default */], {
      show: this.isUserOutOfOffice(),
      onClick: () => null,
      ariaLabel: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_ooo', 'Out of office').toLowerCase(),
      text: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_ooo', 'Out of office'),
      extraText: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_ooo.extra', 'Automatic Replies are enabled')
    })), react_default.a.createElement(menu_group["a" /* default */], null, react_default.a.createElement(menu_item_action["a" /* default */], {
      onClick: setOnline,
      ariaLabel: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_online', 'Online').toLowerCase(),
      text: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_online', 'Online')
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      onClick: setAway,
      ariaLabel: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_away', 'Away').toLowerCase(),
      text: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_away', 'Away')
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      onClick: setDnd,
      ariaLabel: `${Object(utils["gb" /* localizeMessage */])('status_dropdown.set_dnd', 'Do not disturb').toLowerCase()}. ${Object(utils["gb" /* localizeMessage */])('status_dropdown.set_dnd.extra', 'Disables Desktop and Push Notifications').toLowerCase()}`,
      text: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_dnd', 'Do not disturb'),
      extraText: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_dnd.extra', 'Disables Desktop and Push Notifications')
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      onClick: setOffline,
      ariaLabel: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_offline', 'Offline').toLowerCase(),
      text: Object(utils["gb" /* localizeMessage */])('status_dropdown.set_offline', 'Offline')
    }))));
  }

}

status_dropdown_defineProperty(status_dropdown_StatusDropdown, "propTypes", {
  style: prop_types_default.a.object,
  status: prop_types_default.a.string,
  userId: prop_types_default.a.string.isRequired,
  profilePicture: prop_types_default.a.string,
  autoResetPref: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    openModal: prop_types_default.a.func.isRequired,
    setStatus: prop_types_default.a.func.isRequired
  }).isRequired
});

status_dropdown_defineProperty(status_dropdown_StatusDropdown, "defaultProps", {
  userId: '',
  profilePicture: '',
  status: constants["L" /* UserStatuses */].OFFLINE
});
// CONCATENATED MODULE: ./components/status_dropdown/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function status_dropdown_mapStateToProps(state) {
  const currentUser = Object(entities_users["getCurrentUser"])(state);

  if (!currentUser) {
    return {};
  }

  const userId = currentUser.id;
  return {
    userId,
    //profilePicture: currentUser.last_picture_update ? Client4.getProfilePictureUrl(userId, currentUser.last_picture_update) : require(`images/avatar_male.png`),
    profilePicture: client["Client4"].getProfilePictureUrl(userId, currentUser.last_picture_update),
    autoResetPref: Object(entities_preferences["get"])(state, mattermost_redux_constants["Preferences"].CATEGORY_AUTO_RESET_MANUAL_STATUS, userId, ''),
    status: Object(entities_users["getStatusForUserId"])(state, userId)
  };
}

function status_dropdown_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openModal: modals["b" /* openModal */],
      setStatus: actions_users["setStatus"]
    }, dispatch)
  };
}

/* harmony default export */ var status_dropdown = (Object(es["connect"])(status_dropdown_mapStateToProps, status_dropdown_mapDispatchToProps)(status_dropdown_StatusDropdown));
// EXTERNAL MODULE: ./components/svg/menu_icon.jsx
var menu_icon = __webpack_require__(1709);

// EXTERNAL MODULE: ./images/tutorialTip.gif
var images_tutorialTip = __webpack_require__(2961);
var tutorialTip_default = /*#__PURE__*/__webpack_require__.n(images_tutorialTip);

// EXTERNAL MODULE: ./images/tutorialTipWhite.gif
var tutorialTipWhite = __webpack_require__(2962);
var tutorialTipWhite_default = /*#__PURE__*/__webpack_require__.n(tutorialTipWhite);

// CONCATENATED MODULE: ./components/tutorial/tutorial_tip/tutorial_tip.jsx
function tutorial_tip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








const Preferences = constants["N" /* default */].Preferences;
const TutorialSteps = constants["N" /* default */].TutorialSteps;
class tutorial_tip_TutorialTip extends react_default.a.Component {
  constructor(props) {
    super(props);

    tutorial_tip_defineProperty(this, "show", () => {
      this.setState({
        show: true
      });
    });

    tutorial_tip_defineProperty(this, "hide", () => {
      this.setState({
        show: false
      });
    });

    tutorial_tip_defineProperty(this, "handleNext", () => {
      if (this.state.currentScreen < this.props.screens.length - 1) {
        this.setState({
          currentScreen: this.state.currentScreen + 1
        });
        return;
      }

      if (this.props.diagnosticsTag) {
        let tag = this.props.diagnosticsTag;

        if (this.props.screens.length > 1) {
          tag += '_' + (this.state.currentScreen + 1).toString();
        }

        if (this.state.currentScreen === this.props.screens.length - 1) {
          tag += '_okay';
        } else {
          tag += '_next';
        }

        Object(diagnostics_actions["d" /* trackEvent */])('tutorial', tag);
      }

      const {
        currentUserId,
        actions
      } = this.props;
      const {
        closeRhsMenu,
        savePreferences
      } = actions;
      const preferences = [{
        user_id: currentUserId,
        category: Preferences.TUTORIAL_STEP,
        name: currentUserId,
        value: (this.props.step + 1).toString()
      }];
      closeRhsMenu();
      this.hide();
      savePreferences(currentUserId, preferences);
    });

    tutorial_tip_defineProperty(this, "skipTutorial", e => {
      e.preventDefault();

      if (this.props.diagnosticsTag) {
        let tag = this.props.diagnosticsTag;

        if (this.props.screens.length > 1) {
          tag += '_' + this.state.currentScreen;
        }

        tag += '_skip';
        Object(diagnostics_actions["d" /* trackEvent */])('tutorial', tag);
      }

      const {
        currentUserId,
        actions
      } = this.props;
      const preferences = [{
        user_id: currentUserId,
        category: Preferences.TUTORIAL_STEP,
        name: currentUserId,
        value: TutorialSteps.FINISHED.toString()
      }];
      actions.savePreferences(currentUserId, preferences);
    });

    tutorial_tip_defineProperty(this, "handleCircleClick", (e, screen) => {
      e.preventDefault();
      this.setState({
        currentScreen: screen
      });
    });

    tutorial_tip_defineProperty(this, "getTarget", () => {
      return this.refs.target;
    });

    this.state = {
      currentScreen: 0,
      show: false
    };
  }

  render() {
    const buttonText = this.state.currentScreen === this.props.screens.length - 1 ? react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_tip.ok",
      defaultMessage: "Okay"
    }) : react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_tip.next",
      defaultMessage: "Next"
    });
    const dots = [];

    if (this.props.screens.length > 1) {
      for (let i = 0; i < this.props.screens.length; i++) {
        let className = 'circle';

        if (i === this.state.currentScreen) {
          className += ' active';
        }

        dots.push(react_default.a.createElement("a", {
          href: "#",
          key: 'dotactive' + i,
          className: className,
          "data-screen": i,
          onClick: e => this.handleCircleClick(e, i)
        }));
      }
    }

    var tutorialGifImage = tutorialTip_default.a;

    if (this.props.overlayClass === 'tip-overlay--header' || this.props.overlayClass === 'tip-overlay--sidebar' || this.props.overlayClass === 'tip-overlay--header--up') {
      tutorialGifImage = tutorialTipWhite_default.a;
    }

    return react_default.a.createElement("div", {
      id: "tipButton",
      className: 'tip-div ' + this.props.overlayClass,
      onClick: this.show
    }, react_default.a.createElement("img", {
      alt: 'tutorial tip',
      className: "tip-button",
      src: tutorialGifImage,
      width: "35",
      onClick: this.show,
      ref: "target"
    }), react_default.a.createElement(Overlay["a" /* default */], {
      show: this.state.show
    }, react_default.a.createElement("div", {
      className: "tip-backdrop"
    })), react_default.a.createElement(Overlay["a" /* default */], {
      placement: this.props.placement,
      show: this.state.show,
      rootClose: true,
      onHide: this.hide,
      target: this.getTarget
    }, react_default.a.createElement("div", {
      className: 'tip-overlay ' + this.props.overlayClass
    }, react_default.a.createElement("div", {
      className: "arrow"
    }), this.props.screens[this.state.currentScreen], react_default.a.createElement("div", {
      className: "tutorial__footer"
    }, react_default.a.createElement("div", {
      className: "tutorial__circles"
    }, dots), react_default.a.createElement("div", {
      className: "text-right"
    }, react_default.a.createElement("button", {
      id: "tipNextButton",
      className: "btn btn-primary",
      onClick: this.handleNext
    }, buttonText), react_default.a.createElement("div", {
      className: "tip-opt"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_tip.seen",
      defaultMessage: "Seen this before? "
    }), react_default.a.createElement("a", {
      href: "#",
      onClick: this.skipTutorial
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_tip.out",
      defaultMessage: "Opt out of these tips."
    }))))))));
  }

}

tutorial_tip_defineProperty(tutorial_tip_TutorialTip, "propTypes", {
  currentUserId: prop_types_default.a.string.isRequired,
  step: prop_types_default.a.number.isRequired,
  screens: prop_types_default.a.array.isRequired,
  placement: prop_types_default.a.string.isRequired,
  overlayClass: prop_types_default.a.string,
  diagnosticsTag: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    closeRhsMenu: prop_types_default.a.func.isRequired,
    savePreferences: prop_types_default.a.func.isRequired
  })
});

tutorial_tip_defineProperty(tutorial_tip_TutorialTip, "defaultProps", {
  overlayClass: ''
});
// CONCATENATED MODULE: ./components/tutorial/tutorial_tip/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









function tutorial_tip_mapStateToProps(state) {
  const currentUserId = Object(entities_users["getCurrentUserId"])(state);
  return {
    currentUserId,
    step: Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, currentUserId, 0)
  };
}

function tutorial_tip_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      closeRhsMenu: rhs["a" /* closeMenu */],
      savePreferences: actions_preferences["savePreferences"]
    }, dispatch)
  };
}

/* harmony default export */ var tutorial_tip = (Object(es["connect"])(tutorial_tip_mapStateToProps, tutorial_tip_mapDispatchToProps)(tutorial_tip_TutorialTip));
// CONCATENATED MODULE: ./components/tutorial/menu_tutorial_tip.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const MenuTutorialTip = ({
  toggleFunc,
  onBottom
}) => {
  const screens = [];
  screens.push(react_default.a.createElement("div", null, react_default.a.createElement("h4", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "sidebar_header.tutorial.title",
    defaultMessage: "Main Menu"
  })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "sidebar_header.tutorial.body1",
    defaultMessage: "The **Main Menu** is where you can **Invite New Members**, access your **Account Settings** and set your **Theme Color**."
  })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "sidebar_header.tutorial.body2",
    defaultMessage: "Team administrators can also access their **Team Settings** from this menu."
  })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "sidebar_header.tutorial.body3",
    defaultMessage: "System administrators will find a **System Console** option to administrate the entire system."
  }))));
  let placement = 'right';
  let arrow = 'left';

  if (onBottom) {
    placement = 'bottom';
    arrow = 'up';
  }

  return react_default.a.createElement("div", {
    onClick: toggleFunc
  }, react_default.a.createElement(tutorial_tip, {
    placement: placement,
    screens: screens,
    overlayClass: 'tip-overlay--header--' + arrow,
    diagnosticsTag: "tutorial_tip_3_main_menu"
  }));
};

MenuTutorialTip.propTypes = {
  toggleFunc: prop_types_default.a.func,
  onBottom: prop_types_default.a.bool.isRequired
};
/* harmony default export */ var menu_tutorial_tip = (MenuTutorialTip);
// CONCATENATED MODULE: ./components/sidebar/headerCloneTwo/sidebar_header_dropdown_button.jsx
function sidebar_header_dropdown_button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class sidebar_header_dropdown_button_SidebarHeaderDropdownButton extends react_default.a.PureComponent {
  render() {
    const mainMenuToolTip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "main-menu__tooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "sidebar.mainMenu",
      defaultMessage: "Main menu"
    }));
    let tutorialTip = null;

    if (this.props.showTutorialTip) {
      tutorialTip = react_default.a.createElement(menu_tutorial_tip, {
        onBottom: false
      });
    }

    let teamNameWithToolTip = react_default.a.createElement("h1", {
      id: "headerTeamName",
      className: "team__name",
      "data-teamid": this.props.currentUser.department_name
    }, this.props.currentUser.department_name);

    if (this.props.teamDisplayName) {
      teamNameWithToolTip = react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        placement: "bottom",
        overlay: react_default.a.createElement(Tooltip["a" /* default */], {
          id: "team-name__tooltip"
        }, this.props.currentUser.nickname + '  ' + this.props.currentUser.department_name),
        ref: "descriptionOverlay"
      }, teamNameWithToolTip);
    }

    return react_default.a.createElement("div", {
      className: "SidebarHeaderDropdownButton",
      id: "sidebarHeaderDropdownButton"
    }, tutorialTip, react_default.a.createElement("div", {
      id: "headerInfo",
      className: "header__info"
    }, teamNameWithToolTip, react_default.a.createElement("div", {
      id: "headerUsername",
      className: "user__name"
    }, this.props.currentUser.nickname)));
  }

}

sidebar_header_dropdown_button_defineProperty(sidebar_header_dropdown_button_SidebarHeaderDropdownButton, "propTypes", {
  showTutorialTip: prop_types_default.a.bool.isRequired,
  teamDescription: prop_types_default.a.string.isRequired,
  teamId: prop_types_default.a.string.isRequired,
  currentUser: prop_types_default.a.object.isRequired,
  teamDisplayName: prop_types_default.a.string.isRequired
});
// EXTERNAL MODULE: ./components/user_settings/modal/index.js + 1 modules
var user_settings_modal = __webpack_require__(1757);

// EXTERNAL MODULE: ./mattermost-redux/utils/helpers.js
var helpers = __webpack_require__(72);

// EXTERNAL MODULE: ./components/widgets/loading/loading_wrapper.jsx
var loading_wrapper = __webpack_require__(1608);

// CONCATENATED MODULE: ./components/invite_member_modal/invite_member_modal.jsx
function invite_member_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.














const holders = Object(index_es["g" /* defineMessages */])({
  emailError: {
    id: Object(i18n["b" /* t */])('invite_member.emailError'),
    defaultMessage: 'Please enter a valid email address'
  },
  firstname: {
    id: Object(i18n["b" /* t */])('invite_member.firstname'),
    defaultMessage: 'First name'
  },
  lastname: {
    id: Object(i18n["b" /* t */])('invite_member.lastname'),
    defaultMessage: 'Last name'
  },
  modalTitle: {
    id: Object(i18n["b" /* t */])('invite_member.modalTitle'),
    defaultMessage: 'Discard Invitations?'
  },
  modalMessage: {
    id: Object(i18n["b" /* t */])('invite_member.modalMessage'),
    defaultMessage: 'You have unsent invitations, are you sure you want to discard them?'
  },
  modalButton: {
    id: Object(i18n["b" /* t */])('invite_member.modalButton'),
    defaultMessage: 'Yes, Discard'
  }
});

class invite_member_modal_InviteMemberModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    invite_member_modal_defineProperty(this, "onHide", () => {
      this.setState({
        show: false
      });
    });

    invite_member_modal_defineProperty(this, "handleSubmit", async () => {
      const inviteIds = this.state.inviteIds;
      const count = inviteIds.length;
      const invites = [];
      const emails = [];
      const emailErrors = { ...this.state.emailErrors
      };
      const firstNameErrors = { ...this.state.firstNameErrors
      };
      const lastNameErrors = { ...this.state.lastNameErrors
      };
      let valid = true;

      for (let i = 0; i < count; i++) {
        const invite = {};
        const index = inviteIds[i];
        invite.email = react_dom_default.a.findDOMNode(this.refs['email' + index]).value.trim();
        invite.firstName = react_dom_default.a.findDOMNode(this.refs['first_name' + index]).value.trim();
        invite.lastName = react_dom_default.a.findDOMNode(this.refs['last_name' + index]).value.trim();

        if (invite.email !== '' || index === 0) {
          if (!invite.email || !Object(helpers["isEmail"])(invite.email)) {
            emailErrors[index] = this.props.intl.formatMessage(holders.emailError);
            valid = false;
          } else {
            emailErrors[index] = '';
          }

          invites.push(invite);
        }
      }

      this.setState({
        emailErrors,
        firstNameErrors,
        lastNameErrors
      });

      if (!valid || invites.length === 0) {
        return;
      }

      invites.forEach(i => {
        emails.push(i.email);
      });
      this.setState({
        isSendingEmails: true
      });
      const {
        data,
        error
      } = await this.props.actions.sendEmailInvitesToTeam(this.props.teamId, emails);

      if (data) {
        this.handleHide(false);
        this.setState({
          isSendingEmails: false
        });
      } else if (error) {
        if (error.id === 'api.team.invite_members.already.app_error') {
          emailErrors[error.detailed_error] = error.message;
          this.setState({
            emailErrors
          });
        } else {
          this.setState({
            serverError: error.message
          });
        }

        this.setState({
          isSendingEmails: false
        });
      }
    });

    invite_member_modal_defineProperty(this, "handleHide", requireConfirm => {
      if (requireConfirm) {
        var notEmpty = false;

        for (var i = 0; i < this.state.inviteIds.length; i++) {
          var index = this.state.inviteIds[i];

          if (react_dom_default.a.findDOMNode(this.refs['email' + index]).value.trim() !== '') {
            notEmpty = true;
            break;
          }
        }

        if (notEmpty) {
          this.setState({
            showConfirmModal: true
          });
          return;
        }
      }

      this.clearFields();
      this.setState({
        show: false,
        showConfirmModal: false
      });
    });

    invite_member_modal_defineProperty(this, "addInviteFields", () => {
      const count = this.state.idCount + 1;
      const inviteIds = [...this.state.inviteIds];
      inviteIds.push(count);
      this.setState({
        inviteIds,
        idCount: count
      });
    });

    invite_member_modal_defineProperty(this, "clearFields", () => {
      var inviteIds = this.state.inviteIds;

      for (var i = 0; i < inviteIds.length; i++) {
        var index = inviteIds[i];
        react_dom_default.a.findDOMNode(this.refs['email' + index]).value = '';
        react_dom_default.a.findDOMNode(this.refs['first_name' + index]).value = '';
        react_dom_default.a.findDOMNode(this.refs['last_name' + index]).value = '';
      }

      this.setState({
        inviteIds: [0],
        idCount: 0,
        emailErrors: {},
        firstNameErrors: {},
        lastNameErrors: {}
      });
    });

    invite_member_modal_defineProperty(this, "removeInviteFields", inviteId => {
      let count = this.state.idCount;
      const inviteIds = this.state.inviteIds.filter(id => id !== inviteId);

      if (!inviteIds.length) {
        inviteIds.push(++count);
      }

      this.setState({
        inviteIds,
        idCount: count
      });
    });

    invite_member_modal_defineProperty(this, "showGetTeamInviteLinkModal", () => {
      this.handleHide(false);
      global_actions["l" /* showGetTeamInviteLinkModal */]();
    });

    invite_member_modal_defineProperty(this, "handleKeyDown", e => {
      if (utils["V" /* isKeyPressed */](e, constants["N" /* default */].KeyCodes.ENTER)) {
        e.preventDefault();
        this.handleSubmit();
      }
    });

    invite_member_modal_defineProperty(this, "hideConfirmModal", () => {
      this.setState({
        showConfirmModal: false
      });
    });

    this.state = {
      show: true,
      inviteIds: [0],
      idCount: 0,
      emailErrors: {},
      firstNameErrors: {},
      lastNameErrors: {},
      showConfirmModal: false,
      isSendingEmails: false
    };
  }

  render() {
    const {
      currentUser
    } = this.props;
    const {
      formatMessage
    } = this.props.intl;

    if (currentUser != null && this.props.teamType != null) {
      var inviteSections = [];
      var inviteIds = this.state.inviteIds;

      for (var i = 0; i < inviteIds.length; i++) {
        var index = inviteIds[i];
        var emailError = null;

        if (this.state.emailErrors[index]) {
          emailError = react_default.a.createElement("label", {
            className: "control-label"
          }, this.state.emailErrors[index]);
        }

        var firstNameError = null;

        if (this.state.firstNameErrors[index]) {
          firstNameError = react_default.a.createElement("label", {
            className: "control-label"
          }, this.state.firstNameErrors[index]);
        }

        var lastNameError = null;

        if (this.state.lastNameErrors[index]) {
          lastNameError = react_default.a.createElement("label", {
            className: "control-label"
          }, this.state.lastNameErrors[index]);
        }

        var removeButton = null;

        if (index) {
          removeButton = react_default.a.createElement("div", null, react_default.a.createElement("button", {
            type: "button",
            className: "btn btn-link remove__member",
            onClick: this.removeInviteFields.bind(this, index)
          }, react_default.a.createElement("span", {
            className: "fa fa-trash",
            title: formatMessage({
              id: 'generic_icons.remove',
              defaultMessage: 'Remove Icon'
            })
          })));
        }

        var emailClass = 'form-group invite';

        if (emailError) {
          emailClass += ' has-error';
        }

        var nameFields = null;
        var firstNameClass = 'form-group';

        if (firstNameError) {
          firstNameClass += ' has-error';
        }

        var lastNameClass = 'form-group';

        if (lastNameError) {
          lastNameClass += ' has-error';
        }

        nameFields = react_default.a.createElement("div", {
          className: "row row--invite"
        }, react_default.a.createElement("div", {
          className: "col-sm-6"
        }, react_default.a.createElement("div", {
          className: firstNameClass
        }, react_default.a.createElement(localized_input["a" /* default */], {
          onKeyDown: this.handleKeyDown,
          type: "text",
          className: "form-control",
          ref: 'first_name' + index,
          placeholder: holders.firstname,
          maxLength: "64",
          disabled: !this.props.enableUserCreation,
          spellCheck: "false"
        }), firstNameError)), react_default.a.createElement("div", {
          className: "col-sm-6"
        }, react_default.a.createElement("div", {
          className: lastNameClass
        }, react_default.a.createElement(localized_input["a" /* default */], {
          onKeyDown: this.handleKeyDown,
          type: "text",
          className: "form-control",
          ref: 'last_name' + index,
          placeholder: holders.lastname,
          maxLength: "64",
          disabled: !this.props.enableUserCreation,
          spellCheck: "false"
        }), lastNameError)));
        inviteSections[index] = react_default.a.createElement("div", {
          key: 'key' + index
        }, removeButton, react_default.a.createElement("div", {
          className: emailClass
        }, react_default.a.createElement("input", {
          onKeyUp: this.displayNameKeyUp,
          onKeyDown: this.handleKeyDown,
          type: "text",
          ref: 'email' + index,
          className: "form-control",
          placeholder: "email@domain.com",
          maxLength: "64",
          disabled: !this.props.enableUserCreation,
          spellCheck: "false",
          autoFocus: true
        }), emailError), nameFields);
      }

      var serverError = null;

      if (this.state.serverError) {
        serverError = react_default.a.createElement("div", {
          className: "form-group has-error"
        }, react_default.a.createElement("label", {
          className: "control-label"
        }, this.state.serverError));
      }

      var content = null;
      var sendButton = null;

      if (this.props.enableUserCreation) {
        content = react_default.a.createElement("div", null, serverError, react_default.a.createElement("button", {
          type: "button",
          className: "btn btn-link",
          onClick: this.addInviteFields
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "invite_member.addAnother",
          defaultMessage: "Add another"
        })), react_default.a.createElement("br", null), react_default.a.createElement("br", null), react_default.a.createElement("span", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
          id: "invite_member.autoJoin",
          defaultMessage: "People invited automatically join the **{channel}** channel.",
          values: {
            channel: this.props.defaultChannelName
          }
        })));
        var sendButtonLabel = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "invite_member.send",
          defaultMessage: "Send Invitation"
        });

        if (this.state.inviteIds.length > 1) {
          sendButtonLabel = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "invite_member.send2",
            defaultMessage: "Send Invitations"
          });
        }

        sendButton = react_default.a.createElement("button", {
          onClick: this.handleSubmit,
          type: "button",
          className: "btn btn-primary",
          disabled: this.state.isSendingEmails
        }, react_default.a.createElement(loading_wrapper["a" /* default */], {
          loading: this.state.isSendingEmails,
          text: utils["gb" /* localizeMessage */]('invite_member.sending', ' Sending')
        }, sendButtonLabel));
      } else if (this.props.enableUserCreation) {
        var teamInviteLink = null;

        if (currentUser && this.props.teamType === 'O') {
          var link = react_default.a.createElement("button", {
            className: "color--link style--none",
            onClick: this.showGetTeamInviteLinkModal
          }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "invite_member.inviteLink",
            defaultMessage: "Team Invite Link"
          }));
          teamInviteLink = react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "invite_member.teamInviteLink",
            defaultMessage: "You can also invite people using the {link}.",
            values: {
              link
            }
          }));
        }

        content = react_default.a.createElement("div", null, react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "invite_member.content",
          defaultMessage: "Email is currently disabled for your team, and email invitations cannot be sent. Contact your System Administrator to enable email and email invitations."
        })), teamInviteLink);
      } else {
        content = react_default.a.createElement("div", null, react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "invite_member.disabled",
          defaultMessage: "User creation has been disabled for your team. Please ask your Team Administrator for details."
        })));
      }

      return react_default.a.createElement("div", null, react_default.a.createElement(Modal["a" /* default */], {
        dialogClassName: "modal-invite-member",
        show: this.state.show,
        onHide: this.handleHide.bind(this, true),
        onExited: this.props.onHide,
        enforceFocus: !this.state.showConfirmModal,
        backdrop: this.state.isSendingEmails ? 'static' : true,
        role: "dialog",
        "aria-labelledby": "inviteMemberModalLabel"
      }, react_default.a.createElement(Modal["a" /* default */].Header, {
        closeButton: !this.state.isSendingEmails
      }, react_default.a.createElement(Modal["a" /* default */].Title, {
        componentClass: "h1",
        id: "inviteMemberModalLabel"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "invite_member.newMember",
        defaultMessage: "Send Email Invite"
      }))), react_default.a.createElement(Modal["a" /* default */].Body, {
        ref: "modalBody"
      }, react_default.a.createElement("form", {
        role: "form"
      }, inviteSections), content), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
        type: "button",
        className: "btn btn-link",
        onClick: this.handleHide.bind(this, true),
        disabled: this.state.isSendingEmails
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "invite_member.cancel",
        defaultMessage: "Cancel"
      })), sendButton)), react_default.a.createElement(confirm_modal["a" /* default */], {
        title: formatMessage(holders.modalTitle),
        message: formatMessage(holders.modalMessage),
        confirmButtonText: formatMessage(holders.modalButton),
        show: this.state.showConfirmModal,
        onConfirm: this.handleHide.bind(this, false),
        onCancel: this.hideConfirmModal
      }));
    }

    return null;
  }

}

invite_member_modal_defineProperty(invite_member_modal_InviteMemberModal, "propTypes", {
  intl: index_es["i" /* intlShape */].isRequired,
  enableUserCreation: prop_types_default.a.bool.isRequired,
  currentUser: prop_types_default.a.object.isRequired,
  defaultChannelName: prop_types_default.a.string.isRequired,
  teamType: prop_types_default.a.string.isRequired,
  teamId: prop_types_default.a.string.isRequired,
  onHide: prop_types_default.a.func.isRequired,
  actions: prop_types_default.a.shape({
    sendEmailInvitesToTeam: prop_types_default.a.func.isRequired
  }).isRequired
});

/* harmony default export */ var invite_member_modal = (Object(index_es["h" /* injectIntl */])(invite_member_modal_InviteMemberModal));
// CONCATENATED MODULE: ./components/invite_member_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function invite_member_modal_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const enableUserCreation = config.EnableUserCreation === 'true';
  const defaultChannel = Object(entities_channels["getChannelsNameMapInCurrentTeam"])(state)[constants["N" /* default */].DEFAULT_CHANNEL];
  const team = Object(entities_teams["getCurrentTeam"])(state);
  return {
    enableUserCreation,
    currentUser: Object(entities_users["getCurrentUser"])(state),
    defaultChannelName: defaultChannel ? defaultChannel.display_name : '',
    teamType: team ? team.type : '',
    teamId: team ? team.id : ''
  };
}

function invite_member_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      sendEmailInvitesToTeam: actions_teams["sendEmailInvitesToTeam"]
    }, dispatch)
  };
}

/* harmony default export */ var components_invite_member_modal = (Object(es["connect"])(invite_member_modal_mapStateToProps, invite_member_modal_mapDispatchToProps)(invite_member_modal));
// EXTERNAL MODULE: ./components/permissions_gates/team_permission_gate/index.js + 1 modules
var team_permission_gate = __webpack_require__(1719);

// EXTERNAL MODULE: ./components/permissions_gates/system_permission_gate/index.js + 1 modules
var system_permission_gate = __webpack_require__(1686);

// CONCATENATED MODULE: ./components/svg/leave_team_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class leave_team_icon_LeaveTeamIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "navbar_dropdown.leave.icon",
      defaultMessage: "Leave Team Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "100%",
      height: "100%",
      viewBox: "0 0 164 164",
      style: leave_team_icon_style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("path", {
      d: "M26.023,164L26.023,7.035L26.022,0.32L137.658,0.32L137.658,164L124.228,164L124.228, 13.749L39.452,13.749L39.452,164L26.023, 164ZM118.876,164L118.876,18.619L58.137,32.918L58.137,149.701L118.876,164Z"
    }))));
  }

}
const leave_team_icon_style = {
  fillRule: 'evenodd',
  clipRule: 'evenodd',
  strokeLinejoin: 'round',
  strokeMiterlimit: 1.41421
};
// EXTERNAL MODULE: ./selectors/views/modals.js
var views_modals = __webpack_require__(1710);

// CONCATENATED MODULE: ./components/leave_team_modal/leave_team_modal.jsx
function leave_team_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class leave_team_modal_LeaveTeamModal extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    leave_team_modal_defineProperty(this, "handleKeyPress", e => {
      if (Object(utils["V" /* isKeyPressed */])(e, constants["N" /* default */].KeyCodes.ENTER)) {
        this.handleSubmit(e);
      }
    });

    leave_team_modal_defineProperty(this, "handleSubmit", () => {
      this.props.onHide();
      this.props.actions.leaveTeam(this.props.currentTeamId, this.props.currentUserId);
      this.props.actions.toggleSideBarRightMenu();
    });
  }

  componentDidMount() {
    if (this.props.show) {
      document.addEventListener('keypress', this.handleKeyPress);
    }
  }

  componentWillUnmount() {
    document.removeEventListener('keypress', this.handleKeyPress);
  }

  render() {
    return react_default.a.createElement(Modal["a" /* default */], {
      className: "modal-confirm",
      show: this.props.show,
      onHide: this.props.onHide,
      id: "leaveTeamModal",
      role: "dialog",
      "aria-labelledby": "leaveTeamModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: false
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "leaveTeamModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "leave_team_modal.title",
      defaultMessage: "Leave the team?"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "leave_team_modal.desc",
      defaultMessage: "You will be removed from all public and private channels.  If the team is private you will not be able to rejoin the team.  Are you sure?"
    })), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-link",
      onClick: this.props.onHide,
      id: "leaveTeamNo"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "leave_team_modal.no",
      defaultMessage: "No"
    })), react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-danger",
      onClick: this.handleSubmit,
      id: "leaveTeamYes"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "leave_team_modal.yes",
      defaultMessage: "Yes"
    }))));
  }

}

leave_team_modal_defineProperty(leave_team_modal_LeaveTeamModal, "propTypes", {
  /**
   * Current user id.
   */
  currentUserId: prop_types_default.a.string.isRequired,

  /**
   * Current team id.
   */
  currentTeamId: prop_types_default.a.string.isRequired,

  /**
   * hide action
   */
  onHide: prop_types_default.a.func.isRequired,

  /**
   * show or hide modal
   */
  show: prop_types_default.a.bool.isRequired,
  intl: index_es["i" /* intlShape */].isRequired,
  actions: prop_types_default.a.shape({
    /**
     * An action to remove user from team
     */
    leaveTeam: prop_types_default.a.func.isRequired,

    /**
     * An action to toggle the right menu
     */
    toggleSideBarRightMenu: prop_types_default.a.func.isRequired
  })
});

/* harmony default export */ var leave_team_modal = (Object(index_es["h" /* injectIntl */])(leave_team_modal_LeaveTeamModal));
// CONCATENATED MODULE: ./components/leave_team_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function leave_team_modal_mapStateToProps(state) {
  const modalId = constants["p" /* ModalIdentifiers */].LEAVE_TEAM;
  const currentUserId = Object(entities_users["getCurrentUserId"])(state);
  const currentTeamId = Object(entities_teams["getCurrentTeamId"])(state);
  const show = Object(views_modals["a" /* isModalOpen */])(state, modalId);
  return {
    currentUserId,
    currentTeamId,
    show
  };
}

function leave_team_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      leaveTeam: actions_teams["removeUserFromTeam"],
      toggleSideBarRightMenu: global_actions["o" /* toggleSideBarRightMenuAction */]
    }, dispatch)
  };
}

/* harmony default export */ var components_leave_team_modal = (Object(es["connect"])(leave_team_modal_mapStateToProps, leave_team_modal_mapDispatchToProps)(leave_team_modal));
// EXTERNAL MODULE: ./node_modules/bundle-loader?lazy!./components/new_user_settings/index.js
var new_user_settings = __webpack_require__(2963);
var new_user_settings_default = /*#__PURE__*/__webpack_require__.n(new_user_settings);

// EXTERNAL MODULE: ./node_modules/bundle-loader?lazy!./components/settings_sidebar.jsx
var settings_sidebar = __webpack_require__(1851);
var settings_sidebar_default = /*#__PURE__*/__webpack_require__.n(settings_sidebar);

// CONCATENATED MODULE: ./components/new_user_settings/modal/user_settings_modal.jsx
function user_settings_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









 // import loadUserSettings from 'bundle-loader?lazy!components/user_settings';




const user_settings_modal_holders = Object(index_es["g" /* defineMessages */])({
  general: {
    id: Object(i18n["b" /* t */])('user.settings.modal.general'),
    defaultMessage: 'General'
  },
  security: {
    id: Object(i18n["b" /* t */])('user.settings.modal.security'),
    defaultMessage: 'Security'
  },
  notifications: {
    id: Object(i18n["b" /* t */])('user.settings.modal.notifications'),
    defaultMessage: 'Notifications'
  },
  display: {
    id: Object(i18n["b" /* t */])('user.settings.modal.display'),
    defaultMessage: 'Display'
  },
  sidebar: {
    id: Object(i18n["b" /* t */])('user.settings.modal.sidebar'),
    defaultMessage: 'Sidebar'
  },
  advanced: {
    id: Object(i18n["b" /* t */])('user.settings.modal.advanced'),
    defaultMessage: 'Advanced'
  },
  checkEmail: {
    id: 'user.settings.general.checkEmail',
    defaultMessage: 'Check your email at {email} to verify the address. Cannot find the email?'
  },
  confirmTitle: {
    id: Object(i18n["b" /* t */])('user.settings.modal.confirmTitle'),
    defaultMessage: 'Discard Changes?'
  },
  confirmMsg: {
    id: Object(i18n["b" /* t */])('user.settings.modal.confirmMsg'),
    defaultMessage: 'You have unsaved changes, are you sure you want to discard them?'
  },
  confirmBtns: {
    id: Object(i18n["b" /* t */])('user.settings.modal.confirmBtns'),
    defaultMessage: 'Yes, Discard'
  }
});

class user_settings_modal_NewUserSettingsModal extends react_default.a.Component {
  constructor(props) {
    super(props);

    user_settings_modal_defineProperty(this, "handleResend", email => {
      this.setState({
        resendStatus: 'sending'
      });
      this.props.actions.sendVerificationEmail(email).then(({
        data,
        error: err
      }) => {
        if (data) {
          this.setState({
            resendStatus: 'success'
          });
        } else if (err) {
          this.setState({
            resendStatus: 'failure'
          });
        }
      });
    });

    user_settings_modal_defineProperty(this, "handleKeyDown", e => {
      if (utils["e" /* cmdOrCtrlPressed */](e) && e.shiftKey && utils["V" /* isKeyPressed */](e, constants["N" /* default */].KeyCodes.A)) {
        this.handleHide();
      }
    });

    user_settings_modal_defineProperty(this, "handleHide", () => {
      if (this.requireConfirm) {
        this.showConfirmModal(() => this.handleHide());
        return;
      }

      this.props.onHide();
      this.setState({
        show: false
      });
    });

    user_settings_modal_defineProperty(this, "handleHidden", () => {
      this.setState({
        active_tab: this.props.activeTab || 'general',
        active_section: '',
        prev_active_section: 'dummySectionName'
      });
      this.props.onHide();
    });

    user_settings_modal_defineProperty(this, "handleCollapse", () => {
      jquery_default()(react_dom_default.a.findDOMNode(this.modalBodyRef.current)).closest('.modal-dialog').removeClass('display--content');
      this.setState({
        active_tab: '',
        active_section: '',
        prev_active_section: ''
      });
    });

    user_settings_modal_defineProperty(this, "handleConfirm", () => {
      this.setState({
        showConfirmModal: false,
        enforceFocus: true
      });
      this.requireConfirm = false;
      this.customConfirmAction = null;

      if (this.afterConfirm) {
        this.afterConfirm();
        this.afterConfirm = null;
      }
    });

    user_settings_modal_defineProperty(this, "handleCancelConfirmation", () => {
      this.setState({
        showConfirmModal: false,
        enforceFocus: true
      });
      this.afterConfirm = null;
    });

    user_settings_modal_defineProperty(this, "showConfirmModal", afterConfirm => {
      if (afterConfirm) {
        this.afterConfirm = afterConfirm;
      }

      if (this.customConfirmAction) {
        this.customConfirmAction(this.handleConfirm);
        return;
      }

      this.setState({
        showConfirmModal: true,
        enforceFocus: false
      });
    });

    user_settings_modal_defineProperty(this, "closeModal", () => {
      if (this.requireConfirm) {
        this.showConfirmModal(this.closeModal);
      } else {
        this.handleHide();
      }
    });

    user_settings_modal_defineProperty(this, "collapseModal", () => {
      if (this.requireConfirm) {
        this.showConfirmModal(this.collapseModal);
      } else {
        this.handleCollapse();
      }
    });

    user_settings_modal_defineProperty(this, "updateTab", (tab, skipConfirm) => {
      if (!skipConfirm && this.requireConfirm) {
        this.showConfirmModal(() => this.updateTab(tab, true));
      } else {
        this.setState({
          active_tab: tab,
          active_section: '',
          prev_active_section: 'dummySectionName'
        });
      }
    });

    user_settings_modal_defineProperty(this, "updateSection", (section, skipConfirm) => {
      if (!skipConfirm && this.requireConfirm) {
        this.showConfirmModal(() => this.updateSection(section, true));
      } else {
        this.setState({
          prev_active_section: section ? '' : this.state.active_section,
          active_section: section
        });
      }
    });

    this.state = {
      active_tab: props.activeTab || 'general',
      active_section: '',
      prev_active_section: 'dummySectionName',
      // dummy value that should never match any section name
      showConfirmModal: false,
      enforceFocus: true,
      show: true
    };
    this.requireConfirm = false; // Used when settings want to override the default confirm modal with their own
    // If set by a child, it will be called in place of showing the regular confirm
    // modal. It will be passed a function to call on modal confirm

    this.customConfirmAction = null;
    this.modalBodyRef = react_default.a.createRef();
  }

  componentDidMount() {
    document.addEventListener('keydown', this.handleKeyDown);
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleKeyDown);
  }

  componentDidUpdate(prevProps, prevState) {
    if (!utils["Y" /* isMobile */]()) {
      jquery_default()('.settings-content .minimize-settings').perfectScrollbar('update');
    }

    if (this.state.active_tab !== prevState.active_tab) {
      jquery_default()(react_dom_default.a.findDOMNode(this.modalBodyRef.current)).scrollTop(0);
    }
  }

  render() {
    const {
      formatMessage
    } = this.props.intl;

    if (this.props.currentUser == null) {
      return react_default.a.createElement("div", null);
    }

    const modalTitle = type => ({
      // general: '账户设置',
      // notifications: '消息设置',
      // display: '显示',
      general: formatMessage(user_settings_modal_holders.general),
      notifications: formatMessage(user_settings_modal_holders.notifications),
      display: formatMessage(user_settings_modal_holders.display)
    })[type]; // var tabs = [];
    // tabs.push({name: 'general', uiName: formatMessage(holders.general), icon: 'icon fa fa-gear', iconTitle: Utils.localizeMessage('user.settings.general.icon', 'General Settings Icon')});
    // tabs.push({name: 'security', uiName: formatMessage(holders.security), icon: 'icon fa fa-lock', iconTitle: Utils.localizeMessage('user.settings.security.icon', 'Security Settings Icon')});
    // tabs.push({name: 'notifications', uiName: formatMessage(holders.notifications), icon: 'icon fa fa-exclamation-circle', iconTitle: Utils.localizeMessage('user.settings.notifications.icon', 'Notification Settings Icon')});
    // tabs.push({name: 'display', uiName: formatMessage(holders.display), icon: 'icon fa fa-eye', iconTitle: Utils.localizeMessage('user.settings.display.icon', 'Display Settings Icon')});
    // tabs.push({name: 'sidebar', uiName: formatMessage(holders.sidebar), icon: 'icon fa fa-columns', iconTitle: Utils.localizeMessage('user.settings.sidebar.icon', 'Sidebar Settings Icon')});
    // tabs.push({name: 'advanced', uiName: formatMessage(holders.advanced), icon: 'icon fa fa-list-alt', iconTitle: Utils.localizeMessage('user.settings.advance.icon', 'Advanced Settings Icon')});


    return react_default.a.createElement(es_modal["a" /* default */], {
      id: "accountSettingsModal",
      title: modalTitle(this.props.activeTab),
      className: `settings-modal ${this.props.activeTab}`,
      closeIcon: react_default.a.createElement(es_icon["a" /* default */], {
        type: "close-circle",
        theme: "filled"
      }),
      visible: this.state.show,
      onCancel: this.handleHidden,
      role: "dialog",
      footer: null,
      mask: false,
      maskClosable: false,
      centered: true,
      width: '660px'
    }, react_default.a.createElement("div", {
      className: "settings-table",
      ref: this.modalBodyRef
    }, react_default.a.createElement("div", {
      className: "settings-content minimize-settings"
    }, react_default.a.createElement(async_load["a" /* AsyncComponent */], {
      doLoad: new_user_settings_default.a,
      activeTab: this.state.active_tab,
      activeSection: this.state.active_section,
      prevActiveSection: this.state.prev_active_section,
      updateSection: this.updateSection,
      updateTab: this.updateTab,
      closeModal: this.closeModal,
      collapseModal: this.collapseModal,
      setEnforceFocus: enforceFocus => this.setState({
        enforceFocus
      }),
      setRequireConfirm: (requireConfirm, customConfirmAction) => {
        this.requireConfirm = requireConfirm;
        this.customConfirmAction = customConfirmAction;
      }
    }))));
  }

}

user_settings_modal_defineProperty(user_settings_modal_NewUserSettingsModal, "propTypes", {
  currentUser: prop_types_default.a.object.isRequired,
  onHide: prop_types_default.a.func.isRequired,
  intl: index_es["i" /* intlShape */].isRequired,
  actions: prop_types_default.a.shape({
    sendVerificationEmail: prop_types_default.a.func.isRequred
  }).isRequired
});

/* harmony default export */ var modal_user_settings_modal = (Object(index_es["h" /* injectIntl */])(user_settings_modal_NewUserSettingsModal));
// EXTERNAL MODULE: ./components/new_user_settings/modal/index.scss
var new_user_settings_modal = __webpack_require__(2964);

// CONCATENATED MODULE: ./components/new_user_settings/modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function modal_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const closeUnusedDirectMessages = config.CloseUnusedDirectMessages === "true";
  const experimentalChannelOrganization = config.ExperimentalChannelOrganization === "true";
  const sendEmailNotifications = config.SendEmailNotifications === "true";
  const requireEmailVerification = config.RequireEmailVerification === "true";
  const activeTab = state.views.modals.modalState.user_settings ? state.views.modals.modalState.user_settings.activeTab : "general";
  return {
    currentUser: Object(entities_users["getCurrentUser"])(state),
    closeUnusedDirectMessages,
    experimentalChannelOrganization,
    sendEmailNotifications,
    requireEmailVerification,
    activeTab: activeTab
  };
}

function modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      sendVerificationEmail: actions_users["sendVerificationEmail"]
    }, dispatch)
  };
}

/* harmony default export */ var components_new_user_settings_modal = (Object(es["connect"])(modal_mapStateToProps, modal_mapDispatchToProps)(modal_user_settings_modal));
// EXTERNAL MODULE: ./actions/views/search.js
var views_search = __webpack_require__(1626);

// EXTERNAL MODULE: ./components/searchable_user_list/searchable_user_list.jsx + 3 modules
var searchable_user_list = __webpack_require__(2256);

// CONCATENATED MODULE: ./components/searchable_user_list/searchable_user_list_container.jsx
function searchable_user_list_container_extends() { searchable_user_list_container_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return searchable_user_list_container_extends.apply(this, arguments); }

function searchable_user_list_container_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class searchable_user_list_container_SearchableUserListContainer extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.handleTermChange = this.handleTermChange.bind(this);
    this.nextPage = this.nextPage.bind(this);
    this.previousPage = this.previousPage.bind(this);
    this.search = this.search.bind(this);
    this.state = {
      term: '',
      page: 0
    };
  }

  handleTermChange(term) {
    this.setState({
      term
    });
  }

  nextPage() {
    this.setState({
      page: this.state.page + 1
    });
    this.props.nextPage(this.state.page + 1);
  }

  previousPage() {
    this.setState({
      page: this.state.page - 1
    });
  }

  search(term) {
    this.props.search(term);

    if (term !== '') {
      this.setState({
        page: 0
      });
    }
  }

  render() {
    return react_default.a.createElement(searchable_user_list["a" /* default */], searchable_user_list_container_extends({}, this.props, {
      nextPage: this.nextPage,
      previousPage: this.previousPage,
      search: this.search,
      page: this.state.page,
      term: this.state.term,
      onTermChange: this.handleTermChange
    }));
  }

}

searchable_user_list_container_defineProperty(searchable_user_list_container_SearchableUserListContainer, "propTypes", {
  users: prop_types_default.a.arrayOf(prop_types_default.a.object),
  usersPerPage: prop_types_default.a.number,
  total: prop_types_default.a.number,
  extraInfo: prop_types_default.a.object,
  nextPage: prop_types_default.a.func.isRequired,
  search: prop_types_default.a.func.isRequired,
  actions: prop_types_default.a.arrayOf(prop_types_default.a.func),
  actionProps: prop_types_default.a.object,
  actionUserProps: prop_types_default.a.object,
  focusOnMount: prop_types_default.a.bool
});
// EXTERNAL MODULE: ./utils/browser_history.jsx
var browser_history = __webpack_require__(114);

// CONCATENATED MODULE: ./components/icon/dropdown_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class dropdown_icon_DropdownIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.dropdown",
      defaultMessage: "Dropdown Icon"
    }, title => react_default.a.createElement("i", {
      className: "fa fa-angle-down",
      title: title
    }));
  }

}
// CONCATENATED MODULE: ./components/team_members_dropdown/team_members_dropdown.jsx
function team_members_dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const ROWS_FROM_BOTTOM_TO_OPEN_UP = 3;
class team_members_dropdown_TeamMembersDropdown extends react_default.a.Component {
  constructor(props) {
    super(props);

    team_members_dropdown_defineProperty(this, "handleMakeMember", async () => {
      const me = this.props.currentUser;

      if (this.props.user.id === me.id && me.roles.includes('system_admin')) {
        this.handleDemote(this.props.user, 'team_user');
      } else {
        const {
          error
        } = await this.props.actions.updateTeamMemberSchemeRoles(this.props.teamMember.team_id, this.props.user.id, true, false);

        if (error) {
          this.setState({
            serverError: error.message
          });
        } else {
          this.props.actions.getUser(this.props.user.id);
          this.props.actions.getTeamMember(this.props.teamMember.team_id, this.props.user.id);

          if (this.props.user.id === me.id) {
            await this.props.actions.getMyTeamMembers();
            this.props.actions.getMyTeamUnreads();
          }
        }
      }
    });

    team_members_dropdown_defineProperty(this, "handleRemoveFromTeam", async () => {
      const {
        error
      } = await this.props.actions.removeUserFromTeamAndGetStats(this.props.teamMember.team_id, this.props.user.id);

      if (error) {
        this.setState({
          serverError: error.message
        });
      }
    });

    team_members_dropdown_defineProperty(this, "handleMakeAdmin", async () => {
      const me = this.props.currentUser;

      if (this.props.user.id === me.id && me.roles.includes('system_admin')) {
        this.handleDemote(this.props.user, 'team_user team_admin');
      } else {
        const {
          error
        } = await this.props.actions.updateTeamMemberSchemeRoles(this.props.teamMember.team_id, this.props.user.id, true, true);

        if (error) {
          this.setState({
            serverError: error.message
          });
        } else {
          this.props.actions.getUser(this.props.user.id);
          this.props.actions.getTeamMember(this.props.teamMember.team_id, this.props.user.id);
        }
      }
    });

    team_members_dropdown_defineProperty(this, "handleDemote", (user, role, newRole) => {
      this.setState({
        serverError: this.state.serverError,
        showDemoteModal: true,
        user,
        role,
        newRole
      });
    });

    team_members_dropdown_defineProperty(this, "handleDemoteCancel", () => {
      this.setState({
        serverError: null,
        showDemoteModal: false,
        user: null,
        role: null,
        newRole: null
      });
    });

    team_members_dropdown_defineProperty(this, "handleDemoteSubmit", async () => {
      const {
        error
      } = await this.props.actions.updateTeamMemberSchemeRoles(this.props.teamMember.team_id, this.props.user.id, true, false);

      if (error) {
        this.setState({
          serverError: error.message
        });
      } else {
        this.props.actions.getUser(this.props.user.id);
        browser_history["a" /* browserHistory */].push(this.props.teamUrl);
      }
    });

    this.state = {
      serverError: null,
      showDemoteModal: false,
      user: null,
      role: null
    };
  }

  render() {
    let serverError = null;

    if (this.state.serverError) {
      serverError = react_default.a.createElement("div", {
        className: "has-error"
      }, react_default.a.createElement("label", {
        className: "has-error control-label"
      }, this.state.serverError));
    }

    const {
      currentTeam,
      teamMember,
      user
    } = this.props;
    let currentRoles = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_members_dropdown.member",
      defaultMessage: "Member"
    });

    if (teamMember.roles.length > 0 && utils["M" /* isAdmin */](teamMember.roles) || teamMember.scheme_admin) {
      currentRoles = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "team_members_dropdown.teamAdmin",
        defaultMessage: "Team Admin"
      });
    }

    if (user.roles.length > 0 && utils["ab" /* isSystemAdmin */](user.roles)) {
      currentRoles = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "team_members_dropdown.systemAdmin",
        defaultMessage: "System Admin"
      });
    }

    const me = this.props.currentUser;
    let showMakeMember = (utils["M" /* isAdmin */](teamMember.roles) || teamMember.scheme_admin) && !utils["ab" /* isSystemAdmin */](user.roles);
    let showMakeAdmin = !utils["M" /* isAdmin */](teamMember.roles) && !utils["ab" /* isSystemAdmin */](user.roles) && !teamMember.scheme_admin;

    if (user.delete_at > 0) {
      currentRoles = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "team_members_dropdown.inactive",
        defaultMessage: "Inactive"
      });
      showMakeMember = false;
      showMakeAdmin = false;
    }

    const canRemoveFromTeam = user.id !== me.id && !currentTeam.group_constrained;
    let makeDemoteModal = null;

    if (user.id === me.id) {
      const title = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "team_members_dropdown.confirmDemoteRoleTitle",
        defaultMessage: "Confirm demotion from System Admin role"
      });
      const message = react_default.a.createElement("div", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "team_members_dropdown.confirmDemoteDescription",
        defaultMessage: "If you demote yourself from the System Admin role and there is not another user with System Admin privileges, you'll need to re-assign a System Admin by accessing the Mattermost server through a terminal and running the following command."
      }), react_default.a.createElement("br", null), react_default.a.createElement("br", null), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "team_members_dropdown.confirmDemotionCmd",
        defaultMessage: "platform roles system_admin {username}",
        vallues: {
          username: me.username
        }
      }), serverError);
      const confirmButton = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "team_members_dropdown.confirmDemotion",
        defaultMessage: "Confirm Demotion"
      });
      makeDemoteModal = react_default.a.createElement(confirm_modal["a" /* default */], {
        show: this.state.showDemoteModal,
        title: title,
        message: message,
        confirmButtonText: confirmButton,
        onConfirm: this.handleDemoteSubmit,
        onCancel: this.handleDemoteCancel
      });
    }

    if (!canRemoveFromTeam && !showMakeAdmin && !showMakeMember) {
      return react_default.a.createElement("div", null, currentRoles);
    }

    const {
      index,
      totalUsers
    } = this.props;
    let openUp = false;

    if (totalUsers > ROWS_FROM_BOTTOM_TO_OPEN_UP && totalUsers - index <= ROWS_FROM_BOTTOM_TO_OPEN_UP) {
      openUp = true;
    }

    return react_default.a.createElement(menu_wrapper["a" /* default */], null, react_default.a.createElement("button", {
      id: `teamMembersDropdown_${user.username}`,
      className: "dropdown-toggle theme color--link style--none",
      type: "button",
      "aria-expanded": "true"
    }, react_default.a.createElement("span", null, currentRoles, " "), react_default.a.createElement(dropdown_icon_DropdownIcon, null)), react_default.a.createElement("div", null, react_default.a.createElement(menu_menu["a" /* default */], {
      openLeft: true,
      openUp: openUp,
      ariaLabel: utils["gb" /* localizeMessage */]('team_members_dropdown.menuAriaLabel', 'Team member role change')
    }, react_default.a.createElement(menu_item_action["a" /* default */], {
      id: "removeFromTeam",
      show: canRemoveFromTeam,
      onClick: this.handleRemoveFromTeam,
      text: utils["gb" /* localizeMessage */]('team_members_dropdown.leave_team', 'Remove From Team')
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      show: showMakeAdmin,
      onClick: this.handleMakeAdmin,
      text: utils["gb" /* localizeMessage */]('team_members_dropdown.makeAdmin', 'Make Team Admin')
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      show: showMakeMember,
      onClick: this.handleMakeMember,
      text: utils["gb" /* localizeMessage */]('team_members_dropdown.makeMember', 'Make Member')
    })), makeDemoteModal, serverError));
  }

}

team_members_dropdown_defineProperty(team_members_dropdown_TeamMembersDropdown, "propTypes", {
  user: prop_types_default.a.object.isRequired,
  currentUser: prop_types_default.a.object.isRequired,
  teamMember: prop_types_default.a.object.isRequired,
  teamUrl: prop_types_default.a.string.isRequired,
  currentTeam: prop_types_default.a.object.isRequired,
  index: prop_types_default.a.number.isRequired,
  totalUsers: prop_types_default.a.number.isRequired,
  actions: prop_types_default.a.shape({
    getMyTeamMembers: prop_types_default.a.func.isRequired,
    getMyTeamUnreads: prop_types_default.a.func.isRequired,
    getUser: prop_types_default.a.func.isRequired,
    getTeamMember: prop_types_default.a.func.isRequired,
    getTeamStats: prop_types_default.a.func.isRequired,
    getChannelStats: prop_types_default.a.func.isRequired,
    updateTeamMemberSchemeRoles: prop_types_default.a.func.isRequired,
    removeUserFromTeamAndGetStats: prop_types_default.a.func.isRequired,
    updateUserActive: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/team_members_dropdown/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











function team_members_dropdown_mapStateToProps(state) {
  return {
    currentUser: Object(entities_users["getCurrentUser"])(state),
    currentChannelId: Object(entities_channels["getCurrentChannelId"])(state),
    teamUrl: Object(entities_teams["getCurrentRelativeTeamUrl"])(state),
    currentTeam: Object(entities_teams["getCurrentTeam"])(state)
  };
}

function team_members_dropdown_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getMyTeamMembers: actions_teams["getMyTeamMembers"],
      getMyTeamUnreads: actions_teams["getMyTeamUnreads"],
      getUser: actions_users["getUser"],
      getTeamMember: actions_teams["getTeamMember"],
      getTeamStats: actions_teams["getTeamStats"],
      getChannelStats: actions_channels["getChannelStats"],
      updateUserActive: actions_users["updateUserActive"],
      updateTeamMemberSchemeRoles: actions_teams["updateTeamMemberSchemeRoles"],
      removeUserFromTeamAndGetStats: team_actions["d" /* removeUserFromTeamAndGetStats */]
    }, dispatch)
  };
}

/* harmony default export */ var team_members_dropdown = (Object(es["connect"])(team_members_dropdown_mapStateToProps, team_members_dropdown_mapDispatchToProps)(team_members_dropdown_TeamMembersDropdown));
// CONCATENATED MODULE: ./components/member_list_team/member_list_team.jsx
function member_list_team_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const USERS_PER_PAGE = 50;
class member_list_team_MemberListTeam extends react_default.a.Component {
  constructor(props) {
    super(props);

    member_list_team_defineProperty(this, "loadComplete", () => {
      this.setState({
        loading: false
      });
    });

    member_list_team_defineProperty(this, "nextPage", page => {
      this.props.actions.loadProfilesAndTeamMembers(page + 1, USERS_PER_PAGE);
    });

    member_list_team_defineProperty(this, "search", term => {
      this.props.actions.setModalSearchTerm(term);
    });

    this.searchTimeoutId = 0;
    this.state = {
      loading: true
    };
  }

  componentDidMount() {
    this.props.actions.loadProfilesAndTeamMembers(0, constants["N" /* default */].PROFILE_CHUNK_SIZE, this.props.currentTeamId).then(({
      data
    }) => {
      if (data) {
        this.loadComplete();
      }
    });
    this.props.actions.getTeamStats(this.props.currentTeamId);
  }

  componentWillUnmount() {
    this.props.actions.setModalSearchTerm('');
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.searchTerm !== nextProps.searchTerm) {
      clearTimeout(this.searchTimeoutId);
      const searchTerm = nextProps.searchTerm;

      if (searchTerm === '') {
        this.loadComplete();
        this.searchTimeoutId = '';
        return;
      }

      const searchTimeoutId = setTimeout(async () => {
        const {
          loadStatusesForProfilesList,
          loadTeamMembersForProfilesList,
          searchProfiles
        } = nextProps.actions;
        const {
          data
        } = await searchProfiles(searchTerm, {
          team_id: nextProps.currentTeamId
        });

        if (searchTimeoutId !== this.searchTimeoutId) {
          return;
        }

        this.setState({
          loading: true
        });
        loadStatusesForProfilesList(data);
        loadTeamMembersForProfilesList(data, nextProps.currentTeamId).then(({
          data: membersLoaded
        }) => {
          if (membersLoaded) {
            this.loadComplete();
          }
        });
      }, constants["N" /* default */].SEARCH_TIMEOUT_MILLISECONDS);
      this.searchTimeoutId = searchTimeoutId;
    }
  }

  render() {
    let teamMembersDropdown = null;

    if (this.props.canManageTeamMembers) {
      teamMembersDropdown = [team_members_dropdown];
    }

    const teamMembers = this.props.teamMembers;
    const users = this.props.users;
    const actionUserProps = {};
    let usersToDisplay;

    if (this.state.loading) {
      usersToDisplay = null;
    } else {
      usersToDisplay = [];

      for (let i = 0; i < users.length; i++) {
        const user = users[i];

        if (teamMembers[user.id] && user.delete_at === 0) {
          usersToDisplay.push(user);
          actionUserProps[user.id] = {
            teamMember: teamMembers[user.id]
          };
        }
      }
    }

    return react_default.a.createElement(searchable_user_list_container_SearchableUserListContainer, {
      users: usersToDisplay,
      usersPerPage: USERS_PER_PAGE,
      total: this.props.totalTeamMembers,
      nextPage: this.nextPage,
      search: this.search,
      actions: teamMembersDropdown,
      actionUserProps: actionUserProps,
      focusOnMount: !user_agent["m" /* isMobile */]()
    });
  }

}

member_list_team_defineProperty(member_list_team_MemberListTeam, "propTypes", {
  searchTerm: prop_types_default.a.string.isRequired,
  users: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,
  teamMembers: prop_types_default.a.object.isRequired,
  currentTeamId: prop_types_default.a.string.isRequired,
  totalTeamMembers: prop_types_default.a.number.isRequired,
  canManageTeamMembers: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    searchProfiles: prop_types_default.a.func.isRequired,
    getTeamStats: prop_types_default.a.func.isRequired,
    loadProfilesAndTeamMembers: prop_types_default.a.func.isRequired,
    loadStatusesForProfilesList: prop_types_default.a.func.isRequired,
    loadTeamMembersForProfilesList: prop_types_default.a.func.isRequired,
    setModalSearchTerm: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/member_list_team/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













function member_list_team_mapStateToProps(state, ownProps) {
  const canManageTeamMembers = Object(roles["haveITeamPermission"])(state, {
    team: ownProps.teamId,
    permission: mattermost_redux_constants["Permissions"].MANAGE_TEAM_ROLES
  });
  const searchTerm = state.views.search.modalSearch;
  let users;

  if (searchTerm) {
    users = Object(entities_users["searchProfilesInCurrentTeam"])(state, searchTerm);
  } else {
    users = Object(entities_users["getProfilesInCurrentTeam"])(state);
  }

  const stats = Object(entities_teams["getCurrentTeamStats"])(state) || {
    active_member_count: 0
  };
  return {
    searchTerm,
    users,
    teamMembers: Object(entities_teams["getMembersInCurrentTeam"])(state) || {},
    currentTeamId: state.entities.teams.currentTeamId,
    totalTeamMembers: stats.active_member_count,
    canManageTeamMembers
  };
}

function member_list_team_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      searchProfiles: actions_users["searchProfiles"],
      getTeamStats: actions_teams["getTeamStats"],
      loadProfilesAndTeamMembers: user_actions["f" /* loadProfilesAndTeamMembers */],
      loadStatusesForProfilesList: status_actions["b" /* loadStatusesForProfilesList */],
      loadTeamMembersForProfilesList: user_actions["l" /* loadTeamMembersForProfilesList */],
      setModalSearchTerm: views_search["a" /* setModalSearchTerm */]
    }, dispatch)
  };
}

/* harmony default export */ var member_list_team = (Object(es["connect"])(member_list_team_mapStateToProps, member_list_team_mapDispatchToProps)(member_list_team_MemberListTeam));
// CONCATENATED MODULE: ./components/team_members_modal/team_members_modal.jsx
function team_members_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class team_members_modal_TeamMembersModal extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    team_members_modal_defineProperty(this, "onHide", () => {
      this.props.onHide();
    });
  }

  componentDidMount() {
    if (this.props.onLoad) {
      this.props.onLoad();
    }
  }

  render() {
    let teamDisplayName = '';

    if (this.props.currentTeam) {
      teamDisplayName = this.props.currentTeam.display_name;
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "more-modal",
      show: this.props.show,
      onHide: this.onHide,
      onExited: this.props.onHide,
      role: "dialog",
      "aria-labelledby": "teamMemberModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "teamMemberModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_member_modal.members",
      defaultMessage: "{team} Members",
      values: {
        team: teamDisplayName
      }
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement(member_list_team, {
      teamId: this.props.currentTeam.id
    })));
  }

}

team_members_modal_defineProperty(team_members_modal_TeamMembersModal, "propTypes", {
  show: prop_types_default.a.bool.isRequired,
  currentTeam: prop_types_default.a.object.isRequired,
  onHide: prop_types_default.a.func.isRequired,
  onLoad: prop_types_default.a.func
});
// CONCATENATED MODULE: ./components/team_members_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function team_members_modal_mapStateToProps(state) {
  const modalId = constants["p" /* ModalIdentifiers */].TEAM_MEMBERS;
  return {
    currentTeam: Object(entities_teams["getCurrentTeam"])(state),
    show: Object(views_modals["a" /* isModalOpen */])(state, modalId)
  };
}

/* harmony default export */ var team_members_modal = (Object(es["connect"])(team_members_modal_mapStateToProps)(team_members_modal_TeamMembersModal));
// EXTERNAL MODULE: ./components/setting_item_max.jsx
var setting_item_max = __webpack_require__(1579);

// EXTERNAL MODULE: ./components/setting_item_min.jsx
var setting_item_min = __webpack_require__(1583);

// EXTERNAL MODULE: ./components/setting_picture.jsx
var setting_picture = __webpack_require__(2185);

// EXTERNAL MODULE: ./components/icon/back_icon.jsx
var back_icon = __webpack_require__(1711);

// CONCATENATED MODULE: ./components/team_general_tab/team_general_tab.jsx
function team_general_tab_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













const ACCEPTED_TEAM_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/bmp'];
class team_general_tab_GeneralTab extends react_default.a.Component {
  constructor(props) {
    super(props);

    team_general_tab_defineProperty(this, "handleAllowedDomainsSubmit", async () => {
      var state = {
        serverError: '',
        clientError: ''
      };
      var data = { ...this.props.team
      };
      data.allowed_domains = this.state.allowed_domains;
      const {
        error
      } = await this.props.actions.patchTeam(data);

      if (error) {
        state.serverError = error.message;
        this.setState(state);
      } else {
        this.updateSection('');
      }
    });

    team_general_tab_defineProperty(this, "handleOpenInviteSubmit", async () => {
      var state = {
        serverError: '',
        clientError: ''
      };
      var data = { ...this.props.team
      };
      data.allow_open_invite = this.state.allow_open_invite;
      const {
        error
      } = await this.props.actions.patchTeam(data);

      if (error) {
        state.serverError = error.message;
        this.setState(state);
      } else {
        this.updateSection('');
      }
    });

    team_general_tab_defineProperty(this, "handleNameSubmit", async () => {
      var state = {
        serverError: '',
        clientError: ''
      };
      let valid = true;
      const name = this.state.name.trim();

      if (!name) {
        state.clientError = utils["gb" /* localizeMessage */]('general_tab.required', 'This field is required');
        valid = false;
      } else if (name.length < constants["N" /* default */].MIN_TEAMNAME_LENGTH) {
        state.clientError = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "general_tab.teamNameRestrictions",
          defaultMessage: "Team Name must be {min} or more characters up to a maximum of {max}. You can add a longer team description.",
          values: {
            min: constants["N" /* default */].MIN_TEAMNAME_LENGTH,
            max: constants["N" /* default */].MAX_TEAMNAME_LENGTH
          }
        });
        valid = false;
      } else {
        state.clientError = '';
      }

      this.setState(state);

      if (!valid) {
        return;
      }

      var data = { ...this.props.team
      };
      data.display_name = this.state.name;
      const {
        error
      } = await this.props.actions.patchTeam(data);

      if (error) {
        state.serverError = error.message;
        this.setState(state);
      } else {
        this.updateSection('');
      }
    });

    team_general_tab_defineProperty(this, "handleInviteIdSubmit", async () => {
      const state = {
        serverError: '',
        clientError: ''
      };
      this.setState(state);
      const {
        error
      } = await this.props.actions.regenerateTeamInviteId(this.props.team.id);

      if (error) {
        state.serverError = error.message;
        this.setState(state);
      } else {
        this.updateSection('');
      }
    });

    team_general_tab_defineProperty(this, "handleDescriptionSubmit", async () => {
      var state = {
        serverError: '',
        clientError: ''
      };
      let valid = true;
      const description = this.state.description.trim();

      if (description === this.props.team.description) {
        state.clientError = utils["gb" /* localizeMessage */]('general_tab.chooseDescription', 'Please choose a new description for your team');
        valid = false;
      } else {
        state.clientError = '';
      }

      this.setState(state);

      if (!valid) {
        return;
      }

      var data = { ...this.props.team
      };
      data.description = this.state.description;
      const {
        error
      } = await this.props.actions.patchTeam(data);

      if (error) {
        state.serverError = error.message;
        this.setState(state);
      } else {
        this.updateSection('');
      }
    });

    team_general_tab_defineProperty(this, "handleTeamIconSubmit", async () => {
      if (!this.state.teamIconFile) {
        return;
      }

      if (!this.state.submitActive) {
        return;
      }

      this.setState({
        loadingIcon: true,
        clientError: '',
        serverError: ''
      });
      const {
        error
      } = await this.props.actions.setTeamIcon(this.props.team.id, this.state.teamIconFile);

      if (error) {
        this.setState({
          loadingIcon: false,
          serverError: error.message
        });
      } else {
        this.setState({
          loadingIcon: false,
          submitActive: false
        });
        this.updateSection('');
      }
    });

    team_general_tab_defineProperty(this, "handleTeamIconRemove", async () => {
      this.setState({
        loadingIcon: true,
        clientError: '',
        serverError: ''
      });
      const {
        error
      } = await this.props.actions.removeTeamIcon(this.props.team.id);

      if (error) {
        this.setState({
          loadingIcon: false,
          serverError: error.message
        });
      } else {
        this.setState({
          loadingIcon: false,
          submitActive: false
        });
        this.updateSection('');
      }
    });

    team_general_tab_defineProperty(this, "handleUpdateSection", section => {
      this.updateSection(section);
    });

    this.updateSection = this.updateSection.bind(this);
    this.handleNameSubmit = this.handleNameSubmit.bind(this);
    this.handleAllowedDomainsSubmit = this.handleAllowedDomainsSubmit.bind(this);
    this.handleInviteIdSubmit = this.handleInviteIdSubmit.bind(this);
    this.handleOpenInviteSubmit = this.handleOpenInviteSubmit.bind(this);
    this.handleDescriptionSubmit = this.handleDescriptionSubmit.bind(this);
    this.handleTeamIconSubmit = this.handleTeamIconSubmit.bind(this);
    this.handleClose = this.handleClose.bind(this);
    this.updateName = this.updateName.bind(this);
    this.updateDescription = this.updateDescription.bind(this);
    this.updateTeamIcon = this.updateTeamIcon.bind(this);
    this.updateAllowedDomains = this.updateAllowedDomains.bind(this);
    this.handleOpenInviteRadio = this.handleOpenInviteRadio.bind(this);
    this.state = this.setupInitialState(props);
  }

  updateSection(section) {
    if (jquery_default()('.section-max').length) {
      jquery_default()('.settings-modal .modal-body').scrollTop(0).perfectScrollbar('update');
    }

    this.setState(this.setupInitialState(this.props));
    this.props.updateSection(section);
  }

  setupInitialState(props) {
    const team = props.team;
    return {
      name: team.display_name,
      invite_id: team.invite_id,
      allow_open_invite: team.allow_open_invite,
      description: team.description,
      allowed_domains: team.allowed_domains,
      serverError: '',
      clientError: '',
      teamIconFile: null,
      loadingIcon: false,
      submitActive: false
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    this.setState({
      name: nextProps.team.display_name,
      description: nextProps.team.description,
      allowed_domains: nextProps.team.allowed_domains,
      invite_id: nextProps.team.invite_id,
      allow_open_invite: nextProps.team.allow_open_invite
    });
  }

  handleOpenInviteRadio(openInvite) {
    this.setState({
      allow_open_invite: openInvite
    });
  }

  handleClose() {
    this.updateSection('');
  }

  componentDidMount() {
    jquery_default()('#team_settings').on('hidden.bs.modal', this.handleClose);
  }

  componentWillUnmount() {
    jquery_default()('#team_settings').off('hidden.bs.modal', this.handleClose);
  }

  updateName(e) {
    this.setState({
      name: e.target.value
    });
  }

  updateDescription(e) {
    this.setState({
      description: e.target.value
    });
  }

  updateTeamIcon(e) {
    if (e && e.target && e.target.files && e.target.files[0]) {
      const file = e.target.files[0];

      if (!ACCEPTED_TEAM_IMAGE_TYPES.includes(file.type)) {
        this.setState({
          clientError: utils["gb" /* localizeMessage */]('general_tab.teamIconInvalidFileType', 'Only BMP, JPG or PNG images may be used for team icons')
        });
      } else if (file.size > this.props.maxFileSize) {
        this.setState({
          clientError: utils["gb" /* localizeMessage */]('general_tab.teamIconTooLarge', 'Unable to upload team icon. File is too large.')
        });
      } else {
        this.setState({
          teamIconFile: e.target.files[0],
          clientError: '',
          submitActive: true
        });
      }
    } else {
      this.setState({
        teamIconFile: null,
        clientError: utils["gb" /* localizeMessage */]('general_tab.teamIconError', 'An error occurred while selecting the image.')
      });
    }
  }

  updateAllowedDomains(e) {
    this.setState({
      allowed_domains: e.target.value
    });
  }

  render() {
    const team = this.props.team;
    let clientError = null;
    let serverError = null;

    if (this.state.clientError) {
      clientError = this.state.clientError;
    }

    if (this.state.serverError) {
      serverError = this.state.serverError;
    }

    let openInviteSection;

    if (this.props.activeSection === 'open_invite') {
      let inputs;

      if (team.group_constrained) {
        inputs = [react_default.a.createElement("div", {
          key: "userOpenInviteOptions"
        }, react_default.a.createElement("div", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
          id: "team_settings.openInviteDescription.groupConstrained",
          defaultMessage: "No, members of this team are added and removed by linked groups. [Learn More](https://mattermost.com/pl/default-ldap-group-constrained-team-channel.html)"
        })))];
      } else {
        inputs = [react_default.a.createElement("div", {
          key: "userOpenInviteOptions"
        }, react_default.a.createElement("div", {
          className: "radio"
        }, react_default.a.createElement("label", null, react_default.a.createElement("input", {
          id: "teamOpenInvite",
          name: "userOpenInviteOptions",
          type: "radio",
          defaultChecked: this.state.allow_open_invite,
          onChange: this.handleOpenInviteRadio.bind(this, true)
        }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "general_tab.yes",
          defaultMessage: "Yes"
        })), react_default.a.createElement("br", null)), react_default.a.createElement("div", {
          className: "radio"
        }, react_default.a.createElement("label", null, react_default.a.createElement("input", {
          id: "teamOpenInviteNo",
          name: "userOpenInviteOptions",
          type: "radio",
          defaultChecked: !this.state.allow_open_invite,
          onChange: this.handleOpenInviteRadio.bind(this, false)
        }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "general_tab.no",
          defaultMessage: "No"
        })), react_default.a.createElement("br", null)), react_default.a.createElement("div", null, react_default.a.createElement("br", null), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "general_tab.openInviteDesc",
          defaultMessage: "When allowed, a link to this team will be included on the landing page allowing anyone with an account to join this team."
        })))];
      }

      openInviteSection = react_default.a.createElement(setting_item_max["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.openInviteTitle', 'Allow any user with an account on this server to join this team'),
        inputs: inputs,
        submit: this.handleOpenInviteSubmit,
        serverError: serverError,
        updateSection: this.handleUpdateSection
      });
    } else {
      let describe = '';

      if (this.state.allow_open_invite === true) {
        describe = utils["gb" /* localizeMessage */]('general_tab.yes', 'Yes');
      } else if (team.group_constrained) {
        describe = utils["gb" /* localizeMessage */]('team_settings.openInviteSetting.groupConstrained', 'No, members of this team are added and removed by linked groups.');
      } else {
        describe = utils["gb" /* localizeMessage */]('general_tab.no', 'No');
      }

      openInviteSection = react_default.a.createElement(setting_item_min["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.openInviteTitle', 'Allow any user with an account on this server to join this team'),
        describe: describe,
        updateSection: this.handleUpdateSection,
        section: 'open_invite'
      });
    }

    let inviteSection;

    if (this.props.activeSection === 'invite_id' && this.props.canInviteTeamMembers) {
      const inputs = [];
      inputs.push(react_default.a.createElement("div", {
        key: "teamInviteSetting"
      }, react_default.a.createElement("div", {
        className: "row"
      }, react_default.a.createElement("label", {
        className: "col-sm-5 control-label visible-xs-block"
      }), react_default.a.createElement("div", {
        className: "col-sm-12"
      }, react_default.a.createElement("input", {
        id: "teamInviteId",
        autoFocus: true,
        className: "form-control",
        type: "text",
        value: this.state.invite_id,
        maxLength: "32",
        onFocus: utils["ib" /* moveCursorToEnd */],
        readOnly: true
      }))), react_default.a.createElement("div", {
        className: "setting-list__hint"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "general_tab.codeLongDesc",
        defaultMessage: "The Invite Code is used as part of the URL in the team invitation link created by {getTeamInviteLink} in the main menu. Regenerating creates a new team invitation link and invalidates the previous link.",
        values: {
          getTeamInviteLink: react_default.a.createElement("strong", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "general_tab.getTeamInviteLink",
            defaultMessage: "Get Team Invite Link"
          }))
        }
      }))));
      inviteSection = react_default.a.createElement(setting_item_max["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.codeTitle', 'Invite Code'),
        inputs: inputs,
        submit: this.handleInviteIdSubmit,
        serverError: serverError,
        clientError: clientError,
        updateSection: this.handleUpdateSection,
        saveButtonText: utils["gb" /* localizeMessage */]('general_tab.regenerate', 'Regenerate')
      });
    } else if (this.props.canInviteTeamMembers) {
      inviteSection = react_default.a.createElement(setting_item_min["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.codeTitle', 'Invite Code'),
        describe: utils["gb" /* localizeMessage */]('general_tab.codeDesc', "Click 'Edit' to regenerate Invite Code."),
        updateSection: this.handleUpdateSection,
        section: 'invite_id'
      });
    }

    let nameSection;

    if (this.props.activeSection === 'name') {
      const inputs = [];
      let teamNameLabel = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "general_tab.teamName",
        defaultMessage: "Team Name"
      });

      if (utils["Y" /* isMobile */]()) {
        teamNameLabel = '';
      }

      inputs.push(react_default.a.createElement("div", {
        key: "teamNameSetting",
        className: "form-group"
      }, react_default.a.createElement("label", {
        className: "col-sm-5 control-label"
      }, teamNameLabel), react_default.a.createElement("div", {
        className: "col-sm-7"
      }, react_default.a.createElement("input", {
        id: "teamName",
        autoFocus: true,
        className: "form-control",
        type: "text",
        maxLength: constants["N" /* default */].MAX_TEAMNAME_LENGTH.toString(),
        onChange: this.updateName,
        value: this.state.name,
        onFocus: utils["ib" /* moveCursorToEnd */]
      }))));
      const nameExtraInfo = react_default.a.createElement("span", null, utils["gb" /* localizeMessage */]('general_tab.teamNameInfo', 'Set the name of the team as it appears on your sign-in screen and at the top of the left-hand sidebar.'));
      nameSection = react_default.a.createElement(setting_item_max["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.teamName', 'Team Name'),
        inputs: inputs,
        submit: this.handleNameSubmit,
        serverError: serverError,
        clientError: clientError,
        updateSection: this.handleUpdateSection,
        extraInfo: nameExtraInfo
      });
    } else {
      var describe = this.state.name;
      nameSection = react_default.a.createElement(setting_item_min["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.teamName', 'Team Name'),
        describe: describe,
        updateSection: this.handleUpdateSection,
        section: 'name'
      });
    }

    let descriptionSection;

    if (this.props.activeSection === 'description') {
      const inputs = [];
      let teamDescriptionLabel = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "general_tab.teamDescription",
        defaultMessage: "Team Description"
      });

      if (utils["Y" /* isMobile */]()) {
        teamDescriptionLabel = '';
      }

      inputs.push(react_default.a.createElement("div", {
        key: "teamDescriptionSetting",
        className: "form-group"
      }, react_default.a.createElement("label", {
        className: "col-sm-5 control-label"
      }, teamDescriptionLabel), react_default.a.createElement("div", {
        className: "col-sm-7"
      }, react_default.a.createElement("input", {
        id: "teamDescription",
        autoFocus: true,
        className: "form-control",
        type: "text",
        maxLength: constants["N" /* default */].MAX_TEAMDESCRIPTION_LENGTH.toString(),
        onChange: this.updateDescription,
        value: this.state.description,
        onFocus: utils["ib" /* moveCursorToEnd */]
      }))));
      const descriptionExtraInfo = react_default.a.createElement("span", null, utils["gb" /* localizeMessage */]('general_tab.teamDescriptionInfo', 'Team description provides additional information to help users select the right team. Maximum of 50 characters.'));
      descriptionSection = react_default.a.createElement(setting_item_max["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.teamDescription', 'Team Description'),
        inputs: inputs,
        submit: this.handleDescriptionSubmit,
        serverError: serverError,
        clientError: clientError,
        updateSection: this.handleUpdateSection,
        extraInfo: descriptionExtraInfo
      });
    } else {
      let describemsg = '';

      if (this.state.description) {
        describemsg = this.state.description;
      } else {
        describemsg = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "general_tab.emptyDescription",
          defaultMessage: "Click 'Edit' to add a team description."
        });
      }

      descriptionSection = react_default.a.createElement(setting_item_min["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.teamDescription', 'Team Description'),
        describe: describemsg,
        updateSection: this.handleUpdateSection,
        section: 'description'
      });
    }

    let teamIconSection;

    if (this.props.activeSection === 'team_icon') {
      teamIconSection = react_default.a.createElement(setting_picture["a" /* default */], {
        imageContext: "team",
        title: utils["gb" /* localizeMessage */]('general_tab.teamIcon', 'Team Icon'),
        src: utils["J" /* imageURLForTeam */](team),
        file: this.state.teamIconFile,
        serverError: this.state.serverError,
        clientError: this.state.clientError,
        loadingPicture: this.state.loadingIcon,
        submitActive: this.state.submitActive,
        updateSection: e => {
          this.updateSection('');
          e.preventDefault();
        },
        onFileChange: this.updateTeamIcon,
        onSubmit: this.handleTeamIconSubmit,
        onRemove: this.handleTeamIconRemove
      });
    } else {
      let minMessage;

      if (team.last_team_icon_update) {
        minMessage = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "general_tab.teamIconLastUpdated",
          defaultMessage: "Image last updated {date}",
          values: {
            date: react_default.a.createElement(index_es["a" /* FormattedDate */], {
              value: new Date(team.last_team_icon_update),
              day: "2-digit",
              month: "short",
              year: "numeric"
            })
          }
        });
      } else {
        minMessage = utils["Y" /* isMobile */]() ? utils["gb" /* localizeMessage */]('general_tab.teamIconEditHintMobile', 'Click to upload an image.') : utils["gb" /* localizeMessage */]('general_tab.teamIconEditHint', 'Click \'Edit\' to upload an image.');
      }

      teamIconSection = react_default.a.createElement(setting_item_min["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.teamIcon', 'Team Icon'),
        describe: minMessage,
        section: 'team_icon',
        updateSection: this.handleUpdateSection
      });
    }

    let allowedDomainsSection;

    if (this.props.activeSection === 'allowed_domains') {
      const inputs = [];
      inputs.push(react_default.a.createElement("div", {
        key: "allowedDomainsSetting",
        className: "form-group"
      }, react_default.a.createElement("div", {
        className: "col-sm-12"
      }, react_default.a.createElement(localized_input["a" /* default */], {
        id: "allowedDomains",
        autoFocus: true,
        className: "form-control",
        type: "text",
        onChange: this.updateAllowedDomains,
        value: this.state.allowed_domains,
        onFocus: utils["ib" /* moveCursorToEnd */],
        placeholder: {
          id: Object(i18n["b" /* t */])('general_tab.AllowedDomainsExample'),
          defaultMessage: 'corp.mattermost.com, mattermost.org'
        }
      }))));
      const allowedDomainsInfo = react_default.a.createElement("span", null, utils["gb" /* localizeMessage */]('general_tab.AllowedDomainsInfo', 'Users can only join the team if their email matches a specific domain (e.g. "aboutone.org") or list of comma-separated domains (e.g. "corp.mattermost.com, mattermost.org").'));
      allowedDomainsSection = react_default.a.createElement(setting_item_max["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.allowedDomains', 'Allow only users with a specific email domain to join this team'),
        inputs: inputs,
        submit: this.handleAllowedDomainsSubmit,
        serverError: serverError,
        clientError: clientError,
        updateSection: this.handleUpdateSection,
        extraInfo: allowedDomainsInfo
      });
    } else {
      let describemsg = '';

      if (this.state.allowed_domains) {
        describemsg = this.state.allowed_domains;
      } else {
        describemsg = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "general_tab.allowedDomainsEdit",
          defaultMessage: "Click 'Edit' to add an email domain whitelist."
        });
      }

      allowedDomainsSection = react_default.a.createElement(setting_item_min["a" /* default */], {
        title: utils["gb" /* localizeMessage */]('general_tab.allowedDomains', 'allowedDomains'),
        describe: describemsg,
        updateSection: this.handleUpdateSection,
        section: 'allowed_domains'
      });
    }

    return react_default.a.createElement("div", null, react_default.a.createElement("div", {
      className: "modal-header"
    }, react_default.a.createElement("button", {
      id: "closeButton",
      type: "button",
      className: "close",
      "data-dismiss": "modal",
      "aria-label": "Close",
      onClick: this.props.closeModal
    }, react_default.a.createElement("span", {
      "aria-hidden": "true"
    }, '×')), react_default.a.createElement("h4", {
      className: "modal-title",
      ref: "title"
    }, react_default.a.createElement("div", {
      className: "modal-back"
    }, react_default.a.createElement("span", {
      onClick: this.props.collapseModal
    }, react_default.a.createElement(back_icon["a" /* default */], null))), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "general_tab.title",
      defaultMessage: "General Settings"
    }))), react_default.a.createElement("div", {
      ref: "wrapper",
      className: "user-settings"
    }, react_default.a.createElement("h3", {
      className: "tab-header"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "general_tab.title",
      defaultMessage: "General Settings"
    })), react_default.a.createElement("div", {
      className: "divider-dark first"
    }), nameSection, react_default.a.createElement("div", {
      className: "divider-light"
    }), descriptionSection, react_default.a.createElement("div", {
      className: "divider-light"
    }), teamIconSection, !team.group_constrained && react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("div", {
      className: "divider-light"
    }), allowedDomainsSection), react_default.a.createElement("div", {
      className: "divider-light"
    }), openInviteSection, !team.group_constrained && react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("div", {
      className: "divider-light"
    }), inviteSection), react_default.a.createElement("div", {
      className: "divider-dark"
    })));
  }

}

team_general_tab_defineProperty(team_general_tab_GeneralTab, "propTypes", {
  updateSection: prop_types_default.a.func.isRequired,
  team: prop_types_default.a.object.isRequired,
  activeSection: prop_types_default.a.string.isRequired,
  closeModal: prop_types_default.a.func.isRequired,
  collapseModal: prop_types_default.a.func.isRequired,
  maxFileSize: prop_types_default.a.number.isRequired,
  actions: prop_types_default.a.shape({
    patchTeam: prop_types_default.a.func.isRequired,
    regenerateTeamInviteId: prop_types_default.a.func.isRequired,
    removeTeamIcon: prop_types_default.a.func.isRequired,
    setTeamIcon: prop_types_default.a.func.isRequired
  }).isRequired,
  canInviteTeamMembers: prop_types_default.a.bool.isRequired
});
// CONCATENATED MODULE: ./components/team_general_tab/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function team_general_tab_mapStateToProps(state, ownProps) {
  const config = Object(general["getConfig"])(state);
  const maxFileSize = parseInt(config.MaxFileSize, 10);
  const canInviteTeamMembers = Object(roles["haveITeamPermission"])(state, {
    team: ownProps.team.id,
    permission: mattermost_redux_constants["Permissions"].INVITE_USER
  });
  return {
    maxFileSize,
    canInviteTeamMembers
  };
}

function team_general_tab_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      patchTeam: actions_teams["patchTeam"],
      regenerateTeamInviteId: actions_teams["regenerateTeamInviteId"],
      removeTeamIcon: actions_teams["removeTeamIcon"],
      setTeamIcon: actions_teams["setTeamIcon"]
    }, dispatch)
  };
}

/* harmony default export */ var team_general_tab = (Object(es["connect"])(team_general_tab_mapStateToProps, team_general_tab_mapDispatchToProps)(team_general_tab_GeneralTab));
// CONCATENATED MODULE: ./components/setting_upload.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class setting_upload_SettingsUpload extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.doFileSelect = this.doFileSelect.bind(this);
    this.doSubmit = this.doSubmit.bind(this);
    this.state = {
      clientError: this.props.clientError,
      serverError: this.props.serverError,
      filename: ''
    };
  }

  UNSAFE_componentWillReceiveProps() {
    // eslint-disable-line camelcase
    this.setState({
      clientError: this.props.clientError,
      serverError: this.props.serverError
    });
  }

  doFileSelect(e) {
    e.preventDefault();
    var filename = jquery_default()(e.target).val();

    if (filename.substring(3, 11) === 'fakepath') {
      filename = filename.substring(12);
    }

    this.setState({
      clientError: '',
      serverError: '',
      filename
    });
  }

  doSubmit(e) {
    e.preventDefault();
    var inputnode = react_dom_default.a.findDOMNode(this.refs.uploadinput);

    if (inputnode.files && inputnode.files[0]) {
      this.props.submit(inputnode.files[0]);
    } else {
      this.setState({
        clientError: true
      });
    }
  }

  render() {
    let clientError = null;

    if (this.state.clientError) {
      clientError = react_default.a.createElement("div", {
        className: "file-status"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "setting_upload.noFile",
        defaultMessage: "No file selected."
      }));
    }

    let serverError = null;

    if (this.state.serverError) {
      serverError = react_default.a.createElement("div", {
        className: "file-status"
      }, this.state.serverError);
    }

    let fileNameText = null;
    let submitButtonClass = 'btn btn-sm btn-primary disabled';

    if (this.state.filename) {
      fileNameText = react_default.a.createElement("div", {
        className: "file-status file-name"
      }, this.state.filename);
      submitButtonClass = 'btn btn-sm btn-primary';
    }

    return react_default.a.createElement("ul", {
      className: "section-max"
    }, react_default.a.createElement("li", {
      className: "col-sm-12 section-title"
    }, this.props.title), react_default.a.createElement("li", {
      className: "col-sm-offset-3 col-sm-9"
    }, this.props.helpText), react_default.a.createElement("li", {
      className: "col-sm-offset-3 col-sm-9"
    }, react_default.a.createElement("ul", {
      className: "setting-list"
    }, react_default.a.createElement("li", {
      className: "setting-list-item"
    }, react_default.a.createElement("span", {
      className: "btn btn-sm btn-primary btn-file sel-btn"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "setting_upload.select",
      defaultMessage: "Select file"
    }), react_default.a.createElement("input", {
      ref: "uploadinput",
      accept: this.props.fileTypesAccepted,
      type: "file",
      onChange: this.doFileSelect
    })), react_default.a.createElement("a", {
      className: submitButtonClass,
      onClick: this.doSubmit
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "setting_upload.import",
      defaultMessage: "Import"
    })), fileNameText, serverError, clientError))));
  }

}
setting_upload_SettingsUpload.propTypes = {
  title: prop_types_default.a.string.isRequired,
  submit: prop_types_default.a.func.isRequired,
  fileTypesAccepted: prop_types_default.a.string.isRequired,
  clientError: prop_types_default.a.string,
  serverError: prop_types_default.a.string,
  helpText: prop_types_default.a.object
};
// EXTERNAL MODULE: ./components/icon/warning_icon.jsx
var warning_icon = __webpack_require__(1621);

// CONCATENATED MODULE: ./components/team_import_tab.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const team_import_tab_holders = Object(index_es["g" /* defineMessages */])({
  importSlack: {
    id: Object(i18n["b" /* t */])('team_import_tab.importSlack'),
    defaultMessage: 'Import from Slack (Beta)'
  }
});

class team_import_tab_TeamImportTab extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.onImportFailure = this.onImportFailure.bind(this);
    this.onImportSuccess = this.onImportSuccess.bind(this);
    this.doImportSlack = this.doImportSlack.bind(this);
    this.state = {
      status: 'ready',
      link: ''
    };
  }

  onImportFailure() {
    this.setState({
      status: 'fail'
    });
  }

  onImportSuccess(data) {
    this.setState({
      status: 'done',
      link: 'data:application/octet-stream;charset=utf-8,' + encodeURIComponent(atob(data.results))
    });
  }

  doImportSlack(file) {
    this.setState({
      status: 'in-progress',
      link: ''
    });
    utils["L" /* importSlack */](file, this.onImportSuccess, this.onImportFailure);
  }

  render() {
    const {
      formatMessage
    } = this.props.intl;
    const uploadDocsLink = react_default.a.createElement("a", {
      href: "https://docs.mattermost.com/administration/migrating.html#migrating-from-slack",
      target: "_blank",
      rel: "noopener noreferrer"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_import_tab.importHelpDocsLink",
      defaultMessage: "documentation"
    }));
    const uploadExportInstructions = react_default.a.createElement("strong", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_import_tab.importHelpExportInstructions",
      defaultMessage: "Slack > Administration > Workspace settings > Import/Export Data > Export > Start Export"
    }));
    const uploadExporterLink = react_default.a.createElement("a", {
      href: "https://github.com/grundleborg/slack-advanced-exporter",
      target: "_blank",
      rel: "noopener noreferrer"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_import_tab.importHelpExporterLink",
      defaultMessage: "Slack Advanced Exporter"
    }));
    const importCliLink = react_default.a.createElement("a", {
      href: "https://docs.mattermost.com/administration/migrating.html#migrating-from-slack-using-the-mattermost-cli",
      target: "_blank",
      rel: "noopener noreferrer"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_import_tab.importHelpCliDocsLink",
      defaultMessage: "CLI tool for Slack import"
    }));
    const uploadHelpText = react_default.a.createElement("div", null, react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_import_tab.importHelpLine1",
      defaultMessage: "Slack import to Mattermost supports importing of messages in your Slack team's public channels."
    })), react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_import_tab.importHelpLine2",
      defaultMessage: "To import a team from Slack, go to {exportInstructions}. See {uploadDocsLink} to learn more.",
      values: {
        exportInstructions: uploadExportInstructions,
        uploadDocsLink
      }
    })), react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_import_tab.importHelpLine3",
      defaultMessage: "To import posts with attached files, see {slackAdvancedExporterLink} for details.",
      values: {
        slackAdvancedExporterLink: uploadExporterLink
      }
    })), react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_import_tab.importHelpLine4",
      defaultMessage: "For Slack teams with over 10,000 messages, we recommend using the {cliLink}.",
      values: {
        cliLink: importCliLink
      }
    })));
    const uploadSection = react_default.a.createElement(setting_upload_SettingsUpload, {
      title: formatMessage(team_import_tab_holders.importSlack),
      submit: this.doImportSlack,
      helpText: uploadHelpText,
      fileTypesAccepted: ".zip"
    });
    let messageSection;

    switch (this.state.status) {
      case 'ready':
        messageSection = '';
        break;

      case 'in-progress':
        messageSection = react_default.a.createElement("p", {
          className: "confirm-import alert alert-warning"
        }, react_default.a.createElement(loading_spinner["a" /* default */], {
          text: utils["gb" /* localizeMessage */]('team_import_tab.importing', 'Importing...')
        }));
        break;

      case 'done':
        messageSection = react_default.a.createElement("p", {
          className: "confirm-import alert alert-success"
        }, react_default.a.createElement(success_icon["a" /* default */], null), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "team_import_tab.successful",
          defaultMessage: " Import successful: "
        }), react_default.a.createElement("a", {
          href: this.state.link,
          download: "MattermostImportSummary.txt"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "team_import_tab.summary",
          defaultMessage: "View Summary"
        })));
        break;

      case 'fail':
        messageSection = react_default.a.createElement("p", {
          className: "confirm-import alert alert-warning"
        }, react_default.a.createElement(warning_icon["a" /* default */], null), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "team_import_tab.failure",
          defaultMessage: " Import failure: "
        }), react_default.a.createElement("a", {
          href: this.state.link,
          download: "MattermostImportSummary.txt"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "team_import_tab.summary",
          defaultMessage: "View Summary"
        })));
        break;
    }

    return react_default.a.createElement("div", null, react_default.a.createElement("div", {
      className: "modal-header"
    }, react_default.a.createElement("button", {
      type: "button",
      className: "close",
      "data-dismiss": "modal",
      "aria-label": "Close",
      onClick: this.props.closeModal
    }, react_default.a.createElement("span", {
      "aria-hidden": "true"
    }, '×')), react_default.a.createElement("h4", {
      className: "modal-title",
      ref: "title"
    }, react_default.a.createElement("div", {
      className: "modal-back"
    }, react_default.a.createElement("span", {
      onClick: this.props.collapseModal
    }, react_default.a.createElement(back_icon["a" /* default */], null))), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_import_tab.import",
      defaultMessage: "Import"
    }))), react_default.a.createElement("div", {
      ref: "wrapper",
      className: "user-settings"
    }, react_default.a.createElement("h3", {
      className: "tab-header"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_import_tab.import",
      defaultMessage: "Import"
    })), react_default.a.createElement("div", {
      className: "divider-dark first"
    }), uploadSection, react_default.a.createElement("div", {
      className: "divider-dark"
    }), messageSection));
  }

}

team_import_tab_TeamImportTab.propTypes = {
  intl: index_es["i" /* intlShape */].isRequired,
  closeModal: prop_types_default.a.func.isRequired,
  collapseModal: prop_types_default.a.func.isRequired
};
/* harmony default export */ var team_import_tab = (Object(index_es["h" /* injectIntl */])(team_import_tab_TeamImportTab));
// CONCATENATED MODULE: ./components/team_settings/team_settings.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const TeamSettings = ({
  activeTab,
  activeSection,
  updateSection,
  closeModal,
  collapseModal,
  team
}) => {
  if (!team) {
    return null;
  }

  let result;

  switch (activeTab) {
    case 'general':
      result = react_default.a.createElement("div", null, react_default.a.createElement(team_general_tab, {
        team: team,
        activeSection: activeSection,
        updateSection: updateSection,
        closeModal: closeModal,
        collapseModal: collapseModal
      }));
      break;

    case 'import':
      result = react_default.a.createElement("div", null, react_default.a.createElement(team_import_tab, {
        team: team,
        activeSection: activeSection,
        updateSection: updateSection,
        closeModal: closeModal,
        collapseModal: collapseModal
      }));
      break;

    default:
      result = react_default.a.createElement("div", null);
      break;
  }

  return result;
};

TeamSettings.defaultProps = {
  activeTab: '',
  activeSection: ''
};
TeamSettings.propTypes = {
  activeTab: prop_types_default.a.string.isRequired,
  activeSection: prop_types_default.a.string.isRequired,
  updateSection: prop_types_default.a.func.isRequired,
  closeModal: prop_types_default.a.func.isRequired,
  collapseModal: prop_types_default.a.func.isRequired,
  team: prop_types_default.a.object.isRequired
};
/* harmony default export */ var team_settings = (TeamSettings);
// CONCATENATED MODULE: ./components/team_settings/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function team_settings_mapStateToProps(state) {
  return {
    team: Object(entities_teams["getCurrentTeam"])(state)
  };
}

/* harmony default export */ var components_team_settings = (Object(es["connect"])(team_settings_mapStateToProps)(team_settings));
// CONCATENATED MODULE: ./components/team_settings_modal/team_settings_modal.jsx
function team_settings_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










class team_settings_modal_TeamSettingsModal extends react_default.a.Component {
  constructor(props) {
    super(props);

    team_settings_modal_defineProperty(this, "updateTab", tab => {
      this.setState({
        activeTab: tab,
        activeSection: ''
      });

      if (!utils["Y" /* isMobile */]()) {
        jquery_default()('.settings-modal .modal-body').scrollTop(0).perfectScrollbar('update');
      }
    });

    team_settings_modal_defineProperty(this, "updateSection", section => {
      if (jquery_default()('.section-max').length) {
        jquery_default()('.settings-modal .modal-body').scrollTop(0).perfectScrollbar('update');
      }

      this.setState({
        activeSection: section
      });
    });

    team_settings_modal_defineProperty(this, "closeModal", () => {
      this.props.onHide();
    });

    team_settings_modal_defineProperty(this, "collapseModal", () => {
      jquery_default()(react_dom_default.a.findDOMNode(this.refs.modalBody)).closest('.modal-dialog').removeClass('display--content');
      this.setState({
        active_tab: '',
        active_section: ''
      });
    });

    team_settings_modal_defineProperty(this, "handleHide", () => {
      this.props.onHide();
    });

    team_settings_modal_defineProperty(this, "handleHidden", () => {
      this.setState({
        activeTab: 'general',
        activeSection: ''
      });
    });

    this.state = {
      activeTab: 'general',
      activeSection: ''
    };
  }

  componentDidMount() {
    if (!utils["Y" /* isMobile */]()) {
      jquery_default()('.settings-modal .settings-content').perfectScrollbar();
    }
  }

  render() {
    const tabs = [];
    tabs.push({
      name: 'general',
      uiName: utils["gb" /* localizeMessage */]('team_settings_modal.generalTab', 'General'),
      icon: 'icon fa fa-cog',
      iconTitle: utils["gb" /* localizeMessage */]('generic_icons.settings', 'Settings Icon')
    });
    tabs.push({
      name: 'import',
      uiName: utils["gb" /* localizeMessage */]('team_settings_modal.importTab', 'Import'),
      icon: 'icon fa fa-upload',
      iconTitle: utils["gb" /* localizeMessage */]('generic_icons.upload', 'Upload Icon')
    });
    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "settings-modal settings-modal--action",
      show: this.props.show,
      onHide: this.handleHide,
      onExited: this.handleHidden,
      role: "dialog",
      "aria-labelledby": "teamSettingsModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      id: "teamSettingsModalLabel",
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "team_settings_modal.title",
      defaultMessage: "Team Settings"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, {
      ref: "modalBody"
    }, react_default.a.createElement("div", {
      className: "settings-table"
    }, react_default.a.createElement("div", {
      className: "settings-links"
    }, react_default.a.createElement(async_load["a" /* AsyncComponent */], {
      doLoad: settings_sidebar_default.a,
      tabs: tabs,
      activeTab: this.state.activeTab,
      updateTab: this.updateTab
    })), react_default.a.createElement("div", {
      className: "settings-content minimize-settings"
    }, react_default.a.createElement(components_team_settings, {
      activeTab: this.state.activeTab,
      activeSection: this.state.activeSection,
      updateSection: this.updateSection,
      closeModal: this.closeModal,
      collapseModal: this.collapseModal
    })))));
  }

}

team_settings_modal_defineProperty(team_settings_modal_TeamSettingsModal, "propTypes", {
  show: prop_types_default.a.bool,
  onHide: prop_types_default.a.func
});
// CONCATENATED MODULE: ./components/team_settings_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function team_settings_modal_mapStateToProps(state) {
  const modalId = constants["p" /* ModalIdentifiers */].TEAM_SETTINGS;
  return {
    show: Object(views_modals["a" /* isModalOpen */])(state, modalId)
  };
}

/* harmony default export */ var team_settings_modal = (Object(es["connect"])(team_settings_modal_mapStateToProps)(team_settings_modal_TeamSettingsModal));
// EXTERNAL MODULE: ./components/about_build_modal/index.js + 1 modules
var about_build_modal = __webpack_require__(2270);

// EXTERNAL MODULE: ./components/multiselect/multiselect.jsx + 1 modules
var multiselect = __webpack_require__(1685);

// EXTERNAL MODULE: ./components/profile_picture.jsx
var profile_picture = __webpack_require__(1656);

// EXTERNAL MODULE: ./components/icon/add_icon.jsx
var add_icon = __webpack_require__(1696);

// CONCATENATED MODULE: ./components/add_users_to_team/add_users_to_team.jsx
function add_users_to_team_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











const add_users_to_team_USERS_PER_PAGE = 50;
const MAX_SELECTABLE_VALUES = 20;
class add_users_to_team_AddUsersToTeam extends react_default.a.Component {
  constructor(props) {
    super(props);

    add_users_to_team_defineProperty(this, "handleHide", () => {
      this.props.actions.setModalSearchTerm('');
      this.setState({
        show: false
      });
    });

    add_users_to_team_defineProperty(this, "handleExit", () => {
      if (this.props.onHide) {
        this.props.onHide();
      }
    });

    add_users_to_team_defineProperty(this, "handleResponse", err => {
      let addError = null;

      if (err && err.message) {
        addError = err.message;
      }

      this.setState({
        saving: false,
        addError
      });
    });

    add_users_to_team_defineProperty(this, "handleSubmit", async e => {
      if (e) {
        e.preventDefault();
      }

      const userIds = this.state.values.map(v => v.id);

      if (userIds.length === 0) {
        return;
      }

      this.setState({
        saving: true
      });
      const {
        error
      } = await this.props.actions.addUsersToTeam(this.props.currentTeamId, userIds);
      this.handleResponse(error);

      if (!error) {
        this.handleHide();
      }
    });

    add_users_to_team_defineProperty(this, "addValue", value => {
      const values = Object.assign([], this.state.values);
      const userIds = values.map(v => v.id);

      if (value && value.id && userIds.indexOf(value.id) === -1) {
        values.push(value);
      }

      this.setState({
        values
      });
    });

    add_users_to_team_defineProperty(this, "setUsersLoadingState", loadingState => {
      this.setState({
        loadingUsers: loadingState
      });
    });

    add_users_to_team_defineProperty(this, "handlePageChange", (page, prevPage) => {
      if (page > prevPage) {
        this.setUsersLoadingState(true);
        this.props.actions.getProfilesNotInTeam(this.props.currentTeamId, page + 1, add_users_to_team_USERS_PER_PAGE).then(() => {
          this.setUsersLoadingState(false);
        });
      }
    });

    add_users_to_team_defineProperty(this, "handleDelete", values => {
      this.setState({
        values
      });
    });

    add_users_to_team_defineProperty(this, "search", term => {
      this.props.actions.setModalSearchTerm(term);
    });

    this.searchTimeoutId = 0;
    this.state = {
      values: [],
      show: true,
      search: false,
      saving: false,
      addError: null,
      loadingUsers: true
    };
  }

  componentDidMount() {
    this.props.actions.getProfilesNotInTeam(this.props.currentTeamId, this.props.currentTeamGroupConstrained, 0, add_users_to_team_USERS_PER_PAGE * 2).then(() => {
      this.setUsersLoadingState(false);
    });
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.searchTerm !== nextProps.searchTerm) {
      clearTimeout(this.searchTimeoutId);
      const searchTerm = nextProps.searchTerm;

      if (searchTerm === '') {
        return;
      }

      this.searchTimeoutId = setTimeout(async () => {
        this.setUsersLoadingState(true);
        const {
          data
        } = await this.props.actions.searchProfiles(searchTerm, {
          not_in_team_id: this.props.currentTeamId,
          group_constrained: this.props.currentTeamGroupConstrained
        });

        if (data) {
          this.props.actions.loadStatusesForProfilesList(data);
        }

        this.setUsersLoadingState(false);
      }, constants["N" /* default */].SEARCH_TIMEOUT_MILLISECONDS);
    }
  }

  renderOption(option, isSelected, onAdd) {
    var rowSelected = '';

    if (isSelected) {
      rowSelected = 'more-modal__row--selected';
    }

    let email = option.email;

    if (option.is_bot) {
      email = null;
    }

    return react_default.a.createElement("div", {
      key: option.id,
      ref: isSelected ? 'selected' : option.id,
      className: 'more-modal__row clickable ' + rowSelected,
      onClick: () => onAdd(option)
    }, react_default.a.createElement(profile_picture["a" /* default */], {
      src: client["Client4"].getProfilePictureUrl(option.id, option.last_picture_update),
      width: "32",
      height: "32"
    }), react_default.a.createElement("div", {
      className: "more-modal__details"
    }, react_default.a.createElement("div", {
      className: "more-modal__name"
    }, Object(utils["m" /* displayEntireNameForUser */])(option), react_default.a.createElement(bot_badge["a" /* default */], {
      show: Boolean(option.is_bot),
      className: "badge-popoverlist"
    })), react_default.a.createElement("div", {
      className: "more-modal__description"
    }, email)), react_default.a.createElement("div", {
      className: "more-modal__actions"
    }, react_default.a.createElement("div", {
      className: "more-modal__actions--round"
    }, react_default.a.createElement(add_icon["a" /* default */], null))));
  }

  renderValue(props) {
    return props.data.username;
  }

  render() {
    const numRemainingText = react_default.a.createElement("div", {
      id: "numPeopleRemaining"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "multiselect.numPeopleRemaining",
      defaultMessage: "Use \u2191\u2193 to browse, \u21B5 to select. You can add {num, number} more {num, plural, one {person} other {people}}. ",
      values: {
        num: MAX_SELECTABLE_VALUES - this.state.values.length
      }
    }));
    const buttonSubmitText = Object(utils["gb" /* localizeMessage */])('multiselect.add', 'Add');
    const buttonSubmitLoadingText = Object(utils["gb" /* localizeMessage */])('multiselect.adding', 'Adding...');
    let users = [];

    if (this.props.users) {
      users = this.props.users.filter(user => user.delete_at === 0);
    }

    let addError = null;

    if (this.state.addError) {
      addError = react_default.a.createElement("div", {
        className: "has-error col-sm-12"
      }, react_default.a.createElement("label", {
        className: "control-label font-weight--normal"
      }, this.state.addError));
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      id: "addUsersToTeamModal",
      dialogClassName: 'more-modal more-direct-channels',
      show: this.state.show,
      onHide: this.handleHide,
      onExited: this.handleExit,
      role: "dialog",
      "aria-labelledby": "addTeamModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "addTeamModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "add_users_to_team.title",
      defaultMessage: "Add New Members To {teamName} Team",
      values: {
        teamName: react_default.a.createElement("strong", null, this.props.currentTeamName)
      }
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, addError, react_default.a.createElement(multiselect["a" /* default */], {
      key: "addUsersToTeamKey",
      options: users,
      optionRenderer: this.renderOption,
      values: this.state.values,
      valueRenderer: this.renderValue,
      perPage: add_users_to_team_USERS_PER_PAGE,
      handlePageChange: this.handlePageChange,
      handleInput: this.search,
      handleDelete: this.handleDelete,
      handleAdd: this.addValue,
      handleSubmit: this.handleSubmit,
      maxValues: MAX_SELECTABLE_VALUES,
      numRemainingText: numRemainingText,
      buttonSubmitText: buttonSubmitText,
      buttonSubmitLoadingText: buttonSubmitLoadingText,
      saving: this.state.saving,
      loading: this.state.loadingUsers,
      placeholderText: Object(utils["gb" /* localizeMessage */])('multiselect.placeholder', 'Search and add members')
    })));
  }

}

add_users_to_team_defineProperty(add_users_to_team_AddUsersToTeam, "propTypes", {
  currentTeamName: prop_types_default.a.string.isRequired,
  currentTeamId: prop_types_default.a.string.isRequired,
  currentTeamGroupConstrained: prop_types_default.a.bool,
  searchTerm: prop_types_default.a.string.isRequired,
  users: prop_types_default.a.array.isRequired,
  onHide: prop_types_default.a.func,
  actions: prop_types_default.a.shape({
    getProfilesNotInTeam: prop_types_default.a.func.isRequired,
    setModalSearchTerm: prop_types_default.a.func.isRequired,
    searchProfiles: prop_types_default.a.func.isRequired,
    addUsersToTeam: prop_types_default.a.func.isRequired,
    loadStatusesForProfilesList: prop_types_default.a.func.isRequired
  }).isRequired
});

add_users_to_team_defineProperty(add_users_to_team_AddUsersToTeam, "defaultProps", {
  currentTeamGroupConstrained: false
});
// CONCATENATED MODULE: ./components/add_users_to_team/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












function add_users_to_team_mapStateToProps(state) {
  const searchTerm = state.views.search.modalSearch;
  let users;

  if (searchTerm) {
    users = Object(entities_users["searchProfilesNotInCurrentTeam"])(state, searchTerm, true);
  } else {
    users = Object(entities_users["getProfilesNotInCurrentTeam"])(state);
  }

  const team = Object(entities_teams["getCurrentTeam"])(state) || {};
  const modalId = constants["p" /* ModalIdentifiers */].ADD_USER_TO_TEAM;
  return {
    currentTeamName: team.display_name,
    currentTeamId: team.id,
    currentTeamGroupConstrained: team.group_constrained,
    searchTerm,
    users,
    show: Object(views_modals["a" /* isModalOpen */])(state, modalId)
  };
}

function add_users_to_team_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getProfilesNotInTeam: actions_users["getProfilesNotInTeam"],
      setModalSearchTerm: views_search["a" /* setModalSearchTerm */],
      searchProfiles: actions_users["searchProfiles"],
      addUsersToTeam: team_actions["c" /* addUsersToTeam */],
      loadStatusesForProfilesList: status_actions["b" /* loadStatusesForProfilesList */]
    }, dispatch)
  };
}

/* harmony default export */ var add_users_to_team = (Object(es["connect"])(add_users_to_team_mapStateToProps, add_users_to_team_mapDispatchToProps)(add_users_to_team_AddUsersToTeam));
// EXTERNAL MODULE: ./components/add_groups_to_team_modal/index.js + 1 modules
var add_groups_to_team_modal = __webpack_require__(1825);

// EXTERNAL MODULE: ./components/widgets/menu/menu_items/menu_item_external_link.jsx
var menu_item_external_link = __webpack_require__(2186);

// EXTERNAL MODULE: ./components/widgets/menu/menu_items/menu_item.jsx
var menu_item = __webpack_require__(1730);

// CONCATENATED MODULE: ./components/widgets/menu/menu_items/menu_item_link.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




const MenuItemLinkImpl = ({
  to,
  text
}) => react_default.a.createElement(react_router_dom["a" /* Link */], {
  to: to
}, text);
MenuItemLinkImpl.propTypes = {
  to: prop_types_default.a.string.isRequired,
  text: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.node]).isRequired
};
const MenuItemLink = Object(menu_item["a" /* default */])(MenuItemLinkImpl);
MenuItemLink.displayName = 'MenuItemLink';
/* harmony default export */ var menu_item_link = (MenuItemLink);
// EXTERNAL MODULE: ./components/widgets/menu/menu_items/menu_item_toggle_modal_redux.jsx
var menu_item_toggle_modal_redux = __webpack_require__(1934);

// EXTERNAL MODULE: ./mattermost-redux/actions/groups.js
var groups = __webpack_require__(1681);

// EXTERNAL MODULE: ./components/loading_screen.jsx
var loading_screen = __webpack_require__(1569);

// CONCATENATED MODULE: ./components/list_modal.jsx
function list_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const DEFAULT_NUM_PER_PAGE = 50;
class list_modal_ListModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    list_modal_defineProperty(this, "handleHide", () => {
      this.setState({
        show: false
      });
    });

    list_modal_defineProperty(this, "handleExit", () => {
      if (this.props.onHide) {
        this.props.onHide();
      }
    });

    list_modal_defineProperty(this, "onNext", () => {
      const nextPage = this.state.page + 1;
      this.onPageChange(nextPage);
    });

    list_modal_defineProperty(this, "onPrev", () => {
      const prevPage = this.state.page - 1;
      this.onPageChange(prevPage);
    });

    list_modal_defineProperty(this, "onPageChange", async page => {
      this.setState({
        loading: true
      });
      const result = await this.props.loadItems(page, this.state.searchTerm);
      this.setState({
        page,
        items: result.items,
        loading: false
      });
    });

    list_modal_defineProperty(this, "onSearchInput", async event => {
      const {
        target
      } = event;
      const searchTerm = target.value;
      this.setState({
        loading: true,
        searchTerm
      });
      const result = await this.props.loadItems(0, searchTerm);
      const {
        items,
        totalCount
      } = result;
      this.setState({
        loading: false,
        items,
        totalCount
      });
    });

    this.numPerPage = props.numPerPage || DEFAULT_NUM_PER_PAGE;
    this.state = {
      show: true,
      page: 0,
      items: [],
      totalCount: 0,
      loading: true,
      searchTerm: ''
    };
  }

  async componentWillMount() {
    const {
      totalCount,
      items
    } = await this.props.loadItems(0, '');
    this.setState({
      totalCount,
      items,
      loading: false
    });
  }

  renderRows() {
    if (this.state.loading) {
      return react_default.a.createElement("div", null, react_default.a.createElement(loading_screen["a" /* default */], {
        position: "absolute",
        key: "loading"
      }));
    }

    return this.state.items.map(item => this.props.renderRow(item, this));
  }

  paginationRange() {
    let startCount = this.state.page * this.numPerPage + 1;
    const endCount = startCount + this.state.items.length - 1;

    if (endCount === 0) {
      startCount = 0;
    }

    return {
      startCount,
      endCount
    };
  }

  render() {
    if (!this.props.show) {
      return null;
    }

    const {
      endCount,
      startCount
    } = this.paginationRange();
    return react_default.a.createElement("div", null, react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "more-modal more-modal--action",
      show: this.state.show,
      onHide: this.handleHide,
      onExited: this.handleExit
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1"
    }, react_default.a.createElement("span", {
      className: "name"
    }, this.props.titleText)), this.props.titleBarButtonText && this.props.titleBarButtonOnClick && react_default.a.createElement("a", {
      className: "btn btn-md btn-primary",
      href: "#",
      onClick: this.props.titleBarButtonOnClick
    }, this.props.titleBarButtonText)), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement("div", {
      className: "filtered-user-list"
    }, react_default.a.createElement("div", {
      className: "filter-row"
    }, react_default.a.createElement("div", {
      className: "col-xs-12"
    }, react_default.a.createElement("input", {
      id: "searchUsersInput",
      className: "form-control filter-textbox",
      placeholder: this.props.searchPlaceholderText,
      onChange: this.onSearchInput
    })), react_default.a.createElement("div", {
      className: "col-sm-12"
    }, react_default.a.createElement("span", {
      className: "member-count pull-left"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "list_modal.paginatorCount",
      defaultMessage: "{startCount, number} - {endCount, number} of {total, number} total",
      values: {
        startCount,
        endCount,
        total: this.state.totalCount
      }
    })))), react_default.a.createElement("div", {
      className: "more-modal__list"
    }, react_default.a.createElement("div", null, this.renderRows())), react_default.a.createElement("div", {
      className: "filter-controls"
    }, this.state.page > 0 && react_default.a.createElement("button", {
      onClick: this.onPrev,
      className: "btn btn-link filter-control filter-control__prev"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "filtered_user_list.prev",
      defaultMessage: "Previous"
    })), this.state.items.length >= this.props.numPerPage && endCount !== this.state.totalCount && react_default.a.createElement("button", {
      onClick: this.onNext,
      className: "btn btn-link filter-control filter-control__next"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "filtered_user_list.next",
      defaultMessage: "Next"
    })))))));
  }

}

list_modal_defineProperty(list_modal_ListModal, "propTypes", {
  /**
   * loadItems is a function that receives the params (pageNumber, searchTerm) and should return an object
   * with the shape {items: [], totalCount: 0}.
   * items: an array of objects that are passed to each renderRow function.
   * totalCount: an integer representing the total number of items as displayed in the pagination text.
   *
   * Example:
   *     const loadItems = async (pageNumber, searchTerm) => {
   *         const {data} = await loadFromServer(searchTerm, pageNumber, PER_PAGE);
   *         return {
   *             items: data.users,
   *             totalCount: data.total,
   *         };
   *     };
   */
  loadItems: prop_types_default.a.func.isRequired,

  /**
   * renderRow is a function that receives the params (item, listModal) and should return JSX.
   * item: an object as returned by each entry in the loadItems function's 'items' array.
   * listModal: the instance of the ListModal component class.
   *
   * Example:
   *     const renderRow = (item, listModal) => <div>{item.id}</div>;
   */
  renderRow: prop_types_default.a.func.isRequired,

  /**
   * onHide (optional) a function to be invoked when the modal is closed.
   */
  onHide: prop_types_default.a.func,

  /**
   * titleText (optional) a string to show at the top bar of the modal.
   */
  titleText: prop_types_default.a.string,

  /**
   * searchPlaceholderText (optional) a string to show as a placeholder in the search input.
   */
  searchPlaceholderText: prop_types_default.a.string,

  /**
   * titleBarButtonText (optional) a string representing a title bar button text.
   */
  titleBarButtonText: prop_types_default.a.string,

  /**
   * titleBarButtonOnClick (optional) a func to handle title button bar clicks.
   */
  titleBarButtonOnClick: prop_types_default.a.func,

  /**
   * numPerPage (optional) a number setting how many items per page should be displayed. Defaults to
   * DEFAULT_NUM_PER_PAGE.
   */
  numPerPage: prop_types_default.a.number,

  /**
   * show (optional) a boolean setting to hide the modal via props rather then unmounting it.
   */
  show: prop_types_default.a.bool
});

list_modal_defineProperty(list_modal_ListModal, "defaultProps", {
  show: true
});
// EXTERNAL MODULE: ./images/groups-avatar.png
var groups_avatar = __webpack_require__(1808);
var groups_avatar_default = /*#__PURE__*/__webpack_require__.n(groups_avatar);

// CONCATENATED MODULE: ./components/team_groups_manage_modal/team_groups_manage_modal.jsx
function team_groups_manage_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class team_groups_manage_modal_TeamGroupsManageModal extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    team_groups_manage_modal_defineProperty(this, "state", {
      showConfirmModal: false,
      item: {
        member_count: 0
      },
      listModal: null
    });

    team_groups_manage_modal_defineProperty(this, "loadItems", async (pageNumber, searchTerm) => {
      const {
        data
      } = await this.props.actions.getGroupsAssociatedToTeam(this.props.team.id, searchTerm, pageNumber, DEFAULT_NUM_PER_PAGE);
      return {
        items: data.groups,
        totalCount: data.totalGroupCount
      };
    });

    team_groups_manage_modal_defineProperty(this, "handleDeleteCanceled", () => {
      this.setState({
        showConfirmModal: false
      });
    });

    team_groups_manage_modal_defineProperty(this, "handleDeleteConfirmed", () => {
      this.setState({
        showConfirmModal: false
      });
      const {
        item,
        listModal
      } = this.state;
      this.props.actions.unlinkGroupSyncable(item.id, this.props.team.id, mattermost_redux_constants["Groups"].SYNCABLE_TYPE_TEAM).then(async () => {
        listModal.setState({
          loading: true
        });
        const {
          items
        } = await listModal.props.loadItems(listModal.setState.page, listModal.state.searchTerm);
        listModal.setState({
          loading: false,
          items
        });
      });
    });

    team_groups_manage_modal_defineProperty(this, "onClickRemoveGroup", (item, listModal) => {
      this.setState({
        showConfirmModal: true,
        item,
        listModal
      });
    });

    team_groups_manage_modal_defineProperty(this, "onClickConfirmRemoveGroup", (item, listModal) => this.props.actions.unlinkGroupSyncable(item.id, this.props.team.id, mattermost_redux_constants["Groups"].SYNCABLE_TYPE_TEAM).then(async () => {
      listModal.setState({
        loading: true
      });
      const {
        items
      } = await listModal.props.loadItems(listModal.setState.page, listModal.state.searchTerm);
      listModal.setState({
        loading: false,
        items
      });
    }));

    team_groups_manage_modal_defineProperty(this, "onHide", () => {
      this.props.actions.closeModal(constants["p" /* ModalIdentifiers */].MANAGE_TEAM_GROUPS);
    });

    team_groups_manage_modal_defineProperty(this, "titleButtonOnClick", () => {
      this.onHide();
      this.props.actions.openModal({
        modalId: constants["p" /* ModalIdentifiers */].ADD_GROUPS_TO_TEAM,
        dialogType: add_groups_to_team_modal["a" /* default */]
      });
    });

    team_groups_manage_modal_defineProperty(this, "renderRow", (item, listModal) => {
      return react_default.a.createElement("div", {
        key: item.id,
        className: "more-modal__row"
      }, react_default.a.createElement("img", {
        className: "more-modal__image",
        src: groups_avatar_default.a,
        alt: "group picture",
        width: "32",
        height: "32"
      }), react_default.a.createElement("div", {
        className: "more-modal__details"
      }, react_default.a.createElement("div", {
        className: "more-modal__name"
      }, item.display_name, " ", '-', " ", react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "numMembers",
        defaultMessage: "{num, number} {num, plural, one {member} other {members}}",
        values: {
          num: item.member_count
        }
      })))), react_default.a.createElement("div", {
        className: "more-modal__actions"
      }, react_default.a.createElement("button", {
        id: "removeMember",
        type: "button",
        className: "btn btn-danger btn-message",
        onClick: () => this.onClickRemoveGroup(item, listModal)
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "group_list_modal.removeGroupButton",
        defaultMessage: "Remove Group"
      }))));
    });
  }

  render() {
    const {
      formatMessage
    } = this.context.intl;
    const memberCount = this.state.item.member_count;
    return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(list_modal_ListModal, {
      show: !this.state.showConfirmModal,
      titleText: formatMessage({
        id: 'groups',
        defaultMessage: '{team} Groups'
      }, {
        team: this.props.team.display_name
      }),
      searchPlaceholderText: formatMessage({
        id: 'manage_team_groups_modal.search_placeholder',
        defaultMessage: 'Search groups'
      }),
      renderRow: this.renderRow,
      loadItems: this.loadItems,
      onHide: this.onHide,
      titleBarButtonText: formatMessage({
        id: 'group_list_modal.addGroupButton',
        defaultMessage: 'Add Groups'
      }),
      titleBarButtonOnClick: this.titleButtonOnClick
    }), react_default.a.createElement(confirm_modal["a" /* default */], {
      show: this.state.showConfirmModal,
      title: formatMessage({
        id: 'remove_group_confirm_title',
        defaultMessage: 'Remove Group and {memberCount, number} {memberCount, plural, one {Member} other {Members}}'
      }, {
        memberCount
      }),
      message: formatMessage({
        id: 'remove_group_confirm_message',
        defaultMessage: '{memberCount, number} {memberCount, plural, one {member} other {members}} associated to this group will be removed from the team on the next scheduled AD/LDAP synchronization. Are you sure you wish to remove this group and {memberCount} {memberCount, plural, one {member} other {members}}?'
      }, {
        memberCount
      }),
      confirmButtonText: formatMessage({
        id: 'remove_group_confirm_button',
        defaultMessage: 'Yes, Remove Group and {memberCount, plural, one {Member} other {Members}}'
      }, {
        memberCount
      }),
      onConfirm: this.handleDeleteConfirmed,
      onCancel: this.handleDeleteCanceled
    }));
  }

}

team_groups_manage_modal_defineProperty(team_groups_manage_modal_TeamGroupsManageModal, "propTypes", {
  team: prop_types_default.a.object.isRequired,
  actions: prop_types_default.a.shape({
    getGroupsAssociatedToTeam: prop_types_default.a.func.isRequired,
    unlinkGroupSyncable: prop_types_default.a.func.isRequired,
    closeModal: prop_types_default.a.func.isRequired,
    openModal: prop_types_default.a.func.isRequired
  }).isRequired
});

team_groups_manage_modal_defineProperty(team_groups_manage_modal_TeamGroupsManageModal, "contextTypes", {
  intl: index_es["i" /* intlShape */]
});
// CONCATENATED MODULE: ./components/team_groups_manage_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const team_groups_manage_modal_mapStateToProps = (state, ownProps) => {
  return {
    team: state.entities.teams.teams[ownProps.teamID]
  };
};

const team_groups_manage_modal_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    getGroupsAssociatedToTeam: groups["getGroupsAssociatedToTeam"],
    closeModal: modals["a" /* closeModal */],
    openModal: modals["b" /* openModal */],
    unlinkGroupSyncable: groups["unlinkGroupSyncable"]
  }, dispatch)
});

/* harmony default export */ var team_groups_manage_modal = (Object(es["connect"])(team_groups_manage_modal_mapStateToProps, team_groups_manage_modal_mapDispatchToProps)(team_groups_manage_modal_TeamGroupsManageModal));
// CONCATENATED MODULE: ./components/main_menu/main_menu.jsx
function main_menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





























const {
  confirm: main_menu_confirm
} = es_modal["a" /* default */];
class main_menu_MainMenu extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    main_menu_defineProperty(this, "toggleShortcutsModal", e => {
      e.preventDefault();
      global_actions["n" /* toggleShortcutsModal */]();
    });

    main_menu_defineProperty(this, "showGetTeamInviteLinkModal", e => {
      e.preventDefault();
      global_actions["l" /* showGetTeamInviteLinkModal */]();
    });

    main_menu_defineProperty(this, "handleKeyDown", e => {
      if (Object(utils["e" /* cmdOrCtrlPressed */])(e) && e.shiftKey && Object(utils["V" /* isKeyPressed */])(e, constants["g" /* Constants */].KeyCodes.A)) {
        this.props.actions.openModal({
          ModalId: constants["p" /* ModalIdentifiers */].USER_SETTINGS,
          dialogType: user_settings_modal["a" /* default */]
        });
      }
    });

    main_menu_defineProperty(this, "handleEmitUserLoggedOutEvent", () => {
      main_menu_confirm({
        title: '确定要退出吗？',
        cancelText: '取消',
        okText: '确定',

        onOk() {
          global_actions["e" /* emitUserLoggedOutEvent */]();
          ;
        }

      });
    });

    main_menu_defineProperty(this, "getFlagged", e => {
      e.preventDefault();
      this.props.actions.showFlaggedPosts();
      this.props.actions.closeRhsMenu();
    });

    main_menu_defineProperty(this, "searchMentions", e => {
      e.preventDefault();

      if (this.props.isMentionSearch) {
        this.props.actions.closeRightHandSide();
      } else {
        this.props.actions.closeRhsMenu();
        this.props.actions.showMentions();
      }
    });
  }

  componentDidMount() {
    document.addEventListener('keydown', this.handleKeyDown);
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleKeyDown);
  }

  render() {
    const {
      currentUser,
      teamIsGroupConstrained
    } = this.props;

    if (!currentUser) {
      return null;
    }

    const {
      formatMessage
    } = this.context.intl;
    const pluginItems = this.props.pluginMenuItems.map(item => {
      return react_default.a.createElement(menu_item_action["a" /* default */], {
        id: item.id + '_pluginmenuitem',
        key: item.id + '_pluginmenuitem',
        onClick: () => {
          if (item.action) {
            item.action();
          }
        },
        text: item.text,
        icon: this.props.mobile && item.mobileIcon
      });
    });
    return react_default.a.createElement(menu_menu["a" /* default */], {
      mobile: this.props.mobile,
      id: this.props.id,
      ariaLabel: Object(utils["gb" /* localizeMessage */])('navbar_dropdown.menuAriaLabel', 'main menu')
    }, react_default.a.createElement(menu_group["a" /* default */], null, react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "accountSettings",
      modalId: constants["p" /* ModalIdentifiers */].USER_SETTINGS,
      dialogType: components_new_user_settings_modal,
      activeTab: "general",
      text: Object(utils["gb" /* localizeMessage */])('navbar_dropdown.accountSettings', '账号设置')
    }), react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "messageNotific",
      modalId: constants["p" /* ModalIdentifiers */].USER_SETTINGS,
      dialogType: components_new_user_settings_modal,
      activeTab: "notifications",
      text: Object(utils["gb" /* localizeMessage */])('admin.sidebar.notifications', '消息通知')
    }), react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "display",
      modalId: constants["p" /* ModalIdentifiers */].USER_SETTINGS,
      dialogType: components_new_user_settings_modal,
      activeTab: "display",
      text: Object(utils["gb" /* localizeMessage */])('user.settings.modal.display', '显示')
    }), react_default.a.createElement(menu_item_action["a" /* default */], {
      id: "keyboardShortcuts",
      show: !this.props.mobile,
      onClick: this.toggleShortcutsModal,
      text: Object(utils["gb" /* localizeMessage */])('admin.sidebar.keyboardShortcuts', '快捷键')
    }), react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "about",
      modalId: constants["p" /* ModalIdentifiers */].ABOUT,
      dialogType: about_build_modal["a" /* default */],
      text: Object(utils["gb" /* localizeMessage */])('admin.sidebar.about', '关于') // text={formatMessage({id: 'navbar_dropdown.about', defaultMessage: 'About {appTitle}'}, {appTitle: this.props.siteName || 'Aboutone'})}
      // icon={this.props.mobile && <i className='fa fa-info'/>}

    })), react_default.a.createElement(menu_group["a" /* default */], null, react_default.a.createElement(menu_item_action["a" /* default */], {
      id: "logout",
      onClick: this.handleEmitUserLoggedOutEvent,
      text: Object(utils["gb" /* localizeMessage */])('navbar_dropdown.logout', 'Logout'),
      icon: this.props.mobile && react_default.a.createElement("i", {
        className: "fa fa-sign-out"
      })
    })), react_default.a.createElement(menu_group["a" /* default */], null, react_default.a.createElement(system_permission_gate["a" /* default */], {
      permissions: [mattermost_redux_constants["Permissions"].MANAGE_SYSTEM]
    }, react_default.a.createElement(menu_item_link, {
      id: "systemConsole",
      show: !this.props.mobile,
      to: "/admin_console",
      text: Object(utils["gb" /* localizeMessage */])('navbar_dropdown.console', 'System Console'),
      icon: this.props.mobile && react_default.a.createElement("i", {
        className: "fa fa-wrench"
      })
    }))), react_default.a.createElement(menu_group["a" /* default */], null, react_default.a.createElement(team_permission_gate["a" /* default */], {
      teamId: this.props.teamId,
      permissions: [mattermost_redux_constants["Permissions"].MANAGE_SLASH_COMMANDS, mattermost_redux_constants["Permissions"].MANAGE_OAUTH, mattermost_redux_constants["Permissions"].MANAGE_INCOMING_WEBHOOKS, mattermost_redux_constants["Permissions"].MANAGE_OUTGOING_WEBHOOKS]
    }, react_default.a.createElement(menu_item_link, {
      id: "integrations",
      show: !this.props.mobile && (this.props.enableIncomingWebhooks || this.props.enableOutgoingWebhooks || this.props.enableCommands || this.props.enableOAuthServiceProvider),
      to: '/' + this.props.teamName + '/integrations',
      text: Object(utils["gb" /* localizeMessage */])('navbar_dropdown.integrations', 'Integrations')
    })), react_default.a.createElement(menu_item_link, {
      id: "customEmojis",
      show: !this.props.mobile && this.props.enableCustomEmoji && this.props.canCreateOrDeleteCustomEmoji,
      to: '/' + this.props.teamName + '/emoji',
      text: Object(utils["gb" /* localizeMessage */])('navbar_dropdown.emoji', 'Custom Emoji')
    })));
  }

}

main_menu_defineProperty(main_menu_MainMenu, "propTypes", {
  mobile: prop_types_default.a.bool.isRequired,
  id: prop_types_default.a.string,
  teamId: prop_types_default.a.string,
  teamType: prop_types_default.a.string,
  teamName: prop_types_default.a.string,
  siteName: prop_types_default.a.string,
  currentUser: prop_types_default.a.object,
  appDownloadLink: prop_types_default.a.string,
  enableCommands: prop_types_default.a.bool.isRequired,
  enableCustomEmoji: prop_types_default.a.bool.isRequired,
  canCreateOrDeleteCustomEmoji: prop_types_default.a.bool.isRequired,
  enableIncomingWebhooks: prop_types_default.a.bool.isRequired,
  enableOAuthServiceProvider: prop_types_default.a.bool.isRequired,
  enableOutgoingWebhooks: prop_types_default.a.bool.isRequired,
  enableUserCreation: prop_types_default.a.bool.isRequired,
  enableEmailInvitations: prop_types_default.a.bool.isRequired,
  experimentalPrimaryTeam: prop_types_default.a.string,
  helpLink: prop_types_default.a.string,
  reportAProblemLink: prop_types_default.a.string,
  moreTeamsToJoin: prop_types_default.a.bool.isRequired,
  pluginMenuItems: prop_types_default.a.arrayOf(prop_types_default.a.object),
  isMentionSearch: prop_types_default.a.bool,
  teamIsGroupConstrained: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    openModal: prop_types_default.a.func.isRequred,
    showMentions: prop_types_default.a.func,
    showFlaggedPosts: prop_types_default.a.func,
    closeRightHandSide: prop_types_default.a.func.isRequired,
    closeRhsMenu: prop_types_default.a.func.isRequired
  }).isRequired
});

main_menu_defineProperty(main_menu_MainMenu, "defaultProps", {
  teamType: '',
  mobile: false,
  pluginMenuItems: []
});

main_menu_defineProperty(main_menu_MainMenu, "contextTypes", {
  intl: index_es["i" /* intlShape */].isRequired
});
// CONCATENATED MODULE: ./components/main_menu/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













function main_menu_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const currentTeam = Object(entities_teams["getCurrentTeam"])(state);
  const currentUser = Object(entities_users["getCurrentUser"])(state);
  const appDownloadLink = config.AppDownloadLink;
  const enableCommands = config.EnableCommands === 'true';
  const enableCustomEmoji = config.EnableCustomEmoji === 'true';
  const siteName = config.SiteName;
  const enableIncomingWebhooks = config.EnableIncomingWebhooks === 'true';
  const enableOAuthServiceProvider = config.EnableOAuthServiceProvider === 'true';
  const enableOutgoingWebhooks = config.EnableOutgoingWebhooks === 'true';
  const enableUserCreation = config.EnableUserCreation === 'true';
  const enableEmailInvitations = config.EnableEmailInvitations === 'true';
  const experimentalPrimaryTeam = config.ExperimentalPrimaryTeam;
  const helpLink = config.HelpLink;
  const reportAProblemLink = config.ReportAProblemLink;
  let canCreateOrDeleteCustomEmoji = Object(roles["haveISystemPermission"])(state, {
    permission: mattermost_redux_constants["Permissions"].CREATE_EMOJIS
  }) || Object(roles["haveISystemPermission"])(state, {
    permission: mattermost_redux_constants["Permissions"].DELETE_EMOJIS
  });

  if (!canCreateOrDeleteCustomEmoji) {
    for (const team of Object(entities_teams["getMyTeams"])(state)) {
      if (Object(roles["haveITeamPermission"])(state, {
        team: team.id,
        permission: mattermost_redux_constants["Permissions"].CREATE_EMOJIS
      }) || Object(roles["haveITeamPermission"])(state, {
        team: team.id,
        permission: mattermost_redux_constants["Permissions"].DELETE_EMOJIS
      })) {
        canCreateOrDeleteCustomEmoji = true;
        break;
      }
    }
  }

  const joinableTeams = Object(entities_teams["getJoinableTeamIds"])(state);
  const moreTeamsToJoin = joinableTeams && joinableTeams.length > 0;
  const rhsState = Object(selectors_rhs["m" /* getRhsState */])(state);
  return {
    appDownloadLink,
    enableCommands,
    enableCustomEmoji,
    enableIncomingWebhooks,
    enableOAuthServiceProvider,
    enableOutgoingWebhooks,
    enableUserCreation,
    enableEmailInvitations,
    experimentalPrimaryTeam,
    helpLink,
    reportAProblemLink,
    pluginMenuItems: state.plugins.components.MainMenu,
    canCreateOrDeleteCustomEmoji,
    moreTeamsToJoin,
    siteName,
    teamId: currentTeam.id,
    teamName: currentTeam.name,
    teamType: currentTeam.type,
    currentUser,
    isMentionSearch: rhsState === constants["x" /* RHSStates */].MENTION,
    teamIsGroupConstrained: Boolean(currentTeam.group_constrained)
  };
}

function main_menu_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openModal: modals["b" /* openModal */],
      showMentions: rhs["p" /* showMentions */],
      showFlaggedPosts: rhs["n" /* showFlaggedPosts */],
      closeRightHandSide: rhs["b" /* closeRightHandSide */],
      closeRhsMenu: rhs["a" /* closeMenu */]
    }, dispatch)
  };
}

/* harmony default export */ var main_menu = (Object(es["connect"])(main_menu_mapStateToProps, main_menu_mapDispatchToProps)(main_menu_MainMenu));
// CONCATENATED MODULE: ./components/sidebar/headerCloneTwo/dropdown/sidebar_header_dropdown.jsx
function sidebar_header_dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class sidebar_header_dropdown_SidebarHeaderDropdown extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    sidebar_header_dropdown_defineProperty(this, "toggleShortcutsModal", e => {
      e.preventDefault();
      global_actions["n" /* toggleShortcutsModal */]();
    });

    sidebar_header_dropdown_defineProperty(this, "showGetTeamInviteLinkModal", e => {
      e.preventDefault();
      global_actions["l" /* showGetTeamInviteLinkModal */]();
    });

    sidebar_header_dropdown_defineProperty(this, "handleKeyDown", e => {
      if (Object(utils["e" /* cmdOrCtrlPressed */])(e) && e.shiftKey && Object(utils["V" /* isKeyPressed */])(e, constants["g" /* Constants */].KeyCodes.A)) {
        this.props.actions.openModal({
          ModalId: constants["p" /* ModalIdentifiers */].USER_SETTINGS,
          dialogType: user_settings_modal["a" /* default */]
        });
      }
    });

    sidebar_header_dropdown_defineProperty(this, "handleEmitUserLoggedOutEvent", () => {
      global_actions["e" /* emitUserLoggedOutEvent */]();
    });
  }

  componentDidMount() {
    document.addEventListener('keydown', this.handleKeyDown);
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleKeyDown);
  }

  render() {
    const currentUser = this.props.currentUser;

    if (!currentUser) {
      return null;
    }

    return (//<MenuWrapper>
      react_default.a.createElement(sidebar_header_dropdown_button_SidebarHeaderDropdownButton, {
        showTutorialTip: this.props.showTutorialTip,
        teamDescription: this.props.teamDescription,
        currentUser: this.props.currentUser,
        teamDisplayName: this.props.teamDisplayName,
        teamId: this.props.teamId
      }) //<MainMenu id='sidebarDropdownMenu'/>
      //</MenuWrapper>

    );
  }

}

sidebar_header_dropdown_defineProperty(sidebar_header_dropdown_SidebarHeaderDropdown, "propTypes", {
  teamDescription: prop_types_default.a.string.isRequired,
  teamDisplayName: prop_types_default.a.string.isRequired,
  teamId: prop_types_default.a.string.isRequired,
  currentUser: prop_types_default.a.object,
  showTutorialTip: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    openModal: prop_types_default.a.func.isRequred
  }).isRequired
});

sidebar_header_dropdown_defineProperty(sidebar_header_dropdown_SidebarHeaderDropdown, "defaultProps", {
  teamType: '',
  pluginMenuItems: []
});
// CONCATENATED MODULE: ./components/sidebar/headerCloneTwo/dropdown/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function dropdown_mapStateToProps(state) {
  const currentTeam = Object(entities_teams["getCurrentTeam"])(state);
  const currentUser = Object(entities_users["getCurrentUser"])(state);
  const showTutorialTip = Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, currentUser.id) === constants["H" /* TutorialSteps */].MENU_POPOVER && !utils["Y" /* isMobile */]();
  return {
    currentUser,
    teamDescription: currentTeam.description,
    teamDisplayName: currentTeam.display_name,
    teamId: currentTeam.id,
    showTutorialTip
  };
}

function dropdown_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openModal: modals["b" /* openModal */]
    }, dispatch)
  };
}

/* harmony default export */ var headerCloneTwo_dropdown = (Object(es["connect"])(dropdown_mapStateToProps, dropdown_mapDispatchToProps)(sidebar_header_dropdown_SidebarHeaderDropdown));
// CONCATENATED MODULE: ./components/sidebar/headerCloneTwo/sidebar_header.jsx
function sidebar_header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class sidebar_header_SidebarHeader extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    sidebar_header_defineProperty(this, "handleResize", () => {
      const isMobile = utils["Y" /* isMobile */]();
      this.setState({
        isMobile
      });
    });

    this.state = {
      isMobile: utils["Y" /* isMobile */]()
    };
  }

  componentDidMount() {
    window.addEventListener('resize', this.handleResize);
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
  }

  render() {
    const ariaLabel = utils["gb" /* localizeMessage */]('accessibility.sections.lhsHeader', 'team menu region');
    return react_default.a.createElement("div", {
      id: "lhsHeader",
      "aria-label": ariaLabel,
      tabIndex: "-1",
      role: "navigation",
      className: "SidebarHeader team__header theme"
    }, react_default.a.createElement("div", {
      className: "d-flex"
    }, !this.state.isMobile && react_default.a.createElement(status_dropdown, null), react_default.a.createElement(headerCloneTwo_dropdown, null)));
  }

}
// CONCATENATED MODULE: ./components/sidebar/headerCloneTwo/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function headerCloneTwo_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const currentUser = Object(entities_users["getCurrentUser"])(state);
  const enableTutorial = config.EnableTutorial === 'true';
  const showTutorialTip = Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, currentUser.id) === constants["H" /* TutorialSteps */].MENU_POPOVER && !utils["Y" /* isMobile */]();
  return {
    enableTutorial,
    showTutorialTip
  };
}

/* harmony default export */ var headerCloneTwo = (Object(es["connect"])(headerCloneTwo_mapStateToProps)(sidebar_header_SidebarHeader));
// CONCATENATED MODULE: ./components/search_bar/search_bar.jsx
function search_bar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
















const {
  KeyCodes: search_bar_KeyCodes
} = constants["N" /* default */];
class search_bar_SearchBar extends react_default.a.Component {
  constructor() {
    super();

    search_bar_defineProperty(this, "handleClose", () => {
      this.props.actions.closeRightHandSide();
    });

    search_bar_defineProperty(this, "handleKeyDown", e => {
      if (utils["V" /* isKeyPressed */](e, search_bar_KeyCodes.ESCAPE)) {
        e.stopPropagation();
        e.preventDefault();
      }
    });

    search_bar_defineProperty(this, "handleChange", e => {
      var term = e.target.value;
      this.props.actions.updateSearchTerms(term);
    });

    search_bar_defineProperty(this, "handleUserBlur", () => {
      // add time out so that the pinned and member buttons are clickable
      // when focus is released from the search box.
      setTimeout(() => {
        this.setState({
          focused: false
        });
      }, 200);
    });

    search_bar_defineProperty(this, "handleClear", () => {
      this.props.actions.updateSearchTerms('');
    });

    search_bar_defineProperty(this, "handleUserFocus", () => {
      this.setState({
        focused: true
      });
    });

    search_bar_defineProperty(this, "handleSearch", async terms => {
      if (terms.length) {
        const {
          error
        } = await this.props.actions.showSearchResults();

        if (!error) {
          this.handleSearchOnSuccess();
        }
      }
    });

    search_bar_defineProperty(this, "handleSearchOnSuccess", () => {
      if (utils["Y" /* isMobile */]() && this.search) {
        this.search.value = '';
      }
    });

    search_bar_defineProperty(this, "handleSubmit", e => {
      e.preventDefault();
      const terms = this.props.searchTerms.trim();

      if (terms.length === 0) {
        return;
      }

      this.handleSearch(terms);
      this.search.blur();
    });

    search_bar_defineProperty(this, "searchMentions", e => {
      e.preventDefault();

      if (this.props.isMentionSearch) {
        // Close
        this.props.actions.closeRightHandSide();
      } else {
        this.props.actions.showMentions();
      }
    });

    search_bar_defineProperty(this, "getFlagged", e => {
      e.preventDefault();

      if (this.props.isFlaggedPosts) {
        this.props.actions.closeRightHandSide();
      } else {
        this.props.actions.showFlaggedPosts();
      }
    });

    search_bar_defineProperty(this, "getCloud", e => {
      e.preventDefault();

      if (this.props.isCloudPosts) {
        this.props.actions.closeRightHandSide();
      } else {
        this.props.actions.showCloud();
      }
    });

    search_bar_defineProperty(this, "getWork", e => {
      e.preventDefault();
      window.open("https://workspace.zhonganinfo.com/workbench", "_blank");
    });

    search_bar_defineProperty(this, "getSearch", node => {
      this.search = node;
    });

    this.state = {
      focused: false
    };
    this.suggestionProviders = [new search_channel_provider_SearchChannelProvider(), new search_user_provider_SearchUserProvider(), new search_date_provider_SearchDateProvider()];
  }

  componentDidMount() {
    if (utils["Y" /* isMobile */]()) {
      setTimeout(() => {
        const element = document.querySelector('.app__body .sidebar--menu');

        if (element) {
          element.classList.remove('visible');
        }
      });
    }
  }

  renderHintPopover() {
    let helpClass = 'search-help-popover';

    if (!this.props.searchTerms && this.state.focused) {
      helpClass += ' visible';
    }

    return react_default.a.createElement(Popover["a" /* default */], {
      id: "searchbar-help-popup",
      placement: "bottom",
      className: helpClass
    }, react_default.a.createElement(search_hint["a" /* default */], {
      withTitle: true
    }));
  }

  render() {
    let mentionBtn;
    let flagBtn;
    let cloudBtn;
    let workBtn;
    let user;
    let moreBtn;

    if (this.props.showMentionFlagBtns) {
      var flagBtnClass = this.props.isFlaggedPosts ? 'active' : '';
      flagBtn = react_default.a.createElement(HeaderIconWrapper, {
        iconComponent: react_default.a.createElement("span", {
          className: 'flag-btn ' + flagBtnClass
        }),
        buttonClass: 'channel-header__icon style--none ' + flagBtnClass,
        buttonId: 'channelHeaderFlagButton',
        onClick: this.getFlagged,
        tooltipKey: 'flaggedPosts'
      }); //flagBtn = <span className='flag-btn' onClick={this.getFlagged}></span>

      var mentionBtnClass = this.props.isMentionSearch ? 'active' : '';
      mentionBtnClass += this.props.isMentioned || this.props.isBeingInvited ? ' is-mentioned' : ''; // console.log('isMentioned',this.props.isMentioned)

      mentionBtn = react_default.a.createElement(HeaderIconWrapper, {
        iconComponent: react_default.a.createElement("span", {
          className: 'mention-btn ' + mentionBtnClass
        }),
        buttonClass: 'channel-header__icon style--none ',
        buttonId: 'channelHeaderMentionButton',
        onClick: this.searchMentions,
        tooltipKey: 'recentMentions'
      }); //mentionBtn = <span className='mention-btn' onClick={this.searchMentions}></span>

      workBtn = react_default.a.createElement(HeaderIconWrapper, {
        iconComponent: react_default.a.createElement("span", {
          className: "work-btn"
        }),
        buttonClass: 'channel-header__icon style--none ',
        buttonId: 'channelHeaderWorkButton',
        onClick: this.getWork,
        tooltipKey: 'workPosts'
      }); //workBtn = <span className='work-btn' onClick={this.getCloud}></span>

      var cloudBtnClass = this.props.isCloudPosts ? 'active' : '';
      cloudBtn = react_default.a.createElement(HeaderIconWrapper, {
        iconComponent: react_default.a.createElement("span", {
          className: 'cloud-btn ' + cloudBtnClass
        }),
        buttonClass: 'channel-header__icon style--none ' + cloudBtnClass,
        buttonId: 'channelHeaderCloudButton',
        onClick: this.getCloud,
        tooltipKey: 'cloudPosts'
      }); //cloudBtn = <span className='cloud-btn' onClick={this.getCloud}></span>

      moreBtn = react_default.a.createElement("img", {
        src: __webpack_require__(2966),
        onClick: this.searchMentions,
        style: {
          height: '32px',
          margin: '16px 0 0 8px',
          cursor: 'pointer'
        }
      });
      user = react_default.a.createElement("div", {
        className: "flex-child user"
      }, react_default.a.createElement(headerCloneTwo, null));
    }

    const showClear = !this.props.isSearchingTerm && this.props.searchTerms && this.props.searchTerms.trim() !== '';
    let searchFormClass = 'search__form';

    if (this.state.focused) {
      searchFormClass += ' focused';
    }

    const searchClearTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "searchClearTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_bar.clear",
      defaultMessage: "Clear search query"
    }));
    const searchform_container_hide = this.props.isCloudPosts ? 'invisible' : '';
    return react_default.a.createElement("div", {
      className: "sidebar-right__table"
    }, react_default.a.createElement("div", {
      className: "sidebar-collapse__container"
    }, react_default.a.createElement("div", {
      id: "sidebarCollapse",
      className: "sidebar-collapse",
      onClick: this.handleClose
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.back",
      defaultMessage: "Back Icon"
    }, title => react_default.a.createElement("span", {
      className: "fa fa-2x fa-angle-left",
      title: title
    })))), flagBtn, mentionBtn, workBtn, cloudBtn, user);
  }

}

search_bar_defineProperty(search_bar_SearchBar, "propTypes", {
  isSearchingTerm: prop_types_default.a.bool,
  searchTerms: prop_types_default.a.string,
  isMentionSearch: prop_types_default.a.bool,
  isMentioned: prop_types_default.a.bool,
  isBeingInvited: prop_types_default.a.bool,
  isFlaggedPosts: prop_types_default.a.bool,
  isCloudPosts: prop_types_default.a.bool,
  showMentionFlagBtns: prop_types_default.a.bool,
  isFocus: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    updateSearchTerms: prop_types_default.a.func,
    showSearchResults: prop_types_default.a.func,
    showMentions: prop_types_default.a.func,
    showFlaggedPosts: prop_types_default.a.func,
    showCloud: prop_types_default.a.func,
    closeRightHandSide: prop_types_default.a.func
  })
});

search_bar_defineProperty(search_bar_SearchBar, "defaultProps", {
  showMentionFlagBtns: true,
  isFocus: false
});

const search_bar_style = {
  searchForm: {
    overflow: 'visible'
  }
};
// CONCATENATED MODULE: ./components/search_bar/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function search_bar_mapStateToProps(state) {
  const rhsState = Object(selectors_rhs["m" /* getRhsState */])(state); // console.log('unreads',getUnreads(state))
  // console.log('unreadMeetingIds',state.views.meeting.unreadMeetingIds)

  return {
    isSearchingTerm: Object(selectors_rhs["g" /* getIsSearchingTerm */])(state),
    searchTerms: Object(selectors_rhs["o" /* getSearchTerms */])(state),
    isMentionSearch: rhsState === constants["x" /* RHSStates */].MENTION,
    isFlaggedPosts: rhsState === constants["x" /* RHSStates */].FLAG,
    isCloudPosts: rhsState === constants["x" /* RHSStates */].CLOUD,
    isMentioned: Object(entities_channels["getUnreads"])(state).mentionCount > 0,
    isBeingInvited: state.views.meeting.unreadMeetingIds.length > 0
  };
}

function search_bar_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      updateSearchTerms: rhs["w" /* updateSearchTerms */],
      showSearchResults: rhs["s" /* showSearchResults */],
      showMentions: rhs["p" /* showMentions */],
      showCloud: rhs["m" /* showCloud */],
      showFlaggedPosts: rhs["n" /* showFlaggedPosts */],
      closeRightHandSide: rhs["b" /* closeRightHandSide */]
    }, dispatch)
  };
}

/* harmony default export */ var search_bar = (Object(es["connect"])(search_bar_mapStateToProps, search_bar_mapDispatchToProps)(search_bar_SearchBar));
// EXTERNAL MODULE: ./mattermost-redux/actions/search.js
var actions_search = __webpack_require__(397);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/search.js
var entities_search = __webpack_require__(2967);

// EXTERNAL MODULE: ./components/search_results/search_results.jsx + 14 modules
var search_results = __webpack_require__(2251);

// CONCATENATED MODULE: ./components/search_results/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
















function search_results_makeMapStateToProps() {
  let results;
  let posts;
  return function mapStateToProps(state, ownProps) {
    const config = Object(general["getConfig"])(state);
    const dataRetentionEnableMessageDeletion = config.DataRetentionEnableMessageDeletion === "true";
    const dataRetentionMessageRetentionDays = config.DataRetentionMessageRetentionDays;
    const viewArchivedChannels = config.ExperimentalViewArchivedChannels === "true";
    const newResults = Object(selectors_rhs["i" /* getMentionTab */])(state) === constants["O" /* mentionTabKeys */].MEETING ? Object(selectors_rhs["h" /* getMeetingResults */])(state) : Object(entities_posts["getSearchResults"])(state);

    const users = (() => {
      if (!ownProps.channel) {
        return [];
      }

      const doGetProfilesInChannel = Object(entities_users["makeGetProfilesInChannel"])();
      const stats = Object(entities_channels["getAllChannelStats"])(state)[ownProps.channel.id] || {};
      const users = doGetProfilesInChannel(state, ownProps.channel.id, true); // console.log(
      //   "[sider] ownProps.channel.id:",
      //   ownProps.channel.id,
      //   ", state:",
      //   state,
      //   ", users:",
      //   users
      // );

      return users;
    })(); // Cache posts and channels


    if (newResults && newResults !== results) {
      results = newResults;
      posts = [];
      results.forEach(post => {
        if (!post) {
          return;
        }

        const channel = Object(entities_channels["getChannel"])(state, post.channel_id);

        if (channel && channel.delete_at !== 0 && !viewArchivedChannels) {
          return;
        }

        posts.push(post);
      });
    }

    const currentSearch = Object(entities_search["getCurrentSearchForCurrentTeam"])(state) || {};
    return {
      results: posts,
      users,
      matches: Object(entities_posts["getSearchMatches"])(state),
      currentUser: Object(entities_users["getCurrentUser"])(state),
      searchTerms: Object(selectors_rhs["n" /* getSearchResultsTerms */])(state),
      isSearchingTerm: Object(selectors_rhs["g" /* getIsSearchingTerm */])(state),
      isSearchingFlaggedPost: Object(selectors_rhs["e" /* getIsSearchingFlaggedPost */])(state),
      isSearchingPinnedPost: Object(selectors_rhs["f" /* getIsSearchingPinnedPost */])(state),
      isSearchGettingMore: Object(selectors_rhs["d" /* getIsSearchGettingMore */])(state),
      isSearchAtEnd: currentSearch.isEnd,
      compactDisplay: entities_preferences["get"](state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].MESSAGE_DISPLAY, constants["w" /* Preferences */].MESSAGE_DISPLAY_DEFAULT) === constants["w" /* Preferences */].MESSAGE_DISPLAY_COMPACT,
      dataRetentionEnableMessageDeletion,
      dataRetentionMessageRetentionDays,
      channel: ownProps.channel,
      collectList: state.views.rhs.collectList
    };
  };
}

function search_results_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getMorePostsForSearch: actions_search["getMorePostsForSearch"],
      showCloud: rhs["m" /* showCloud */],
      setSidebarSearchTerm: views_search["b" /* setSidebarSearchTerm */]
    }, dispatch)
  };
}

/* harmony default export */ var components_search_results = (Object(es["connect"])(search_results_makeMapStateToProps, search_results_mapDispatchToProps)(search_results["a" /* default */]));
// EXTERNAL MODULE: ./components/search_results_header/index.jsx + 3 modules
var search_results_header = __webpack_require__(2257);

// CONCATENATED MODULE: ./plugins/rhs_plugin/rhs_plugin.jsx
function rhs_plugin_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class rhs_plugin_RhsPlugin extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("div", {
      id: "rhsContainer",
      className: "sidebar-right__body",
      ref: "sidebarbody"
    }, react_default.a.createElement(search_results_header["a" /* default */], null, this.props.title), react_default.a.createElement(pluggable["a" /* default */], {
      pluggableName: "RightHandSidebarComponent",
      pluggableId: this.props.pluggableId
    }));
  }

}

rhs_plugin_defineProperty(rhs_plugin_RhsPlugin, "propTypes", {
  title: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object]),
  pluggableId: prop_types_default.a.string.isRequired
});
// CONCATENATED MODULE: ./plugins/rhs_plugin/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function rhs_plugin_mapStateToProps(state) {
  const rhsPlugins = state.plugins.components.RightHandSidebarComponent;
  const pluginId = Object(selectors_rhs["j" /* getPluginId */])(state);
  const pluginName = rhsPlugins.find(element => element.id === pluginId).title;
  return {
    title: pluginName,
    pluggableId: pluginId
  };
}

/* harmony default export */ var rhs_plugin = (Object(es["connect"])(rhs_plugin_mapStateToProps)(rhs_plugin_RhsPlugin));
// CONCATENATED MODULE: ./components/sidebar_right/sidebar_right.jsx
function sidebar_right_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












class sidebar_right_SidebarRight extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    sidebar_right_defineProperty(this, "onShrink", () => {
      this.props.actions.setRhsExpanded(false);
    });
  }

  componentDidUpdate(prevProps) {
    const wasOpen = prevProps.searchVisible || prevProps.postRightVisible;
    const isOpen = this.props.searchVisible || this.props.postRightVisible;

    if (!wasOpen && isOpen) {
      Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_rhs_opened');

      if (utils["k" /* disableVirtList */]()) {
        setTimeout(this.props.actions.scrollPostList, 0);
      }
    }

    const {
      actions,
      isPinnedPosts,
      channel
    } = this.props;

    if (isPinnedPosts && prevProps.isPinnedPosts === isPinnedPosts && channel.id !== prevProps.channel.id) {
      actions.showPinnedPosts(channel.id);
    }
  }

  render() {
    const {
      channel,
      currentUserId,
      isFlaggedPosts,
      isMembers,
      isMentionSearch,
      mentionTab,
      isPinnedPosts,
      isCloudPosts,
      postRightVisible,
      postCardVisible,
      previousRhsState,
      searchVisible,
      isPluginView
    } = this.props;
    let content = null;
    let expandedClass = '';

    if (this.props.isExpanded) {
      expandedClass = 'sidebar--right--expanded';
    }

    var searchForm = null;

    if (currentUserId) {
      searchForm = react_default.a.createElement(search_bar, {
        isFocus: searchVisible && !isFlaggedPosts && !isMembers && !isPinnedPosts && !isCloudPosts
      });
    }

    let channelDisplayName = '';

    if (channel) {
      if (channel.type === constants["N" /* default */].DM_CHANNEL || channel.type === constants["N" /* default */].GM_CHANNEL) {
        channelDisplayName = utils["gb" /* localizeMessage */]('rhs_root.direct', 'Direct Message');
      } else {
        channelDisplayName = channel.display_name;
      }
    }

    if (searchVisible) {
      content = react_default.a.createElement("div", {
        className: "sidebar--right__content"
      }, react_default.a.createElement("div", {
        className: "search-bar__container channel-header alt"
      }, searchForm), react_default.a.createElement(components_search_results, {
        channel: channel,
        isMentionSearch: isMentionSearch,
        mentionTab: mentionTab,
        isFlaggedPosts: isFlaggedPosts,
        isMembers: isMembers,
        isPinnedPosts: isPinnedPosts,
        isCloudPosts: isCloudPosts,
        toggleSize: this.toggleSize,
        shrink: this.onShrink,
        channelDisplayName: channelDisplayName
      }));
    } else if (postRightVisible) {
      content = react_default.a.createElement("div", {
        className: "post-right__container"
      }, react_default.a.createElement(FileUploadOverlay, {
        overlayType: "right"
      }), react_default.a.createElement("div", {
        className: "search-bar__container channel-header alt"
      }, searchForm), react_default.a.createElement(rhs_thread, {
        previousRhsState: previousRhsState,
        currentUserId: currentUserId,
        toggleSize: this.toggleSize,
        shrink: this.onShrink
      }));
    } else if (isPluginView) {
      content = react_default.a.createElement("div", {
        className: "post-right__container"
      }, react_default.a.createElement("div", {
        className: "search-bar__container channel-header alt"
      }, searchForm), react_default.a.createElement(rhs_plugin, null));
    } else if (postCardVisible) {
      content = react_default.a.createElement("div", {
        className: "post-right__container"
      }, react_default.a.createElement("div", {
        className: "search-bar__container channel-header alt"
      }, searchForm), react_default.a.createElement(rhs_card, {
        previousRhsState: previousRhsState
      }));
    }

    if (!content) {
      expandedClass = '';
    }

    return react_default.a.createElement("div", {
      className: classnames_default()('sidebar--right', expandedClass, {
        'move--left': this.props.isOpen
      }),
      id: "sidebar-right"
    }, react_default.a.createElement("div", {
      onClick: this.onShrink,
      className: "sidebar--right__bg"
    }), react_default.a.createElement("div", {
      className: "sidebar-right-container"
    }, content));
  }

}

sidebar_right_defineProperty(sidebar_right_SidebarRight, "propTypes", {
  isExpanded: prop_types_default.a.bool.isRequired,
  isOpen: prop_types_default.a.bool.isRequired,
  currentUserId: prop_types_default.a.string.isRequired,
  channel: prop_types_default.a.object,
  postRightVisible: prop_types_default.a.bool,
  postCardVisible: prop_types_default.a.bool,
  searchVisible: prop_types_default.a.bool,
  isMentionSearch: prop_types_default.a.bool,
  mentionTab: prop_types_default.a.string,
  isFlaggedPosts: prop_types_default.a.bool,
  isMembers: prop_types_default.a.bool,
  isPinnedPosts: prop_types_default.a.bool,
  isPluginView: prop_types_default.a.bool,
  isCloudPosts: prop_types_default.a.bool,
  previousRhsState: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    setRhsExpanded: prop_types_default.a.func.isRequired,
    showPinnedPosts: prop_types_default.a.func.isRequired,
    scrollPostList: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/sidebar_right/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











function sidebar_right_mapStateToProps(state) {
  const rhsState = Object(selectors_rhs["m" /* getRhsState */])(state); // console.log(rhsState)

  const channel = Object(entities_channels["getCurrentChannel"])(state) || null;
  return {
    isExpanded: Object(selectors_rhs["a" /* getIsRhsExpanded */])(state),
    isOpen: Object(selectors_rhs["c" /* getIsRhsOpen */])(state),
    channel,
    currentUserId: Object(entities_users["getCurrentUserId"])(state),
    postRightVisible: Boolean(Object(selectors_rhs["t" /* getSelectedPostId */])(state)),
    postCardVisible: Boolean(Object(selectors_rhs["s" /* getSelectedPostCardId */])(state)),
    searchVisible: Boolean(rhsState) && rhsState !== constants["x" /* RHSStates */].PLUGIN,
    previousRhsState: Object(selectors_rhs["l" /* getPreviousRhsState */])(state),
    isMentionSearch: rhsState === constants["x" /* RHSStates */].MENTION,
    mentionTab: Object(selectors_rhs["i" /* getMentionTab */])(state),
    isCloudPosts: rhsState === constants["x" /* RHSStates */].CLOUD,
    isFlaggedPosts: rhsState === constants["x" /* RHSStates */].FLAG,
    isPinnedPosts: rhsState === constants["x" /* RHSStates */].PIN,
    isPluginView: rhsState === constants["x" /* RHSStates */].PLUGIN,
    isMembers: rhsState === constants["x" /* RHSStates */].MEMBER
  };
}

function sidebar_right_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      setRhsExpanded: rhs["l" /* setRhsExpanded */],
      showPinnedPosts: rhs["q" /* showPinnedPosts */],
      scrollPostList: views_channel["h" /* scrollPostList */]
    }, dispatch)
  };
}

/* harmony default export */ var sidebar_right = (Object(es["connect"])(sidebar_right_mapStateToProps, sidebar_right_mapDispatchToProps)(sidebar_right_SidebarRight));
// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/CSSTransition.js + 2 modules
var CSSTransition = __webpack_require__(3493);

// CONCATENATED MODULE: ./components/sidebar_right_menu/sidebar_right_menu.jsx
function sidebar_right_menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const ANIMATION_DURATION = 500;
class sidebar_right_menu_SidebarRightMenu extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    sidebar_right_menu_defineProperty(this, "handleEmitUserLoggedOutEvent", () => {
      global_actions["e" /* emitUserLoggedOutEvent */]();
    });
  }

  render() {
    var siteName = '';

    if (this.props.siteName != null) {
      siteName = this.props.siteName;
    }

    var teamDisplayName = siteName;

    if (this.props.teamDisplayName) {
      teamDisplayName = this.props.teamDisplayName;
    }

    let tutorialTip = null;

    if (this.props.showTutorialTip) {
      tutorialTip = react_default.a.createElement(menu_tutorial_tip, {
        onBottom: true
      });
      this.props.actions.openRhsMenu();
    }

    return react_default.a.createElement("div", {
      className: classnames_default()('sidebar--menu', {
        'move--left': this.props.isOpen && utils["Y" /* isMobile */]()
      }),
      id: "sidebar-menu"
    }, react_default.a.createElement("div", {
      className: "team__header theme"
    }, react_default.a.createElement(react_router_dom["a" /* Link */], {
      className: "team__name",
      to: `/channels/${constants["g" /* Constants */].DEFAULT_CHANNEL}`
    }, teamDisplayName)), react_default.a.createElement("div", {
      className: "nav-pills__container mobile-main-menu"
    }, tutorialTip, react_default.a.createElement(CSSTransition["a" /* default */], {
      in: this.props.isOpen && utils["Y" /* isMobile */](),
      classNames: "MobileRightSidebarMenu",
      enter: true,
      exit: true,
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: {
        enter: ANIMATION_DURATION,
        exit: ANIMATION_DURATION
      }
    }, react_default.a.createElement(main_menu, {
      mobile: true
    }))));
  }

}

sidebar_right_menu_defineProperty(sidebar_right_menu_SidebarRightMenu, "propTypes", {
  isOpen: prop_types_default.a.bool.isRequired,
  teamDisplayName: prop_types_default.a.string,
  showTutorialTip: prop_types_default.a.bool.isRequired,
  siteName: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    openRhsMenu: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/sidebar_right_menu/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












function sidebar_right_menu_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const currentTeam = Object(entities_teams["getCurrentTeam"])(state);
  const enableTutorial = config.EnableTutorial === 'true';
  const tutorialStep = Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, Object(entities_users["getCurrentUserId"])(state), constants["H" /* TutorialSteps */].FINISHED);
  const siteName = config.SiteName;
  return {
    teamDisplayName: currentTeam.display_name,
    isOpen: Object(selectors_rhs["b" /* getIsRhsMenuOpen */])(state),
    showTutorialTip: enableTutorial && Object(utils["Y" /* isMobile */])() && tutorialStep === constants["H" /* TutorialSteps */].MENU_POPOVER,
    siteName
  };
}

function sidebar_right_menu_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openRhsMenu: rhs["f" /* openMenu */]
    }, dispatch)
  };
}

/* harmony default export */ var sidebar_right_menu = (Object(es["connect"])(sidebar_right_menu_mapStateToProps, sidebar_right_menu_mapDispatchToProps)(sidebar_right_menu_SidebarRightMenu));
// CONCATENATED MODULE: ./components/user_settings/import_theme_modal.jsx
function import_theme_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const import_theme_modal_ActionTypes = constants["N" /* default */].ActionTypes;
class import_theme_modal_ImportThemeModal extends react_default.a.Component {
  constructor(props) {
    super(props);

    import_theme_modal_defineProperty(this, "updateShow", (show, args) => {
      this.setState({
        show,
        callback: args.callback
      });
    });

    import_theme_modal_defineProperty(this, "handleSubmit", e => {
      e.preventDefault();
      const text = this.state.value;

      if (!this.isInputValid(text)) {
        this.setState({
          inputError: react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "user.settings.import_theme.submitError",
            defaultMessage: "Invalid format, please try copying and pasting in again."
          })
        });
        return;
      }

      const colors = text.split(',');
      const theme = {
        type: 'custom'
      };
      theme.sidebarBg = colors[0];
      theme.sidebarText = colors[5];
      theme.sidebarUnreadText = colors[5];
      theme.sidebarTextHoverBg = colors[4];
      theme.sidebarTextActiveBorder = colors[2];
      theme.sidebarTextActiveColor = colors[3];
      theme.sidebarHeaderBg = colors[1];
      theme.sidebarHeaderTextColor = colors[5];
      theme.onlineIndicator = colors[6];
      theme.awayIndicator = '#E0B333';
      theme.mentionBg = colors[7];
      theme.mentionColor = '#ffffff';
      theme.centerChannelBg = '#ffffff';
      theme.centerChannelColor = '#333333';
      theme.newMessageSeparator = '#F80';
      theme.linkColor = '#2389d7';
      theme.buttonBg = '#26a970';
      theme.buttonColor = '#ffffff';
      theme.mentionHighlightBg = '#fff2bb';
      theme.mentionHighlightLink = '#2f81b7';
      theme.codeTheme = 'github';
      this.state.callback(theme);
      this.setState({
        show: false,
        callback: null
      });
    });

    import_theme_modal_defineProperty(this, "handleChange", e => {
      const value = e.target.value;
      this.setState({
        value
      });

      if (this.isInputValid(value)) {
        this.setState({
          inputError: null
        });
      } else {
        this.setState({
          inputError: react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "user.settings.import_theme.submitError",
            defaultMessage: "Invalid format, please try copying and pasting in again."
          })
        });
      }
    });

    import_theme_modal_defineProperty(this, "handleOnHide", () => {
      this.setState({
        show: false
      });
    });

    this.state = {
      value: '',
      inputError: '',
      show: false,
      callback: null
    };
  }

  componentDidMount() {
    modal_store.addModalListener(import_theme_modal_ActionTypes.TOGGLE_IMPORT_THEME_MODAL, this.updateShow);
  }

  componentWillUnmount() {
    modal_store.removeModalListener(import_theme_modal_ActionTypes.TOGGLE_IMPORT_THEME_MODAL, this.updateShow);
  }

  isInputValid(text) {
    if (text.length === 0) {
      return false;
    }

    if (text.indexOf(' ') !== -1) {
      return false;
    }

    if (text.length > 0 && text.indexOf(',') === -1) {
      return false;
    }

    if (text.length > 0) {
      const colors = text.split(',');

      if (colors.length !== 8) {
        return false;
      }

      for (let i = 0; i < colors.length; i++) {
        if (colors[i].length !== 7 && colors[i].length !== 4) {
          return false;
        }

        if (colors[i].charAt(0) !== '#') {
          return false;
        }
      }
    }

    return true;
  }

  render() {
    return react_default.a.createElement("span", null, react_default.a.createElement(Modal["a" /* default */], {
      show: this.state.show,
      onHide: this.handleOnHide,
      role: "dialog",
      "aria-labelledby": "importThemeModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "importThemeModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "user.settings.import_theme.importHeader",
      defaultMessage: "Import Slack Theme"
    }))), react_default.a.createElement("form", {
      role: "form",
      className: "form-horizontal"
    }, react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "user.settings.import_theme.importBody",
      defaultMessage: "To import a theme, go to a Slack team and look for \"Preferences -> Sidebar Theme\". Open the custom theme option, copy the theme color values and paste them here:"
    })), react_default.a.createElement("div", {
      className: "form-group less"
    }, react_default.a.createElement("div", {
      className: "col-sm-12"
    }, react_default.a.createElement("input", {
      id: "themeVector",
      type: "text",
      className: "form-control",
      value: this.state.value,
      onChange: this.handleChange
    }), react_default.a.createElement("div", {
      className: "input__help"
    }, this.state.inputError)))), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      id: "cancelButton",
      type: "button",
      className: "btn btn-link",
      onClick: this.handleOnHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "user.settings.import_theme.cancel",
      defaultMessage: "Cancel"
    })), react_default.a.createElement("button", {
      id: "submitButton",
      onClick: this.handleSubmit,
      type: "submit",
      className: "btn btn-primary",
      tabIndex: "3"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "user.settings.import_theme.submit",
      defaultMessage: "Submit"
    }))))));
  }

}
// EXTERNAL MODULE: ./components/modal_controller/index.js + 1 modules
var modal_controller = __webpack_require__(2273);

// EXTERNAL MODULE: ./selectors/i18n.js
var selectors_i18n = __webpack_require__(302);

// CONCATENATED MODULE: ./selectors/lhs.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
function getIsLhsOpen(state) {
  return state.views.lhs.isOpen;
}
// EXTERNAL MODULE: ./utils/team_utils.jsx
var team_utils = __webpack_require__(1726);

// EXTERNAL MODULE: ./node_modules/react-contextmenu/es6/index.js + 9 modules
var es6 = __webpack_require__(3433);

// CONCATENATED MODULE: ./components/copy_url_context_menu/copy_url_context_menu.jsx
function copy_url_context_menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class copy_url_context_menu_CopyUrlContextMenu extends react_default.a.Component {
  constructor(...args) {
    super(...args);

    copy_url_context_menu_defineProperty(this, "copy", () => {
      let link = this.props.link; // Transform relative links to absolute ones for copy and paste.

      if (link.indexOf('http://') === -1 && link.indexOf('https://') === -1) {
        link = this.props.siteURL + link;
      }

      this.props.actions.copyToClipboard(link);
    });
  }

  render() {
    const contextMenu = react_default.a.createElement(es6["a" /* ContextMenu */], {
      id: 'copy-url-context-menu' + this.props.menuId
    }, react_default.a.createElement(es6["c" /* MenuItem */], {
      onClick: this.copy
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "copy_url_context_menu.getChannelLink",
      defaultMessage: "Copy Link"
    })));
    const contextMenuTrigger = react_default.a.createElement(es6["b" /* ContextMenuTrigger */], {
      id: 'copy-url-context-menu' + this.props.menuId
    }, this.props.children);
    return react_default.a.createElement("span", null, contextMenu, contextMenuTrigger);
  }

}

copy_url_context_menu_defineProperty(copy_url_context_menu_CopyUrlContextMenu, "propTypes", {
  // The child component that will be right-clicked on to show the context menu
  children: prop_types_default.a.element,
  // The link to copy to the user's clipboard when the 'Copy' option is selected from the context menu
  link: prop_types_default.a.string.isRequired,
  // A unique id differentiating this instance of context menu from others on the page.
  menuId: prop_types_default.a.string.isRequired,
  siteURL: prop_types_default.a.string.isRequired,
  actions: prop_types_default.a.shape({
    copyToClipboard: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/copy_url_context_menu/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function copy_url_context_menu_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  return {
    siteURL: config.SiteURL
  };
}

function copy_url_context_menu_mapDispatchToProps() {
  return {
    actions: {
      copyToClipboard: utils["g" /* copyToClipboard */]
    }
  };
}

/* harmony default export */ var copy_url_context_menu = (Object(es["connect"])(copy_url_context_menu_mapStateToProps, copy_url_context_menu_mapDispatchToProps)(copy_url_context_menu_CopyUrlContextMenu));
// CONCATENATED MODULE: ./components/team_sidebar/components/team_button.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class team_button_TeamButton extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.handleSwitch = this.handleSwitch.bind(this);
    this.handleDisabled = this.handleDisabled.bind(this);
  }

  handleSwitch(e) {
    e.preventDefault();
    Object(diagnostics_actions["b" /* mark */])('TeamLink#click');
    Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_team_sidebar_switch_team');
    this.props.switchTeam(this.props.url);
  }

  handleDisabled(e) {
    e.preventDefault();
  }

  render() {
    const teamIconUrl = this.props.teamIconUrl;
    let teamClass = this.props.active ? 'active' : '';
    const btnClass = this.props.btnClass;
    const disabled = this.props.disabled ? 'team-disabled' : '';
    const handleClick = this.props.active || this.props.disabled ? this.handleDisabled : this.handleSwitch;
    let badge;

    if (!teamClass) {
      teamClass = this.props.unread ? 'unread' : '';

      if (this.props.mentions) {
        badge = react_default.a.createElement("span", {
          className: 'badge pull-right small'
        }, this.props.mentions);
      }
    }

    let content = this.props.content;

    if (!content) {
      if (teamIconUrl) {
        content = react_default.a.createElement("div", {
          className: "team-btn__content"
        }, react_default.a.createElement("div", {
          className: "team-btn__image",
          style: {
            backgroundImage: `url('${teamIconUrl}')`
          }
        }));
      } else {
        let initials = this.props.displayName;
        initials = initials ? initials.replace(/\s/g, '').substring(0, 2) : '??';
        content = react_default.a.createElement("div", {
          className: "team-btn__content"
        }, react_default.a.createElement("div", {
          className: "team-btn__initials"
        }, initials));
      }
    }

    const toolTip = this.props.tip || Object(utils["gb" /* localizeMessage */])('team.button.name_undefined', 'Name undefined');
    const btn = react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: this.props.placement,
      overlay: react_default.a.createElement(Tooltip["a" /* default */], {
        id: `tooltip-${this.props.url}`
      }, toolTip)
    }, react_default.a.createElement("div", {
      className: 'team-btn ' + btnClass
    }, content));
    let teamButton;

    if (Object(user_agent["c" /* isDesktopApp */])()) {
      teamButton = react_default.a.createElement("button", {
        className: 'btn btn-link ' + disabled,
        onClick: handleClick
      }, btn); // if this is not a "special" team button, give it a context menu

      if (!this.props.url.endsWith('create_team') && !this.props.url.endsWith('select_team')) {
        teamButton = react_default.a.createElement(copy_url_context_menu, {
          link: this.props.url,
          menuId: this.props.url
        }, teamButton);
      }
    } else {
      teamButton = react_default.a.createElement(react_router_dom["a" /* Link */], {
        id: `${this.props.url.slice(1)}TeamButton`,
        className: `${disabled} TeamButton_${this.props.url.slice(1)}`,
        to: this.props.url,
        onClick: handleClick
      }, btn);
    }

    return react_default.a.createElement("div", {
      className: `team-container ${teamClass}`
    }, teamButton);
  }

}
team_button_TeamButton.defaultProps = {
  btnClass: '',
  tip: '',
  placement: 'right',
  active: false,
  disabled: false,
  unread: false,
  mentions: 0
};
team_button_TeamButton.propTypes = {
  btnClass: prop_types_default.a.string,
  url: prop_types_default.a.string.isRequired,
  displayName: prop_types_default.a.string,
  content: prop_types_default.a.node,
  tip: prop_types_default.a.node.isRequired,
  active: prop_types_default.a.bool,
  disabled: prop_types_default.a.bool,
  unread: prop_types_default.a.bool,
  mentions: prop_types_default.a.number,
  placement: prop_types_default.a.oneOf(['left', 'right', 'top', 'bottom']),
  teamIconUrl: prop_types_default.a.string,
  switchTeam: prop_types_default.a.func.isRequired
};
// CONCATENATED MODULE: ./components/team_sidebar/team_sidebar_controller.jsx
function team_sidebar_controller_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function team_sidebar_controller_extends() { team_sidebar_controller_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return team_sidebar_controller_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











function team_sidebar_controller_renderView(props) {
  return react_default.a.createElement("div", team_sidebar_controller_extends({}, props, {
    className: "scrollbar--view"
  }));
}
function team_sidebar_controller_renderThumbHorizontal(props) {
  return react_default.a.createElement("div", team_sidebar_controller_extends({}, props, {
    className: "scrollbar--horizontal"
  }));
}
function team_sidebar_controller_renderThumbVertical(props) {
  return react_default.a.createElement("div", team_sidebar_controller_extends({}, props, {
    className: "scrollbar--vertical"
  }));
}
class team_sidebar_controller_TeamSidebar extends react_default.a.PureComponent {
  componentDidMount() {
    this.props.actions.getTeams(0, 200);
  }

  render() {
    const root = document.querySelector('#root'); // if (this.props.myTeams.length <= 1) {
    //     root.classList.remove('multi-teams');
    //     return null;
    // }

    root.classList.add('multi-teams');
    const plugins = [];
    const teams = Object(team_utils["a" /* filterAndSortTeamsByDisplayName */])(this.props.myTeams, this.props.locale).map(team => {
      const member = this.props.myTeamMembers[team.id];
      return react_default.a.createElement(team_button_TeamButton, {
        key: 'switch_team_' + team.name,
        url: `/${team.name}`,
        tip: team.display_name,
        active: team.id === this.props.currentTeamId,
        displayName: team.display_name,
        unread: member.msg_count > 0,
        mentions: member.mention_count,
        teamIconUrl: utils["J" /* imageURLForTeam */](team),
        switchTeam: this.props.actions.switchTeam
      });
    });

    if (this.props.moreTeamsToJoin && !this.props.experimentalPrimaryTeam) {
      teams.push(react_default.a.createElement(team_button_TeamButton, {
        btnClass: "team-btn__add",
        key: "more_teams",
        url: "/select_team",
        tip: react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "team_sidebar.join",
          defaultMessage: "Other teams you can join."
        }),
        content: '+',
        switchTeam: this.props.actions.switchTeam
      }));
    } else {
      teams.push(react_default.a.createElement(system_permission_gate["a" /* default */], {
        permissions: [permissions_default.a.CREATE_TEAM],
        key: "more_teams"
      }, react_default.a.createElement(team_button_TeamButton, {
        btnClass: "team-btn__add",
        url: "/create_team",
        tip: react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "navbar_dropdown.create",
          defaultMessage: "Create a New Team"
        }),
        content: '+',
        switchTeam: this.props.actions.switchTeam
      })));
    }

    plugins.push(react_default.a.createElement("div", {
      key: "team-sidebar-bottom-plugin",
      className: "team-sidebar-bottom-plugin is-empty"
    }, react_default.a.createElement(pluggable["a" /* default */], {
      pluggableName: "BottomTeamSidebar"
    })));
    return react_default.a.createElement("div", {
      className: classnames_default()('team-sidebar', {
        'move--right': this.props.isOpen
      })
    }, react_default.a.createElement("div", {
      className: "team-box"
    }, react_default.a.createElement("div", {
      className: "team-wrapper"
    }, react_default.a.createElement(react_custom_scrollbars_lib_default.a, {
      autoHide: true,
      autoHideTimeout: 500,
      autoHideDuration: 500,
      renderThumbHorizontal: team_sidebar_controller_renderThumbHorizontal,
      renderThumbVertical: team_sidebar_controller_renderThumbVertical,
      renderView: team_sidebar_controller_renderView,
      onScroll: this.handleScroll
    }, teams)), plugins));
  }

}

team_sidebar_controller_defineProperty(team_sidebar_controller_TeamSidebar, "propTypes", {
  myTeams: prop_types_default.a.array.isRequired,
  currentTeamId: prop_types_default.a.string.isRequired,
  moreTeamsToJoin: prop_types_default.a.bool.isRequired,
  myTeamMembers: prop_types_default.a.object.isRequired,
  isOpen: prop_types_default.a.bool.isRequired,
  experimentalPrimaryTeam: prop_types_default.a.string,
  locale: prop_types_default.a.string.isRequired,
  actions: prop_types_default.a.shape({
    getTeams: prop_types_default.a.func.isRequired,
    switchTeam: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/team_sidebar/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











function team_sidebar_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const experimentalPrimaryTeam = config.ExperimentalPrimaryTeam;
  const joinableTeams = Object(entities_teams["getJoinableTeamIds"])(state);
  const moreTeamsToJoin = joinableTeams && joinableTeams.length > 0;
  return {
    currentTeamId: Object(entities_teams["getCurrentTeamId"])(state),
    myTeams: Object(entities_teams["getMyTeams"])(state),
    myTeamMembers: Object(entities_teams["getTeamMemberships"])(state),
    isOpen: getIsLhsOpen(state),
    experimentalPrimaryTeam,
    locale: Object(selectors_i18n["a" /* getCurrentLocale */])(state),
    moreTeamsToJoin
  };
}

function team_sidebar_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getTeams: actions_teams["getTeams"],
      switchTeam: team_actions["e" /* switchTeam */]
    }, dispatch)
  };
}

/* harmony default export */ var team_sidebar = (Object(react_router["f" /* withRouter */])(Object(es["connect"])(team_sidebar_mapStateToProps, team_sidebar_mapDispatchToProps)(team_sidebar_controller_TeamSidebar)));
// EXTERNAL MODULE: ./actions/views/lhs.js
var lhs = __webpack_require__(1722);

// EXTERNAL MODULE: ./node_modules/rebound/dist/rebound.js
var rebound = __webpack_require__(2968);

// EXTERNAL MODULE: ./utils/channel_utils.jsx
var utils_channel_utils = __webpack_require__(310);

// EXTERNAL MODULE: ./images/favicon/favicon-32x32.ico
var favicon_32x32 = __webpack_require__(1935);
var favicon_32x32_default = /*#__PURE__*/__webpack_require__.n(favicon_32x32);

// EXTERNAL MODULE: ./images/favicon/favicon-reddot-16x16.ico
var favicon_reddot_16x16 = __webpack_require__(1936);
var favicon_reddot_16x16_default = /*#__PURE__*/__webpack_require__.n(favicon_reddot_16x16);

// EXTERNAL MODULE: ./node_modules/reselect/es/index.js
var reselect_es = __webpack_require__(150);

// EXTERNAL MODULE: ./components/quick_input.jsx
var quick_input = __webpack_require__(1766);

// CONCATENATED MODULE: ./components/searchable_channel_list.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












const NEXT_BUTTON_TIMEOUT_MILLISECONDS = 500;
class searchable_channel_list_SearchableChannelList extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.createChannelRow = this.createChannelRow.bind(this);
    this.nextPage = this.nextPage.bind(this);
    this.previousPage = this.previousPage.bind(this);
    this.doSearch = this.doSearch.bind(this);
    this.nextTimeoutId = 0;
    this.state = {
      joiningChannel: '',
      page: 0,
      nextDisabled: false
    };
  }

  componentDidMount() {
    // only focus the search box on desktop so that we don't cause the keyboard to open on mobile
    if (!user_agent["m" /* isMobile */]() && this.refs.filter) {
      this.refs.filter.focus();
    }
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevState.page !== this.state.page) {
      jquery_default()(this.refs.channelList).scrollTop(0);
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.isSearch && !this.props.isSearch) {
      this.setState({
        page: 0
      });
    }
  }

  handleJoin(channel) {
    this.setState({
      joiningChannel: channel.id
    });
    this.props.handleJoin(channel, () => {
      this.setState({
        joiningChannel: ''
      });
    });
  }

  createChannelRow(channel) {
    return react_default.a.createElement("div", {
      className: "more-modal__row",
      key: channel.id
    }, react_default.a.createElement("div", {
      className: "more-modal__details"
    }, react_default.a.createElement("p", {
      className: "more-modal__name"
    }, channel.display_name), react_default.a.createElement("p", {
      className: "more-modal__description"
    }, channel.purpose)), react_default.a.createElement("div", {
      className: "more-modal__actions"
    }, react_default.a.createElement("button", {
      onClick: this.handleJoin.bind(this, channel),
      className: "btn btn-primary",
      disabled: this.state.joiningChannel
    }, react_default.a.createElement(loading_wrapper["a" /* default */], {
      loading: this.state.joiningChannel === channel.id,
      text: Object(utils["gb" /* localizeMessage */])('more_channels.joining', 'Joining...')
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "more_channels.join",
      defaultMessage: "Join"
    })))));
  }

  nextPage(e) {
    e.preventDefault();
    this.setState({
      page: this.state.page + 1,
      nextDisabled: true
    });
    this.nextTimeoutId = setTimeout(() => this.setState({
      nextDisabled: false
    }), NEXT_BUTTON_TIMEOUT_MILLISECONDS);
    this.props.nextPage(this.state.page + 1);
    jquery_default()(react_dom_default.a.findDOMNode(this.refs.channelListScroll)).scrollTop(0);
  }

  previousPage(e) {
    e.preventDefault();
    this.setState({
      page: this.state.page - 1
    });
    jquery_default()(react_dom_default.a.findDOMNode(this.refs.channelListScroll)).scrollTop(0);
  }

  doSearch() {
    const term = this.refs.filter.value;
    this.props.search(term);

    if (term === '') {
      this.setState({
        page: 0
      });
    }
  }

  render() {
    const channels = this.props.channels;
    let listContent;
    let nextButton;
    let previousButton;

    if (this.props.loading && channels.length === 0) {
      listContent = react_default.a.createElement(loading_screen["a" /* default */], {
        style: {
          marginTop: '50%'
        }
      });
    } else if (channels.length === 0) {
      listContent = react_default.a.createElement("div", {
        className: "no-channel-message"
      }, react_default.a.createElement("p", {
        className: "primary-message"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "more_channels.noMore",
        defaultMessage: "No more channels to join"
      })), this.props.noResultsText);
    } else {
      const pageStart = this.state.page * this.props.channelsPerPage;
      const pageEnd = pageStart + this.props.channelsPerPage;
      const channelsToDisplay = this.props.channels.slice(pageStart, pageEnd);
      listContent = channelsToDisplay.map(this.createChannelRow);

      if (channelsToDisplay.length >= this.props.channelsPerPage && pageEnd < this.props.channels.length) {
        nextButton = react_default.a.createElement("button", {
          className: "btn btn-link filter-control filter-control__next",
          onClick: this.nextPage,
          disabled: this.state.nextDisabled
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "more_channels.next",
          defaultMessage: "Next"
        }));
      }

      if (this.state.page > 0) {
        previousButton = react_default.a.createElement("button", {
          className: "btn btn-link filter-control filter-control__prev",
          onClick: this.previousPage
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "more_channels.prev",
          defaultMessage: "Previous"
        }));
      }
    }

    let input = react_default.a.createElement("div", {
      className: "filter-row filter-row--full"
    }, react_default.a.createElement("div", {
      className: "col-sm-12"
    }, react_default.a.createElement(quick_input["a" /* default */], {
      id: "searchChannelsTextbox",
      ref: "filter",
      className: "form-control filter-textbox",
      placeholder: {
        id: Object(i18n["b" /* t */])('filtered_channels_list.search'),
        defaultMessage: 'Search channels'
      },
      inputComponent: localized_input["a" /* default */],
      onInput: this.doSearch
    })));

    if (this.props.createChannelButton) {
      input = react_default.a.createElement("div", {
        className: "channel_search"
      }, react_default.a.createElement("div", {
        className: "search_input"
      }, react_default.a.createElement(quick_input["a" /* default */], {
        id: "searchChannelsTextbox",
        ref: "filter",
        className: "form-control filter-textbox",
        placeholder: {
          id: Object(i18n["b" /* t */])('filtered_channels_list.search'),
          defaultMessage: 'Search channels'
        },
        inputComponent: localized_input["a" /* default */],
        onInput: this.doSearch
      })), react_default.a.createElement("div", {
        className: "create_button"
      }, this.props.createChannelButton));
    }

    return react_default.a.createElement("div", {
      className: "filtered-user-list"
    }, input, react_default.a.createElement("div", {
      ref: "channelList",
      className: "more-modal__list"
    }, react_default.a.createElement("div", {
      ref: "channelListScroll"
    }, listContent)), react_default.a.createElement("div", {
      className: "filter-controls"
    }, previousButton, nextButton));
  }

}
searchable_channel_list_SearchableChannelList.defaultProps = {
  channels: [],
  isSearch: false
};
searchable_channel_list_SearchableChannelList.propTypes = {
  channels: prop_types_default.a.arrayOf(prop_types_default.a.object),
  channelsPerPage: prop_types_default.a.number,
  nextPage: prop_types_default.a.func.isRequired,
  isSearch: prop_types_default.a.bool,
  search: prop_types_default.a.func.isRequired,
  handleJoin: prop_types_default.a.func.isRequired,
  noResultsText: prop_types_default.a.object,
  loading: prop_types_default.a.bool,
  createChannelButton: prop_types_default.a.element
};
// CONCATENATED MODULE: ./components/more_channels/more_channels.jsx
function more_channels_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









const CHANNELS_CHUNK_SIZE = 50;
const CHANNELS_PER_PAGE = 50;
const SEARCH_TIMEOUT_MILLISECONDS = 100;
class more_channels_MoreChannels extends react_default.a.Component {
  constructor(props) {
    super(props);

    more_channels_defineProperty(this, "handleHide", () => {
      this.setState({
        show: false
      });

      if (this.props.bodyOnly) {
        this.handleExit();
      }
    });

    more_channels_defineProperty(this, "handleExit", () => {
      if (this.props.onModalDismissed) {
        this.props.onModalDismissed();
      }
    });

    more_channels_defineProperty(this, "onChange", force => {
      if (this.state.search && !force) {
        return;
      }

      this.setState({
        searchedChannels: [],
        serverError: null
      });
    });

    more_channels_defineProperty(this, "nextPage", page => {
      this.props.actions.getChannels(this.props.teamId, page + 1, CHANNELS_PER_PAGE);
    });

    more_channels_defineProperty(this, "handleJoin", (channel, done) => {
      const {
        actions,
        currentUserId,
        teamId,
        teamName
      } = this.props;
      actions.joinChannel(currentUserId, teamId, channel.id).then(result => {
        if (result.error) {
          this.setState({
            serverError: result.error.message
          });
        } else {
          browser_history["a" /* browserHistory */].push(Object(utils_url["b" /* getRelativeChannelURL */])(teamName, channel.name));
          this.handleHide();
        }

        if (done) {
          done();
        }
      });
    });

    more_channels_defineProperty(this, "search", term => {
      clearTimeout(this.searchTimeoutId);

      if (term === '') {
        this.onChange(true);
        this.setState({
          search: false,
          searchedChannels: [],
          searching: false
        });
        this.searchTimeoutId = '';
        return;
      }

      this.setState({
        search: true,
        searching: true
      });
      const searchTimeoutId = setTimeout(() => {
        this.props.actions.searchMoreChannels(term).then(result => {
          if (searchTimeoutId !== this.searchTimeoutId) {
            return;
          }

          if (result.data) {
            this.setSearchResults(result.data);
          } else {
            this.setState({
              searchedChannels: [],
              searching: false
            });
          }
        }).catch(() => {
          this.setState({
            searchedChannels: [],
            searching: false
          });
        });
      }, SEARCH_TIMEOUT_MILLISECONDS);
      this.searchTimeoutId = searchTimeoutId;
    });

    more_channels_defineProperty(this, "setSearchResults", channels => {
      this.setState({
        searchedChannels: channels.filter(c => c.delete_at === 0),
        searching: false
      });
    });

    this.searchTimeoutId = 0;
    this.state = {
      show: true,
      search: false,
      searchedChannels: [],
      serverError: null,
      searching: false
    };
  }

  componentDidMount() {
    this.props.actions.getChannels(this.props.teamId, 0, CHANNELS_CHUNK_SIZE * 2);
  }

  render() {
    const {
      channels,
      teamId,
      channelsRequestStarted,
      bodyOnly
    } = this.props;
    const {
      search,
      searchedChannels,
      serverError: serverErrorState,
      show,
      searching
    } = this.state;
    let serverError;

    if (serverErrorState) {
      serverError = react_default.a.createElement("div", {
        className: "form-group has-error"
      }, react_default.a.createElement("label", {
        className: "control-label"
      }, serverErrorState));
    }

    const createNewChannelButton = react_default.a.createElement(team_permission_gate["a" /* default */], {
      teamId: teamId,
      permissions: [permissions_default.a.CREATE_PUBLIC_CHANNEL, permissions_default.a.CREATE_PRIVATE_CHANNEL]
    }, react_default.a.createElement("button", {
      id: "createNewChannel",
      type: "button",
      className: "btn btn-primary channel-create-btn",
      onClick: this.props.handleNewChannel
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "more_channels.create",
      defaultMessage: "Create New Channel"
    })));
    const createChannelHelpText = react_default.a.createElement(team_permission_gate["a" /* default */], {
      teamId: teamId,
      permissions: [permissions_default.a.CREATE_PUBLIC_CHANNEL, permissions_default.a.CREATE_PRIVATE_CHANNEL]
    }, react_default.a.createElement("p", {
      className: "secondary-message"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "more_channels.createClick",
      defaultMessage: "Click 'Create New Channel' to make a new one"
    })));
    const body = react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(searchable_channel_list_SearchableChannelList, {
      channels: search ? searchedChannels : channels,
      channelsPerPage: CHANNELS_PER_PAGE,
      nextPage: this.nextPage,
      isSearch: search,
      search: this.search,
      handleJoin: this.handleJoin,
      noResultsText: createChannelHelpText,
      loading: search ? searching : channelsRequestStarted,
      createChannelButton: bodyOnly && createNewChannelButton
    }), serverError);

    if (bodyOnly) {
      return body;
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "more-modal more-modal--action",
      show: show,
      onHide: this.handleHide,
      onExited: this.handleExit,
      role: "dialog",
      "aria-labelledby": "moreChannelsModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "moreChannelsModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "more_channels.title",
      defaultMessage: "More Channels"
    })), createNewChannelButton), react_default.a.createElement(Modal["a" /* default */].Body, null, body));
  }

}

more_channels_defineProperty(more_channels_MoreChannels, "propTypes", {
  channels: prop_types_default.a.array.isRequired,
  currentUserId: prop_types_default.a.string.isRequired,
  teamId: prop_types_default.a.string.isRequired,
  teamName: prop_types_default.a.string.isRequired,
  onModalDismissed: prop_types_default.a.func,
  handleNewChannel: prop_types_default.a.func,
  channelsRequestStarted: prop_types_default.a.bool,
  bodyOnly: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    getChannels: prop_types_default.a.func.isRequired,
    joinChannel: prop_types_default.a.func.isRequired,
    searchMoreChannels: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/more_channels/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const getNotArchivedOtherChannels = Object(reselect_es["a" /* createSelector */])(entities_channels["getOtherChannels"], channels => channels && channels.filter(c => c.delete_at === 0));

function more_channels_mapStateToProps(state) {
  const team = Object(entities_teams["getCurrentTeam"])(state) || {};
  return {
    channels: getNotArchivedOtherChannels(state) || [],
    currentUserId: Object(entities_users["getCurrentUserId"])(state),
    teamId: team.id,
    teamName: team.name,
    channelsRequestStarted: state.requests.channels.getChannels.status === mattermost_redux_constants["RequestStatus"].STARTED
  };
}

function more_channels_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getChannels: actions_channels["getChannels"],
      joinChannel: actions_channels["joinChannel"],
      searchMoreChannels: channel_actions["g" /* searchMoreChannels */]
    }, dispatch)
  };
}

/* harmony default export */ var more_channels = (Object(es["connect"])(more_channels_mapStateToProps, more_channels_mapDispatchToProps)(more_channels_MoreChannels));
// CONCATENATED MODULE: ./components/more_direct_channels/group_message_option.jsx
function group_message_option_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class group_message_option_GroupMessageOption extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.addValue = this.addValue.bind(this);
  }

  getStyle() {
    let className = 'mentions__name';

    if (this.props.isSelected) {
      className += ' suggestion--selected';
    }

    return className;
  }

  displayName() {
    return this.props.channel.profiles.map(profile => '@' + profile.username).join(', ');
  }

  addValue() {
    this.props.onAdd(this.props.channel.profiles);
  }

  render() {
    return react_default.a.createElement("div", {
      key: this.props.channel.id,
      className: 'more-modal__row clickable ' + this.getStyle(),
      onClick: this.addValue
    }, react_default.a.createElement("div", {
      className: "more-modal__gm-icon bg-text-200"
    }, this.props.channel.profiles.length), react_default.a.createElement("div", {
      className: "more-modal__details"
    }, react_default.a.createElement("div", {
      className: "more-modal__name"
    }, this.displayName())), react_default.a.createElement("div", {
      className: "more-modal__actions"
    }, react_default.a.createElement("div", {
      className: "more-modal__actions--round"
    }, react_default.a.createElement(add_icon["a" /* default */], null))));
  }

}

group_message_option_defineProperty(group_message_option_GroupMessageOption, "propTypes", {
  channel: prop_types_default.a.object.isRequired,
  isSelected: prop_types_default.a.bool.isRequired,
  onAdd: prop_types_default.a.func.isRequired
});
// CONCATENATED MODULE: ./components/more_direct_channels/more_direct_channels.jsx
function more_direct_channels_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













const more_direct_channels_USERS_PER_PAGE = 50;
const more_direct_channels_MAX_SELECTABLE_VALUES = constants["N" /* default */].MAX_USERS_IN_GM - 1;
class more_direct_channels_MoreDirectChannels extends react_default.a.Component {
  constructor(props) {
    super(props);

    more_direct_channels_defineProperty(this, "loadProfilesMissingStatus", (users = [], statuses = {}) => {
      const missingStatusByIds = users.filter(user => !statuses[user.id]).map(user => user.id);

      if (missingStatusByIds.length > 0) {
        this.props.actions.getStatusesByIds(missingStatusByIds);
      }
    });

    more_direct_channels_defineProperty(this, "handleHide", () => {
      this.props.actions.setModalSearchTerm('');
      this.setState({
        show: false
      });

      if (this.props.bodyOnly) {
        this.handleExit();
      }
    });

    more_direct_channels_defineProperty(this, "setUsersLoadingState", loadingState => {
      this.setState({
        loadingUsers: loadingState
      });
    });

    more_direct_channels_defineProperty(this, "handleExit", () => {
      if (this.exitToChannel) {
        browser_history["a" /* browserHistory */].push(this.exitToChannel);
      }

      if (this.props.onModalDismissed) {
        this.props.onModalDismissed();
      }

      if (this.props.onHide) {
        this.props.onHide();
      }
    });

    more_direct_channels_defineProperty(this, "handleSubmit", (values = this.state.values) => {
      const {
        actions
      } = this.props;

      if (this.state.saving) {
        return;
      }

      const userIds = values.map(v => v.id);

      if (userIds.length === 0) {
        return;
      }

      this.setState({
        saving: true
      });

      const done = result => {
        const {
          data,
          error
        } = result;
        this.setState({
          saving: false
        });

        if (!error) {
          this.exitToChannel = '/' + this.props.currentTeamName + '/channels/' + data.name;
          this.handleHide();
        }
      };

      if (userIds.length === 1) {
        actions.openDirectChannelToUserId(userIds[0]).then(done);
      } else {
        actions.openGroupChannelToUserIds(userIds).then(done);
      }
    });

    more_direct_channels_defineProperty(this, "addValue", value => {
      if (Array.isArray(value)) {
        this.addUsers(value);
      } else if ('profiles' in value) {
        this.addUsers(value.profiles);
      } else {
        const values = Object.assign([], this.state.values);

        if (values.indexOf(value) === -1) {
          values.push(value);
        }

        this.setState({
          values
        });
      }
    });

    more_direct_channels_defineProperty(this, "addUsers", users => {
      const values = Object.assign([], this.state.values);
      const existingUserIds = values.map(user => user.id);

      for (const user of users) {
        if (existingUserIds.indexOf(user.id) !== -1) {
          continue;
        }

        values.push(user);
      }

      this.setState({
        values
      });
    });

    more_direct_channels_defineProperty(this, "getUserProfiles", page => {
      const pageNum = page ? page + 1 : 0;

      if (this.props.restrictDirectMessage === 'any') {
        this.props.actions.getProfiles(pageNum, more_direct_channels_USERS_PER_PAGE * 2).then(() => {
          this.setUsersLoadingState(false);
        });
      } else {
        this.props.actions.getProfilesInTeam(this.props.currentTeamId, pageNum, more_direct_channels_USERS_PER_PAGE * 2).then(() => {
          this.setUsersLoadingState(false);
        });
      }
    });

    more_direct_channels_defineProperty(this, "handlePageChange", (page, prevPage) => {
      if (page > prevPage) {
        this.setUsersLoadingState(true);
        this.getUserProfiles(page);
      }
    });

    more_direct_channels_defineProperty(this, "resetPaging", () => {
      if (this.refs.multiselect) {
        this.refs.multiselect.resetPaging();
      }
    });

    more_direct_channels_defineProperty(this, "search", term => {
      this.props.actions.setModalSearchTerm(term);
    });

    more_direct_channels_defineProperty(this, "handleDelete", values => {
      this.setState({
        values
      });
    });

    more_direct_channels_defineProperty(this, "renderOption", (option, isSelected, onAdd) => {
      if (option.type && option.type === 'G') {
        return react_default.a.createElement(group_message_option_GroupMessageOption, {
          key: option.id,
          channel: option,
          isSelected: isSelected,
          onAdd: onAdd
        });
      }

      const displayName = Object(utils["m" /* displayEntireNameForUser */])(option);
      let modalName = displayName;

      if (option.id === this.props.currentUserId) {
        modalName = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "more_direct_channels.directchannel.you",
          defaultMessage: "{displayname} (you)",
          values: {
            displayname: displayName
          }
        });
      } else if (option.delete_at) {
        modalName = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "more_direct_channels.directchannel.deactivated",
          defaultMessage: "{displayname} - Deactivated",
          values: {
            displayname: displayName
          }
        });
      }

      var rowSelected = '';

      if (isSelected) {
        rowSelected = 'more-modal__row--selected';
      }

      const status = option.delete_at || option.is_bot ? null : this.props.statuses[option.id];
      const email = option.is_bot ? null : option.email;
      return react_default.a.createElement("div", {
        key: option.id,
        ref: isSelected ? 'selected' : option.id,
        className: 'more-modal__row clickable ' + rowSelected,
        onClick: () => onAdd(option)
      }, react_default.a.createElement(profile_picture["a" /* default */], {
        src: client["Client4"].getProfilePictureUrl(option.id, option.last_picture_update),
        status: status,
        width: "32",
        height: "32"
      }), react_default.a.createElement("div", {
        className: "more-modal__details"
      }, react_default.a.createElement("div", {
        className: "more-modal__name"
      }, modalName, react_default.a.createElement(bot_badge["a" /* default */], {
        show: Boolean(option.is_bot),
        className: "badge-popoverlist"
      })), react_default.a.createElement("div", {
        className: "more-modal__description"
      }, email)), react_default.a.createElement("div", {
        className: "more-modal__actions"
      }, react_default.a.createElement("div", {
        className: "more-modal__actions--round"
      }, react_default.a.createElement(add_icon["a" /* default */], null))));
    });

    more_direct_channels_defineProperty(this, "handleSubmitImmediatelyOn", value => {
      return value.id === this.props.currentUserId || Boolean(value.delete_at);
    });

    this.searchTimeoutId = 0;
    const _values = [];

    if (props.currentChannelMembers) {
      for (let i = 0; i < props.currentChannelMembers.length; i++) {
        const user = Object.assign({}, props.currentChannelMembers[i]);

        if (user.id === props.currentUserId) {
          continue;
        }

        _values.push(user);
      }
    }

    this.state = {
      values: _values,
      show: true,
      search: false,
      saving: false,
      loadingUsers: true
    };
  }

  componentDidMount() {
    this.getUserProfiles();
    this.props.actions.getTotalUsersStats();
    this.loadProfilesMissingStatus(this.props.users, this.props.statuses);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.searchTerm !== nextProps.searchTerm) {
      clearTimeout(this.searchTimeoutId);
      const searchTerm = nextProps.searchTerm;

      if (searchTerm === '') {
        this.resetPaging();
      } else {
        const teamId = nextProps.restrictDirectMessage === 'any' ? '' : nextProps.currentTeamId;
        this.searchTimeoutId = setTimeout(async () => {
          this.setUsersLoadingState(true);
          const [{
            data: profilesData
          }, {
            data: groupChannelsData
          }] = await Promise.all([this.props.actions.searchProfiles(searchTerm, {
            team_id: teamId
          }), this.props.actions.searchGroupChannels(searchTerm)]);

          if (profilesData) {
            this.props.actions.loadStatusesForProfilesList(profilesData);
          }

          if (groupChannelsData) {
            this.props.actions.loadProfilesForGroupChannels(groupChannelsData);
          }

          this.resetPaging();
          this.setUsersLoadingState(false);
        }, constants["N" /* default */].SEARCH_TIMEOUT_MILLISECONDS);
      }
    }

    if (this.props.users.length !== nextProps.users.length || Object.keys(this.props.statuses).length !== Object.keys(nextProps.statuses).length) {
      this.loadProfilesMissingStatus(nextProps.users, nextProps.statuses);
    }
  }

  renderValue(props) {
    return props.data.username;
  }

  render() {
    let note;

    if (this.props.currentChannelMembers) {
      if (this.state.values && this.state.values.length >= more_direct_channels_MAX_SELECTABLE_VALUES) {
        note = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "more_direct_channels.new_convo_note.full",
          defaultMessage: 'You\'ve reached the maximum number of people for this conversation. Consider creating a private channel instead.'
        });
      } else if (this.props.isExistingChannel) {
        note = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "more_direct_channels.new_convo_note",
          defaultMessage: 'This will start a new conversation. If you\'re adding a lot of people, consider creating a private channel instead.'
        });
      }
    }

    const buttonSubmitText = Object(utils["gb" /* localizeMessage */])('multiselect.go', 'Go');
    const buttonSubmitLoadingText = Object(utils["gb" /* localizeMessage */])('multiselect.loading', 'Loading..');
    const numRemainingText = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "multiselect.numPeopleRemaining",
      defaultMessage: "Use \u2191\u2193 to browse, \u21B5 to select. You can add {num, number} more {num, plural, one {person} other {people}}. ",
      values: {
        num: more_direct_channels_MAX_SELECTABLE_VALUES - this.state.values.length
      }
    });
    let users = this.props.users || [];

    if (this.state.values.length) {
      users = users.filter(user => user.delete_at === 0 && user.id !== this.props.currentUserId);
    } else {
      const active = [];
      const inactive = [];

      for (const user of users) {
        (user.delete_at ? inactive : active).push(user);
      }

      users = active.concat(inactive);
    }

    const groupChannels = this.props.groupChannels || [];
    const options = [...users, ...groupChannels];
    const body = react_default.a.createElement(multiselect["a" /* default */], {
      key: "moreDirectChannelsList",
      ref: "multiselect",
      options: options,
      optionRenderer: this.renderOption,
      values: this.state.values,
      valueRenderer: this.renderValue,
      perPage: more_direct_channels_USERS_PER_PAGE,
      handlePageChange: this.handlePageChange,
      handleInput: this.search,
      handleDelete: this.handleDelete,
      handleAdd: this.addValue,
      handleSubmit: this.handleSubmit,
      noteText: note,
      maxValues: more_direct_channels_MAX_SELECTABLE_VALUES,
      numRemainingText: numRemainingText,
      buttonSubmitText: buttonSubmitText,
      buttonSubmitLoadingText: buttonSubmitLoadingText,
      submitImmediatelyOn: this.handleSubmitImmediatelyOn,
      saving: this.state.saving,
      loading: this.state.loadingUsers,
      users: this.props.users,
      totalCount: this.props.totalCount,
      placeholderText: Object(utils["gb" /* localizeMessage */])('multiselect.placeholder', 'Search and add members')
    });

    if (this.props.bodyOnly) {
      return body;
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: 'more-modal more-direct-channels',
      show: this.state.show,
      onHide: this.handleHide,
      onExited: this.handleExit,
      role: "dialog",
      "aria-labelledby": "moreDmModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "moreDmModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "more_direct_channels.title",
      defaultMessage: "Direct Messages"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, body), react_default.a.createElement(Modal["a" /* default */].Footer, {
      className: "modal-footer--invisible"
    }, react_default.a.createElement("button", {
      id: "closeModalButton",
      type: "button",
      className: "btn btn-link"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "general_button.close",
      defaultMessage: "Close"
    }))));
  }

}

more_direct_channels_defineProperty(more_direct_channels_MoreDirectChannels, "propTypes", {
  currentUserId: prop_types_default.a.string.isRequired,
  currentTeamId: prop_types_default.a.string.isRequired,
  currentTeamName: prop_types_default.a.string.isRequired,
  searchTerm: prop_types_default.a.string.isRequired,
  users: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,
  groupChannels: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,
  statuses: prop_types_default.a.object.isRequired,
  totalCount: prop_types_default.a.number,

  /*
   * List of current channel members of existing channel
   */
  currentChannelMembers: prop_types_default.a.arrayOf(prop_types_default.a.object),

  /*
   * Whether the modal is for existing channel or not
   */
  isExistingChannel: prop_types_default.a.bool.isRequired,

  /*
   * The mode by which direct messages are restricted, if at all.
   */
  restrictDirectMessage: prop_types_default.a.string,
  onModalDismissed: prop_types_default.a.func,
  onHide: prop_types_default.a.func,
  bodyOnly: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    getProfiles: prop_types_default.a.func.isRequired,
    getProfilesInTeam: prop_types_default.a.func.isRequired,
    getStatusesByIds: prop_types_default.a.func.isRequired,
    getTotalUsersStats: prop_types_default.a.func.isRequired,
    loadStatusesForProfilesList: prop_types_default.a.func.isRequired,
    loadProfilesForGroupChannels: prop_types_default.a.func.isRequired,
    openDirectChannelToUserId: prop_types_default.a.func.isRequired,
    openGroupChannelToUserIds: prop_types_default.a.func.isRequired,
    searchProfiles: prop_types_default.a.func.isRequired,
    searchGroupChannels: prop_types_default.a.func.isRequired,
    setModalSearchTerm: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/more_direct_channels/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
















function more_direct_channels_mapStateToProps(state, ownProps) {
  const currentUserId = Object(entities_users["getCurrentUserId"])(state);
  let currentChannelMembers = [];

  if (ownProps.isExistingChannel) {
    currentChannelMembers = Object(entities_users["getProfilesInCurrentChannel"])(state);
  }

  const config = Object(general["getConfig"])(state);
  const restrictDirectMessage = config.RestrictDirectMessage;
  const searchTerm = state.views.search.modalSearch;
  let users;

  if (searchTerm) {
    if (restrictDirectMessage === 'any') {
      users = Object(entities_users["searchProfiles"])(state, searchTerm, false);
    } else {
      users = Object(entities_users["searchProfilesInCurrentTeam"])(state, searchTerm, false);
    }
  } else if (restrictDirectMessage === 'any') {
    users = Object(entities_users["getProfiles"])(state);
  } else {
    users = Object(entities_users["getProfilesInCurrentTeam"])(state);
  }

  const filteredGroupChannels = filterGroupChannels(Object(entities_channels["getChannelsWithUserProfiles"])(state), searchTerm);
  const team = Object(entities_teams["getCurrentTeam"])(state);
  const stats = Object(entities_users["getTotalUsersStats"])(state) || {
    total_users_count: 0
  };
  return {
    currentTeamId: team.id,
    currentTeamName: team.name,
    searchTerm,
    users,
    groupChannels: filteredGroupChannels,
    statuses: state.entities.users.statuses,
    currentChannelMembers,
    currentUserId,
    restrictDirectMessage,
    totalCount: stats.total_users_count
  };
}

const filterGroupChannels = Object(helpers["memoizeResult"])((channels, term) => {
  return channels.filter(channel => {
    const matches = Object(user_utils["filterProfilesMatchingTerm"])(channel.profiles, term);
    return matches.length > 0;
  });
});

function more_direct_channels_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getProfiles: actions_users["getProfiles"],
      getProfilesInTeam: actions_users["getProfilesInTeam"],
      getStatusesByIds: actions_users["getStatusesByIds"],
      getTotalUsersStats: actions_users["getTotalUsersStats"],
      loadStatusesForProfilesList: status_actions["b" /* loadStatusesForProfilesList */],
      loadProfilesForGroupChannels: user_actions["h" /* loadProfilesForGroupChannels */],
      openDirectChannelToUserId: channel_actions["e" /* openDirectChannelToUserId */],
      openGroupChannelToUserIds: channel_actions["f" /* openGroupChannelToUserIds */],
      searchProfiles: actions_users["searchProfiles"],
      searchGroupChannels: actions_channels["searchGroupChannels"],
      setModalSearchTerm: views_search["a" /* setModalSearchTerm */]
    }, dispatch)
  };
}

/* harmony default export */ var more_direct_channels = (Object(es["connect"])(more_direct_channels_mapStateToProps, more_direct_channels_mapDispatchToProps)(more_direct_channels_MoreDirectChannels));
// EXTERNAL MODULE: ./mattermost-redux/actions/errors.js
var actions_errors = __webpack_require__(105);

// CONCATENATED MODULE: ./components/svg/draft_icon.jsx
function draft_icon_extends() { draft_icon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return draft_icon_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class draft_icon_DraftIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", draft_icon_extends({}, this.props, {
      id: "draftIcon"
    }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.channel.draft",
      defaultMessage: "Channel Draft Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "14px",
      height: "14px",
      viewBox: "0 0 50 51",
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fillRule: "evenodd"
    }, react_default.a.createElement("path", {
      d: "M11.980198,46.7136356 L14.9834983,43.7103353 L7.22772277,35.9545597 L4.22442244,38.95786 L4.22442244,42.4892132 L8.44884488,42.4892132 L8.44884488,46.7136356 L11.980198,46.7136356 Z M29.2409241,16.0865729 C29.2409241,15.6025221 28.9989023,15.3605003 28.5148515,15.3605003 C28.2948284,15.3605003 28.1078116,15.4375072 27.9537954,15.5915234 L10.0660066,33.4793122 C9.91199043,33.6333283 9.8349835,33.8203452 9.8349835,34.0403683 C9.8349835,34.5244191 10.0770053,34.7664409 10.5610561,34.7664409 C10.7810792,34.7664409 10.968096,34.6894339 11.1221122,34.5354178 L29.009901,16.647629 C29.1639172,16.4936128 29.2409241,16.306596 29.2409241,16.0865729 Z M27.4587459,9.74993922 L41.1881188,23.4793122 L13.7293729,50.938058 L0,50.938058 L0,37.2086851 L27.4587459,9.74993922 Z M50,12.9182561 C50,14.0843785 49.5929634,15.0744676 48.7788779,15.8885531 L43.30033,21.3671009 L29.5709571,7.637728 L35.049505,2.19218345 C35.8415881,1.35609566 36.8316772,0.938058036 38.019802,0.938058036 C39.1859244,0.938058036 40.1870145,1.35609566 41.0231023,2.19218345 L48.7788779,9.91495573 C49.5929634,10.7730458 50,11.7741359 50,12.9182561 Z"
    })))));
  }

}
// EXTERNAL MODULE: ./components/svg/globe_icon.jsx
var globe_icon = __webpack_require__(1653);

// EXTERNAL MODULE: ./components/svg/lock_icon.jsx
var lock_icon = __webpack_require__(1654);

// EXTERNAL MODULE: ./components/svg/archive_icon.jsx
var archive_icon = __webpack_require__(1691);

// CONCATENATED MODULE: ./components/suggestion/switch_channel_provider.jsx
function switch_channel_provider_extends() { switch_channel_provider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return switch_channel_provider_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


























const switch_channel_provider_getState = redux_store["a" /* default */].getState;

class switch_channel_provider_SwitchChannelSuggestion extends suggestion["a" /* default */] {
  static get propTypes() {
    return { ...super.propTypes,
      channelMember: prop_types_default.a.object,
      hasDraft: prop_types_default.a.bool
    };
  }

  render() {
    const {
      item,
      isSelection
    } = this.props;
    const channel = item.channel;
    const channelIsArchived = channel.delete_at && channel.delete_at !== 0;
    const member = this.props.channelMember;
    let badge = null;

    if (member) {
      if (member.notify_props && member.mention_count > 0) {
        badge = react_default.a.createElement("span", {
          className: "badge"
        }, member.mention_count);
      }
    }

    let className = 'mentions__name';

    if (isSelection) {
      className += ' suggestion--selected';
    }

    const displayName = channel.display_name;
    let icon = null;

    if (channelIsArchived) {
      icon = react_default.a.createElement(archive_icon["a" /* default */], {
        className: "icon icon__archive"
      });
    } else if (this.props.hasDraft) {
      icon = react_default.a.createElement(draft_icon_DraftIcon, {
        className: "icon icon__draft icon--body"
      });
    } else if (channel.type === constants["g" /* Constants */].OPEN_CHANNEL) {
      icon = react_default.a.createElement(globe_icon["a" /* default */], {
        className: "icon icon__globe icon--body"
      });
    } else if (channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
      icon = react_default.a.createElement(lock_icon["a" /* default */], {
        className: "icon icon__lock icon--body"
      });
    } else if (channel.type === constants["g" /* Constants */].GM_CHANNEL) {
      icon = react_default.a.createElement("div", {
        className: "status status--group"
      }, 'G');
    } else {
      icon = react_default.a.createElement("div", {
        className: "pull-left"
      }, react_default.a.createElement("img", {
        alt: '',
        className: "mention__image",
        src: utils["K" /* imageURLForUser */](channel.userId)
      }));
    }

    let tag = null;

    if (channel.type === constants["g" /* Constants */].DM_CHANNEL) {
      var teammate = utils["v" /* getDirectTeammate */](channel.id);

      if (utils["P" /* isEmptyObject */](teammate)) {
        teammate = Object(entities_users["getUser"])(switch_channel_provider_getState(), channel.userId);
      }

      tag = react_default.a.createElement(bot_badge["a" /* default */], {
        show: Boolean(teammate && teammate.is_bot),
        className: "badge-autocomplete"
      });
    }

    return react_default.a.createElement("div", switch_channel_provider_extends({
      onClick: this.handleClick,
      className: className,
      id: `switchChannel_${channel.name}`
    }, suggestion["a" /* default */].baseProps), icon, react_default.a.createElement("span", null, displayName), tag, badge);
  }

}

function mapStateToPropsForSwitchChannelSuggestion(state, ownProps) {
  const channelId = ownProps.item && ownProps.item.channel ? ownProps.item.channel.id : '';
  const draft = channelId ? Object(selectors_rhs["k" /* getPostDraft */])(state, constants["F" /* StoragePrefixes */].DRAFT, channelId) : false;
  return {
    channelMember: Object(entities_channels["getMyChannelMemberships"])(state)[channelId],
    hasDraft: draft && Boolean(draft.message.trim() || draft.fileInfos.length || draft.uploadsInProgress.length)
  };
}

const ConnectedSwitchChannelSuggestion = Object(es["connect"])(mapStateToPropsForSwitchChannelSuggestion)(switch_channel_provider_SwitchChannelSuggestion);
let switch_channel_provider_prefix = '';

function quickSwitchSorter(wrappedA, wrappedB) {
  const aIsArchived = wrappedA.channel.delete_at ? wrappedA.channel.delete_at !== 0 : false;
  const bIsArchived = wrappedB.channel.delete_at ? wrappedB.channel.delete_at !== 0 : false;

  if (aIsArchived && !bIsArchived) {
    return 1;
  } else if (!aIsArchived && bIsArchived) {
    return -1;
  } else if (wrappedA.type === constants["g" /* Constants */].MENTION_CHANNELS && wrappedB.type === constants["g" /* Constants */].MENTION_MORE_CHANNELS) {
    return -1;
  } else if (wrappedB.type === constants["g" /* Constants */].MENTION_CHANNELS && wrappedA.type === constants["g" /* Constants */].MENTION_MORE_CHANNELS) {
    return 1;
  }

  if (wrappedA.deactivated && !wrappedB.deactivated) {
    return 1;
  } else if (wrappedB.deactivated && !wrappedA.deactivated) {
    return -1;
  }

  const a = wrappedA.channel;
  const b = wrappedB.channel;
  let aDisplayName = a.display_name.toLowerCase();
  let bDisplayName = b.display_name.toLowerCase();

  if (a.type === constants["g" /* Constants */].DM_CHANNEL) {
    aDisplayName = aDisplayName.substring(1);
  }

  if (b.type === constants["g" /* Constants */].DM_CHANNEL) {
    bDisplayName = bDisplayName.substring(1);
  }

  const aStartsWith = aDisplayName.startsWith(switch_channel_provider_prefix);
  const bStartsWith = bDisplayName.startsWith(switch_channel_provider_prefix);

  if (aStartsWith && bStartsWith || !aStartsWith && !bStartsWith) {
    //
    // MM-12677 When this is migrated this needs to be fixed to pull the user's locale
    //
    return Object(channel_utils["sortChannelsByTypeAndDisplayName"])('en', a, b);
  } else if (aStartsWith) {
    return -1;
  }

  return 1;
}

function makeChannelSearchFilter(channelPrefix) {
  const channelPrefixLower = channelPrefix.toLowerCase();
  const curState = switch_channel_provider_getState();
  const usersInChannels = Object(entities_users["getUserIdsInChannels"])(curState);
  const userSearchStrings = {};
  return channel => {
    let searchString = channel.display_name;

    if (channel.type === constants["g" /* Constants */].GM_CHANNEL || channel.type === constants["g" /* Constants */].DM_CHANNEL) {
      const usersInChannel = usersInChannels[channel.id] || new Set([]); // In case the channel is a DM and the profilesInChannel is not populated

      if (!usersInChannel.size && channel.type === constants["g" /* Constants */].DM_CHANNEL) {
        const userId = utils["F" /* getUserIdFromChannelId */](channel.name);
        const user = Object(entities_users["getUser"])(curState, userId);

        if (user) {
          usersInChannel.add(userId);
        }
      }

      for (const userId of usersInChannel) {
        let userString = userSearchStrings[userId];

        if (!userString) {
          const user = Object(entities_users["getUser"])(curState, userId);

          if (!user) {
            continue;
          }

          const {
            nickname,
            username
          } = user;
          userString = `${nickname}${username}${utils["A" /* getFullName */](user)}`;
          userSearchStrings[userId] = userString;
        }

        searchString += userString;
      }
    }

    return searchString.toLowerCase().includes(channelPrefixLower);
  };
}

class switch_channel_provider_SwitchChannelProvider extends provider["a" /* default */] {
  handlePretextChanged(channelPrefix, resultsCallback) {
    if (channelPrefix) {
      switch_channel_provider_prefix = channelPrefix;
      this.startNewRequest(channelPrefix); // Dispatch suggestions for local data

      const channels = Object(entities_channels["getChannelsInCurrentTeam"])(switch_channel_provider_getState()).concat(Object(entities_channels["getDirectAndGroupChannels"])(switch_channel_provider_getState()));
      const users = Object.assign([], Object(entities_users["searchProfiles"])(switch_channel_provider_getState(), channelPrefix, false));
      this.formatChannelsAndDispatch(channelPrefix, resultsCallback, channels, users, true); // Fetch data from the server and dispatch

      this.fetchUsersAndChannels(channelPrefix, resultsCallback);
    } else {
      this.formatUnreadChannelsAndDispatch(resultsCallback);
    }

    return true;
  }

  async fetchUsersAndChannels(channelPrefix, resultsCallback) {
    const state = switch_channel_provider_getState();
    const teamId = Object(entities_teams["getCurrentTeamId"])(state);

    if (!teamId) {
      return;
    }

    const config = Object(general["getConfig"])(state);
    let usersAsync;

    if (config.RestrictDirectMessage === 'team') {
      usersAsync = client["Client4"].autocompleteUsers(channelPrefix, teamId, '');
    } else {
      usersAsync = client["Client4"].autocompleteUsers(channelPrefix, '', '');
    }

    const channelsAsync = actions_channels["searchChannels"](teamId, channelPrefix)(redux_store["a" /* default */].dispatch, redux_store["a" /* default */].getState);
    let usersFromServer = [];
    let channelsFromServer = [];

    try {
      usersFromServer = await usersAsync;
      const {
        data
      } = await channelsAsync;
      channelsFromServer = data;
    } catch (err) {
      redux_store["a" /* default */].dispatch(Object(actions_errors["logError"])(err));
    }

    if (this.shouldCancelDispatch(channelPrefix)) {
      return;
    }

    const users = Object.assign([], Object(entities_users["searchProfiles"])(state, channelPrefix, false)).concat(usersFromServer.users);
    const currentUserId = Object(entities_users["getCurrentUserId"])(state);
    redux_store["a" /* default */].dispatch({
      type: action_types["UserTypes"].RECEIVED_PROFILES_LIST,
      data: users.filter(user => user.id !== currentUserId)
    });
    const channels = Object(entities_channels["getChannelsInCurrentTeam"])(state).concat(Object(entities_channels["getDirectAndGroupChannels"])(state)).concat(channelsFromServer);
    this.formatChannelsAndDispatch(channelPrefix, resultsCallback, channels, users);
  }

  userWrappedChannel(user, channel) {
    let displayName = `@${user.username}`;

    if ((user.first_name || user.last_name) && user.nickname) {
      displayName += ` - ${utils["A" /* getFullName */](user)} (${user.nickname})`;
    } else if (user.nickname) {
      displayName += ` - (${user.nickname})`;
    } else if (user.first_name || user.last_name) {
      displayName += ` - ${utils["A" /* getFullName */](user)}`;
    }

    if (user.delete_at) {
      displayName += ' - ' + utils["gb" /* localizeMessage */]('channel_switch_modal.deactivated', 'Deactivated');
    }

    return {
      channel: {
        display_name: displayName,
        name: user.username,
        id: channel ? channel.id : user.id,
        userId: user.id,
        update_at: user.update_at,
        type: constants["g" /* Constants */].DM_CHANNEL,
        last_picture_update: user.last_picture_update || 0
      },
      name: user.username,
      deactivated: user.delete_at
    };
  }

  formatChannelsAndDispatch(channelPrefix, resultsCallback, allChannels, users, skipNotInChannel = false) {
    const channels = [];
    const members = Object(entities_channels["getMyChannelMemberships"])(switch_channel_provider_getState());

    if (this.shouldCancelDispatch(channelPrefix)) {
      return;
    }

    const completedChannels = {};
    const channelFilter = makeChannelSearchFilter(channelPrefix);
    const state = switch_channel_provider_getState();
    const config = Object(general["getConfig"])(state);
    const viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';

    for (const id of Object.keys(allChannels)) {
      const channel = allChannels[id];

      if (completedChannels[channel.id]) {
        continue;
      }

      if (channelFilter(channel)) {
        const newChannel = Object.assign({}, channel);
        const channelIsArchived = channel.delete_at !== 0;
        let wrappedChannel = {
          channel: newChannel,
          name: newChannel.name,
          deactivated: false
        };

        if (!viewArchivedChannels && channelIsArchived) {
          continue;
        } else if (channelIsArchived && members[channel.id]) {
          wrappedChannel.type = constants["g" /* Constants */].ARCHIVED_CHANNEL;
        } else if (channelIsArchived && !members[channel.id]) {
          continue;
        } else if (newChannel.type === constants["g" /* Constants */].GM_CHANNEL) {
          newChannel.name = newChannel.display_name;
          wrappedChannel.name = newChannel.name;
          const isGMVisible = Object(channel_utils["isGroupChannelVisible"])(config, Object(entities_preferences["getMyPreferences"])(state), channel, Object(entities_posts["getLastPostPerChannel"])(state)[channel.id], Object(channel_utils["isUnreadChannel"])(Object(entities_channels["getMyChannelMemberships"])(state), channel));

          if (isGMVisible) {
            wrappedChannel.type = constants["g" /* Constants */].MENTION_CHANNELS;
          } else {
            wrappedChannel.type = constants["g" /* Constants */].MENTION_MORE_CHANNELS;

            if (skipNotInChannel) {
              continue;
            }
          }
        } else if (newChannel.type === constants["g" /* Constants */].DM_CHANNEL) {
          const userId = utils["F" /* getUserIdFromChannelId */](newChannel.name);
          const user = users.find(u => u.id === userId);

          if (user) {
            completedChannels[user.id] = true;
            wrappedChannel = this.userWrappedChannel(user, newChannel);
            const isDMVisible = Object(channel_utils["isDirectChannelVisible"])(user.id, config, Object(entities_preferences["getMyPreferences"])(state), channel, Object(entities_posts["getLastPostPerChannel"])(state)[channel.id], Object(channel_utils["isUnreadChannel"])(Object(entities_channels["getMyChannelMemberships"])(state), channel));

            if (isDMVisible) {
              wrappedChannel.type = constants["g" /* Constants */].MENTION_CHANNELS;
            } else {
              wrappedChannel.type = constants["g" /* Constants */].MENTION_MORE_CHANNELS;

              if (skipNotInChannel) {
                continue;
              }
            }
          } else {
            continue;
          }
        } else if (members[channel.id]) {
          wrappedChannel.type = constants["g" /* Constants */].MENTION_CHANNELS;
        } else {
          wrappedChannel.type = constants["g" /* Constants */].MENTION_MORE_CHANNELS;

          if (skipNotInChannel || !newChannel.display_name.toLowerCase().startsWith(channelPrefix)) {
            continue;
          }
        }

        completedChannels[channel.id] = true;
        channels.push(wrappedChannel);
      }
    }

    for (let i = 0; i < users.length; i++) {
      const user = users[i];

      if (completedChannels[user.id]) {
        continue;
      }

      const isDMVisible = Object(entities_preferences["getBool"])(switch_channel_provider_getState(), mattermost_redux_constants["Preferences"].CATEGORY_DIRECT_CHANNEL_SHOW, user.id, false);
      const wrappedChannel = this.userWrappedChannel(user);

      if (isDMVisible) {
        wrappedChannel.type = constants["g" /* Constants */].MENTION_CHANNELS;
      } else {
        wrappedChannel.type = constants["g" /* Constants */].MENTION_MORE_CHANNELS;

        if (skipNotInChannel) {
          continue;
        }
      }

      completedChannels[user.id] = true;
      channels.push(wrappedChannel);
    }

    const channelNames = channels.sort(quickSwitchSorter).map(wrappedChannel => wrappedChannel.channel.name);

    if (skipNotInChannel) {
      channels.push({
        type: constants["g" /* Constants */].MENTION_MORE_CHANNELS,
        loading: true
      });
    }

    resultsCallback({
      matchedPretext: channelPrefix,
      terms: channelNames,
      items: channels,
      component: ConnectedSwitchChannelSuggestion
    });
  }

  formatUnreadChannelsAndDispatch(resultsCallback) {
    const getChannel = Object(entities_channels["makeGetChannel"])();
    const unreadChannelIds = Object(entities_channels["getSortedUnreadChannelIds"])(switch_channel_provider_getState(), false);
    const channels = [];

    for (let i = 0; i < unreadChannelIds.length; i++) {
      const channel = getChannel(switch_channel_provider_getState(), {
        id: unreadChannelIds[i]
      }) || {};
      let wrappedChannel = {
        channel,
        name: channel.name,
        deactivated: false
      };

      if (channel.type === constants["g" /* Constants */].GM_CHANNEL) {
        wrappedChannel.name = channel.display_name;
      } else if (channel.type === constants["g" /* Constants */].DM_CHANNEL) {
        const user = Object(entities_users["getUser"])(switch_channel_provider_getState(), utils["F" /* getUserIdFromChannelId */](channel.name));

        if (!user) {
          continue;
        }

        wrappedChannel = this.userWrappedChannel(user, channel);
      }

      wrappedChannel.type = constants["g" /* Constants */].MENTION_UNREAD_CHANNELS;
      channels.push(wrappedChannel);
    }

    const channelNames = channels.map(wrappedChannel => wrappedChannel.channel.name);
    resultsCallback({
      matchedPretext: '',
      terms: channelNames,
      items: channels,
      component: ConnectedSwitchChannelSuggestion
    });
  }

}
// CONCATENATED MODULE: ./components/suggestion/switch_team_provider.jsx
function switch_team_provider_extends() { switch_team_provider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return switch_team_provider_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const switch_team_provider_getState = redux_store["a" /* default */].getState;

class switch_team_provider_SwitchTeamSuggestion extends suggestion["a" /* default */] {
  render() {
    const {
      item,
      isSelection
    } = this.props;
    let className = 'mentions__name';

    if (isSelection) {
      className += ' suggestion--selected';
    }

    return react_default.a.createElement("div", switch_team_provider_extends({
      onClick: this.handleClick,
      className: className
    }, suggestion["a" /* default */].baseProps), react_default.a.createElement("div", {
      className: "status"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "general_tab.teamIcon",
      defaultMessage: "Team Icon"
    }, title => react_default.a.createElement("i", {
      className: "fa fa-group",
      title: title
    }))), item.display_name);
  }

}

let switch_team_provider_prefix = '';

function switch_team_provider_quickSwitchSorter(a, b) {
  const aDisplayName = a.display_name.toLowerCase();
  const bDisplayName = b.display_name.toLowerCase();
  const aStartsWith = aDisplayName.startsWith(switch_team_provider_prefix);
  const bStartsWith = bDisplayName.startsWith(switch_team_provider_prefix);

  if (aStartsWith && bStartsWith) {
    const locale = Object(selectors_i18n["a" /* getCurrentLocale */])(switch_team_provider_getState());

    if (aDisplayName !== bDisplayName) {
      return aDisplayName.localeCompare(bDisplayName, locale, {
        numeric: true
      });
    }

    return a.name.localeCompare(b.name, locale, {
      numeric: true
    });
  } else if (aStartsWith) {
    return -1;
  }

  return 1;
}

class switch_team_provider_SwitchTeamProvider extends provider["a" /* default */] {
  handlePretextChanged(teamPrefix, resultsCallback) {
    if (teamPrefix) {
      switch_team_provider_prefix = teamPrefix;
      this.startNewRequest(teamPrefix);
      const allTeams = entities_teams["getMyTeams"](switch_team_provider_getState());
      const teams = allTeams.filter(team => {
        return team.display_name.toLowerCase().indexOf(teamPrefix) !== -1 || team.name.indexOf(teamPrefix) !== -1;
      });
      const teamNames = teams.sort(switch_team_provider_quickSwitchSorter).map(team => team.name);
      resultsCallback({
        matchedPretext: teamPrefix,
        terms: teamNames,
        items: teams,
        component: switch_team_provider_SwitchTeamSuggestion
      });
      return true;
    }

    return false;
  }

}
// CONCATENATED MODULE: ./components/quick_switch_modal/quick_switch_modal.jsx
function quick_switch_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













const CHANNEL_MODE = 'channel';
const TEAM_MODE = 'team';
class quick_switch_modal_QuickSwitchModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    quick_switch_modal_defineProperty(this, "focusTextbox", () => {
      if (this.switchBox == null) {
        return;
      }

      const textbox = this.switchBox.getTextbox();

      if (document.activeElement !== textbox) {
        textbox.focus();
        utils["kb" /* placeCaretAtEnd */](textbox);
      }
    });

    quick_switch_modal_defineProperty(this, "setSwitchBoxRef", input => {
      this.switchBox = input;
      this.focusTextbox();
    });

    quick_switch_modal_defineProperty(this, "onShow", () => {
      this.setState({
        text: ''
      });
    });

    quick_switch_modal_defineProperty(this, "onHide", () => {
      this.focusPostTextbox();
      this.setState({
        text: ''
      });
      this.props.onHide();
    });

    quick_switch_modal_defineProperty(this, "focusPostTextbox", () => {
      if (!user_agent["m" /* isMobile */]()) {
        setTimeout(() => {
          const textbox = document.querySelector('#post_textbox');

          if (textbox) {
            textbox.focus();
          }
        });
      }
    });

    quick_switch_modal_defineProperty(this, "onChange", e => {
      this.setState({
        text: e.target.value
      });
    });

    quick_switch_modal_defineProperty(this, "handleKeyDown", e => {
      if (utils["V" /* isKeyPressed */](e, constants["N" /* default */].KeyCodes.TAB)) {
        e.preventDefault();
        this.switchMode();
      }
    });

    quick_switch_modal_defineProperty(this, "handleSubmit", async selected => {
      if (!selected) {
        return;
      }

      if (this.state.mode === CHANNEL_MODE) {
        const {
          joinChannelById,
          switchToChannel
        } = this.props.actions;
        const selectedChannel = selected.channel;

        if (selected.type === constants["N" /* default */].MENTION_MORE_CHANNELS && selectedChannel.type === constants["N" /* default */].OPEN_CHANNEL) {
          await joinChannelById(selectedChannel.id);
        }

        switchToChannel(selectedChannel).then(result => {
          if (result.data) {
            this.onHide();
          }
        });
      } else {
        browser_history["a" /* browserHistory */].push('/' + selected.name);
        this.onHide();
      }
    });

    quick_switch_modal_defineProperty(this, "enableChannelProvider", () => {
      this.channelProviders[0].disableDispatches = false;
      this.teamProviders[0].disableDispatches = true;
    });

    quick_switch_modal_defineProperty(this, "enableTeamProvider", () => {
      this.teamProviders[0].disableDispatches = false;
      this.channelProviders[0].disableDispatches = true;
    });

    quick_switch_modal_defineProperty(this, "switchMode", () => {
      if (this.state.mode === CHANNEL_MODE && this.props.showTeamSwitcher) {
        this.enableTeamProvider();
        this.setState({
          mode: TEAM_MODE
        });
      } else if (this.state.mode === TEAM_MODE) {
        this.enableChannelProvider();
        this.setState({
          mode: CHANNEL_MODE
        });
      }
    });

    quick_switch_modal_defineProperty(this, "handleOnClick", e => {
      e.preventDefault();
      const mode = e.currentTarget.getAttribute('data-mode');
      this.enableChannelProvider();
      this.setState({
        mode
      });
      this.focusTextbox();
    });

    this.channelProviders = [new switch_channel_provider_SwitchChannelProvider()];
    this.teamProviders = [new switch_team_provider_SwitchTeamProvider()];
    this.switchBox = null;
    this.state = {
      text: '',
      mode: CHANNEL_MODE
    };
  }

  render() {
    let providers = this.channelProviders;
    let header;
    let renderDividers = true;
    let channelShortcut = Object(i18n["b" /* t */])('quick_switch_modal.channelsShortcut.windows');
    let defaultChannelShortcut = 'CTRL+K';

    if (utils["W" /* isMac */]()) {
      channelShortcut = Object(i18n["b" /* t */])('quick_switch_modal.channelsShortcut.mac');
      defaultChannelShortcut = 'CMD+K';
    }

    let teamShortcut = Object(i18n["b" /* t */])('quick_switch_modal.teamsShortcut.windows');
    let defaultTeamShortcut = 'CTRL+ALT+K';

    if (utils["W" /* isMac */]()) {
      teamShortcut = Object(i18n["b" /* t */])('quick_switch_modal.teamsShortcut.mac');
      defaultTeamShortcut = 'CMD+ALT+K';
    }

    if (this.props.showTeamSwitcher) {
      let channelsActiveClass = '';
      let teamsActiveClass = '';

      if (this.state.mode === TEAM_MODE) {
        providers = this.teamProviders;
        renderDividers = false;
        teamsActiveClass = 'active';
      } else {
        channelsActiveClass = 'active';
      }

      header = react_default.a.createElement("div", {
        className: "nav nav-tabs"
      }, react_default.a.createElement("li", {
        className: channelsActiveClass
      }, react_default.a.createElement("a", {
        "data-mode": 'channel',
        href: "#",
        onClick: this.handleOnClick
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "quick_switch_modal.channels",
        defaultMessage: "Channels"
      }), react_default.a.createElement("span", {
        className: "small"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: channelShortcut,
        defaultMessage: defaultChannelShortcut
      })))), react_default.a.createElement("li", {
        className: teamsActiveClass
      }, react_default.a.createElement("a", {
        "data-mode": 'team',
        href: "#",
        onClick: this.handleOnClick
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "quick_switch_modal.teams",
        defaultMessage: "Teams"
      }), react_default.a.createElement("span", {
        className: "small"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: teamShortcut,
        defaultMessage: defaultTeamShortcut
      })))));
    }

    let help;

    if (utils["Y" /* isMobile */]()) {
      help = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "quick_switch_modal.help_mobile",
        defaultMessage: "Type to find a channel."
      });
    } else if (this.props.showTeamSwitcher) {
      help = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "quick_switch_modal.help",
        defaultMessage: "Start typing then use TAB to toggle channels/teams, \u2191\u2193 to browse, \u21B5 to select, and ESC to dismiss."
      });
    } else {
      help = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "quick_switch_modal.help_no_team",
        defaultMessage: "Type to find a channel. Use \u2191\u2193 to browse, \u21B5 to select, ESC to dismiss."
      });
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "channel-switch-modal modal--overflow",
      ref: "modal",
      show: true,
      onHide: this.onHide,
      enforceFocus: false,
      restoreFocus: false,
      role: "dialog",
      "aria-labelledby": "quickSwitchModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      id: "quickSwitchModalLabel",
      closeButton: true
    }), react_default.a.createElement(Modal["a" /* default */].Body, null, header, react_default.a.createElement("div", {
      id: "quickSwitchHint",
      className: "modal__hint"
    }, help), react_default.a.createElement(suggestion_box["a" /* default */], {
      id: "quickSwitchInput",
      ref: this.setSwitchBoxRef,
      className: "form-control focused",
      onChange: this.onChange,
      value: this.state.text,
      onKeyDown: this.handleKeyDown,
      onItemSelected: this.handleSubmit,
      listComponent: suggestion_list["a" /* default */],
      maxLength: "64",
      providers: providers,
      listStyle: "bottom",
      completeOnTab: false,
      spellCheck: "false",
      renderDividers: renderDividers,
      delayInputUpdate: true,
      openWhenEmpty: true
    })));
  }

}

quick_switch_modal_defineProperty(quick_switch_modal_QuickSwitchModal, "propTypes", {
  /**
   * The function called to hide the modal
   */
  onHide: prop_types_default.a.func.isRequired,

  /**
   * Set to show team switcher
   */
  showTeamSwitcher: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    joinChannelById: prop_types_default.a.func.isRequired,
    switchToChannel: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/quick_switch_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function quick_switch_modal_mapStateToProps() {
  return {
    showTeamSwitcher: false
  };
}

function quick_switch_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      joinChannelById: views_channel["e" /* joinChannelById */],
      switchToChannel: views_channel["k" /* switchToChannel */]
    }, dispatch)
  };
}

/* harmony default export */ var quick_switch_modal = (Object(es["connect"])(quick_switch_modal_mapStateToProps, quick_switch_modal_mapDispatchToProps)(quick_switch_modal_QuickSwitchModal));
// EXTERNAL MODULE: ./node_modules/antd/es/radio/index.js + 3 modules
var es_radio = __webpack_require__(3489);

// CONCATENATED MODULE: ./components/channel_icon/channel_icon.jsx
function channel_icon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




class channel_icon_ChannelIcon extends react_default.a.Component {
  constructor(props) {
    super(props);
  }

  render() {
    const {
      channelType
    } = this.props;
    const type = channelType === 'P' ? 'private' : 'public';
    return react_default.a.createElement("div", {
      className: `channel-icon-box channel-icon-box-${channelType}`
    }, react_default.a.createElement(es_radio["a" /* default */].Group, {
      onChange: this.props.onIconChange,
      value: this.props.channelIcon
    }, react_default.a.createElement("div", {
      className: "channel-icon-default"
    }, react_default.a.createElement(es_radio["a" /* default */], {
      value: `${type}_00.png`
    }, react_default.a.createElement("img", {
      src: __webpack_require__(2969)(`./${type}_00.png`)
    })), react_default.a.createElement("span", null, "\u9ED8\u8BA4")), react_default.a.createElement("div", {
      className: "icon-list"
    }, Array.from(7).map(val => {
      return react_default.a.createElement(es_radio["a" /* default */], {
        key: val,
        value: `${type}_0${val + 1}.png`
      }, react_default.a.createElement("img", {
        src: __webpack_require__(2970)(`./${type}_0${val + 1}.png`)
      }));
    }))));
  }

}

channel_icon_defineProperty(channel_icon_ChannelIcon, "propTypes", {
  onIconChange: PropTypes.func.isRequired,
  channelIcon: PropTypes.string.isRequired,
  channelType: PropTypes.string.isRequired
});

/* harmony default export */ var channel_icon = (channel_icon_ChannelIcon);
// CONCATENATED MODULE: ./components/new_channel_modal/new_channel_modal.jsx
function new_channel_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











class new_channel_modal_NewChannelModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    new_channel_modal_defineProperty(this, "onEnterKeyDown", e => {
      const enterPressed = utils["V" /* isKeyPressed */](e, constants["N" /* default */].KeyCodes.ENTER);
      const {
        ctrlSend
      } = this.props; // Enter pressed alone without required cmd or ctrl key

      if (ctrlSend && enterPressed && !e.ctrlKey) {
        e.preventDefault();
      } else if (ctrlSend && enterPressed && e.ctrlKey || !ctrlSend && enterPressed && !e.shiftKey && !e.altKey) {
        this.handleSubmit(e);
      }
    });

    new_channel_modal_defineProperty(this, "handleSubmit", e => {
      e.preventDefault();
      const displayName = react_dom_default.a.findDOMNode(this.refs.display_name).value.trim();

      if (displayName.length < constants["N" /* default */].MIN_CHANNELNAME_LENGTH) {
        this.setState({
          displayNameError: true
        });
        return;
      }

      this.props.onSubmitChannel();
    });

    new_channel_modal_defineProperty(this, "handleChange", () => {
      const newData = {
        displayName: this.refs.display_name.value
      };
      this.props.onDataChanged(newData);
    });

    new_channel_modal_defineProperty(this, "handleOnURLChange", e => {
      e.preventDefault();

      if (this.props.onChangeURLPressed) {
        this.props.onChangeURLPressed();
      }
    });

    new_channel_modal_defineProperty(this, "handleTypeSelect", e => {
      this.props.onTypeSwitched(e.target.value);
    });

    new_channel_modal_defineProperty(this, "handleIconChange", e => {
      this.props.onIconSwitched(e.target.value);
    });

    new_channel_modal_defineProperty(this, "handlePublicTypeSelect", () => {
      this.props.onTypeSwitched('O');
    });

    new_channel_modal_defineProperty(this, "handlePrivateTypeSelect", () => {
      this.props.onTypeSwitched('P');
    });

    this.state = {
      displayNameError: ''
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.show === true && this.props.show === false) {
      this.setState({
        displayNameError: ''
      });
    }
  }

  componentDidMount() {
    // ???
    if (user_agent["f" /* isInternetExplorer */]() || user_agent["d" /* isEdge */]()) {
      jquery_default()('body').addClass('browser--ie');
    }
  }

  render() {
    const {
      canCreatePublicChannel,
      canCreatePrivateChannel
    } = this.props;
    const enableTypeSelection = canCreatePublicChannel && canCreatePrivateChannel;
    var displayNameError = null;
    var serverError = null;
    var displayNameClass = 'form-group';

    if (this.state.displayNameError) {
      displayNameError = react_default.a.createElement("p", {
        className: "form-error"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_modal.displayNameError",
        defaultMessage: "Channel name must be 2 or more characters"
      }), this.state.displayNameError);
      displayNameClass += ' has-error';
    }

    if (this.props.serverError) {
      serverError = react_default.a.createElement("div", {
        className: "form-group has-error"
      }, react_default.a.createElement("div", {
        className: "col-sm-12"
      }, react_default.a.createElement("p", {
        id: "createChannelError",
        className: "input__help error"
      }, this.props.serverError)));
    }

    const publicChannelDesc = react_default.a.createElement("span", {
      className: "channel-type-radio"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_modal.publicName",
      defaultMessage: "Public"
    }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_modal.publicHint",
      defaultMessage: " - Anyone can join this channel."
    }));
    const privateChannelDesc = react_default.a.createElement("span", {
      className: "channel-type-radio"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_modal.privateName",
      defaultMessage: "Private"
    }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_modal.privateHint",
      defaultMessage: " - Only invited members can join this channel."
    }));
    let typeOptions = null;

    if (enableTypeSelection) {
      typeOptions = react_default.a.createElement(es_radio["a" /* default */].Group, {
        className: "channel-types-radio",
        onChange: this.handleTypeSelect,
        value: this.props.channelType
      }, react_default.a.createElement(es_radio["a" /* default */], {
        value: 'O'
      }, publicChannelDesc), react_default.a.createElement(es_radio["a" /* default */], {
        value: 'P'
      }, privateChannelDesc));
    } else {
      typeOptions = react_default.a.createElement("div", {
        className: "type-container multi-select__radio"
      }, react_default.a.createElement("div", {
        className: "radio"
      }, canCreatePublicChannel ? publicChannelDesc : null, canCreatePrivateChannel ? privateChannelDesc : null));
    }

    const prettyTeamURL = Object(utils_url["d" /* getShortenedURL */])();
    const {
      formatMessage
    } = this.props.intl;
    return react_default.a.createElement(es_modal["a" /* default */], {
      className: "new-channel__modal new-channel",
      closeIcon: react_default.a.createElement(es_icon["a" /* default */], {
        type: "close-circle",
        theme: "filled"
      }),
      visible: this.props.show,
      onCancel: this.props.onModalDismissed,
      onOk: this.handleSubmit,
      role: "dialog",
      title: formatMessage({
        id: 'channel_modal.modalTitle',
        defaultMessage: 'New Channel'
      }),
      cancelText: formatMessage({
        id: 'channel_modal.cancel',
        defaultMessage: 'Cancel'
      }),
      okText: formatMessage({
        id: 'channel_modal.createNew',
        defaultMessage: 'Create New Channel'
      }),
      mask: false,
      maskClosable: false,
      centered: true,
      width: '660px'
    }, react_default.a.createElement("div", {
      className: "new-channel-box"
    }, react_default.a.createElement("div", {
      className: "item"
    }, react_default.a.createElement("p", {
      className: "title"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_modal.type",
      defaultMessage: "Type"
    }), react_default.a.createElement("span", null, "*")), react_default.a.createElement("div", null, typeOptions)), react_default.a.createElement("div", {
      className: "item"
    }, react_default.a.createElement("p", {
      className: "title"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_modal.name",
      defaultMessage: "Name"
    }), react_default.a.createElement("span", null, "*")), react_default.a.createElement("div", null, react_default.a.createElement("input", {
      ref: "display_name",
      id: "newChannelName",
      value: this.props.channelData.displayName,
      placeholder: "E.g.: \"Bugs\", \"Marketing\", \"\u5BA2\u6237\u652F\u6301\"",
      maxLength: constants["N" /* default */].MAX_CHANNELNAME_LENGTH,
      autoFocus: true,
      tabIndex: "1",
      onChange: this.handleChange,
      onKeyDown: this.onEnterKeyDown,
      className: "channel-name"
    }), displayNameError)), react_default.a.createElement("div", {
      className: "item"
    }, react_default.a.createElement("p", {
      className: "title"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_modal.icon",
      defaultMessage: "Icon Select"
    }), react_default.a.createElement("span", null, "*")), react_default.a.createElement(channel_icon, {
      onIconChange: this.handleIconChange,
      channelIcon: this.props.channelIcon,
      channelType: this.props.channelType
    }))));
  }

}

new_channel_modal_defineProperty(new_channel_modal_NewChannelModal, "propTypes", {
  /**
   * Set whether to show the modal or not
   */
  show: prop_types_default.a.bool.isRequired,

  /**
   * Id of the active team
   */
  currentTeamId: prop_types_default.a.string.isRequired,

  /**
   * The type of channel to create, 'O' or 'P'
   */
  channelType: prop_types_default.a.string.isRequired,

  /**
   * The icon of channel to create
   */
  channelIcon: prop_types_default.a.string.isRequired,

  /**
   * The data needed to create the channel
   */
  channelData: prop_types_default.a.object.isRequired,

  /**
   * Set to force form submission on CTRL/CMD + ENTER instead of ENTER
   */
  ctrlSend: prop_types_default.a.bool,

  /**
   * Server error from failed channel creation
   */
  serverError: prop_types_default.a.node,

  /**
   * Function used to submit the channel
   */
  onSubmitChannel: prop_types_default.a.func.isRequired,

  /**
   * Function to call when modal is dimissed
   */
  onModalDismissed: prop_types_default.a.func.isRequired,

  /**
   * Function to call when modal has exited
   */
  onModalExited: prop_types_default.a.func,

  /**
   * Function to call to switch channel type
   */
  onTypeSwitched: prop_types_default.a.func.isRequired,

  /**
   * Function to call to switch channel icon
   */
  onIconSwitched: prop_types_default.a.func.isRequired,

  /**
   * Function to call when edit URL button is pressed
   */
  onChangeURLPressed: prop_types_default.a.func.isRequired,

  /**
   * Function to call when channel data is modified
   */
  onDataChanged: prop_types_default.a.func.isRequired,

  /**
   * Permission to create public channel
   */
  canCreatePublicChannel: prop_types_default.a.bool.isRequired,

  /**
   * Permission to create private channel
   */
  canCreatePrivateChannel: prop_types_default.a.bool.isRequired
});
// CONCATENATED MODULE: ./components/new_channel_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function new_channel_modal_mapStateToProps(state) {
  return {
    ctrlSend: Object(entities_preferences["getBool"])(state, mattermost_redux_constants["Preferences"].CATEGORY_ADVANCED_SETTINGS, 'send_on_ctrl_enter'),
    currentTeamId: Object(entities_teams["getCurrentTeamId"])(state)
  };
}

/* harmony default export */ var new_channel_modal = (Object(es["connect"])(new_channel_modal_mapStateToProps)(Object(index_es["h" /* injectIntl */])(new_channel_modal_NewChannelModal)));
// CONCATENATED MODULE: ./components/change_url_modal/change_url_modal.jsx
function change_url_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class change_url_modal_ChangeURLModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    change_url_modal_defineProperty(this, "onURLChanged", e => {
      const url = e.target.value.trim();
      this.setState({
        currentURL: url.replace(/[^A-Za-z0-9-_]/g, '').toLowerCase(),
        userEdit: true
      });
    });

    change_url_modal_defineProperty(this, "formattedError", (key, id, message) => {
      return react_default.a.createElement("span", {
        key: key
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: id,
        defaultMessage: message
      }), react_default.a.createElement("br", null));
    });

    change_url_modal_defineProperty(this, "getURLError", url => {
      let error = []; //eslint-disable-line prefer-const

      if (url.length < 2) {
        error.push(this.formattedError('error1', Object(i18n["b" /* t */])('change_url.longer'), 'URL must be two or more characters.'));
      }

      if (url.charAt(0) === '-' || url.charAt(0) === '_') {
        error.push(this.formattedError('error2', Object(i18n["b" /* t */])('change_url.startWithLetter'), 'URL must start with a letter or number.'));
      }

      if (url.length > 1 && (url.charAt(url.length - 1) === '-' || url.charAt(url.length - 1) === '_')) {
        error.push(this.formattedError('error3', Object(i18n["b" /* t */])('change_url.endWithLetter'), 'URL must end with a letter or number.'));
      }

      if (url.indexOf('__') > -1) {
        error.push(this.formattedError('error4', Object(i18n["b" /* t */])('change_url.noUnderscore'), 'URL can not contain two underscores in a row.'));
      } // In case of error we don't detect


      if (error.length === 0) {
        error.push(this.formattedError('errorlast', Object(i18n["b" /* t */])('change_url.invalidUrl'), 'Invalid URL'));
      }

      return error;
    });

    change_url_modal_defineProperty(this, "onSubmit", e => {
      e.preventDefault();
      const url = this.refs.urlinput.value;
      const cleanedURL = Object(utils_url["a" /* cleanUpUrlable */])(url);

      if (cleanedURL !== url || url.length < 2 || url.indexOf('__') > -1) {
        this.setState({
          urlError: this.getURLError(url)
        });
        return;
      }

      this.setState({
        urlError: '',
        userEdit: false
      });
      this.props.onModalSubmit(url);
    });

    change_url_modal_defineProperty(this, "onCancel", () => {
      this.setState({
        urlError: '',
        userEdit: false
      });
      this.props.onModalDismissed();
    });

    this.state = {
      currentURL: props.currentURL,
      urlError: '',
      userEdit: false
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    // This check prevents the url being deleted when we re-render
    // because of user status check
    if (!this.state.userEdit) {
      this.setState({
        currentURL: nextProps.currentURL
      });
    }
  }

  render() {
    let urlClass = 'input-group input-group--limit';
    let error = null;

    if (this.state.urlError) {
      urlClass += ' has-error';
    }

    if (this.props.serverError || this.state.urlError) {
      error = react_default.a.createElement("div", {
        className: "has-error"
      }, react_default.a.createElement("p", {
        className: "input__help error"
      }, this.state.urlError || this.props.serverError));
    }

    const fullURL = this.props.currentTeamURL + '/channels';
    const shortURL = Object(utils_url["d" /* getShortenedURL */])(fullURL);
    const urlTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "urlTooltip"
    }, fullURL);
    return react_default.a.createElement(Modal["a" /* default */], {
      show: this.props.show,
      onHide: this.onCancel,
      onExited: this.props.onModalExited,
      role: "dialog",
      "aria-labelledby": "changeUrlModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "changeUrlModalLabel"
    }, this.props.title)), react_default.a.createElement("form", {
      role: "form",
      className: "form-horizontal"
    }, react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement("div", {
      className: "modal-intro"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_flow.changeUrlDescription",
      defaultMessage: "Some characters are now allowed in URLs and may be removed."
    })), react_default.a.createElement("div", {
      className: "form-group"
    }, react_default.a.createElement("label", {
      className: "col-sm-3 form__label control-label"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "change_url.urlLabel",
      defaultMessage: "Channel URL"
    })), react_default.a.createElement("div", {
      className: "col-sm-9"
    }, react_default.a.createElement("div", {
      className: urlClass
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: urlTooltip
    }, react_default.a.createElement("span", {
      className: "input-group-addon"
    }, shortURL)), react_default.a.createElement("input", {
      type: "text",
      ref: "urlinput",
      className: "form-control",
      maxLength: constants["N" /* default */].MAX_CHANNELNAME_LENGTH,
      onChange: this.onURLChanged,
      value: this.state.currentURL,
      autoFocus: true,
      tabIndex: "1"
    })), error))), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-link",
      onClick: this.onCancel
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "change_url.close",
      defaultMessage: "Close"
    })), react_default.a.createElement("button", {
      onClick: this.onSubmit,
      type: "submit",
      className: "btn btn-primary",
      tabIndex: "2"
    }, this.props.submitButtonText))));
  }

}

change_url_modal_defineProperty(change_url_modal_ChangeURLModal, "propTypes", {
  /**
  * Set whether to show the modal or not
  */
  show: prop_types_default.a.bool.isRequired,

  /**
  * Set to change the title of the modal
  */
  title: prop_types_default.a.node,

  /**
  * Set to change the submit button text
  */
  submitButtonText: prop_types_default.a.node,

  /**
  * Set to change the current URL
  */
  currentURL: prop_types_default.a.string,

  /**
  * Set to the current team URL
  */
  currentTeamURL: prop_types_default.a.string.isRequired,

  /**
  * Server error from failed channel creation
  */
  serverError: prop_types_default.a.node,

  /**
   * Function to call when modal is submitted
   */
  onModalSubmit: prop_types_default.a.func.isRequired,

  /**
   * Function to call when modal is exited
   */
  onModalExited: prop_types_default.a.func,

  /**
   * Function to call when modal is dimissed
   */
  onModalDismissed: prop_types_default.a.func.isRequired
});

change_url_modal_defineProperty(change_url_modal_ChangeURLModal, "defaultProps", {
  show: false,
  title: 'Change URL',
  submitButtonText: 'Save',
  currentURL: '',
  serverError: null
});
// CONCATENATED MODULE: ./components/change_url_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function change_url_modal_mapStateToProps(state) {
  const currentTeam = Object(entities_teams["getCurrentTeam"])(state);
  const currentTeamURL = `${Object(utils_url["e" /* getSiteURL */])()}/${currentTeam.name}`;
  return {
    currentTeamURL
  };
}

/* harmony default export */ var change_url_modal = (Object(es["connect"])(change_url_modal_mapStateToProps)(change_url_modal_ChangeURLModal));
// CONCATENATED MODULE: ./components/new_channel_flow/new_channel_flow.jsx
function new_channel_flow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








const SHOW_NEW_CHANNEL = 1;
const SHOW_EDIT_URL = 2;
const SHOW_EDIT_URL_THEN_COMPLETE = 3;
class new_channel_flow_NewChannelFlow extends react_default.a.Component {
  constructor(props) {
    super(props);

    new_channel_flow_defineProperty(this, "onSubmit", () => {
      if (!this.state.channelDisplayName) {
        this.setState({
          serverError: utils["gb" /* localizeMessage */]('channel_flow.invalidName', 'Invalid Channel Name')
        });
        return;
      } // if (this.state.channelName.length < 2) {
      //     this.setState({flowState: SHOW_EDIT_URL_THEN_COMPLETE});
      //     return;
      // }


      const {
        actions,
        currentTeamId
      } = this.props;
      const currTime = new Date().getTime() + this.props.currentUser.id;
      const channel = {
        team_id: currentTeamId,
        name: currTime,
        display_name: this.state.channelDisplayName,
        purpose: this.state.channelPurpose,
        header: this.state.channelHeader,
        type: this.state.channelType,
        icon_id: this.state.channelIcon
      };
      actions.createChannel(channel).then(result => {
        if (result.error) {
          this.onCreateChannelError(result.error);
          return;
        }

        window.isNewChannel = true; //是否是新创建频道

        this.props.onModalDismissed();
        actions.switchToChannel(result.data);
      });
    });

    new_channel_flow_defineProperty(this, "onCreateChannelError", err => {
      if (err.id === 'model.channel.is_valid.2_or_more.app_error') {
        this.setState({
          flowState: SHOW_EDIT_URL_THEN_COMPLETE,
          serverError: react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "channel_flow.handleTooShort",
            defaultMessage: "Channel URL must be 2 or more lowercase alphanumeric characters"
          })
        });
      } else if (err.id === 'store.sql_channel.update.exists.app_error') {
        this.setState({
          serverError: utils["gb" /* localizeMessage */]('channel_flow.alreadyExist', 'A channel with that URL already exists')
        });
      } else {
        this.setState({
          serverError: err.message
        });
      }
    });

    new_channel_flow_defineProperty(this, "typeSwitched", channelType => {
      this.setState({
        channelType,
        serverError: '',
        channelIcon: channelType === 'O' ? 'public_00.png' : 'private_00.png'
      });
    });

    new_channel_flow_defineProperty(this, "iconSwitched", channelIcon => {
      this.setState({
        channelIcon,
        serverError: ''
      });
    });

    new_channel_flow_defineProperty(this, "urlChangeRequested", e => {
      if (e) {
        e.preventDefault();
      }

      this.setState({
        flowState: SHOW_EDIT_URL
      });
    });

    new_channel_flow_defineProperty(this, "urlChangeSubmitted", newURL => {
      if (this.state.flowState === SHOW_EDIT_URL_THEN_COMPLETE) {
        this.setState({
          channelName: newURL,
          nameModified: true
        }, this.onSubmit);
      } else {
        this.setState({
          flowState: SHOW_NEW_CHANNEL,
          serverError: null,
          channelName: newURL,
          nameModified: true
        });
      }
    });

    new_channel_flow_defineProperty(this, "urlChangeDismissed", () => {
      this.setState({
        flowState: SHOW_NEW_CHANNEL
      });
    });

    new_channel_flow_defineProperty(this, "channelDataChanged", data => {
      this.setState({
        channelDisplayName: data.displayName,
        channelPurpose: data.purpose,
        channelHeader: data.header
      });

      if (!this.state.nameModified) {
        this.setState({
          channelName: Object(utils_url["a" /* cleanUpUrlable */])(data.displayName.trim())
        });
      }
    });

    const _channelType = props.channelType || constants["N" /* default */].OPEN_CHANNEL;

    this.state = {
      serverError: '',
      channelType: _channelType,
      channelIcon: _channelType === 'O' ? 'public_00.png' : 'private_00.png',
      flowState: SHOW_NEW_CHANNEL,
      channelDisplayName: '',
      channelName: '',
      channelPurpose: '',
      channelHeader: '',
      nameModified: false
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    // If we are being shown, grab channel type from props and clear
    if (nextProps.show === true && this.props.show === false) {
      this.setState({
        serverError: '',
        channelType: nextProps.channelType,
        channelIcon: nextProps.channelType === 'O' ? 'public_00.png' : 'private_00.png',
        flowState: SHOW_NEW_CHANNEL,
        channelDisplayName: '',
        channelName: '',
        channelPurpose: '',
        channelHeader: '',
        nameModified: false
      });
    }
  }

  render() {
    const channelData = {
      name: this.state.channelDisplayName,
      displayName: this.state.channelDisplayName,
      purpose: this.state.channelPurpose,
      header: this.state.channelHeader
    };
    let showChannelModal = false;
    let showChangeURLModal = false;
    let changeURLTitle = '';
    let changeURLSubmitButtonText = ''; // Only listen to flow state if we are being shown

    if (this.props.show) {
      showChannelModal = true;
    }

    return react_default.a.createElement("span", null, react_default.a.createElement(new_channel_modal, {
      show: showChannelModal,
      channelType: this.state.channelType,
      channelIcon: this.state.channelIcon,
      canCreatePublicChannel: this.props.canCreatePublicChannel,
      canCreatePrivateChannel: this.props.canCreatePrivateChannel,
      channelData: channelData,
      serverError: this.state.serverError,
      onSubmitChannel: this.onSubmit,
      onModalDismissed: this.props.onModalDismissed,
      onTypeSwitched: this.typeSwitched,
      onIconSwitched: this.iconSwitched,
      onChangeURLPressed: this.urlChangeRequested,
      onDataChanged: this.channelDataChanged
    }), react_default.a.createElement(change_url_modal, {
      show: showChangeURLModal,
      title: changeURLTitle,
      submitButtonText: changeURLSubmitButtonText,
      currentURL: this.state.channelName,
      serverError: this.state.serverError,
      onModalSubmit: this.urlChangeSubmitted,
      onModalDismissed: this.urlChangeDismissed
    }));
  }

}

new_channel_flow_defineProperty(new_channel_flow_NewChannelFlow, "propTypes", {
  currentUser: prop_types_default.a.object,

  /**
  * Set whether to show the modal or not
  */
  show: prop_types_default.a.bool.isRequired,

  /**
  * Set to Constants.OPEN_CHANNEL or Constants.PRIVATE_CHANNEL depending on which modal we should show first
  */
  channelType: prop_types_default.a.string.isRequired,

  /**
  * Function to call when modal is dimissed
  */
  onModalDismissed: prop_types_default.a.func.isRequired,

  /**
  * The current team ID
  */
  currentTeamId: prop_types_default.a.string.isRequired,

  /**
   * Permission to create public channel
   */
  canCreatePublicChannel: prop_types_default.a.bool.isRequired,

  /**
   * Permission to create private channel
   */
  canCreatePrivateChannel: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    createChannel: prop_types_default.a.func.isRequired,
    switchToChannel: prop_types_default.a.func.isRequired
  })
});

new_channel_flow_defineProperty(new_channel_flow_NewChannelFlow, "defaultProps", {
  show: false,
  channelType: constants["N" /* default */].OPEN_CHANNEL
});
// CONCATENATED MODULE: ./components/new_channel_flow/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function new_channel_flow_mapStateToProps(state) {
  return {
    currentTeamId: Object(entities_teams["getCurrentTeamId"])(state),
    currentUser: Object(entities_users["getCurrentUser"])(state)
  };
}

function new_channel_flow_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      createChannel: actions_channels["createChannel"],
      switchToChannel: views_channel["k" /* switchToChannel */]
    }, dispatch)
  };
}

/* harmony default export */ var new_channel_flow = (Object(es["connect"])(new_channel_flow_mapStateToProps, new_channel_flow_mapDispatchToProps)(new_channel_flow_NewChannelFlow));
// CONCATENATED MODULE: ./components/svg/unread_below_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class unread_below_icon_UnreadBelowIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.arrow.down",
      defaultMessage: "Down Arrow Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "10px",
      height: "10px",
      viewBox: "0 0 10 10",
      style: unread_below_icon_style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", {
      transform: "matrix(1,0,0,1,-20,-18)"
    }, react_default.a.createElement("g", {
      transform: "matrix(0.0330723,0,0,0.0322634,15.8132,12.3164)"
    }, react_default.a.createElement("path", {
      d: "M245.803,377.493C245.803,377.493 204.794,336.485 179.398,311.088C168.55,300.24 150.962,300.24 140.114,311.088C138.327,312.875 136.517,314.686 134.73,316.473C123.882,327.321 123.882,344.908 134.73,355.756C167.972,388.998 233.949,454.975 256.949,477.975C262.158,483.184 269.223,486.111 276.591,486.111C277.38,486.111 278.176,486.111 278.965,486.111C286.332,486.111 293.397,483.184 298.607,477.975C321.607,454.975 387.584,388.998 420.826,355.756C431.674,344.908 431.674,327.321 420.826,316.473C419.039,314.686 417.228,312.875 415.441,311.088C404.593,300.24 387.005,300.24 376.158,311.088C350.761,336.485 309.753,377.493 309.753,377.493C309.753,377.493 309.753,279.687 309.753,203.94C309.753,196.573 306.826,189.508 301.617,184.298C296.408,179.089 289.342,176.162 281.975,176.162C279.191,176.162 276.364,176.162 273.58,176.162C266.213,176.162 259.148,179.089 253.939,184.298C248.729,189.508 245.803,196.573 245.803,203.94L245.803,377.493Z"
    }))))));
  }

}
const unread_below_icon_style = {
  fillRule: 'evenodd',
  clipRule: 'evenodd',
  strokeLinejoin: 'round',
  strokeMiterlimit: 1.41421
};
// CONCATENATED MODULE: ./components/unread_channel_indicator.jsx
function unread_channel_indicator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class unread_channel_indicator_UnreadChannelIndicator extends react_default.a.PureComponent {
  render() {
    let displayValue = 'none';

    if (this.props.show) {
      displayValue = 'block';
    }

    return react_default.a.createElement("div", {
      id: 'unreadIndicator' + this.props.name,
      className: 'nav-pills__unread-indicator ' + this.props.extraClass,
      style: {
        display: displayValue
      },
      onClick: this.props.onClick
    }, this.props.content, react_default.a.createElement(unread_below_icon_UnreadBelowIcon, {
      className: "icon icon__unread"
    }));
  }

}

unread_channel_indicator_defineProperty(unread_channel_indicator_UnreadChannelIndicator, "propTypes", {
  /**
   * Function to call when the indicator is clicked
   */
  onClick: prop_types_default.a.func.isRequired,

  /**
   * Set whether to show the indicator or not
   */
  show: prop_types_default.a.bool,

  /**
   * The additional CSS class for the indicator
   */
  extraClass: prop_types_default.a.string,

  /**
   * The content of the indicator
   */
  content: prop_types_default.a.node,

  /**
   * The name of the indicator
   */
  name: prop_types_default.a.string
});

unread_channel_indicator_defineProperty(unread_channel_indicator_UnreadChannelIndicator, "defaultProps", {
  show: false,
  extraClass: '',
  content: ''
});
// CONCATENATED MODULE: ./components/sidebar/header/sidebar_header_dropdown_button.jsx
function header_sidebar_header_dropdown_button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class header_sidebar_header_dropdown_button_SidebarHeaderDropdownButton extends react_default.a.PureComponent {
  render() {
    const mainMenuToolTip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "main-menu__tooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "sidebar.mainMenu",
      defaultMessage: "Main menu"
    }));
    let tutorialTip = null;

    if (this.props.showTutorialTip) {
      tutorialTip = react_default.a.createElement(menu_tutorial_tip, {
        onBottom: false
      });
    }

    let teamNameWithToolTip = react_default.a.createElement("h1", {
      id: "headerTeamName",
      className: "team__name",
      "data-teamid": this.props.teamId
    }, this.props.teamDisplayName);

    if (this.props.teamDescription) {
      teamNameWithToolTip = react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        placement: "bottom",
        overlay: react_default.a.createElement(Tooltip["a" /* default */], {
          id: "team-name__tooltip"
        }, this.props.teamDescription),
        ref: "descriptionOverlay"
      }, teamNameWithToolTip);
    }

    return react_default.a.createElement("div", {
      className: "SidebarHeaderDropdownButton",
      id: "sidebarHeaderDropdownButton"
    }, tutorialTip, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "right",
      overlay: mainMenuToolTip
    }, react_default.a.createElement("div", {
      id: "headerInfo",
      className: "header__info"
    }, teamNameWithToolTip, react_default.a.createElement("div", {
      id: "headerUsername",
      className: "user__name"
    }, this.props.currentUser.username), react_default.a.createElement("button", {
      className: "style--none sidebar-header-dropdown__icon",
      "aria-label": Object(utils["gb" /* localizeMessage */])('navbar_dropdown.menuAriaLabel', 'main menu')
    }, react_default.a.createElement(menu_icon["a" /* default */], null)))));
  }

}

header_sidebar_header_dropdown_button_defineProperty(header_sidebar_header_dropdown_button_SidebarHeaderDropdownButton, "propTypes", {
  showTutorialTip: prop_types_default.a.bool.isRequired,
  teamDescription: prop_types_default.a.string.isRequired,
  teamId: prop_types_default.a.string.isRequired,
  currentUser: prop_types_default.a.object.isRequired,
  teamDisplayName: prop_types_default.a.string.isRequired
});
// CONCATENATED MODULE: ./components/sidebar/header/dropdown/sidebar_header_dropdown.jsx
function dropdown_sidebar_header_dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class dropdown_sidebar_header_dropdown_SidebarHeaderDropdown extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    dropdown_sidebar_header_dropdown_defineProperty(this, "toggleShortcutsModal", e => {
      e.preventDefault();
      global_actions["n" /* toggleShortcutsModal */]();
    });

    dropdown_sidebar_header_dropdown_defineProperty(this, "showGetTeamInviteLinkModal", e => {
      e.preventDefault();
      global_actions["l" /* showGetTeamInviteLinkModal */]();
    });

    dropdown_sidebar_header_dropdown_defineProperty(this, "handleKeyDown", e => {
      if (Object(utils["e" /* cmdOrCtrlPressed */])(e) && e.shiftKey && Object(utils["V" /* isKeyPressed */])(e, constants["g" /* Constants */].KeyCodes.A)) {
        this.props.actions.openModal({
          ModalId: constants["p" /* ModalIdentifiers */].USER_SETTINGS,
          dialogType: user_settings_modal["a" /* default */]
        });
      }
    });

    dropdown_sidebar_header_dropdown_defineProperty(this, "handleEmitUserLoggedOutEvent", () => {
      global_actions["e" /* emitUserLoggedOutEvent */]();
    });
  }

  componentDidMount() {
    document.addEventListener('keydown', this.handleKeyDown);
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleKeyDown);
  }

  render() {
    const currentUser = this.props.currentUser;

    if (!currentUser) {
      return null;
    }

    return react_default.a.createElement(menu_wrapper["a" /* default */], null, react_default.a.createElement(header_sidebar_header_dropdown_button_SidebarHeaderDropdownButton, {
      showTutorialTip: this.props.showTutorialTip,
      teamDescription: this.props.teamDescription,
      currentUser: this.props.currentUser,
      teamDisplayName: this.props.teamDisplayName,
      teamId: this.props.teamId
    }), react_default.a.createElement(main_menu, {
      id: "sidebarDropdownMenu"
    }));
  }

}

dropdown_sidebar_header_dropdown_defineProperty(dropdown_sidebar_header_dropdown_SidebarHeaderDropdown, "propTypes", {
  teamDescription: prop_types_default.a.string.isRequired,
  teamDisplayName: prop_types_default.a.string.isRequired,
  teamId: prop_types_default.a.string.isRequired,
  currentUser: prop_types_default.a.object,
  showTutorialTip: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    openModal: prop_types_default.a.func.isRequred
  }).isRequired
});

dropdown_sidebar_header_dropdown_defineProperty(dropdown_sidebar_header_dropdown_SidebarHeaderDropdown, "defaultProps", {
  teamType: '',
  pluginMenuItems: []
});
// CONCATENATED MODULE: ./components/sidebar/header/dropdown/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function header_dropdown_mapStateToProps(state) {
  const currentTeam = Object(entities_teams["getCurrentTeam"])(state);
  const currentUser = Object(entities_users["getCurrentUser"])(state);
  const showTutorialTip = Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, currentUser.id) === constants["H" /* TutorialSteps */].MENU_POPOVER && !utils["Y" /* isMobile */]();
  return {
    currentUser,
    teamDescription: currentTeam.description,
    teamDisplayName: currentTeam.display_name,
    teamId: currentTeam.id,
    showTutorialTip
  };
}

function header_dropdown_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openModal: modals["b" /* openModal */]
    }, dispatch)
  };
}

/* harmony default export */ var header_dropdown = (Object(es["connect"])(header_dropdown_mapStateToProps, header_dropdown_mapDispatchToProps)(dropdown_sidebar_header_dropdown_SidebarHeaderDropdown));
// CONCATENATED MODULE: ./components/sidebar/header/sidebar_header.jsx
function header_sidebar_header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class header_sidebar_header_SidebarHeader extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    header_sidebar_header_defineProperty(this, "handleResize", () => {
      const isMobile = utils["Y" /* isMobile */]();
      this.setState({
        isMobile
      });
    });

    this.state = {
      isMobile: utils["Y" /* isMobile */]()
    };
  }

  componentDidMount() {
    window.addEventListener('resize', this.handleResize);
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
  }

  render() {
    const ariaLabel = utils["gb" /* localizeMessage */]('accessibility.sections.lhsHeader', 'team menu region');
    return react_default.a.createElement("div", {
      id: "lhsHeader",
      "aria-label": ariaLabel,
      tabIndex: "-1",
      role: "navigation",
      className: "SidebarHeader team__header theme"
    }, react_default.a.createElement("div", {
      className: "d-flex"
    }, !this.state.isMobile && react_default.a.createElement(status_dropdown, null), react_default.a.createElement(header_dropdown, null)));
  }

}
// CONCATENATED MODULE: ./components/sidebar/header/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function header_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const currentUser = Object(entities_users["getCurrentUser"])(state);
  const enableTutorial = config.EnableTutorial === 'true';
  const showTutorialTip = Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, currentUser.id) === constants["H" /* TutorialSteps */].MENU_POPOVER && !utils["Y" /* isMobile */]();
  return {
    enableTutorial,
    showTutorialTip
  };
}

/* harmony default export */ var sidebar_header = (Object(es["connect"])(header_mapStateToProps)(header_sidebar_header_SidebarHeader));
// CONCATENATED MODULE: ./components/sidebar/headerClone/sidebar_header_dropdown_button.jsx
function headerClone_sidebar_header_dropdown_button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class headerClone_sidebar_header_dropdown_button_SidebarHeaderDropdownButton extends react_default.a.PureComponent {
  render() {
    const mainMenuToolTip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "main-menu__tooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "sidebar.mainMenu",
      defaultMessage: "Main menu"
    }));
    let tutorialTip = null;

    if (this.props.showTutorialTip) {
      tutorialTip = react_default.a.createElement(menu_tutorial_tip, {
        onBottom: false
      });
    }

    let teamNameWithToolTip = react_default.a.createElement("h1", {
      id: "headerTeamName",
      className: "team__name",
      "data-teamid": this.props.teamId
    }, this.props.teamDisplayName);

    if (this.props.teamDescription) {
      teamNameWithToolTip = react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        placement: "bottom",
        overlay: react_default.a.createElement(Tooltip["a" /* default */], {
          id: "team-name__tooltip"
        }, this.props.teamDescription),
        ref: "descriptionOverlay"
      }, teamNameWithToolTip);
    }

    return (// <div
      //     className='SidebarHeaderDropdownButton'
      //     id='sidebarHeaderDropdownButton'
      // >
      //     {tutorialTip}
      react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        placement: "top",
        overlay: mainMenuToolTip
      }, react_default.a.createElement("button", {
        className: "style--none sidebar-header-dropdown__icon",
        "aria-label": Object(utils["gb" /* localizeMessage */])('navbar_dropdown.menuAriaLabel', 'main menu')
      }, react_default.a.createElement("span", {
        className: "setting-btn"
      }))) // </div>

    );
  }

}

headerClone_sidebar_header_dropdown_button_defineProperty(headerClone_sidebar_header_dropdown_button_SidebarHeaderDropdownButton, "propTypes", {
  showTutorialTip: prop_types_default.a.bool.isRequired,
  teamDescription: prop_types_default.a.string.isRequired,
  teamId: prop_types_default.a.string.isRequired,
  currentUser: prop_types_default.a.object.isRequired,
  teamDisplayName: prop_types_default.a.string.isRequired
});
// CONCATENATED MODULE: ./components/sidebar/headerClone/dropdown/sidebar_header_dropdown.jsx
function headerClone_dropdown_sidebar_header_dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class headerClone_dropdown_sidebar_header_dropdown_SidebarHeaderDropdown extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    headerClone_dropdown_sidebar_header_dropdown_defineProperty(this, "toggleShortcutsModal", e => {
      e.preventDefault();
      global_actions["n" /* toggleShortcutsModal */]();
    });

    headerClone_dropdown_sidebar_header_dropdown_defineProperty(this, "showGetTeamInviteLinkModal", e => {
      e.preventDefault();
      global_actions["l" /* showGetTeamInviteLinkModal */]();
    });

    headerClone_dropdown_sidebar_header_dropdown_defineProperty(this, "handleKeyDown", e => {
      if (Object(utils["e" /* cmdOrCtrlPressed */])(e) && e.shiftKey && Object(utils["V" /* isKeyPressed */])(e, constants["g" /* Constants */].KeyCodes.A)) {
        this.props.actions.openModal({
          ModalId: constants["p" /* ModalIdentifiers */].USER_SETTINGS,
          dialogType: user_settings_modal["a" /* default */]
        });
      }
    });

    headerClone_dropdown_sidebar_header_dropdown_defineProperty(this, "handleEmitUserLoggedOutEvent", () => {
      global_actions["e" /* emitUserLoggedOutEvent */]();
    });
  }

  componentDidMount() {
    document.addEventListener('keydown', this.handleKeyDown);
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleKeyDown);
  }

  render() {
    const currentUser = this.props.currentUser;

    if (!currentUser) {
      return null;
    }

    return react_default.a.createElement(menu_wrapper["a" /* default */], {
      className: "MenuWrapper-left"
    }, react_default.a.createElement(headerClone_sidebar_header_dropdown_button_SidebarHeaderDropdownButton, {
      showTutorialTip: this.props.showTutorialTip,
      teamDescription: this.props.teamDescription,
      currentUser: this.props.currentUser,
      teamDisplayName: this.props.teamDisplayName,
      teamId: this.props.teamId
    }), react_default.a.createElement(main_menu, {
      id: "sidebarDropdownMenu"
    }));
  }

}

headerClone_dropdown_sidebar_header_dropdown_defineProperty(headerClone_dropdown_sidebar_header_dropdown_SidebarHeaderDropdown, "propTypes", {
  teamDescription: prop_types_default.a.string.isRequired,
  teamDisplayName: prop_types_default.a.string.isRequired,
  teamId: prop_types_default.a.string.isRequired,
  currentUser: prop_types_default.a.object,
  showTutorialTip: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    openModal: prop_types_default.a.func.isRequred
  }).isRequired
});

headerClone_dropdown_sidebar_header_dropdown_defineProperty(headerClone_dropdown_sidebar_header_dropdown_SidebarHeaderDropdown, "defaultProps", {
  teamType: '',
  pluginMenuItems: []
});
// CONCATENATED MODULE: ./components/sidebar/headerClone/dropdown/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function headerClone_dropdown_mapStateToProps(state) {
  const currentTeam = Object(entities_teams["getCurrentTeam"])(state);
  const currentUser = Object(entities_users["getCurrentUser"])(state);
  const showTutorialTip = Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, currentUser.id) === constants["H" /* TutorialSteps */].MENU_POPOVER && !utils["Y" /* isMobile */]();
  return {
    currentUser,
    teamDescription: currentTeam.description,
    teamDisplayName: currentTeam.display_name,
    teamId: currentTeam.id,
    showTutorialTip
  };
}

function headerClone_dropdown_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openModal: modals["b" /* openModal */]
    }, dispatch)
  };
}

/* harmony default export */ var headerClone_dropdown = (Object(es["connect"])(headerClone_dropdown_mapStateToProps, headerClone_dropdown_mapDispatchToProps)(headerClone_dropdown_sidebar_header_dropdown_SidebarHeaderDropdown));
// CONCATENATED MODULE: ./components/sidebar/headerClone/sidebar_header.jsx
function headerClone_sidebar_header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class headerClone_sidebar_header_SidebarHeader extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    headerClone_sidebar_header_defineProperty(this, "handleResize", () => {
      const isMobile = utils["Y" /* isMobile */]();
      this.setState({
        isMobile
      });
    });

    this.state = {
      isMobile: utils["Y" /* isMobile */]()
    };
  }

  componentDidMount() {
    window.addEventListener('resize', this.handleResize);
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
  }

  render() {
    const ariaLabel = utils["gb" /* localizeMessage */]('accessibility.sections.lhsHeader', 'team menu region');
    return react_default.a.createElement("div", {
      id: "lhsHeader",
      "aria-label": ariaLabel,
      tabIndex: "-1",
      role: "navigation",
      className: "SidebarHeader team__header theme"
    }, react_default.a.createElement(headerClone_dropdown, null));
  }

}
// CONCATENATED MODULE: ./components/sidebar/headerClone/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function headerClone_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const currentUser = Object(entities_users["getCurrentUser"])(state);
  const enableTutorial = config.EnableTutorial === 'true';
  const showTutorialTip = Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, currentUser.id) === constants["H" /* TutorialSteps */].MENU_POPOVER && !utils["Y" /* isMobile */]();
  return {
    enableTutorial,
    showTutorialTip
  };
}

/* harmony default export */ var headerClone = (Object(es["connect"])(headerClone_mapStateToProps)(headerClone_sidebar_header_SidebarHeader));
// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/common.js
var common = __webpack_require__(207);

// EXTERNAL MODULE: ./mattermost-redux/utils/post_list.js
var post_list = __webpack_require__(64);

// CONCATENATED MODULE: ./components/svg/bot_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class bot_icon_BotIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.bot",
      defaultMessage: "Bot Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "16",
      height: "13",
      viewBox: "0 0 36 30",
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("path", {
      d: "M0,15.7391304 L0,23.0434783 C0,24.0535326 0.786888587,24.8695652 1.76086957,24.8695652 L3.52173913,24.8695652 L3.52173913,13.9130435 L1.76086957,13.9130435 C0.786888587,13.9130435 0,14.7290761 0,15.7391304 Z M26.0496894,6.50271739 L19.7888199,6.50271739 L19.7888199,2.83423913 C19.7888199,1.81967561 18.989441,1 18,1 C17.010559,1 16.2111801,1.81967561 16.2111801,2.83423913 L16.2111801,6.50271739 L9.95031056,6.50271739 C7.47950311,6.50271739 5.47826087,8.55477242 5.47826087,11.0883152 L5.47826087,26.6793478 C5.47826087,28.7027429 7.0826087,30.3478261 9.05590062,30.3478261 L26.9440994,30.3478261 C28.9173913,30.3478261 30.5217391,28.7027429 30.5217391,26.6793478 L30.5217391,11.0883152 C30.5217391,8.55477242 28.5204969,6.50271739 26.0496894,6.50271739 Z M14.4782609,24.8695652 L10.9565217,24.8695652 L10.9565217,22.9130435 L14.4782609,22.9130435 L14.4782609,24.8695652 Z M12.5217391,17.826087 C11.2245652,17.826087 10.173913,16.7754348 10.173913,15.4782609 C10.173913,14.181087 11.2245652,13.1304348 12.5217391,13.1304348 C13.818913,13.1304348 14.8695652,14.181087 14.8695652,15.4782609 C14.8695652,16.7754348 13.818913,17.826087 12.5217391,17.826087 Z M19.9565217,24.8695652 L16.4347826,24.8695652 L16.4347826,22.9130435 L19.9565217,22.9130435 L19.9565217,24.8695652 Z M25.0434783,24.8695652 L21.5217391,24.8695652 L21.5217391,22.9130435 L25.0434783,22.9130435 L25.0434783,24.8695652 Z M23.2826087,17.826087 C22.0935326,17.826087 21.1304348,16.7754348 21.1304348,15.4782609 C21.1304348,14.181087 22.0935326,13.1304348 23.2826087,13.1304348 C24.4716848,13.1304348 25.4347826,14.181087 25.4347826,15.4782609 C25.4347826,16.7754348 24.4716848,17.826087 23.2826087,17.826087 Z M34.2391304,13.9130435 L32.4782609,13.9130435 L32.4782609,24.8695652 L34.2391304,24.8695652 C35.2131114,24.8695652 36,24.0535326 36,23.0434783 L36,15.7391304 C36,14.7290761 35.2131114,13.9130435 34.2391304,13.9130435 Z"
    }))));
  }

}
// CONCATENATED MODULE: ./components/sidebar/sidebar_channel_button_or_link/sidebar_channel_button_or_link_icon.jsx
function sidebar_channel_button_or_link_icon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class sidebar_channel_button_or_link_icon_SidebarChannelButtonOrLinkIcon extends react_default.a.PureComponent {
  render() {
    let icon = null;

    if (this.props.channelIsArchived) {
      icon = react_default.a.createElement(archive_icon["a" /* default */], {
        className: "icon icon__archive"
      });
    } else if (this.props.hasDraft) {
      icon = react_default.a.createElement(draft_icon_DraftIcon, {
        className: "icon icon__draft"
      });
    } else if (this.props.channelType === constants["g" /* Constants */].OPEN_CHANNEL) {
      icon = react_default.a.createElement(globe_icon["a" /* default */], {
        className: "icon icon__globe"
      });
    } else if (this.props.channelType === constants["g" /* Constants */].PRIVATE_CHANNEL) {
      icon = react_default.a.createElement(lock_icon["a" /* default */], {
        className: "icon icon__lock"
      });
    } else if (this.props.channelType === constants["g" /* Constants */].GM_CHANNEL) {
      icon = react_default.a.createElement("div", {
        className: "status status--group"
      }, this.props.membersCount);
    } else if (this.props.channelType === constants["g" /* Constants */].DM_CHANNEL) {
      if (this.props.teammateId && this.props.teammateDeletedAt) {
        icon = react_default.a.createElement(archive_icon["a" /* default */], {
          className: "icon icon__archive"
        });
      } else if (this.props.teammateId && this.props.teammateIsBot) {
        icon = react_default.a.createElement(bot_icon_BotIcon, {
          className: "icon icon__bot"
        });
      } else {
        icon = react_default.a.createElement(status_icon["a" /* default */], {
          type: "avatar",
          status: this.props.channelStatus
        });
      }
    }

    return icon;
  }

}

sidebar_channel_button_or_link_icon_defineProperty(sidebar_channel_button_or_link_icon_SidebarChannelButtonOrLinkIcon, "propTypes", {
  channelIsArchived: prop_types_default.a.bool.isRequired,
  channelType: prop_types_default.a.string.isRequired,
  channelStatus: prop_types_default.a.string,
  hasDraft: prop_types_default.a.bool.isRequired,
  membersCount: prop_types_default.a.number,
  teammateId: prop_types_default.a.string,
  teammateDeletedAt: prop_types_default.a.number,
  teammateIsBot: prop_types_default.a.bool
});
// CONCATENATED MODULE: ./components/sidebar/sidebar_channel_button_or_link/sidebar_channel_button_or_link_close_button.jsx
function sidebar_channel_button_or_link_close_button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class sidebar_channel_button_or_link_close_button_SidebarChannelButtonOrLinkCloseButton extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    sidebar_channel_button_or_link_close_button_defineProperty(this, "overlayTriggerAttr", ['hover', 'focus']);

    sidebar_channel_button_or_link_close_button_defineProperty(this, "handleClose", e => {
      e.stopPropagation();
      e.preventDefault();
      this.props.handleClose();
    });
  }

  render() {
    let closeButton = null;

    if (this.props.handleClose && !this.props.badge) {
      let removeTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "remove-dm-tooltip"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.removeList",
        defaultMessage: "Remove from list"
      }));
      closeButton = react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: this.overlayTriggerAttr,
        delayShow: 1000,
        placement: "top",
        overlay: removeTooltip
      }, react_default.a.createElement("span", {
        onClick: this.handleClose,
        className: "btn-close"
      }, '×'));
    }

    return closeButton;
  }

}

sidebar_channel_button_or_link_close_button_defineProperty(sidebar_channel_button_or_link_close_button_SidebarChannelButtonOrLinkCloseButton, "propTypes", {
  handleClose: prop_types_default.a.func,
  channelId: prop_types_default.a.string.isRequired,
  channelType: prop_types_default.a.string.isRequired,
  teammateId: prop_types_default.a.string,
  badge: prop_types_default.a.bool
});
// EXTERNAL MODULE: ./utils/request.js
var utils_request = __webpack_require__(25);

// CONCATENATED MODULE: ./api/channels.js

const channels_prefix = '/api/v4/'; // 搜索联系人

const getChannelsPost = params => {
  return Object(utils_request["a" /* default */])({
    url: `${channels_prefix}channels/${params.id}/posts`,
    method: 'GET',
    params: {
      page: params.page,
      per_page: params.per_page
    }
  });
}; // 解散频道

const dissolveChannel = params => {
  return Object(utils_request["a" /* default */])({
    url: `${channels_prefix}channels/${params.id}/members`,
    method: 'DELETE'
  });
};
// EXTERNAL MODULE: ./components/sidebar/sidebar_channel_button_or_link/dnd.png
var dnd = __webpack_require__(2971);
var dnd_default = /*#__PURE__*/__webpack_require__.n(dnd);

// CONCATENATED MODULE: ./components/sidebar/sidebar_channel_button_or_link/sidebar_channel_button_or_link.jsx
function sidebar_channel_button_or_link_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

















let sidebar_channel_button_or_link_unreadMsgs = 0;
class sidebar_channel_button_or_link_SidebarChannelButtonOrLink extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    sidebar_channel_button_or_link_defineProperty(this, "overlayTriggerAttr", ['hover', 'focus']);

    sidebar_channel_button_or_link_defineProperty(this, "trackChannelSelectedEvent", () => {
      if (this.props.hasCheckbox) {
        return es_message["a" /* default */].warn('选择消息只能在当前频道进行');
      }

      Object(diagnostics_actions["b" /* mark */])('SidebarChannelLink#click');
      Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_channel_selected');
      this.props.showCloud(false, this.props.channelId);
    });

    sidebar_channel_button_or_link_defineProperty(this, "handleClick", () => {
      if (this.props.hasCheckbox) {
        return es_message["a" /* default */].warn('选择消息只能在当前频道进行');
      }

      this.trackChannelSelectedEvent();
      browser_history["a" /* browserHistory */].push(this.props.link);
    });

    sidebar_channel_button_or_link_defineProperty(this, "render", () => {
      // let badge = null;
      // if (this.props.badge) {
      //     badge = (
      //         <span
      //             id='unreadMentions'
      //             className='badge'
      //         >
      //             {this.props.unreadMentions}
      //         </span>
      //     );
      // }
      let badge = react_default.a.createElement("span", {
        id: "unreadMentions",
        className: "badge unreadMentions"
      }, 11);

      const notificFormat = () => {
        // console.log(this.props.unreadCount)
        const num = this.props.unreadMsgs;

        if (num) {
          return num > 99 ? '99+' : num;
        }
      };

      let countMsg = this.props.unreadMsgs > 0 && this.props.unreadCount === 'true' && react_default.a.createElement("span", {
        className: "notific_count"
      }, notificFormat());
      const content = react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("div", {
        className: "channel-icon-wrap"
      }, react_default.a.createElement("img", {
        src: this.props.channelIcon,
        className: "channel-icon"
      }), this.props.unreadMsgs > 0 && react_default.a.createElement("span", {
        className: "notific-icon"
      })), react_default.a.createElement("span", {
        className: "sidebar-item__name"
      }, react_default.a.createElement("span", null, this.props.displayName), react_default.a.createElement("span", {
        className: "info_demo"
      }, this.state.message), !this.props.channelMuted ? countMsg : react_default.a.createElement("img", {
        className: "notify_dnd",
        style: {
          width: 10
        },
        src: dnd_default.a
      })), badge, react_default.a.createElement(sidebar_channel_button_or_link_close_button_SidebarChannelButtonOrLinkCloseButton, {
        handleClose: this.props.handleClose,
        channelId: this.props.channelId,
        channelType: this.props.channelType,
        teammateId: this.props.teammateId,
        badge: this.props.badge
      }));
      let element;
      let ariaLabel = this.props.displayName;

      if (this.props.channelType === constants["N" /* default */].OPEN_CHANNEL) {
        ariaLabel += ` ${Object(utils["gb" /* localizeMessage */])('accessibility.sidebar.types.public', 'public channel')}`;
      } else if (this.props.channelType === constants["N" /* default */].PRIVATE_CHANNEL) {
        ariaLabel += ` ${Object(utils["gb" /* localizeMessage */])('accessibility.sidebar.types.private', 'private channel')}`;
      }

      if (this.props.unreadMentions === 1) {
        ariaLabel += ` ${this.props.unreadMentions} ${Object(utils["gb" /* localizeMessage */])('accessibility.sidebar.types.mention', 'mention')}`;
      } else if (this.props.unreadMentions > 1) {
        ariaLabel += ` ${this.props.unreadMentions} ${Object(utils["gb" /* localizeMessage */])('accessibility.sidebar.types.mentions', 'mentions')}`;
      }

      if (this.props.unreadMsgs > 0 && this.props.showUnreadForMsgs && this.props.unreadMentions === 0) {
        ariaLabel += ` ${Object(utils["gb" /* localizeMessage */])('accessibility.sidebar.types.unread', 'unread')}`;
      }

      ariaLabel = ariaLabel.toLowerCase();

      if (Object(user_agent["c" /* isDesktopApp */])()) {
        const renderBtn = react_default.a.createElement("button", {
          className: 'btn btn-link ' + this.props.rowClass,
          "aria-label": ariaLabel,
          onClick: this.handleClick
        }, content);
        element = react_default.a.createElement("div", null, this.props.link ? react_default.a.createElement(copy_url_context_menu, {
          link: this.props.link,
          menuId: this.props.channelId
        }, renderBtn) : renderBtn);
      } else {
        element = this.props.link ? react_default.a.createElement(react_router_dom["a" /* Link */], {
          id: `sidebarItem_${this.props.channelName}`,
          "aria-label": ariaLabel,
          to: this.props.link,
          className: this.props.rowClass,
          onClick: this.trackChannelSelectedEvent
        }, content) : react_default.a.createElement("div", {
          id: `sidebarItem_${this.props.channelName}`,
          "aria-label": ariaLabel,
          className: this.props.rowClass,
          onClick: this.trackChannelSelectedEvent
        }, content);
      }

      if (this.props.channelType === constants["N" /* default */].GM_CHANNEL) {
        const displayNameToolTip = react_default.a.createElement(Tooltip["a" /* default */], {
          id: "channel-displayname__tooltip",
          style: sidebar_channel_button_or_link_style.channelTooltip
        }, this.props.displayName);
        element = react_default.a.createElement(OverlayTrigger["a" /* default */], {
          trigger: this.overlayTriggerAttr,
          delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
          placement: "top",
          overlay: displayNameToolTip
        }, element);
      }

      return element;
    });

    this.state = {
      message: ''
    };
  }

  filterMessage(latestPost, latestPostUser) {
    let message = latestPost.message;
    const postUser = latestPostUser ? latestPostUser : this.props.latestPostUser;

    if (latestPost.id) {
      const emojiList = message.match(/:(\w+): /g);

      if (emojiList) {
        emojiList.forEach(val => {
          if (this.props.emojiMap.get(val.substr(1, val.length - 3))) {
            message = message.replace(val, '[表情] ');
          }
        });
      }

      if (latestPost.delete_at > 0) {
        message = '[已撤回]';
      } else if (latestPost.card_type == 5 || latestPost.message && Object(utils["X" /* isMeet */])(latestPost.message)) {
        message = '[会议邀请]';
      } else if (latestPost.card_type) {
        message = '[卡片消息]';
      } else if (latestPost.file_ids && latestPost.file_ids.length > 0) {
        const reg = /^(png|jpg|jpeg|gif)$/; // 如果是 channel 接口拿到的数据，则不会有metadata字段，就拿file_ids字段作匹配
        // 如果是 post 接口拿到当数据，则有metadata字段，就取metadata

        if (!latestPost.metadata && reg.test(latestPost.file_ids[0])) {
          message = '[图片]' + message;
        } else if (latestPost.metadata && latestPost.metadata.files && reg.test(latestPost.metadata.files[0].extension)) {
          message = '[图片]' + message;
        } else {
          message = '[文件]' + message;
        }
      } else if (latestPost.type === 'system_join_team') {
        message = `${latestPost.props.username} 加入了团队`;
      } else if (latestPost.type === 'system_remove_from_team') {
        message = `${latestPost.props.username} 被移出此团队`;
      } else if (latestPost.type === 'system_join_channel') {
        message = `${latestPost.props.username} 加入了频道`;
      } else if (latestPost.type === 'system_remove_from_channel') {
        message = `${latestPost.props.removedUsername} 离开了频道`;
      } // 发最后一条信息的人员姓名


      const fromWebhook = latestPost.props && latestPost.props.from_webhook === 'true';
      const isSystemMessage = post_utils["l" /* isSystemMessage */](latestPost);
      const isBot = Boolean(postUser && postUser.is_bot);
      const {
        formatMessage
      } = this.props.intl;

      if (fromWebhook && !isBot) {
        message = latestPost.props.override_username + '：' + message;
      } else if (isSystemMessage && !isBot) {
        message = formatMessage({
          id: 'post_info.system',
          defaultMessage: 'System'
        }) + '：' + message;
      } else if (this.props.channelType !== constants["N" /* default */].DM_CHANNEL && postUser) {
        message = postUser.nickname == "" ? postUser.first_name : postUser.nickname + '：' + message;
      }

      if (isBot) {
        console.log("isbot---", postUser);
      } // 如果当前有@


      if (this.props.unreadMsgs > 0 && (message.indexOf('@' + this.props.user.username) > -1 || message.indexOf('@all') > -1)) {
        message = react_default.a.createElement("span", {
          className: "special-message-txt"
        }, react_default.a.createElement("i", null, "[\u6709\u4EBA@\u6211]"), " ", message);
      }
    }

    return message;
  }

  setMessage(latestPost, latestPostUser) {
    if (latestPost) {
      this.setState({
        message: this.filterMessage(latestPost, latestPostUser)
      });
    } else {
      const params = {
        id: this.props.channelId,
        page: 0,
        per_page: 1
      };
      getChannelsPost(params).then(data => {
        const order = data.data.order[0];

        if (order) {
          const latestPost = data.data.posts[order];
          const message = this.filterMessage(latestPost);
          this.setState({
            message
          });
        }
      });
    }
  }

  componentDidMount() {
    let latestPost = this.props.latestPost;
    this.setMessage(latestPost);
    sidebar_channel_button_or_link_unreadMsgs = this.props.unreadMsgs;
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.unreadMsgs !== nextProps.unreadMsgs) {
      this.setMessage();
    }

    if (this.props.latestPost.id !== nextProps.latestPost.id) {
      this.setMessage(nextProps.latestPost, nextProps.latestPostUser);
    }
  }

}

sidebar_channel_button_or_link_defineProperty(sidebar_channel_button_or_link_SidebarChannelButtonOrLink, "propTypes", {
  link: prop_types_default.a.string,
  rowClass: prop_types_default.a.string.isRequired,
  channelType: prop_types_default.a.string.isRequired,
  channelIcon: prop_types_default.a.string.isRequired,
  channelId: prop_types_default.a.string.isRequired,
  channelName: prop_types_default.a.string.isRequired,
  displayName: prop_types_default.a.string.isRequired,
  channelStatus: prop_types_default.a.string,
  handleClose: prop_types_default.a.func,
  hasDraft: prop_types_default.a.bool.isRequired,
  badge: prop_types_default.a.bool,
  membersCount: prop_types_default.a.number.isRequired,
  showUnreadForMsgs: prop_types_default.a.bool.isRequired,
  unreadMsgs: prop_types_default.a.number.isRequired,
  unreadMentions: prop_types_default.a.number.isRequired,
  teammateId: prop_types_default.a.string,
  teammateDeletedAt: prop_types_default.a.number,
  teammateIsBot: prop_types_default.a.bool,
  channelIsArchived: prop_types_default.a.bool.isRequired,
  latestPost: prop_types_default.a.object.isRequired,
  emojiMap: prop_types_default.a.object.isRequired,
  user: prop_types_default.a.object.isRequired,
  latestPostUser: prop_types_default.a.object
});

const sidebar_channel_button_or_link_style = {
  channelTooltip: {
    paddingLeft: '8px',
    maxWidth: '228px'
  }
};
// CONCATENATED MODULE: ./components/sidebar/sidebar_tutorial_tip.jsx
function sidebar_tutorial_tip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class sidebar_tutorial_tip_SidebarTutorialTip extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    sidebar_tutorial_tip_defineProperty(this, "render", () => {
      const screens = [];
      let townSquareDisplayName = constants["g" /* Constants */].DEFAULT_CHANNEL_UI_NAME;

      if (this.props.townSquareDisplayName) {
        townSquareDisplayName = this.props.townSquareDisplayName;
      }

      let offTopicDisplayName = constants["g" /* Constants */].OFFTOPIC_CHANNEL_UI_NAME;

      if (this.props.offTopicDisplayName) {
        offTopicDisplayName = this.props.offTopicDisplayName;
      }

      screens.push(react_default.a.createElement("div", null, react_default.a.createElement("h4", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.tutorialScreen1.title",
        defaultMessage: "Channels"
      })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
        id: "sidebar.tutorialScreen1.body",
        defaultMessage: '**Channels** organize conversations across different topics. They\'re open to everyone on your team. To send private communications use **Direct Messages** for a single person or **Private Channels** for multiple people.'
      }))));
      screens.push(react_default.a.createElement("div", null, react_default.a.createElement("h4", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.tutorialScreen2.title",
        defaultMessage: "\"{townsquare}\" and \"{offtopic}\" channels",
        values: {
          townsquare: townSquareDisplayName,
          offtopic: offTopicDisplayName
        }
      })), react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.tutorialScreen2.body1",
        defaultMessage: "Here are two public channels to start:"
      })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
        id: "sidebar.tutorialScreen2.body2",
        defaultMessage: "**{townsquare}** is a place for team-wide communication. Everyone in your team is a member of this channel.",
        values: {
          townsquare: townSquareDisplayName
        }
      })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
        id: "sidebar.tutorialScreen2.body3",
        defaultMessage: "**{offtopic}** is a place for fun and humor outside of work-related channels. You and your team can decide what other channels to create.",
        values: {
          offtopic: offTopicDisplayName
        }
      }))));
      screens.push(react_default.a.createElement("div", null, react_default.a.createElement("h4", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.tutorialScreen3.title",
        defaultMessage: "Creating and Joining Channels"
      })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
        id: "sidebar.tutorialScreen3.body1",
        defaultMessage: "Click **\"More...\"** to create a new channel or join an existing one."
      })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
        id: "sidebar.tutorialScreen3.body2",
        defaultMessage: "You can also create a new channel by clicking the **\"+\" symbol** next to the public or private channel header."
      }))));
      return react_default.a.createElement(tutorial_tip, {
        placement: "right",
        screens: screens,
        overlayClass: "tip-overlay--sidebar",
        diagnosticsTag: "tutorial_tip_2_channels"
      });
    });
  }

}

sidebar_tutorial_tip_defineProperty(sidebar_tutorial_tip_SidebarTutorialTip, "propTypes", {
  townSquareDisplayName: prop_types_default.a.string,
  offTopicDisplayName: prop_types_default.a.string
});
// CONCATENATED MODULE: ./components/sidebar/sidebar_channel/sidebar_channel.jsx
function sidebar_channel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class sidebar_channel_SidebarChannel extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    sidebar_channel_defineProperty(this, "isLeaving", false);

    sidebar_channel_defineProperty(this, "handleLeavePublicChannel", () => {
      this.props.actions.leaveChannel(this.props.channelId);
      Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_public_channel_x_button_clicked');
    });

    sidebar_channel_defineProperty(this, "handleLeavePrivateChannel", () => {
      global_actions["m" /* showLeavePrivateChannelModal */]({
        id: this.props.channelId,
        display_name: this.props.channelDisplayName
      });
      Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_private_channel_x_button_clicked');
    });

    sidebar_channel_defineProperty(this, "handleLeaveDirectChannel", () => {
      if (!this.isLeaving) {
        this.isLeaving = true;
        this.props.actions.setChannelVisible([this.props.channelId], 'false').then(() => this.isLeaving = false);
        Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_direct_channel_x_button_clicked');
      }

      if (this.props.active) {
        browser_history["a" /* browserHistory */].push(`/${this.props.currentTeamName}/channels/${this.props.redirectChannel}`);
      }
    });

    sidebar_channel_defineProperty(this, "handleShowChannel", () => {
      const currentUserId = this.props.currentUserId;
      return this.props.actions.savePreferences(currentUserId, [{
        user_id: currentUserId,
        category: constants["g" /* Constants */].Preferences.CATEGORY_PRIVATE_CHANNEL_SHOW,
        name: this.props.channelId,
        value: 'true'
      }]);
    });

    sidebar_channel_defineProperty(this, "showChannelAsUnread", () => {
      return this.props.unreadMentions > 0 || this.props.unreadMsgs > 0 && this.props.showUnreadForMsgs;
    });

    sidebar_channel_defineProperty(this, "render", () => {
      if (this.props.channelIsArchived && !this.props.active) {
        return null;
      }

      if (!this.props.channelType) {
        console.log("2222222", this.props, this.props.channelDisplayName, this.props.channelType);
        return react_default.a.createElement("div", null);
      }

      if (this.props.channelType === constants["g" /* Constants */].PRIVATE_CHANNEL || this.props.channelType === constants["g" /* Constants */].OPEN_CHANNEL) {
        let visible = this.props.visible;

        if (this.props.unreadMsgs && !visible) {
          this.handleShowChannel();
          visible = true;
        }

        if (!visible) {
          return null;
        }
      }

      let closeHandler = null;

      if (!this.showChannelAsUnread()) {
        if (this.props.shouldHideChannel) {
          return '';
        }

        closeHandler = this.handleLeaveDirectChannel;
      }

      let linkClass = '';

      if (this.props.active) {
        linkClass = 'active';
      }

      let rowClass = 'sidebar-item';
      let badge = false;

      if (this.showChannelAsUnread()) {
        rowClass += ' unread-title';
      }

      if (this.props.unreadMentions > 0) {
        rowClass += ' has-badge';
        badge = true;
      }

      if (this.props.channelMuted) {
        rowClass += ' muted';
      }

      if (closeHandler && !badge) {
        rowClass += ' has-close';
      }

      let tutorialTip = null;

      if (this.props.showTutorialTip && this.props.channelName === constants["g" /* Constants */].DEFAULT_CHANNEL) {
        tutorialTip = react_default.a.createElement(sidebar_tutorial_tip_SidebarTutorialTip, {
          townSquareDisplayName: this.props.townSquareDisplayName,
          offTopicDisplayName: this.props.offTopicDisplayName
        });
        this.props.actions.openLhs();
      }

      let link = '';

      if (this.props.channelFake) {
        link = `/${this.props.currentTeamName}/channels/${this.props.channelName}?fakechannel=${encodeURIComponent(this.props.channelStringified)}`;
      } else if (this.props.channelType === constants["g" /* Constants */].DM_CHANNEL) {
        link = `/${this.props.currentTeamName}/messages/@${this.props.channelTeammateUsername}`;
      } else if (this.props.channelType === constants["g" /* Constants */].GM_CHANNEL) {
        link = `/${this.props.currentTeamName}/messages/${this.props.channelName}`;
      } else {
        link = `/${this.props.currentTeamName}/channels/${this.props.channelName}`;
      }

      let displayName = '';

      if (this.props.currentUserId === this.props.channelTeammateId) {
        displayName = this.context.intl.formatMessage({
          id: 'sidebar.directchannel.you',
          defaultMessage: '{displayname} (you)'
        }, {
          displayname: this.props.channelDisplayName
        });
      } else {
        displayName = this.props.channelDisplayName;
      }

      return react_default.a.createElement("li", {
        key: this.props.channelName,
        ref: 'channel',
        className: linkClass
      }, react_default.a.createElement(sidebar_channel_button_or_link_SidebarChannelButtonOrLink, {
        link: this.props.hasCheckbox ? null : link,
        hasCheckbox: this.props.hasCheckbox,
        rowClass: rowClass,
        channelId: this.props.channelId,
        channelName: this.props.channelName,
        channelStatus: this.props.channelStatus,
        channelType: this.props.channelType,
        channelIcon: this.props.channelIcon,
        displayName: displayName,
        handleClose: closeHandler,
        hasDraft: this.props.hasDraft,
        badge: badge,
        showUnreadForMsgs: this.props.showUnreadForMsgs,
        unreadMentions: this.props.unreadMentions,
        unreadMsgs: this.props.unreadMsgs,
        membersCount: this.props.membersCount,
        teammateId: this.props.channelTeammateId,
        teammateDeletedAt: this.props.channelTeammateDeletedAt,
        teammateIsBot: this.props.channelTeammateIsBot,
        channelIsArchived: this.props.channelIsArchived,
        unreadCount: this.props.unreadCount,
        channelMuted: this.props.channelMuted,
        isMuted: this.props.isMuted,
        latestPost: this.props.latestPost,
        emojiMap: this.props.emojiMap,
        user: this.props.user,
        latestPostUser: this.props.latestPostUser,
        showCloud: this.props.actions.showCloud,
        intl: this.props.intl
      }), tutorialTip);
    });
  }

}

sidebar_channel_defineProperty(sidebar_channel_SidebarChannel, "propTypes", {
  /**
   * Global config object
   */
  config: prop_types_default.a.object.isRequired,

  /**
   * Channel id
   */
  channelId: prop_types_default.a.string.isRequired,

  /**
   * Channel name
   */
  channelName: prop_types_default.a.string.isRequired,

  /**
   * Channel display name
   */
  channelDisplayName: prop_types_default.a.string.isRequired,

  /**
   * Channel is muted
   */
  channelMuted: prop_types_default.a.bool,

  /**
   * Channel type
   */
  channelType: prop_types_default.a.string.isRequired,

  /**
   * Channel status
   */
  channelStatus: prop_types_default.a.string,

  /**
   * Channel is fake
   */
  channelFake: prop_types_default.a.bool,

  /**
   * Serialized channel information (for fake channels)
   */
  channelStringified: prop_types_default.a.string,

  /**
   * Teammate id (for direct messages)
   */
  channelTeammateId: prop_types_default.a.string,

  /**
   * Teammate username (for direct messages)
   */
  channelTeammateUsername: prop_types_default.a.string,

  /**
   * Teammate delete at date (for direct messages)
   */
  channelTeammateDeletedAt: prop_types_default.a.number,

  /**
   * Teammate is_bot (for direct messages)
   */
  channelTeammateIsBot: prop_types_default.a.bool,

  /**
   * Whether the channel contains a draft in the center channel
   */
  hasDraft: prop_types_default.a.bool.isRequired,

  /**
   * Whether or not to mark the channel as unread when it has unread messages and no mentions
   */
  showUnreadForMsgs: prop_types_default.a.bool.isRequired,

  /**
   * Number of unread messages
   */
  unreadMsgs: prop_types_default.a.number.isRequired,

  /**
   * Number of unread mentions
   */
  unreadMentions: prop_types_default.a.number.isRequired,

  /**
   * Set if the channel is the current active channel
   */
  active: prop_types_default.a.bool.isRequired,

  /**
   * Current team name
   */
  currentTeamName: prop_types_default.a.string.isRequired,

  /**
   * Current user id
   */
  currentUserId: prop_types_default.a.string.isRequired,

  /**
   * Set if the tutorial must be shown
   */
  showTutorialTip: prop_types_default.a.bool.isRequired,

  /**
   * TownSquare (default channel) display name
   */
  townSquareDisplayName: prop_types_default.a.string,

  /**
   * OffTopic (default channel) display name
   */
  offTopicDisplayName: prop_types_default.a.string,

  /**
   * Number of members
   */
  membersCount: prop_types_default.a.number.isRequired,

  /**
   * Flag if channel should be hidden in sidebar
   */
  shouldHideChannel: prop_types_default.a.bool.isRequired,
  channelIsArchived: prop_types_default.a.bool.isRequired,
  redirectChannel: prop_types_default.a.string.isRequired,
  latestPost: prop_types_default.a.object.isRequired,
  emojiMap: prop_types_default.a.object.isRequired,
  user: prop_types_default.a.object.isRequired,
  latestPostUser: prop_types_default.a.object,
  actions: prop_types_default.a.shape({
    savePreferences: prop_types_default.a.func.isRequired,
    leaveChannel: prop_types_default.a.func.isRequired,
    openLhs: prop_types_default.a.func.isRequired,
    showCloud: prop_types_default.a.func.isRequired
  }).isRequired
});

sidebar_channel_defineProperty(sidebar_channel_SidebarChannel, "contextTypes", {
  intl: index_es["i" /* intlShape */].isRequired
});
// CONCATENATED MODULE: ./components/sidebar/sidebar_channel/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

















const memoizedGetLatestPostId = Object(helpers["memoizeResult"])(postIds => Object(post_utils["f" /* getLatestPostId */])(postIds));











function sidebar_channel_makeMapStateToProps() {
  const getChannel = Object(entities_channels["makeGetChannel"])();
  return (state, ownProps) => {
    const channelId = ownProps.channelId;
    const config = Object(general["getConfig"])(state);
    const currentChannelId = Object(entities_channels["getCurrentChannelId"])(state);
    const channel = getChannel(state, {
      id: channelId
    }) || {};
    const draft = channel.id ? Object(selectors_rhs["k" /* getPostDraft */])(state, constants["F" /* StoragePrefixes */].DRAFT, channel.id) : false;
    const enableTutorial = config.EnableTutorial === 'true';
    const tutorialStep = Object(entities_preferences["getInt"])(state, constants["g" /* Constants */].Preferences.TUTORIAL_STEP, ownProps.currentUserId, constants["g" /* Constants */].TutorialSteps.FINISHED);
    const channelsByName = Object(entities_channels["getChannelsNameMapInCurrentTeam"])(state);
    const memberIds = Object(entities_users["getUserIdsInChannels"])(state);
    let membersCount = 0;

    if (memberIds && memberIds[channel.id]) {
      membersCount = memberIds[channel.id].size;

      if (memberIds[channel.id].has(ownProps.currentUserId)) {
        membersCount--;
      }
    }

    const member = Object(common["getMyChannelMemberships"])(state)[channelId];
    let unreadMentions = 0;
    let unreadMsgs = 0;
    let showUnreadForMsgs = true;

    if (member) {
      unreadMentions = member.mention_count;

      if (channel) {
        unreadMsgs = Math.max(channel.total_msg_count - member.msg_count, 0);
      }

      if (member.notify_props) {
        showUnreadForMsgs = member.notify_props.mark_unread !== constants["q" /* NotificationLevels */].MENTION;
      }
    }

    const teammateNameDisplay = Object(entities_preferences["getTeammateNameDisplaySetting"])(state);
    let teammate = null;
    let channelTeammateId = '';
    let channelTeammateDeletedAt = 0;
    let channelTeammateUsername = '';
    let channelTeammateIsBot = false;
    let channelDisplayName = channel.display_name; // 频道图标处理

    let channelIcon = channel.icon_id;
    const reg = /public_|private_/;

    if (!channelIcon || !reg.test(channelIcon)) {
      channelIcon = __webpack_require__(410)(`./${channel.type === 'O' ? 'public_00.png' : 'private_00.png'}`);
    } else {
      channelIcon = __webpack_require__(410)(`./${channelIcon}`);
    }

    if (channel.type === constants["g" /* Constants */].DM_CHANNEL) {
      teammate = Object(entities_users["getUser"])(state, channel.teammate_id);

      if (teammate) {
        channelTeammateId = teammate.id;
        channelTeammateDeletedAt = teammate.delete_at;
        channelTeammateUsername = teammate.username;
        channelTeammateIsBot = teammate.is_bot;
        channelIcon = utils["K" /* imageURLForUser */]({
          id: teammate.id
        });
        channelDisplayName = teammate.nickname == "" ? teammate.first_name == "" ? teammate.username : teammate.first_name : teammate.nickname; //console.log("sssssss----state",state,"ownProps",ownProps,"member----",member,"channel----",channel,"teammate----",teammate,"teammateNameDisplay----",teammateNameDisplay,"channelDisplayName----",channelDisplayName)
      }
    }

    let shouldHideChannel = false;

    if (channel.name === constants["g" /* Constants */].DEFAULT_CHANNEL && !ownProps.active && Object(entities_channels["shouldHideDefaultChannel"])(state, channel) && !Object(channel_utils["isFavoriteChannel"])(state.entities.preferences.myPreferences, channel.id)) {
      shouldHideChannel = true;
    }

    const user = Object(entities_users["getCurrentUser"])(state);
    let unreadCount = null;

    if (user.notify_props) {
      unreadCount = user.notify_props.unread;

      if (!user.notify_props.unread) {
        unreadCount = 'true';
      }
    }

    let latestPost = channel.props ? JSON.parse(channel.props.resume) : {};
    const preparePostIdsForPostList = Object(post_list["makePreparePostIdsForPostList"])();
    let postIds;
    const lastViewedAt = state.views.channel.lastChannelViewTime[channelId];
    postIds = Object(entities_posts["getPostIdsInChannel"])(state, channelId);

    if (postIds) {
      postIds = preparePostIdsForPostList(state, {
        postIds,
        lastViewedAt,
        indicateNewMessages: true
      });
      const latestPostId = memoizedGetLatestPostId(postIds);
      latestPost = Object(entities_posts["getPost"])(state, latestPostId);
    }

    let latestPostUser = null;

    if (channel.type !== constants["g" /* Constants */].DM_CHANNEL) {
      latestPostUser = Object(entities_users["getUser"])(state, latestPost.user_id);
    } // 判断是否已从频道列表删除


    const visible = Object(entities_preferences["getBool"])(state, constants["g" /* Constants */].Preferences.CATEGORY_PRIVATE_CHANNEL_SHOW, channelId, true); // 判断是否是在合并消息状态

    let channelPostSelect;
    let hasCheckbox = false;

    if (state.views.posts) {
      channelPostSelect = state.views.posts.channelPostSelect;

      if (channelPostSelect && constants["f" /* ChannelPostSelectType */].MERGE === channelPostSelect.type) {
        hasCheckbox = channelPostSelect.visibleCheckbox || false;
      }
    }

    return {
      config,
      hasCheckbox,
      channelId,
      channelName: channel.name,
      channelDisplayName,
      channelType: channel.type,
      channelIcon,
      channelStatus: channel.status,
      channelFake: channel.fake,
      channelMuted: Object(channel_utils["isChannelMuted"])(member),
      channelStringified: channel.fake && JSON.stringify(channel),
      channelTeammateId,
      channelTeammateUsername,
      channelTeammateDeletedAt,
      channelTeammateIsBot,
      hasDraft: draft && Boolean(draft.message.trim() || draft.fileInfos.length || draft.uploadsInProgress.length) && currentChannelId !== channel.id,
      showTutorialTip: enableTutorial && tutorialStep === constants["g" /* Constants */].TutorialSteps.CHANNEL_POPOVER,
      townSquareDisplayName: channelsByName[constants["g" /* Constants */].DEFAULT_CHANNEL] && channelsByName[constants["g" /* Constants */].DEFAULT_CHANNEL].display_name,
      offTopicDisplayName: channelsByName[constants["g" /* Constants */].OFFTOPIC_CHANNEL] && channelsByName[constants["g" /* Constants */].OFFTOPIC_CHANNEL].display_name,
      showUnreadForMsgs,
      unreadMsgs,
      unreadMentions,
      membersCount,
      shouldHideChannel,
      channelIsArchived: channel.delete_at !== 0,
      redirectChannel: Object(entities_channels["getRedirectChannelNameForTeam"])(state, Object(entities_teams["getCurrentTeamId"])(state)),
      unreadCount,
      latestPost: latestPost ? latestPost : {},
      emojiMap: Object(selectors_emojis["a" /* getEmojiMap */])(state),
      currentTeamId: Object(entities_teams["getCurrentTeamId"])(state),
      user,
      latestPostUser,
      visible
    };
  };
}

function sidebar_channel_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      savePreferences: actions_preferences["savePreferences"],
      leaveChannel: views_channel["f" /* leaveChannel */],
      openLhs: lhs["b" /* open */],
      showCloud: rhs["m" /* showCloud */],
      setChannelVisible: channel_actions["h" /* setChannelVisible */]
    }, dispatch)
  };
}

/* harmony default export */ var sidebar_channel = (Object(es["connect"])(sidebar_channel_makeMapStateToProps, sidebar_channel_mapDispatchToProps, null, {
  withRef: true
})(Object(index_es["h" /* injectIntl */])(sidebar_channel_SidebarChannel)));
// CONCATENATED MODULE: ./components/sidebar/channel_create.jsx
function channel_create_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class channel_create_ChannelCreate extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    channel_create_defineProperty(this, "getTooltipTriggers", () => {
      if (utils["Y" /* isMobile */]()) {
        return [];
      }

      return ['hover'];
    });

    channel_create_defineProperty(this, "renderPublic", () => {
      if (!this.props.canCreatePublicChannel) {
        return null;
      }

      const tooltipTriggers = this.getTooltipTriggers();
      const ariaLabelPublic = `${utils["gb" /* localizeMessage */]('sidebar.createChannel', 'Create new public channel').toLowerCase()} ${utils["gb" /* localizeMessage */]('accessibility.button.button', 'button')}`;
      const tooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "new-channel-tooltip"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.createChannel",
        defaultMessage: "Create new public channel"
      }));
      return react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: tooltipTriggers,
        delayShow: 500,
        placement: "top",
        overlay: tooltip
      }, react_default.a.createElement("button", {
        id: "createPublicChannel",
        "aria-label": ariaLabelPublic,
        type: "button",
        className: "add-channel-btn cursor--pointer style--none",
        onClick: this.props.createPublicChannel
      }, '+'));
    });

    channel_create_defineProperty(this, "renderPrivate", () => {
      if (!this.props.canCreatePrivateChannel) {
        return null;
      }

      const tooltipTriggers = this.getTooltipTriggers();
      const ariaLabelPrivate = `${utils["gb" /* localizeMessage */]('sidebar.createGroup', 'Create new private channel').toLowerCase()} ${utils["gb" /* localizeMessage */]('accessibility.button.button', 'button')}`;
      const tooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "new-group-tooltip"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.createGroup",
        defaultMessage: "Create new private channel"
      }));
      return react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: tooltipTriggers,
        delayShow: 500,
        placement: "top",
        overlay: tooltip
      }, react_default.a.createElement("button", {
        id: "createPrivateChannel",
        "aria-label": ariaLabelPrivate,
        type: "button",
        className: "add-channel-btn cursor--pointer style--none",
        onClick: this.props.createPrivateChannel
      }, '+'));
    });

    channel_create_defineProperty(this, "renderDirect", () => {
      const ariaLabelDM = `${utils["gb" /* localizeMessage */]('sidebar.createDirectMessage', 'Create new direct message')} ${utils["gb" /* localizeMessage */]('accessibility.button.button', 'button')}`;
      const tooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "new-group-tooltip",
        className: "hidden-xs"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.createDirectMessage",
        defaultMessage: "Create new direct message"
      }));
      return react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: 'hover',
        className: "hidden-xs",
        delayShow: 500,
        placement: "top",
        overlay: tooltip
      }, react_default.a.createElement("button", {
        id: "addDirectChannel",
        "aria-label": ariaLabelDM,
        className: "add-channel-btn cursor--pointer style--none",
        onClick: this.props.createDirectMessage
      }, '+'));
    });

    channel_create_defineProperty(this, "renderCombined", () => {
      const {
        canCreatePublicChannel,
        canCreatePrivateChannel
      } = this.props;

      if (canCreatePublicChannel && !canCreatePrivateChannel) {
        return this.renderPublic();
      }

      if (canCreatePrivateChannel && !canCreatePublicChannel) {
        return this.renderPrivate();
      }

      if (!canCreatePublicChannel && !canCreatePrivateChannel) {
        return null;
      }

      const tooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "new-group-tooltip",
        className: "hidden-xs"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.createPublicPrivateChannel",
        defaultMessage: "Create new public or private channel"
      }));
      return react_default.a.createElement(OverlayTrigger["a" /* default */], {
        className: "hidden-xs",
        delayShow: 500,
        placement: "top",
        overlay: tooltip
      }, react_default.a.createElement("button", {
        type: "button",
        className: "add-channel-btn cursor--pointer style--none",
        onClick: this.props.createPublicDirectChannel
      }, '+'));
    });
  }

  render() {
    const {
      sectionType
    } = this.props;

    switch (sectionType) {
      case 'public':
        return this.renderPublic();

      case 'private':
        return this.renderPrivate();

      case 'direct':
        return this.renderDirect();

      case 'recent':
      case 'alpha':
        return this.renderCombined();
    }

    return null;
  }

}

channel_create_defineProperty(channel_create_ChannelCreate, "propTypes", {
  sectionType: prop_types["PropTypes"].string.isRequired,
  createPublicChannel: prop_types["PropTypes"].func.isRequired,
  createPrivateChannel: prop_types["PropTypes"].func.isRequired,
  createDirectMessage: prop_types["PropTypes"].func.isRequired,
  createPublicDirectChannel: prop_types["PropTypes"].func.isRequired,
  canCreatePublicChannel: prop_types["PropTypes"].bool.isRequired,
  canCreatePrivateChannel: prop_types["PropTypes"].bool.isRequired
});
// EXTERNAL MODULE: ./components/sidebar/add_public.png
var add_public = __webpack_require__(2972);
var add_public_default = /*#__PURE__*/__webpack_require__.n(add_public);

// EXTERNAL MODULE: ./components/sidebar/add_privite.png
var add_privite = __webpack_require__(2973);

// CONCATENATED MODULE: ./components/sidebar/channel_create_clone.jsx
function channel_create_clone_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class channel_create_clone_ChannelCreate extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    channel_create_clone_defineProperty(this, "getTooltipTriggers", () => {
      if (utils["Y" /* isMobile */]()) {
        return [];
      }

      return ['hover'];
    });

    channel_create_clone_defineProperty(this, "renderPublic", () => {
      if (!this.props.canCreatePublicChannel) {
        return null;
      }

      const tooltipTriggers = this.getTooltipTriggers();
      const ariaLabelPublic = `${utils["gb" /* localizeMessage */]('sidebar.createChannel', 'Create new public channel').toLowerCase()} ${utils["gb" /* localizeMessage */]('accessibility.button.button', 'button')}`;
      const tooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "new-channel-tooltip"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.createChannel",
        defaultMessage: "Create new public channel"
      }));
      return react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: tooltipTriggers,
        delayShow: 500,
        placement: "top",
        overlay: tooltip
      }, react_default.a.createElement("button", {
        id: "createPublicChannel",
        "aria-label": ariaLabelPublic,
        type: "button",
        className: "add-channel-btn cursor--pointer style--none",
        onClick: this.props.createPublicChannel,
        style: {
          width: '40px',
          height: '40px'
        }
      }, react_default.a.createElement("img", {
        src: add_public_default.a
      })));
    });

    channel_create_clone_defineProperty(this, "renderPrivate", () => {
      if (!this.props.canCreatePrivateChannel) {
        return null;
      }

      const tooltipTriggers = this.getTooltipTriggers();
      const ariaLabelPrivate = `${utils["gb" /* localizeMessage */]('sidebar.createGroup', 'Create new private channel').toLowerCase()} ${utils["gb" /* localizeMessage */]('accessibility.button.button', 'button')}`;
      const tooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "new-group-tooltip"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.createGroup",
        defaultMessage: "Create new private channel"
      }));
      return react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: tooltipTriggers,
        delayShow: 500,
        placement: "top",
        overlay: tooltip
      }, react_default.a.createElement("button", {
        id: "createPrivateChannel",
        "aria-label": ariaLabelPrivate,
        type: "button",
        className: "add-channel-btn cursor--pointer style--none",
        onClick: this.props.createPrivateChannel,
        style: {
          width: '40px',
          height: '40px'
        }
      }, react_default.a.createElement("span", {
        className: "add-btn"
      })));
    });

    channel_create_clone_defineProperty(this, "renderDirect", () => {
      const ariaLabelDM = `${utils["gb" /* localizeMessage */]('sidebar.createDirectMessage', 'Create new direct message')} ${utils["gb" /* localizeMessage */]('accessibility.button.button', 'button')}`;
      const tooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "new-group-tooltip",
        className: "hidden-xs"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.createDirectMessage",
        defaultMessage: "Create new direct message"
      }));
      return react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: 'hover',
        className: "hidden-xs",
        delayShow: 500,
        placement: "top",
        overlay: tooltip
      }, react_default.a.createElement("button", {
        id: "addDirectChannel",
        "aria-label": ariaLabelDM,
        className: "add-channel-btn cursor--pointer style--none",
        onClick: this.props.createDirectMessage
      }, '+'));
    });

    channel_create_clone_defineProperty(this, "renderCombined", () => {
      const {
        canCreatePublicChannel,
        canCreatePrivateChannel
      } = this.props;

      if (canCreatePublicChannel && !canCreatePrivateChannel) {
        return this.renderPublic();
      }

      if (canCreatePrivateChannel && !canCreatePublicChannel) {
        return this.renderPrivate();
      }

      if (!canCreatePublicChannel && !canCreatePrivateChannel) {
        return null;
      }

      const tooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "new-group-tooltip",
        className: "hidden-xs"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.createPublicPrivateChannel",
        defaultMessage: "Create new public or private channel"
      }));
      return react_default.a.createElement(OverlayTrigger["a" /* default */], {
        className: "hidden-xs",
        delayShow: 500,
        placement: "top",
        overlay: tooltip
      }, react_default.a.createElement("button", {
        type: "button",
        className: "add-channel-btn cursor--pointer style--none",
        onClick: this.props.createPublicDirectChannel
      }, '+'));
    });
  }

  render() {
    const {
      sectionType
    } = this.props;

    switch (sectionType) {
      case 'public':
        return this.renderPublic();

      case 'private':
        return this.renderPrivate();

      case 'direct':
        return this.renderDirect();

      case 'recent':
      case 'alpha':
        return this.renderCombined();
    }

    return null;
  }

}

channel_create_clone_defineProperty(channel_create_clone_ChannelCreate, "propTypes", {
  sectionType: prop_types["PropTypes"].string.isRequired,
  createPublicChannel: prop_types["PropTypes"].func.isRequired,
  createPrivateChannel: prop_types["PropTypes"].func.isRequired,
  createDirectMessage: prop_types["PropTypes"].func.isRequired,
  createPublicDirectChannel: prop_types["PropTypes"].func.isRequired,
  canCreatePublicChannel: prop_types["PropTypes"].bool.isRequired,
  canCreatePrivateChannel: prop_types["PropTypes"].bool.isRequired
});
// CONCATENATED MODULE: ./components/sidebar/channel_more.jsx
function channel_more_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class channel_more_ChannelMore extends react_default.a.PureComponent {
  render() {
    const {
      sectionType,
      moreChannels,
      moreDirectMessages,
      browsePublicDirectChannels
    } = this.props;

    switch (sectionType) {
      case 'public':
        return react_default.a.createElement("li", {
          key: "public-channel-more",
          id: "morePublicButton"
        }, react_default.a.createElement("button", {
          id: "sidebarChannelsMore",
          className: "nav-more cursor--pointer style--none btn--block",
          onClick: moreChannels
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "sidebar.moreElips",
          defaultMessage: "More..."
        })));

      case 'direct':
        return react_default.a.createElement("li", {
          key: "dm-more",
          id: "moreDMButton"
        }, react_default.a.createElement("button", {
          id: "moreDirectMessage",
          className: "nav-more cursor--pointer style--none btn--block",
          onClick: moreDirectMessages
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "sidebar.moreElips",
          defaultMessage: "More..."
        })));

      case 'recent':
      case 'alpha':
        return react_default.a.createElement("li", {
          key: "public-dm-more",
          id: "moreRecentAlphaButton"
        }, react_default.a.createElement("button", {
          id: "morePublicDirectChannels",
          className: "nav-more cursor--pointer style--none btn--block",
          onClick: browsePublicDirectChannels
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "sidebar.moreElips",
          defaultMessage: "More..."
        })));
    }

    return null;
  }

}

channel_more_defineProperty(channel_more_ChannelMore, "propTypes", {
  sectionType: prop_types["PropTypes"].string.isRequired,
  moreChannels: prop_types["PropTypes"].func.isRequired,
  moreDirectMessages: prop_types["PropTypes"].func.isRequired,
  browsePublicDirectChannels: prop_types["PropTypes"].func.isRequired
});
// CONCATENATED MODULE: ./components/sidebar/channel_name.jsx
function channel_name_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const clickableChannelHeader = ['recent', 'alpha'];
class channel_name_ChannelName extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    channel_name_defineProperty(this, "sectionTypeFormatMessageId", sectionType => {
      switch (sectionType) {
        case 'public':
          return Object(i18n["b" /* t */])('sidebar.types.public');

        case 'private':
          return Object(i18n["b" /* t */])('sidebar.types.private');

        case 'direct':
          return Object(i18n["b" /* t */])('sidebar.types.direct');

        case 'favorite':
          return Object(i18n["b" /* t */])('sidebar.types.favorite');

        case 'unreads':
          return Object(i18n["b" /* t */])('sidebar.types.unreads');

        case 'recent':
          return Object(i18n["b" /* t */])('sidebar.types.recent');

        default:
          return Object(i18n["b" /* t */])('sidebar.types.alpha');
      }
    });
  }

  render() {
    const {
      sectionType,
      channelName,
      browsePublicDirectChannels
    } = this.props;
    let tooltipTriggers = ['hover', 'focus'];

    if (utils["Y" /* isMobile */]()) {
      tooltipTriggers = [];
    }

    const formattedMessageId = this.sectionTypeFormatMessageId(sectionType);
    let name = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: formattedMessageId,
      defaultMessage: channelName
    });

    if (clickableChannelHeader.indexOf(sectionType) !== -1) {
      const createPublicDirectChannelTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
        id: "new-group-tooltip",
        className: "hidden-xs"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "sidebar.browseChannelDirectChannel",
        defaultMessage: "Browse Channels and Direct Messages"
      }));
      name = react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: tooltipTriggers,
        delayShow: 500,
        placement: "top",
        overlay: createPublicDirectChannelTooltip
      }, react_default.a.createElement("div", {
        role: "presentation",
        className: "public_direct_name",
        onClick: browsePublicDirectChannels
      }, name));
    }

    return name;
  }

}

channel_name_defineProperty(channel_name_ChannelName, "propTypes", {
  sectionType: prop_types["PropTypes"].string.isRequired,
  channelName: prop_types["PropTypes"].string.isRequired,
  browsePublicDirectChannels: prop_types["PropTypes"].func.isRequired
});
// CONCATENATED MODULE: ./components/sidebar/more_public_direct_channels.jsx
function more_public_direct_channels_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class more_public_direct_channels_MorePublicDirectChannels extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    more_public_direct_channels_defineProperty(this, "state", {
      show: true,
      key: 'channels'
    });

    more_public_direct_channels_defineProperty(this, "handleHide", () => {
      this.setState({
        show: false
      });
    });

    more_public_direct_channels_defineProperty(this, "handleExit", () => {
      if (this.props.onModalDismissed) {
        this.props.onModalDismissed();
      }
    });

    more_public_direct_channels_defineProperty(this, "handleSelect", key => {
      this.setState({
        key
      });
    });
  }

  render() {
    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: 'more-modal more-direct-channels more-public-direct-channels',
      show: this.state.show,
      onHide: this.handleHide,
      onExited: this.handleExit,
      role: "dialog",
      "aria-labelledby": "morePublicModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "morePublicModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "more_public_direct_channels.title",
      defaultMessage: "Channels and Direct Messages"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement(Tabs["a" /* default */], {
      id: "morePublicDirectChannelTabs",
      className: "modal-tabs",
      defaultActiveKey: "channels",
      activeKey: this.state.key,
      onSelect: this.handleSelect,
      unmountOnExit: true
    }, react_default.a.createElement(Tab["a" /* default */], {
      eventKey: "channels",
      title: Object(utils["gb" /* localizeMessage */])('more_public_direct_channels.channels', 'Channels')
    }, react_default.a.createElement(more_channels, {
      handleNewChannel: this.props.handleNewChannel,
      onModalDismissed: this.handleHide,
      bodyOnly: true
    })), react_default.a.createElement(Tab["a" /* default */], {
      eventKey: "dm",
      title: Object(utils["gb" /* localizeMessage */])('more_public_direct_channels.direct_messages', 'Direct Messages')
    }, react_default.a.createElement(more_direct_channels, {
      onModalDismissed: this.handleHide,
      isExistingChannel: false,
      bodyOnly: true
    })))));
  }

}

more_public_direct_channels_defineProperty(more_public_direct_channels_MorePublicDirectChannels, "propTypes", {
  handleNewChannel: prop_types_default.a.func,
  onModalDismissed: prop_types_default.a.func
});
// EXTERNAL MODULE: ./components/sidebar/zhongan.png
var zhongan = __webpack_require__(2974);

// EXTERNAL MODULE: ./components/sidebar/add.png
var add = __webpack_require__(2975);

// EXTERNAL MODULE: ./components/sidebar/add_channel.png
var add_channel = __webpack_require__(2976);

// CONCATENATED MODULE: ./components/sidebar/sidebar.jsx
function sidebar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function sidebar_extends() { sidebar_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return sidebar_extends.apply(this, arguments); }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










































function sidebar_renderView(props) {
  return react_default.a.createElement("div", sidebar_extends({}, props, {
    className: "scrollbar--view"
  }));
}
function sidebar_renderThumbHorizontal(props) {
  return react_default.a.createElement("div", sidebar_extends({}, props, {
    className: "scrollbar--horizontal"
  }));
}
function sidebar_renderThumbVertical(props) {
  return react_default.a.createElement("div", sidebar_extends({}, props, {
    className: "scrollbar--vertical"
  }));
}
class sidebar_Sidebar extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    sidebar_defineProperty(this, "handleOpenMoreDirectChannelsModal", e => {
      e.preventDefault();

      if (this.state.showDirectChannelsModal) {
        this.hideMoreDirectChannelsModal();
      } else {
        this.showMoreDirectChannelsModal();
      }
    });

    sidebar_defineProperty(this, "updateTitle", () => {
      const {
        config,
        currentChannel,
        currentTeam,
        currentTeammate,
        unreads
      } = this.props;

      if (currentChannel && currentTeam) {
        let currentSiteName = "AboutOne"; // if (config.SiteName != null) {
        //   currentSiteName = config.SiteName;
        // }

        let currentChannelName = currentChannel.display_name;

        if (currentChannel.type === constants["g" /* Constants */].DM_CHANNEL) {
          if (currentTeammate != null) {
            currentChannelName = currentTeammate.display_name;
          }
        }

        const mentionTitle = unreads.mentionCount > 0 ? "(" + unreads.mentionCount + ") " : "";
        const unreadTitle = unreads.messageCount > 0 ? "* " : "";
        document.title = mentionTitle + unreadTitle + currentChannelName + " - " + this.props.currentTeam.display_name + " " + currentSiteName;
      }
    });

    sidebar_defineProperty(this, "updateFavicon", active => {
      const link16x16 = document.querySelector('link[rel="icon"][sizes="16x16"]');
      link16x16.type = 'image/x-icon';
      const link32x32 = document.querySelector('link[rel="icon"][sizes="32x32"]');
      link32x32.type = 'image/x-icon';
      const link96x96 = document.querySelector('link[rel="icon"][sizes="96x96"]');
      link96x96.type = 'image/x-icon';

      if (active) {
        link16x16.href = typeof favicon_reddot_16x16_default.a === "string" ? favicon_reddot_16x16_default.a : "";
        link32x32.href = typeof favicon_reddot_16x16_default.a === "string" ? favicon_reddot_16x16_default.a : "";
        link96x96.href = typeof favicon_reddot_16x16_default.a === "string" ? favicon_reddot_16x16_default.a : "";
      } else {
        link16x16.href = typeof favicon_32x32_default.a === "string" ? favicon_32x32_default.a : "";
        link32x32.href = typeof favicon_32x32_default.a === "string" ? favicon_32x32_default.a : "";
        link96x96.href = typeof favicon_32x32_default.a === "string" ? favicon_32x32_default.a : "";
      }
    });

    sidebar_defineProperty(this, "onScroll", () => {
      this.updateUnreadIndicators();
    });

    sidebar_defineProperty(this, "handleScrollAnimationUpdate", spring => {
      const {
        scrollbar
      } = this.refs;
      const val = spring.getCurrentValue();
      scrollbar.scrollTop(val);
    });

    sidebar_defineProperty(this, "scrollToFirstUnreadChannel", () => {
      if (this.firstUnreadChannel) {
        const displayedChannels = this.getDisplayedChannels(this.state.orderedChannelIds);
        this.unreadScrollAnimate.setCurrentValue(this.refs.scrollbar.getScrollTop()).setAtRest();
        let position;

        if (displayedChannels.length > 0 && displayedChannels[0] === this.firstUnreadChannel) {
          position = rebound["MathUtil"].mapValueInRange(0, 0, 1, 0, 1);
        } else {
          const unreadMargin = 15;
          const firstUnreadElement = jquery_default()(react_dom_default.a.findDOMNode(this.refs[this.firstUnreadChannel]));
          const scrollTop = firstUnreadElement.position().top - unreadMargin;
          position = rebound["MathUtil"].mapValueInRange(scrollTop, 0, 1, 0, 1);
        }

        this.unreadScrollAnimate.setEndValue(position);
      }
    });

    sidebar_defineProperty(this, "scrollToLastUnreadChannel", () => {
      if (this.lastUnreadChannel) {
        const {
          scrollbar
        } = this.refs;
        const unreadMargin = 15;
        const lastUnreadElement = jquery_default()(react_dom_default.a.findDOMNode(this.refs[this.lastUnreadChannel]));
        const elementBottom = lastUnreadElement.position().top + lastUnreadElement.height();
        const scrollTop = elementBottom - scrollbar.getClientHeight() + unreadMargin;
        const position = rebound["MathUtil"].mapValueInRange(scrollTop, 0, 1, 0, 1);
        this.unreadScrollAnimate.setCurrentValue(scrollbar.getScrollTop()).setAtRest();
        this.unreadScrollAnimate.setEndValue(position);
      }
    });

    sidebar_defineProperty(this, "updateUnreadIndicators", () => {
      let showTopUnread = false;
      let showBottomUnread = false; // Consider partially obscured channels as above/below

      const unreadMargin = 15;

      if (this.firstUnreadChannel) {
        const firstUnreadElement = jquery_default()(react_dom_default.a.findDOMNode(this.refs[this.firstUnreadChannel]));
        const firstUnreadPosition = firstUnreadElement ? firstUnreadElement.position() : null;

        if (firstUnreadPosition && firstUnreadPosition.top + firstUnreadElement.height() - unreadMargin < this.refs.scrollbar.getScrollTop()) {
          showTopUnread = true;
        }
      }

      if (this.lastUnreadChannel) {
        const lastUnreadElement = jquery_default()(react_dom_default.a.findDOMNode(this.refs[this.lastUnreadChannel]));
        const lastUnreadPosition = lastUnreadElement ? lastUnreadElement.position() : null;

        if (lastUnreadPosition && lastUnreadPosition.top + unreadMargin > this.refs.scrollbar.getScrollTop() + this.refs.scrollbar.getClientHeight()) {
          showBottomUnread = true;
        }
      }

      if (showTopUnread !== this.state.showTopUnread || showBottomUnread !== this.state.showBottomUnread) {
        this.setState({
          showTopUnread,
          showBottomUnread
        });
      }
    });

    sidebar_defineProperty(this, "updateScrollbarOnChannelChange", channelId => {
      const curChannel = this.refs[channelId].getWrappedInstance().refs.channel.getBoundingClientRect();

      if (curChannel.top - constants["g" /* Constants */].CHANNEL_SCROLL_ADJUSTMENT < 0 || curChannel.top + curChannel.height > this.refs.scrollbar.view.getBoundingClientRect().height) {
        this.refs.scrollbar.scrollTop(this.refs.scrollbar.view.scrollTop + (curChannel.top - constants["g" /* Constants */].CHANNEL_SCROLL_ADJUSTMENT));
      }
    });

    sidebar_defineProperty(this, "navigateChannelShortcut", e => {
      if (e.altKey && !e.shiftKey && (utils["V" /* isKeyPressed */](e, constants["g" /* Constants */].KeyCodes.UP) || utils["V" /* isKeyPressed */](e, constants["g" /* Constants */].KeyCodes.DOWN))) {
        e.preventDefault();

        if (this.isSwitchingChannel) {
          return;
        }

        this.isSwitchingChannel = true;
        const allChannelIds = this.getDisplayedChannels(this.state.orderedChannelIds);
        const curChannelId = this.props.currentChannel.id;
        let curIndex = -1;

        for (let i = 0; i < allChannelIds.length; i++) {
          if (allChannelIds[i] === curChannelId) {
            curIndex = i;
          }
        }

        let nextIndex = curIndex;

        if (utils["V" /* isKeyPressed */](e, constants["g" /* Constants */].KeyCodes.DOWN)) {
          nextIndex = curIndex + 1;
        } else {
          nextIndex = curIndex - 1;
        }

        const nextChannelId = allChannelIds[utils["hb" /* mod */](nextIndex, allChannelIds.length)];
        this.props.actions.switchToChannelById(nextChannelId);
        this.updateScrollbarOnChannelChange(nextChannelId);
        this.isSwitchingChannel = false;
      } else if (utils["e" /* cmdOrCtrlPressed */](e) && e.shiftKey && utils["V" /* isKeyPressed */](e, constants["g" /* Constants */].KeyCodes.K)) {
        this.handleOpenMoreDirectChannelsModal(e);
      }
    });

    sidebar_defineProperty(this, "navigateUnreadChannelShortcut", e => {
      if (e.altKey && e.shiftKey && (utils["V" /* isKeyPressed */](e, constants["g" /* Constants */].KeyCodes.UP) || utils["V" /* isKeyPressed */](e, constants["g" /* Constants */].KeyCodes.DOWN))) {
        e.preventDefault();

        if (this.isSwitchingChannel) {
          return;
        }

        this.isSwitchingChannel = true;
        const allChannelIds = this.getDisplayedChannels(this.state.orderedChannelIds);
        let direction = 0;

        if (utils["V" /* isKeyPressed */](e, constants["g" /* Constants */].KeyCodes.UP)) {
          direction = -1;
        } else {
          direction = 1;
        }

        const nextIndex = utils_channel_utils["b" /* findNextUnreadChannelId */](this.props.currentChannel.id, allChannelIds, this.props.unreadChannelIds, direction);

        if (nextIndex !== -1) {
          const nextChannelId = allChannelIds[nextIndex];
          this.props.actions.switchToChannelById(nextChannelId);
          this.updateScrollbarOnChannelChange(nextChannelId);
        }

        this.isSwitchingChannel = false;
      }
    });

    sidebar_defineProperty(this, "getDisplayedChannels", (orderedChannelIds = []) => {
      return orderedChannelIds.reduce((allChannelIds, section) => {
        allChannelIds.push(...section.items);
        return allChannelIds;
      }, []);
    });

    sidebar_defineProperty(this, "channelIdIsDisplayedForProps", (orderedChannelIds = [], id) => {
      const allChannels = this.getDisplayedChannels(orderedChannelIds);

      for (let i = 0; i < allChannels.length; i++) {
        if (allChannels[i] === id) {
          return true;
        }
      }

      return false;
    });

    sidebar_defineProperty(this, "showMorePublicDirectChannelsModal", () => {
      this.setState({
        showMorePublicChannelsModal: true
      });
      Object(diagnostics_actions["d" /* trackEvent */])("ui", "ui_channels_more_public_direct");
    });

    sidebar_defineProperty(this, "hideMorePublicDirectChannelsModal", () => {
      this.setState({
        showMorePublicChannelsModal: false
      });
    });

    sidebar_defineProperty(this, "onHandleNewChannel", () => {
      this.hideMorePublicDirectChannelsModal();
      this.showNewChannelModal(constants["g" /* Constants */].OPEN_CHANNEL);
    });

    sidebar_defineProperty(this, "showMoreChannelsModal", () => {
      this.setState({
        showMoreChannelsModal: true
      });
      Object(diagnostics_actions["d" /* trackEvent */])("ui", "ui_channels_more_public");
    });

    sidebar_defineProperty(this, "hideMoreChannelsModal", () => {
      this.setState({
        showMoreChannelsModal: false
      });
    });

    sidebar_defineProperty(this, "showNewPublicChannelModal", () => {
      this.showNewChannelModal(constants["g" /* Constants */].OPEN_CHANNEL);
    });

    sidebar_defineProperty(this, "showNewPrivateChannelModal", () => {
      this.showNewChannelModal(constants["g" /* Constants */].PRIVATE_CHANNEL);
    });

    sidebar_defineProperty(this, "showNewChannelModal", type => {
      this.setState({
        newChannelModalType: type
      });
    });

    sidebar_defineProperty(this, "hideNewChannelModal", () => {
      this.setState({
        newChannelModalType: ""
      });
    });

    sidebar_defineProperty(this, "showMoreDirectChannelsModal", () => {
      Object(diagnostics_actions["d" /* trackEvent */])("ui", "ui_channels_more_direct");
      this.setState({
        showDirectChannelsModal: true
      });
    });

    sidebar_defineProperty(this, "hideMoreDirectChannelsModal", () => {
      this.setState({
        showDirectChannelsModal: false
      });
    });

    sidebar_defineProperty(this, "openQuickSwitcher", e => {
      e.preventDefault();
      this.props.actions.openModal({
        modalId: constants["p" /* ModalIdentifiers */].QUICK_SWITCH,
        dialogType: quick_switch_modal
      });
    });

    sidebar_defineProperty(this, "createSidebarChannel", channelId => {
      return react_default.a.createElement(sidebar_channel, {
        key: channelId,
        ref: channelId,
        channelId: channelId,
        active: channelId === this.props.currentChannel.id,
        currentTeamName: this.props.currentTeam.name,
        currentUserId: this.props.currentUser.id
      });
    });

    sidebar_defineProperty(this, "renderOrderedChannels", () => {
      const {
        orderedChannelIds
      } = this.state;
      const sectionsToHide = [constants["C" /* SidebarChannelGroups */].UNREADS, constants["C" /* SidebarChannelGroups */].FAVORITE];
      const sidebarItems = [];
      const sidebarUnreadItems = [];
      orderedChannelIds.map(sec => {
        sec.items.map(item => {
          const o = {
            type: sec.type,
            name: sec.name,
            ariaLabel: sec.name.toLowerCase(),
            channelId: item
          };

          if (!this.props.unreadChannelIds.includes(item)) {
            sidebarItems.push(o);
          } else {
            sidebarUnreadItems.push(o);
          }
        });
        return sidebarItems;
      });
      const _sidebarItems = [...sidebarUnreadItems, ...sidebarItems]; // console.log(orderedChannelIds, '-------sidebar')
      //console.log("_sidebarItems",_sidebarItems, this.props.unreadChannelIds, this);

      return react_default.a.createElement(react_custom_scrollbars_lib_default.a, {
        ref: "scrollbar",
        autoHide: true,
        autoHideTimeout: 500,
        autoHideDuration: 500,
        renderThumbHorizontal: sidebar_renderThumbHorizontal,
        renderThumbVertical: sidebar_renderThumbVertical,
        renderView: sidebar_renderView,
        onScroll: this.onScroll,
        style: {
          position: "absolute"
        }
      }, react_default.a.createElement("div", {
        id: "sidebarChannelContainer",
        className: "nav-pills__container"
      }, _sidebarItems.map(channelItem => {
        return react_default.a.createElement("div", {
          key: channelItem.channelId,
          "aria-label": channelItem.ariaLabel,
          role: "presentation",
          className: `nav nav-pills nav-stacked nav-${channelItem.type}`
        }, this.createSidebarChannel(channelItem.channelId));
      })));
    });

    this.badgesActive = false;
    this.firstUnreadChannel = null;
    this.lastUnreadChannel = null;
    this.isLeaving = new Map();
    this.isSwitchingChannel = false;
    this.closedDirectChannel = false;
    this.state = {
      newChannelModalType: "",
      orderedChannelIds: props.orderedChannelIds,
      showDirectChannelsModal: false,
      showMoreChannelsModal: false,
      showMorePublicChannelsModal: false
    };
    this.animate = new rebound["SpringSystem"]();
    this.unreadScrollAnimate = this.animate.createSpring();
    this.unreadScrollAnimate.setOvershootClampingEnabled(true); // disables the spring action at the end of animation

    this.unreadScrollAnimate.addListener({
      onSpringUpdate: this.handleScrollAnimationUpdate
    });
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.orderedChannelIds[0].type === constants["C" /* SidebarChannelGroups */].UNREADS && prevState.orderedChannelIds[0].type === constants["C" /* SidebarChannelGroups */].UNREADS && prevState.orderedChannelIds[0].items.length === nextProps.orderedChannelIds[0].items.length && prevState.orderedChannelIds[0].items.includes(nextProps.currentChannel.id)) {
      return null;
    }

    if (nextProps.orderedChannelIds !== prevState.orderedChannelIds) {
      return {
        orderedChannelIds: nextProps.orderedChannelIds
      };
    }

    return null;
  }

  componentDidMount() {
    this.updateUnreadIndicators();
    document.addEventListener("keydown", this.navigateChannelShortcut);
    document.addEventListener("keydown", this.navigateUnreadChannelShortcut);
  }

  componentDidUpdate(prevProps) {
    // if the active channel disappeared (which can happen when dm channels
    // autoclose), go to user default channel in team
    if (this.props.currentTeam === prevProps.currentTeam && this.props.currentChannel.id === prevProps.currentChannel.id && !this.channelIdIsDisplayedForProps(this.props.orderedChannelIds, this.props.currentChannel.id) && this.channelIdIsDisplayedForProps(prevProps.orderedChannelIds, this.props.currentChannel.id)) {
      this.closedDirectChannel = true;
      Object(global_actions["f" /* redirectUserToDefaultTeam */])();
      return;
    } // reset the scrollbar upon switching teams


    if (this.props.currentTeam !== prevProps.currentTeam) {
      this.refs.scrollbar.scrollToTop();
    } // close the LHS on mobile when you change channels


    if (this.props.currentChannel.id !== prevProps.currentChannel.id) {
      if (this.closedDirectChannel) {
        this.closedDirectChannel = false;
      } else {
        this.props.actions.close();
      }
    }

    this.updateTitle();
    this.setBadgesActiveAndFavicon();
    this.setFirstAndLastUnreadChannels();
    this.updateUnreadIndicators();
  }

  componentWillUnmount() {
    document.removeEventListener("keydown", this.navigateChannelShortcut);
    document.removeEventListener("keydown", this.navigateUnreadChannelShortcut);
    this.animate.deregisterSpring(this.unreadScrollAnimate);
    this.animate.removeAllListeners();
    this.unreadScrollAnimate.destroy();
  }

  handleScroll() {}

  setBadgesActiveAndFavicon() {
    const link = document.querySelector('link[rel="icon"]');

    if (!link) {
      return;
    }

    this.lastBadgesActive = this.badgesActive;
    this.badgesActive = this.props.unreads.mentionCount > 0; // update the favicon to show if there are any notifications

    if (this.lastBadgesActive !== this.badgesActive) {
      this.updateFavicon(this.badgesActive);
    }
  }

  setFirstAndLastUnreadChannels() {
    const {
      currentChannel,
      unreadChannelIds
    } = this.props;
    const {
      orderedChannelIds
    } = this.state;
    this.getDisplayedChannels(orderedChannelIds).map(channelId => {
      if (channelId !== currentChannel.id && unreadChannelIds.includes(channelId)) {
        if (!this.firstUnreadChannel) {
          this.firstUnreadChannel = channelId;
        }

        this.lastUnreadChannel = channelId;
      }

      return null;
    });
  }

  render() {
    const {
      channelSwitcherOption
    } = this.props;
    const ariaLabel = utils["gb" /* localizeMessage */]("accessibility.sections.lhsList", "channel sidebar region"); // Check if we have all info needed to render

    if (this.props.currentTeam == null || this.props.currentUser == null) {
      return react_default.a.createElement("div", null);
    } // keep track of the first and last unread channels so we can use them to set the unread indicators


    this.firstUnreadChannel = null;
    this.lastUnreadChannel = null;
    let showChannelModal = false;

    if (this.state.newChannelModalType !== "") {
      showChannelModal = true;
    }

    const above = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "sidebar.unreads",
      defaultMessage: "More unreads"
    });
    const below = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "sidebar.unreads",
      defaultMessage: "More unreads"
    });
    let moreDirectChannelsModal;

    if (this.state.showDirectChannelsModal) {
      moreDirectChannelsModal = react_default.a.createElement(more_direct_channels, {
        onModalDismissed: this.hideMoreDirectChannelsModal,
        isExistingChannel: false
      });
    }

    let moreChannelsModal;

    if (this.state.showMoreChannelsModal) {
      moreChannelsModal = react_default.a.createElement(more_channels, {
        onModalDismissed: this.hideMoreChannelsModal,
        handleNewChannel: () => {
          this.hideMoreChannelsModal();
          this.showNewChannelModal(constants["g" /* Constants */].OPEN_CHANNEL);
        }
      });
    }

    let quickSwitchText = null;

    if (channelSwitcherOption) {
      let quickSwitchTextShortcutId = Object(i18n["b" /* t */])("quick_switch_modal.channelsShortcut.windows");
      let quickSwitchTextShortcutDefault = "- CTRL+K";

      if (utils["W" /* isMac */]()) {
        quickSwitchTextShortcutId = Object(i18n["b" /* t */])("quick_switch_modal.channelsShortcut.mac");
        quickSwitchTextShortcutDefault = "- ⌘K";
      }

      const quickSwitchTextShortcut = react_default.a.createElement("span", {
        className: "switch__shortcut hidden-xs"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: quickSwitchTextShortcutId,
        defaultMessage: quickSwitchTextShortcutDefault
      }));
      quickSwitchText = react_default.a.createElement("div", {
        className: "sidebar__switcher"
      }, react_default.a.createElement("button", {
        id: "sidebarSwitcherButton",
        className: "btn btn-link",
        onClick: this.openQuickSwitcher
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_switch_modal.title",
        defaultMessage: "Switch Channels"
      }), quickSwitchTextShortcut));
    }

    let morePublicDirectChannelsModal;

    if (this.state.showMorePublicChannelsModal) {
      morePublicDirectChannelsModal = react_default.a.createElement(more_public_direct_channels_MorePublicDirectChannels, {
        onModalDismissed: this.hideMorePublicDirectChannelsModal,
        handleNewChannel: this.onHandleNewChannel,
        isExistingChannel: false
      });
    } // const list = filterAndSortTeamsByDisplayName(
    //   this.props.myTeams,
    //   this.props.locale
    // );
    // const teams = list.map((team, index) => {
    //   //console.log(111111, team.id, index);
    //   const member = this.props.myTeamMembers[team.id];
    //   //console.log(222222222, member);
    //   return (
    //     <TeamButton
    //       key={"switch_team_" + index}
    //       url={`/${team.name}`}
    //       tip={team.display_name}
    //       active={team.id === this.props.currentTeamId}
    //       displayName={team.display_name}
    //       unread={member.msg_count > 0}
    //       mentions={member.mention_count}
    //       teamIconUrl={Utils.imageURLForTeam(team)}
    //       switchTeam={this.props.actions.switchTeam}
    //     />
    //   );
    // });


    return react_default.a.createElement("div", {
      className: classnames_default()("sidebar--left", {
        "move--right": this.props.isOpen && utils["Y" /* isMobile */]()
      }),
      id: "sidebar-left",
      key: "sidebar-left"
    }, react_default.a.createElement("div", {
      className: "left"
    }, react_default.a.createElement("div", {
      className: "content"
    }, react_default.a.createElement(team_sidebar, null)), react_default.a.createElement("div", {
      className: "bottom"
    }, react_default.a.createElement(headerClone, null))), react_default.a.createElement("div", {
      className: "right"
    }, react_default.a.createElement(new_channel_flow, {
      show: showChannelModal,
      canCreatePublicChannel: this.props.canCreatePublicChannel,
      canCreatePrivateChannel: this.props.canCreatePrivateChannel,
      channelType: this.state.newChannelModalType,
      onModalDismissed: this.hideNewChannelModal
    }), morePublicDirectChannelsModal, moreDirectChannelsModal, moreChannelsModal, react_default.a.createElement("div", {
      className: "siderTop"
    }, react_default.a.createElement("span", null, "Aboutone")), react_default.a.createElement("div", {
      className: "sidebar--left__icons"
    }, react_default.a.createElement(pluggable["a" /* default */], {
      pluggableName: "LeftSidebarHeader"
    })), react_default.a.createElement("div", {
      id: "lhsList",
      role: "application",
      "aria-label": ariaLabel,
      tabIndex: "-1",
      className: "sidebar--left__list"
    }, this.renderOrderedChannels()), react_default.a.createElement("div", {
      className: "add_channel"
    }, react_default.a.createElement(channel_create_clone_ChannelCreate, {
      sectionType: "private",
      canCreatePublicChannel: this.props.canCreatePublicChannel,
      canCreatePrivateChannel: this.props.canCreatePrivateChannel,
      createPublicChannel: this.showNewPublicChannelModal,
      createPrivateChannel: this.showNewPrivateChannelModal,
      createDirectMessage: this.handleOpenMoreDirectChannelsModal,
      createPublicDirectChannel: this.showNewPublicChannelModal
    }))));
  }

}

sidebar_defineProperty(sidebar_Sidebar, "propTypes", {
  //locale: PropTypes.string.isRequired,
  //myTeams: PropTypes.array.isRequired,
  //myTeamMembers: PropTypes.object.isRequired,

  /**
   * Global config object
   */
  config: prop_types["PropTypes"].object.isRequired,
  isOpen: prop_types["PropTypes"].bool.isRequired,

  /**
   * List of unread channels (ids)
   */
  unreadChannelIds: prop_types["PropTypes"].array,

  /**
   * List of ordered channels (ids)
   */
  orderedChannelIds: prop_types["PropTypes"].arrayOf(prop_types["PropTypes"].shape({
    /**
     * Type of channel
     */
    type: prop_types["PropTypes"].string.isRequired,

    /**
     * Displayed name in sidebar
     */
    name: prop_types["PropTypes"].string.isRequired,

    /**
     * List of ids for the channels (ids)
     */
    items: prop_types["PropTypes"].array.isRequired
  })),

  /**
   * Current channel object
   */
  currentChannel: prop_types["PropTypes"].object,

  /**
   * Current channel teammeat (for direct messages)
   */
  currentTeammate: prop_types["PropTypes"].object,

  /**
   * Current team object
   */
  currentTeam: prop_types["PropTypes"].object,

  /**
   * Current user object
   */
  currentUser: prop_types["PropTypes"].object,

  /**
   * Number of unread mentions/messages
   */
  unreads: prop_types["PropTypes"].object.isRequired,

  /**
   * Permission to create public channel
   */
  canCreatePublicChannel: prop_types["PropTypes"].bool.isRequired,

  /**
   * Permission to create private channel
   */
  canCreatePrivateChannel: prop_types["PropTypes"].bool.isRequired,

  /**
   * Flag to display the Switch channel shortcut
   */
  channelSwitcherOption: prop_types["PropTypes"].bool.isRequired,
  actions: prop_types["PropTypes"].shape({
    close: prop_types["PropTypes"].func.isRequired,
    switchToChannelById: prop_types["PropTypes"].func.isRequired,
    openModal: prop_types["PropTypes"].func.isRequired //switchTeam: PropTypes.func.isRequired
    //currentTeamId: PropTypes.string.isRequired

  }).isRequired
});

sidebar_defineProperty(sidebar_Sidebar, "defaultProps", {
  currentChannel: {}
});
// CONCATENATED MODULE: ./components/sidebar/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



















function sidebar_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const currentChannel = Object(entities_channels["getCurrentChannel"])(state);
  const currentTeammate = currentChannel && currentChannel.teammate_id && Object(entities_channels["getCurrentChannel"])(state, currentChannel.teammate_id);
  const currentTeam = Object(entities_teams["getCurrentTeam"])(state);
  const canCreatePublicChannel = Object(roles["haveITeamPermission"])(state, {
    team: currentTeam.id,
    permission: permissions_default.a.CREATE_PUBLIC_CHANNEL
  });
  const canCreatePrivateChannel = Object(roles["haveITeamPermission"])(state, {
    team: currentTeam.id,
    permission: permissions_default.a.CREATE_PRIVATE_CHANNEL
  });
  const sidebarPrefs = Object(entities_preferences["getSidebarPreferences"])(state);
  const lastUnreadChannel = state.views.channel.keepChannelIdAsUnread;
  const unreadChannelIds = Object(entities_channels["getSortedUnreadChannelIds"])(state, lastUnreadChannel);
  const orderedChannelIds = Object(entities_channels["getOrderedChannelIds"])(state, lastUnreadChannel, sidebarPrefs.grouping, sidebarPrefs.sorting, sidebarPrefs.unreads_at_top === "true", sidebarPrefs.favorite_at_top === "true");
  const channelSwitcherOption = Object(entities_preferences["getBool"])(state, mattermost_redux_constants["Preferences"].CATEGORY_SIDEBAR_SETTINGS, "channel_switcher_section", "true");
  return {
    config,
    unreadChannelIds,
    orderedChannelIds,
    channelSwitcherOption,
    currentChannel,
    currentTeammate,
    currentTeam,
    currentUser: Object(entities_users["getCurrentUser"])(state),
    canCreatePublicChannel,
    canCreatePrivateChannel,
    isOpen: getIsLhsOpen(state),
    unreads: Object(entities_channels["getUnreads"])(state),
    //myTeams: getMyTeams(state),
    //myTeamMembers: getTeamMemberships(state),
    //currentTeamId: getCurrentTeamId(state),
    locale: Object(selectors_i18n["a" /* getCurrentLocale */])(state)
  };
}

function sidebar_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      close: lhs["a" /* close */],
      switchToChannelById: views_channel["l" /* switchToChannelById */],
      openModal: modals["b" /* openModal */] //switchTeam

    }, dispatch)
  };
}

/* harmony default export */ var sidebar = (Object(es["connect"])(sidebar_mapStateToProps, sidebar_mapDispatchToProps)(sidebar_Sidebar));
// EXTERNAL MODULE: ./selectors/local_storage.js
var selectors_local_storage = __webpack_require__(1830);

// CONCATENATED MODULE: ./components/permalink_view/actions.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function focusPost(postId, returnTo = '') {
  return async (dispatch, getState) => {
    const {
      data
    } = await dispatch(Object(actions_posts["getPostThread"])(postId));

    if (!data) {
      browser_history["a" /* browserHistory */].replace(`/error?type=${constants["i" /* ErrorPageTypes */].PERMALINK_NOT_FOUND}&returnTo=${returnTo}`);
      return;
    }

    const state = getState();
    const channelId = data.posts[data.order[0]].channel_id;
    let channel = state.entities.channels.channels[channelId];
    const teamId = Object(entities_teams["getCurrentTeamId"])(state);

    if (!channel) {
      const {
        data: channelData
      } = await dispatch(Object(actions_channels["getChannel"])(channelId));

      if (!channelData) {
        browser_history["a" /* browserHistory */].replace(`/error?type=${constants["i" /* ErrorPageTypes */].PERMALINK_NOT_FOUND}&returnTo=${returnTo}`);
        return;
      }

      channel = channelData;
    }

    const myMember = state.entities.channels.myMembers[channelId];

    if (!myMember) {
      // If it's a DM or GM channel and we don't have a channel member for it already, user is not a member
      if (channel.type === constants["g" /* Constants */].DM_CHANNEL || channel.type === constants["g" /* Constants */].GM_CHANNEL) {
        browser_history["a" /* browserHistory */].replace(`/error?type=${constants["i" /* ErrorPageTypes */].PERMALINK_NOT_FOUND}&returnTo=${returnTo}`);
        return;
      }

      await dispatch(Object(actions_channels["joinChannel"])(Object(entities_users["getCurrentUserId"])(getState()), null, channelId));
    }

    if (channel.team_id && channel.team_id !== teamId) {
      browser_history["a" /* browserHistory */].replace(`/error?type=${constants["i" /* ErrorPageTypes */].PERMALINK_NOT_FOUND}&returnTo=${returnTo}`);
      return;
    }

    if (channel && channel.type === constants["g" /* Constants */].DM_CHANNEL) {
      Object(user_actions["d" /* loadNewDMIfNeeded */])(channel.id);
    } else if (channel && channel.type === constants["g" /* Constants */].GM_CHANNEL) {
      Object(user_actions["e" /* loadNewGMIfNeeded */])(channel.id);
    }

    dispatch(Object(actions_channels["selectChannel"])(channelId));
    dispatch({
      type: constants["b" /* ActionTypes */].RECEIVED_FOCUSED_POST,
      data: postId,
      channelId
    });
    dispatch(Object(channel_actions["d" /* loadChannelsForCurrentUser */])());
    dispatch(Object(actions_channels["getChannelStats"])(channelId));
  };
}
// EXTERNAL MODULE: ./node_modules/bootstrap/dist/js/npm.js
var npm = __webpack_require__(2187);

// CONCATENATED MODULE: ./components/edit_channel_header_modal/edit_channel_header_modal.jsx
function edit_channel_header_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const edit_channel_header_modal_KeyCodes = constants["N" /* default */].KeyCodes;
const edit_channel_header_modal_holders = Object(index_es["g" /* defineMessages */])({
  error: {
    id: Object(i18n["b" /* t */])('edit_channel_header_modal.error'),
    defaultMessage: 'This channel header is too long, please enter a shorter one'
  }
});

class edit_channel_header_modal_EditChannelHeaderModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    edit_channel_header_modal_defineProperty(this, "handleChange", e => {
      this.setState({
        header: e.target.value
      });
    });

    edit_channel_header_modal_defineProperty(this, "handleSave", () => {
      const {
        channel,
        actions: {
          patchChannel
        }
      } = this.props;
      const {
        header
      } = this.state;
      patchChannel(channel.id, {
        header
      });
    });

    edit_channel_header_modal_defineProperty(this, "onHide", () => {
      this.setState({
        show: false
      });
    });

    edit_channel_header_modal_defineProperty(this, "focusTextbox", () => {
      if (this.refs.editChannelHeaderTextbox) {
        this.refs.editChannelHeaderTextbox.getWrappedInstance().focus();
      }
    });

    edit_channel_header_modal_defineProperty(this, "blurTextbox", () => {
      if (this.refs.editChannelHeaderTextbox) {
        this.refs.editChannelHeaderTextbox.getWrappedInstance().blur();
      }
    });

    edit_channel_header_modal_defineProperty(this, "handleEntering", () => {
      this.focusTextbox();
    });

    edit_channel_header_modal_defineProperty(this, "handleKeyDown", e => {
      const {
        ctrlSend
      } = this.props;

      if (ctrlSend && Object(utils["V" /* isKeyPressed */])(e, edit_channel_header_modal_KeyCodes.ENTER) && e.ctrlKey === true) {
        this.handleKeyPress(e);
      }
    });

    edit_channel_header_modal_defineProperty(this, "handleKeyPress", e => {
      const {
        ctrlSend
      } = this.props;

      if (!Object(user_agent["m" /* isMobile */])() && (ctrlSend && e.ctrlKey || !ctrlSend)) {
        if (Object(utils["V" /* isKeyPressed */])(e, edit_channel_header_modal_KeyCodes.ENTER) && !e.shiftKey && !e.altKey) {
          e.preventDefault();
          this.blurTextbox();
          this.handleSave(e);
        }
      }
    });

    this.state = {
      header: props.channel.header,
      show: true,
      showError: false
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    const {
      requestStatus: nextRequestStatus
    } = nextProps;
    const {
      requestStatus
    } = this.props;

    if (requestStatus !== nextRequestStatus && nextRequestStatus === mattermost_redux_constants["RequestStatus"].FAILURE) {
      this.setState({
        showError: true
      });
    } else if (requestStatus !== nextRequestStatus && nextRequestStatus === mattermost_redux_constants["RequestStatus"].SUCCESS) {
      this.onHide();
    } else {
      this.setState({
        showError: false
      });
    }
  }

  render() {
    let serverError = null;

    if (this.props.serverError && this.state.showError) {
      let errorMsg;

      if (this.props.serverError.server_error_id === 'model.channel.is_valid.header.app_error') {
        errorMsg = this.props.intl.formatMessage(edit_channel_header_modal_holders.error);
      } else {
        errorMsg = this.props.serverError.message;
      }

      serverError = react_default.a.createElement("div", {
        className: "form-group has-error"
      }, react_default.a.createElement("br", null), react_default.a.createElement("label", {
        className: "control-label"
      }, errorMsg));
    }

    let headerTitle = null;

    if (this.props.channel.type === constants["N" /* default */].DM_CHANNEL) {
      headerTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "edit_channel_header_modal.title_dm",
        defaultMessage: "Edit Header"
      });
    } else {
      headerTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "edit_channel_header_modal.title",
        defaultMessage: "Edit Header for {channel}",
        values: {
          channel: this.props.channel.display_name
        }
      });
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      show: this.state.show,
      onHide: this.onHide,
      onEntering: this.handleEntering,
      onExited: this.props.onHide,
      role: "dialog",
      "aria-labelledby": "editChannelHeaderModalLabel",
      backdrop: false
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "editChannelHeaderModalLabel"
    }, headerTitle)), react_default.a.createElement(Modal["a" /* default */].Body, {
      bsClass: "modal-body edit-modal-body"
    }, react_default.a.createElement("div", null, react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "edit_channel_header_modal.description",
      defaultMessage: "Edit the text appearing next to the channel name in the channel header."
    })), react_default.a.createElement(components_textbox, {
      value: this.state.header,
      onChange: this.handleChange,
      onKeyPress: this.handleKeyPress,
      onKeyDown: this.handleKeyDown,
      supportsCommands: false,
      suggestionListStyle: "bottom",
      createMessage: Object(utils["gb" /* localizeMessage */])('edit_channel_header.editHeader', 'Edit the Channel Header...'),
      previewMessageLink: Object(utils["gb" /* localizeMessage */])('edit_channel_header.previewHeader', 'Edit Header'),
      handlePostError: this.handlePostError,
      id: "edit_textbox",
      ref: "editChannelHeaderTextbox",
      characterLimit: 1024
    }), react_default.a.createElement("br", null), serverError)), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-link cancel-button",
      onClick: this.onHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "edit_channel_header_modal.cancel",
      defaultMessage: "Cancel"
    })), react_default.a.createElement("button", {
      disabled: this.props.requestStatus === mattermost_redux_constants["RequestStatus"].STARTED,
      type: "button",
      className: "btn btn-primary save-button",
      onClick: this.handleSave
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "edit_channel_header_modal.save",
      defaultMessage: "Save"
    }))));
  }

}

edit_channel_header_modal_defineProperty(edit_channel_header_modal_EditChannelHeaderModal, "propTypes", {
  /*
   * react-intl helper object
   */
  intl: index_es["i" /* intlShape */].isRequired,

  /*
   * callback to call when modal will hide
   */
  onHide: prop_types_default.a.func.isRequired,

  /*
   * Object with info about current channel ,
   */
  channel: prop_types_default.a.object.isRequired,

  /*
   * boolean should be `ctrl` button pressed to send
   */
  ctrlSend: prop_types_default.a.bool.isRequired,

  /*
   * object with info about server error
   */
  serverError: prop_types_default.a.object,

  /*
   * string with info about about request
   */
  requestStatus: prop_types_default.a.string.isRequired,

  /*
   * Collection of redux actions
   */
  actions: prop_types_default.a.shape({
    /*
     * patch channel redux-action
     */
    patchChannel: prop_types_default.a.func.isRequired
  }).isRequired
});

/* harmony default export */ var edit_channel_header_modal = (Object(index_es["h" /* injectIntl */])(edit_channel_header_modal_EditChannelHeaderModal));
// CONCATENATED MODULE: ./components/edit_channel_header_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const edit_channel_header_modal_mapStateToProps = Object(reselect_es["a" /* createSelector */])(state => Object(entities_preferences["getBool"])(state, constants["N" /* default */].Preferences.CATEGORY_ADVANCED_SETTINGS, 'send_on_ctrl_enter'), ({
  requests
}) => {
  const {
    channels: {
      updateChannel
    }
  } = requests;
  return {
    serverError: updateChannel.error,
    requestStatus: updateChannel.status
  };
}, (ctrlSend, submitInfo) => ({
  ctrlSend,
  ...submitInfo
}));

function edit_channel_header_modal_mapDispatchToProps(dispatch) {
  return {
    actions: {
      patchChannel: Object(redux["bindActionCreators"])(actions_channels["patchChannel"], dispatch)
    }
  };
}

/* harmony default export */ var components_edit_channel_header_modal = (Object(es["connect"])(edit_channel_header_modal_mapStateToProps, edit_channel_header_modal_mapDispatchToProps)(edit_channel_header_modal));
// EXTERNAL MODULE: ./components/channel_new_invite_modal/index.js + 1 modules
var channel_new_invite_modal = __webpack_require__(1687);

// CONCATENATED MODULE: ./components/channel_members_dropdown/channel_members_dropdown.jsx
function channel_members_dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









const channel_members_dropdown_ROWS_FROM_BOTTOM_TO_OPEN_UP = 3;
class channel_members_dropdown_ChannelMembersDropdown extends react_default.a.Component {
  constructor(props) {
    super(props);

    channel_members_dropdown_defineProperty(this, "handleRemoveFromChannel", () => {
      if (this.state.removing) {
        return;
      }

      const {
        actions,
        channel,
        user
      } = this.props;
      this.setState({
        removing: true
      });
      actions.removeChannelMember(channel.id, user.id).then(result => {
        if (result.error) {
          this.setState({
            serverError: result.error.message,
            removing: false
          });
          return;
        }

        this.setState({
          removing: false
        });
        actions.getChannelStats(channel.id);
      });
    });

    channel_members_dropdown_defineProperty(this, "handleMakeChannelMember", async () => {
      const {
        error
      } = await this.props.actions.updateChannelMemberSchemeRoles(this.props.channel.id, this.props.user.id, true, false);

      if (error) {
        this.setState({
          serverError: error.message
        });
      } else {
        this.props.actions.getChannelStats(this.props.channel.id);
      }
    });

    channel_members_dropdown_defineProperty(this, "handleMakeChannelAdmin", async () => {
      const {
        error
      } = await this.props.actions.updateChannelMemberSchemeRoles(this.props.channel.id, this.props.user.id, true, true);

      if (error) {
        this.setState({
          serverError: error.message
        });
      } else {
        this.props.actions.getChannelStats(this.props.channel.id);
      }
    });

    this.state = {
      serverError: null,
      removing: false
    };
  }

  renderRole(isChannelAdmin) {
    if (isChannelAdmin) {
      return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_members_dropdown.channel_admin",
        defaultMessage: "Channel Admin"
      });
    }

    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_members_dropdown.channel_member",
      defaultMessage: "Channel Member"
    });
  }

  render() {
    const supportsChannelAdmin = this.props.isLicensed;
    const isChannelAdmin = supportsChannelAdmin && (utils["N" /* isChannelAdmin */](this.props.isLicensed, this.props.channelMember.roles) || this.props.channelMember.scheme_admin);
    let serverError = null;

    if (this.state.serverError) {
      serverError = react_default.a.createElement("div", {
        className: "has-error"
      }, react_default.a.createElement("label", {
        className: "has-error control-label"
      }, this.state.serverError));
    }

    if (this.props.user.id === this.props.currentUserId) {
      return null;
    }

    if (this.props.canChangeMemberRoles) {
      const role = this.renderRole(isChannelAdmin);
      const canRemoveFromChannel = this.props.canRemoveMember && this.props.channel.name !== constants["g" /* Constants */].DEFAULT_CHANNEL && !this.props.channel.group_constrained;
      const canMakeChannelMember = isChannelAdmin;
      const canMakeChannelAdmin = supportsChannelAdmin && !isChannelAdmin;

      if (canMakeChannelMember || canMakeChannelAdmin) {
        const {
          index,
          totalUsers
        } = this.props;
        let openUp = false;

        if (totalUsers > channel_members_dropdown_ROWS_FROM_BOTTOM_TO_OPEN_UP && totalUsers - index <= channel_members_dropdown_ROWS_FROM_BOTTOM_TO_OPEN_UP) {
          openUp = true;
        }

        return react_default.a.createElement(menu_wrapper["a" /* default */], null, react_default.a.createElement("button", {
          className: "dropdown-toggle theme color--link style--none",
          type: "button"
        }, react_default.a.createElement("span", null, role, " "), react_default.a.createElement(dropdown_icon_DropdownIcon, null)), react_default.a.createElement(menu_menu["a" /* default */], {
          openLeft: true,
          openUp: openUp,
          ariaLabel: utils["gb" /* localizeMessage */]('channel_members_dropdown.menuAriaLabel', 'Channel member role change')
        }, react_default.a.createElement(menu_item_action["a" /* default */], {
          show: canMakeChannelMember,
          onClick: this.handleMakeChannelMember,
          text: utils["gb" /* localizeMessage */]('channel_members_dropdown.make_channel_member', 'Make Channel Member')
        }), react_default.a.createElement(menu_item_action["a" /* default */], {
          show: canMakeChannelAdmin,
          onClick: this.handleMakeChannelAdmin,
          text: utils["gb" /* localizeMessage */]('channel_members_dropdown.make_channel_admin', 'Make Channel Admin')
        }), react_default.a.createElement(menu_item_action["a" /* default */], {
          show: canRemoveFromChannel,
          onClick: this.handleRemoveFromChannel,
          text: utils["gb" /* localizeMessage */]('channel_members_dropdown.remove_from_channel', 'Remove From Channel')
        }), serverError));
      }
    }

    if (this.props.canRemoveMember && this.props.channel.name !== constants["g" /* Constants */].DEFAULT_CHANNEL && !this.props.channel.group_constrained) {
      return react_default.a.createElement("button", {
        id: "removeMember",
        type: "button",
        className: "btn btn-danger btn-message",
        onClick: this.handleRemoveFromChannel,
        disabled: this.state.removing
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_members_dropdown.remove_member",
        defaultMessage: "Remove Member"
      }));
    }

    if (this.props.channel.name === constants["g" /* Constants */].DEFAULT_CHANNEL) {
      return react_default.a.createElement("div", null);
    }

    return react_default.a.createElement("div", null, this.renderRole(isChannelAdmin));
  }

}

channel_members_dropdown_defineProperty(channel_members_dropdown_ChannelMembersDropdown, "propTypes", {
  channel: prop_types_default.a.object.isRequired,
  user: prop_types_default.a.object.isRequired,
  currentUserId: prop_types_default.a.string.isRequired,
  channelMember: prop_types_default.a.object.isRequired,
  isLicensed: prop_types_default.a.bool.isRequired,
  canChangeMemberRoles: prop_types_default.a.bool.isRequired,
  canRemoveMember: prop_types_default.a.bool.isRequired,
  index: prop_types_default.a.number.isRequired,
  totalUsers: prop_types_default.a.number.isRequired,
  actions: prop_types_default.a.shape({
    getChannelStats: prop_types_default.a.func.isRequired,
    updateChannelMemberSchemeRoles: prop_types_default.a.func.isRequired,
    removeChannelMember: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_members_dropdown/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function channel_members_dropdown_mapStateToProps(state, ownProps) {
  const {
    channel
  } = ownProps;
  const canChangeMemberRoles = Object(roles["haveIChannelPermission"])(state, {
    channel: channel.id,
    team: channel.team_id,
    permission: mattermost_redux_constants["Permissions"].MANAGE_CHANNEL_ROLES
  });
  const license = Object(general["getLicense"])(state);
  const isLicensed = license.IsLicensed === 'true';
  const canRemoveMember = Object(utils_channel_utils["a" /* canManageMembers */])(channel);
  return {
    currentUserId: Object(entities_users["getCurrentUserId"])(state),
    isLicensed,
    canChangeMemberRoles,
    canRemoveMember
  };
}

function channel_members_dropdown_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      getChannelStats: actions_channels["getChannelStats"],
      updateChannelMemberSchemeRoles: actions_channels["updateChannelMemberSchemeRoles"],
      removeChannelMember: actions_channels["removeChannelMember"]
    }, dispatch)
  };
}

/* harmony default export */ var channel_members_dropdown = (Object(es["connect"])(channel_members_dropdown_mapStateToProps, channel_members_dropdown_mapDispatchToProps)(channel_members_dropdown_ChannelMembersDropdown));
// CONCATENATED MODULE: ./components/member_list_channel/member_list_channel.jsx
function member_list_channel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const member_list_channel_USERS_PER_PAGE = 50;
class member_list_channel_MemberListChannel extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    member_list_channel_defineProperty(this, "loadComplete", () => {
      this.setState({
        loading: false
      });
    });

    member_list_channel_defineProperty(this, "nextPage", page => {
      this.props.actions.loadProfilesAndTeamMembersAndChannelMembers(page + 1, member_list_channel_USERS_PER_PAGE);
    });

    member_list_channel_defineProperty(this, "handleSearch", term => {
      this.props.actions.setModalSearchTerm(term);
    });

    this.searchTimeoutId = 0;
    this.state = {
      loading: true
    };
  }

  componentDidMount() {
    const {
      actions,
      currentChannelId,
      currentTeamId
    } = this.props;
    actions.loadProfilesAndTeamMembersAndChannelMembers(0, constants["N" /* default */].PROFILE_CHUNK_SIZE, currentTeamId, currentChannelId).then(({
      data
    }) => {
      if (data) {
        this.loadComplete();
      }
    });
    actions.getChannelStats(currentChannelId);
  }

  componentWillUnmount() {
    this.props.actions.setModalSearchTerm('');
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.searchTerm !== nextProps.searchTerm) {
      clearTimeout(this.searchTimeoutId);
      const searchTerm = nextProps.searchTerm;

      if (searchTerm === '') {
        this.loadComplete();
        this.searchTimeoutId = '';
        return;
      }

      const searchTimeoutId = setTimeout(async () => {
        const {
          data
        } = await this.props.actions.searchProfiles(searchTerm, {
          team_id: nextProps.currentTeamId,
          in_channel_id: nextProps.currentChannelId
        });

        if (searchTimeoutId !== this.searchTimeoutId) {
          return;
        }

        this.setState({
          loading: true
        });
        nextProps.actions.loadStatusesForProfilesList(data);
        nextProps.actions.loadTeamMembersAndChannelMembersForProfilesList(data, nextProps.currentTeamId, nextProps.currentChannelId).then(({
          data: membersLoaded
        }) => {
          if (membersLoaded) {
            this.loadComplete();
          }
        });
      }, constants["N" /* default */].SEARCH_TIMEOUT_MILLISECONDS);
      this.searchTimeoutId = searchTimeoutId;
    }
  }

  render() {
    const channelIsArchived = this.props.channel.delete_at !== 0;
    return react_default.a.createElement(searchable_user_list_container_SearchableUserListContainer, {
      users: this.props.usersToDisplay,
      usersPerPage: member_list_channel_USERS_PER_PAGE,
      total: this.props.totalChannelMembers,
      nextPage: this.nextPage,
      search: this.handleSearch,
      actions: channelIsArchived ? [] : [channel_members_dropdown],
      actionUserProps: this.props.actionUserProps,
      focusOnMount: !user_agent["m" /* isMobile */]()
    });
  }

}

member_list_channel_defineProperty(member_list_channel_MemberListChannel, "propTypes", {
  currentTeamId: prop_types_default.a.string.isRequired,
  currentChannelId: prop_types_default.a.string.isRequired,
  searchTerm: prop_types_default.a.string.isRequired,
  usersToDisplay: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,
  actionUserProps: prop_types_default.a.object.isRequired,
  totalChannelMembers: prop_types_default.a.number.isRequired,
  channel: prop_types_default.a.object.isRequired,
  actions: prop_types_default.a.shape({
    searchProfiles: prop_types_default.a.func.isRequired,
    getChannelStats: prop_types_default.a.func.isRequired,
    setModalSearchTerm: prop_types_default.a.func.isRequired,
    loadProfilesAndTeamMembersAndChannelMembers: prop_types_default.a.func.isRequired,
    loadStatusesForProfilesList: prop_types_default.a.func.isRequired,
    loadTeamMembersAndChannelMembersForProfilesList: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/member_list_channel/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













const getUsersAndActionsToDisplay = Object(reselect_es["a" /* createSelector */])((state, users) => users, entities_teams["getMembersInCurrentTeam"], entities_channels["getMembersInCurrentChannel"], entities_channels["getCurrentChannel"], (users = [], teamMembers = {}, channelMembers = {}, channel = {}) => {
  const actionUserProps = {};
  const usersToDisplay = [];

  for (let i = 0; i < users.length; i++) {
    const user = users[i];

    if (teamMembers[user.id] && channelMembers[user.id] && user.delete_at === 0) {
      usersToDisplay.push(user);
      actionUserProps[user.id] = {
        channel,
        teamMember: teamMembers[user.id],
        channelMember: channelMembers[user.id]
      };
    }
  }

  return {
    usersToDisplay: usersToDisplay.sort(user_utils["sortByUsername"]),
    actionUserProps
  };
});

function member_list_channel_mapStateToProps(state) {
  const searchTerm = state.views.search.modalSearch;
  let users;

  if (searchTerm) {
    users = Object(entities_users["searchProfilesInCurrentChannel"])(state, searchTerm);
  } else {
    users = Object(entities_users["getProfilesInCurrentChannel"])(state);
  }

  const stats = Object(entities_channels["getCurrentChannelStats"])(state) || {
    member_count: 0
  };
  return { ...getUsersAndActionsToDisplay(state, users),
    currentTeamId: state.entities.teams.currentTeamId,
    currentChannelId: state.entities.channels.currentChannelId,
    searchTerm,
    totalChannelMembers: stats.member_count
  };
}

function member_list_channel_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      searchProfiles: actions_users["searchProfiles"],
      getChannelStats: actions_channels["getChannelStats"],
      setModalSearchTerm: views_search["a" /* setModalSearchTerm */],
      loadProfilesAndTeamMembersAndChannelMembers: user_actions["g" /* loadProfilesAndTeamMembersAndChannelMembers */],
      loadStatusesForProfilesList: status_actions["b" /* loadStatusesForProfilesList */],
      loadTeamMembersAndChannelMembersForProfilesList: user_actions["k" /* loadTeamMembersAndChannelMembersForProfilesList */]
    }, dispatch)
  };
}

/* harmony default export */ var member_list_channel = (Object(es["connect"])(member_list_channel_mapStateToProps, member_list_channel_mapDispatchToProps)(member_list_channel_MemberListChannel));
// CONCATENATED MODULE: ./components/channel_members_modal/channel_members_modal.jsx
function channel_members_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class channel_members_modal_ChannelMembersModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    channel_members_modal_defineProperty(this, "handleHide", () => {
      this.setState({
        show: false
      });
    });

    channel_members_modal_defineProperty(this, "handleExit", () => {
      this.props.onHide();
    });

    channel_members_modal_defineProperty(this, "onAddNewMembersButton", () => {
      const {
        channel,
        actions
      } = this.props;
      actions.openModal({
        modalId: constants["p" /* ModalIdentifiers */].CHANNEL_INVITE,
        dialogType: channel_new_invite_modal["a" /* default */],
        dialogProps: {
          channel
        }
      });
      this.handleExit();
    });

    this.state = {
      show: true
    };
  }

  render() {
    const channelIsArchived = this.props.channel.delete_at !== 0;
    return react_default.a.createElement("div", null, react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "more-modal more-modal--action",
      show: this.state.show,
      onHide: this.handleHide,
      onExited: this.handleExit,
      role: "dialog",
      "aria-labelledby": "channelMembersModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "channelMembersModalLabel"
    }, react_default.a.createElement("span", {
      className: "name"
    }, this.props.channel.display_name), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_members_modal.members",
      defaultMessage: " Members"
    })), this.props.canManageChannelMembers && !channelIsArchived && react_default.a.createElement("a", {
      id: "showInviteModal",
      className: "btn btn-md btn-primary",
      href: "#",
      onClick: this.onAddNewMembersButton
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_members_modal.addNew",
      defaultMessage: " Add New Members"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement(member_list_channel, {
      channel: this.props.channel
    }))));
  }

}

channel_members_modal_defineProperty(channel_members_modal_ChannelMembersModal, "propTypes", {
  /**
   * Bool whether user has permission to manage current channel
   */
  canManageChannelMembers: prop_types_default.a.bool.isRequired,

  /**
   * Object with info about current channel
   */
  channel: prop_types_default.a.object.isRequired,

  /**
   * Function that is called when modal is hidden
   */
  onHide: prop_types_default.a.func.isRequired,
  actions: prop_types_default.a.shape({
    openModal: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_members_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const channel_members_modal_mapStateToProps = state => ({
  canManageChannelMembers: Object(entities_channels["canManageChannelMembers"])(state)
});

const channel_members_modal_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    openModal: modals["b" /* openModal */]
  }, dispatch)
});

/* harmony default export */ var channel_members_modal = (Object(es["connect"])(channel_members_modal_mapStateToProps, channel_members_modal_mapDispatchToProps)(channel_members_modal_ChannelMembersModal));
// CONCATENATED MODULE: ./components/svg/member_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class member_icon_MemberIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.member",
      defaultMessage: "Member Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "14px",
      height: "14px",
      viewBox: "0 0 16 16",
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", {
      id: "Symbols",
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react_default.a.createElement("g", {
      id: "Channel-Header/Web-HD",
      transform: "translate(-725.000000, -32.000000)",
      fillRule: "nonzero",
      fill: "inherit"
    }, react_default.a.createElement("g", {
      id: "Channel-Header"
    }, react_default.a.createElement("g", {
      id: "user-count",
      transform: "translate(676.000000, 22.000000)"
    }, react_default.a.createElement("path", {
      d: "M64.9481342,24 C64.6981342,20.955 63.2551342,19.076 60.6731342,18.354 C61.4831342,17.466 61.9881342,16.296 61.9881342,15 C61.9881342,12.238 59.7501342,10 56.9881342,10 C54.2261342,10 51.9881342,12.238 51.9881342,15 C51.9881342,16.297 52.4941342,17.467 53.3031342,18.354 C50.7221342,19.076 49.2771342,20.955 49.0271342,24 C49.0161342,24.146 49.0061342,24.577 49.0001342,25.001 C48.9911342,25.553 49.4361342,26 49.9881342,26 L63.9881342,26 C64.5411342,26 64.9851342,25.553 64.9761342,25.001 C64.9701342,24.577 64.9601342,24.146 64.9481342,24 Z M56.9881342,12 C58.6421342,12 59.9881342,13.346 59.9881342,15 C59.9881342,16.654 58.6421342,18 56.9881342,18 C55.3341342,18 53.9881342,16.654 53.9881342,15 C53.9881342,13.346 55.3341342,12 56.9881342,12 Z M51.0321342,24 C51.2981342,21.174 52.7911342,20 55.9881342,20 L57.9881342,20 C61.1851342,20 62.6781342,21.174 62.9441342,24 L51.0321342,24 Z",
      id: "User_4_x2C__Profile_5-Copy-9"
    }))))))));
  }

}
// CONCATENATED MODULE: ./components/svg/message_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class message_icon_MessageIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.message",
      defaultMessage: "Message Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "18px",
      height: "16px",
      viewBox: "0 0 18 16",
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react_default.a.createElement("g", {
      transform: "translate(-200.000000, -174.000000)",
      fill: "inherit"
    }, react_default.a.createElement("g", {
      transform: "translate(200.000000, 174.000000)"
    }, react_default.a.createElement("path", {
      d: "M7.2546625,1.42801356 C10.458475,1.42801356 12.999475,3.24528136 12.999475,5.52023729 C12.9895,8.04188475 10.6062625,9.89326102 7.40245,9.89326102 C7.40245,9.89326102 6.9134125,9.91229831 6.4115125,9.83747119 L5.82535,9.79622373 L5.15335,10.3586169 C4.997425,10.5397356 4.3199125,11.1095322 3.736375,11.4794373 C4.0915375,10.4598847 4.07605,10.1370441 4.07605,10.1370441 L4.1251375,9.49004068 L3.55315,9.19549153 C2.0986375,8.44616271 1.4444875,6.88616271 1.4444875,5.52023729 C1.4444875,3.24528136 4.05085,1.42801356 7.2546625,1.42801356 M7.2546625,0.370386441 C3.465475,0.370386441 0.3944875,2.65829831 0.3944875,5.52023729 C0.3944875,7.3028678 1.2623125,9.20342373 3.0751375,10.1370441 C3.0751375,10.1478847 3.07225,10.1560814 3.07225,10.1679797 C3.07225,10.9426915 2.43175,12.0048136 2.1794875,12.4429356 L2.1805375,12.4429356 C2.1605875,12.4902644 2.148775,12.5420881 2.148775,12.5973492 C2.148775,12.8141627 2.322025,12.9881424 2.5375375,12.9881424 C2.5693,12.9881424 2.6210125,12.9815322 2.6393875,12.9815322 C2.6446375,12.9815322 2.6467375,12.9815322 2.6462125,12.9831186 C3.986275,12.762339 5.9642125,11.2435864 6.2576875,10.8837288 C6.5585125,10.928678 6.761425,10.9358169 7.0136875,10.9358169 C7.120525,10.9358169 7.2347125,10.9342305 7.3696375,10.9342305 C11.1583,10.9342305 14.094625,8.75446102 14.049475,5.52023729 C14.049475,2.65829831 11.0435875,0.370386441 7.2546625,0.370386441"
    }), react_default.a.createElement("path", {
      d: "M17.2055125,9.79172881 C17.2055125,8.35811525 16.6498,7.26532203 15.2624875,6.4451322 C15.228625,6.82614237 15.120475,7.23517966 15.0031375,7.59477288 C15.8998375,8.21903729 16.1555125,8.85995932 16.1555125,9.79172881 C16.1555125,10.9323797 15.62815,11.7597085 14.40175,12.3919051 L13.879375,12.653139 C13.879375,12.653139 13.9337125,14.0082237 14.0140375,14.3511593 C12.9895,13.5946915 12.6374875,12.9630237 12.6374875,12.9630237 L12.08545,13.0486915 C11.86705,13.0809492 11.276425,13.0812136 11.276425,13.0812136 C9.85,13.0812136 8.7929125,12.7388068 7.8909625,12.0278169 C8.135875,12.0124814 6.42805,12.0132746 6.3899875,12.0468542 C7.4326375,13.3297559 9.1373125,14.1388407 11.276425,14.1388407 C11.3927125,14.1388407 11.49115,14.1398983 11.58355,14.1398983 C11.801425,14.1398983 11.9773,14.1338169 12.237175,14.095478 C12.491275,14.4058915 13.914025,15.7728746 15.0724375,15.9629831 C15.0719125,15.9619254 15.073225,15.9619254 15.078475,15.9619254 C15.0939625,15.9619254 15.13885,15.967478 15.16615,15.967478 C15.3522625,15.967478 15.5024125,15.8167661 15.5024125,15.6293017 C15.5024125,15.5817085 15.49165,15.5367593 15.47485,15.4960407 L15.4759,15.4960407 C15.258025,15.117939 14.9159875,14.0129831 14.9159875,13.3435051 C14.9159875,13.3331932 14.9128375,13.3260542 14.9128375,13.3168 C16.4797,12.5095661 17.2055125,11.3321627 17.2055125,9.79172881"
    })))))));
  }

}
// CONCATENATED MODULE: ./components/popover_list_members/popover_list_members_item.jsx
function popover_list_members_item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class popover_list_members_item_PopoverListMembersItem extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    popover_list_members_item_defineProperty(this, "handleClick", () => {
      this.props.onItemClick(this.props.user);
    });
  }

  render() {
    if (!this.props.user) {
      return null;
    }

    const name = utils["w" /* getDisplayNameByUser */](this.props.user);

    if (!name) {
      return null;
    }

    let messageIcon;

    if (this.props.showMessageIcon) {
      messageIcon = react_default.a.createElement(message_icon_MessageIcon, {
        className: "icon icon__message",
        "aria-hidden": "true"
      });
    }

    const botClass = this.props.user.is_bot ? ' more-modal__row--bot' : '';
    const status = this.props.user.is_bot ? null : this.props.status;
    return react_default.a.createElement("div", {
      className: 'more-modal__row' + botClass,
      onClick: this.handleClick
    }, react_default.a.createElement(profile_picture["a" /* default */], {
      src: client["Client4"].getProfilePictureUrl(this.props.user.id, this.props.user.last_picture_update),
      status: status,
      width: "32",
      height: "32"
    }), react_default.a.createElement("div", {
      className: "more-modal__details d-flex whitespace--nowrap"
    }, react_default.a.createElement("div", {
      className: "more-modal__name"
    }, name), react_default.a.createElement(bot_badge["a" /* default */], {
      show: Boolean(this.props.user.is_bot),
      className: "badge-popoverlist"
    })), react_default.a.createElement("div", {
      className: "more-modal__actions"
    }, messageIcon));
  }

}

popover_list_members_item_defineProperty(popover_list_members_item_PopoverListMembersItem, "propTypes", {
  showMessageIcon: prop_types_default.a.bool.isRequired,
  onItemClick: prop_types_default.a.func.isRequired,
  status: prop_types_default.a.string.isRequired,
  user: prop_types_default.a.object.isRequired
});

popover_list_members_item_defineProperty(popover_list_members_item_PopoverListMembersItem, "defaultProps", {
  status: constants["L" /* UserStatuses */].OFFLINE
});
// CONCATENATED MODULE: ./components/popover_list_members/popover_list_members.jsx
function popover_list_members_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.














class popover_list_members_PopoverListMembers extends react_default.a.Component {
  constructor(props) {
    super(props);

    popover_list_members_defineProperty(this, "sortUsers", (users, statuses) => {
      return utils["pb" /* sortUsersByStatusAndDisplayName */](users, statuses);
    });

    popover_list_members_defineProperty(this, "handleShowDirectChannel", user => {
      const {
        actions
      } = this.props;
      const teammateId = user.id;

      if (teammateId) {
        actions.openDirectChannelToUserId(teammateId).then(({
          data
        }) => {
          if (data) {
            browser_history["a" /* browserHistory */].push(this.props.teamUrl + "/channels/" + data.name);
          }

          this.closePopover();
        });
      }
    });

    popover_list_members_defineProperty(this, "closePopover", () => {
      this.setState({
        showPopover: false
      });
    });

    popover_list_members_defineProperty(this, "showMembersModal", e => {
      e.preventDefault();
      this.setState({
        showPopover: false,
        showChannelMembersModal: true
      });
    });

    popover_list_members_defineProperty(this, "hideChannelMembersModal", () => {
      this.setState({
        showChannelMembersModal: false
      });
    });

    popover_list_members_defineProperty(this, "showChannelInviteModal", () => {
      this.setState({
        showChannelInviteModal: true
      });
    });

    popover_list_members_defineProperty(this, "hideChannelInviteModal", () => {
      this.setState({
        showChannelInviteModal: false
      });
    });

    popover_list_members_defineProperty(this, "hideTeamMembersModal", () => {
      this.setState({
        showTeamMembersModal: false
      });
    });

    popover_list_members_defineProperty(this, "handleGetProfilesInChannel", e => {
      this.setState({
        popoverTarget: e.target,
        showPopover: !this.state.showPopover
      });
      this.props.actions.getProfilesInChannel(this.props.channel.id, 0, undefined, "status"); // eslint-disable-line no-undefined
    });

    popover_list_members_defineProperty(this, "getTargetPopover", () => {
      return this.state.popoverTarget;
    });

    this.state = {
      showPopover: false,
      showTeamMembersModal: false,
      showChannelMembersModal: false,
      showChannelInviteModal: false,
      sortedUsers: this.sortUsers(props.users, props.statuses)
    };
  }

  componentDidUpdate() {
    jquery_default()(".member-list__popover .popover-content .more-modal__body").perfectScrollbar();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.users !== nextProps.users || this.props.statuses !== nextProps.statuses) {
      const sortedUsers = this.sortUsers(nextProps.users, nextProps.statuses);
      this.setState({
        sortedUsers
      });
    }
  }

  render() {
    const isDirectChannel = this.props.channel.type === constants["g" /* Constants */].DM_CHANNEL;
    const items = this.state.sortedUsers.map(user => react_default.a.createElement(popover_list_members_item_PopoverListMembersItem, {
      key: user.id,
      onItemClick: this.handleShowDirectChannel,
      showMessageIcon: this.props.currentUserId !== user.id && !isDirectChannel,
      status: this.props.statuses[user.id],
      user: user
    }));
    const channelIsArchived = this.props.channel.delete_at !== 0;
    let popoverButton;

    if (this.props.channel.type !== constants["g" /* Constants */].GM_CHANNEL && !channelIsArchived) {
      let membersName = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "members_popover.manageMembers",
        defaultMessage: "Manage Members"
      });
      const manageMembers = Object(utils_channel_utils["a" /* canManageMembers */])(this.props.channel);
      const isDefaultChannel = this.props.channel.name === constants["g" /* Constants */].DEFAULT_CHANNEL;

      if (isDefaultChannel || !manageMembers) {
        membersName = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "members_popover.viewMembers",
          defaultMessage: "View Members"
        });
      }

      popoverButton = react_default.a.createElement("div", {
        className: "more-modal__button",
        key: "popover-member-more"
      }, react_default.a.createElement("button", {
        className: "btn btn-link",
        onClick: this.showMembersModal
      }, membersName));
    }

    const count = this.props.memberCount;
    let countText = "-";

    if (count > 0) {
      countText = count.toString();
    }

    const title = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "members_popover.title",
      defaultMessage: "Channel Members"
    });
    let channelMembersModal;

    if (this.state.showChannelMembersModal) {
      channelMembersModal = react_default.a.createElement(channel_members_modal, {
        onHide: this.hideChannelMembersModal,
        showInviteModal: this.showChannelInviteModal,
        channel: this.props.channel
      });
    }

    let teamMembersModal;

    if (this.state.showTeamMembersModal) {
      teamMembersModal = react_default.a.createElement(team_members_modal, {
        onHide: this.hideTeamMembersModal
      });
    }

    let channelInviteModal;

    if (this.state.showChannelInviteModal) {
      channelInviteModal = react_default.a.createElement(channel_new_invite_modal["a" /* default */], {
        onHide: this.hideChannelInviteModal,
        channel: this.props.channel
      });
    }

    const channelMembersTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "channelMembersTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_header.channelMembers",
      defaultMessage: "Members"
    }));
    const ariaLabel = `${utils["gb" /* localizeMessage */]("channel_header.channelMembers", "Members")}`.toLowerCase();
    return react_default.a.createElement("div", {
      id: "channelMember"
    }, react_default.a.createElement(Overlay["a" /* default */], {
      rootClose: true,
      onHide: this.closePopover,
      show: this.state.showPopover,
      target: this.getTargetPopover,
      placement: "bottom"
    }, react_default.a.createElement(Popover["a" /* default */], {
      ref: "memebersPopover",
      className: "member-list__popover",
      id: "member-list-popover"
    }, react_default.a.createElement("div", {
      className: "more-modal__header"
    }, title, this.props.channel.group_constrained && react_default.a.createElement("div", {
      className: "subhead"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_header.groupConstrained",
      defaultMessage: "Members managed by linked groups."
    }))), react_default.a.createElement("div", {
      className: "more-modal__body"
    }, react_default.a.createElement("div", {
      className: "more-modal__list"
    }, items)), popoverButton)), channelMembersModal, teamMembersModal, channelInviteModal);
  }

}

popover_list_members_defineProperty(popover_list_members_PopoverListMembers, "propTypes", {
  channel: prop_types_default.a.object.isRequired,
  statuses: prop_types_default.a.object.isRequired,
  users: prop_types_default.a.array.isRequired,
  memberCount: prop_types_default.a.number,
  currentUserId: prop_types_default.a.string.isRequired,
  teamUrl: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    openModal: prop_types_default.a.func.isRequired,
    getProfilesInChannel: prop_types_default.a.func.isRequired,
    openDirectChannelToUserId: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/popover_list_members/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function popover_list_members_makeMapStateToProps() {
  const doGetProfilesInChannel = Object(entities_users["makeGetProfilesInChannel"])();
  return function mapStateToProps(state, ownProps) {
    const stats = Object(entities_channels["getAllChannelStats"])(state)[ownProps.channel.id] || {};
    const users = doGetProfilesInChannel(state, ownProps.channel.id, true); //console.log('[popover] ownProps.channel.id:', ownProps.channel.id, ', state:', state, ', users:', users);

    return {
      currentUserId: Object(entities_users["getCurrentUserId"])(state),
      memberCount: stats.member_count,
      users,
      statuses: Object(entities_users["getUserStatuses"])(state),
      teamUrl: Object(entities_teams["getCurrentRelativeTeamUrl"])(state)
    };
  };
}

function popover_list_members_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openModal: modals["b" /* openModal */],
      getProfilesInChannel: actions_users["getProfilesInChannel"],
      openDirectChannelToUserId: channel_actions["e" /* openDirectChannelToUserId */]
    }, dispatch)
  };
}

/* harmony default export */ var popover_list_members = (Object(es["connect"])(popover_list_members_makeMapStateToProps, popover_list_members_mapDispatchToProps)(popover_list_members_PopoverListMembers));
// CONCATENATED MODULE: ./components/svg/flag_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class flag_icon_FlagIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.flag",
      defaultMessage: "Flag Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "14px",
      height: "14px",
      viewBox: "0 0 16 16",
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react_default.a.createElement("g", {
      transform: "translate(-1106.000000, -33.000000)",
      fillRule: "nonzero",
      fill: "inherit"
    }, react_default.a.createElement("g", null, react_default.a.createElement("g", {
      transform: "translate(1096.000000, 22.000000)"
    }, react_default.a.createElement("g", {
      transform: "translate(10.000000, 11.000000)"
    }, react_default.a.createElement("path", {
      d: "M8,1 L2,1 C2,0.447 1.553,0 1,0 C0.447,0 0,0.447 0,1 L0,15.5 C0,15.776 0.224,16 0.5,16 L1.5,16 C1.776,16 2,15.776 2,15.5 L2,11 L7,11 L7,12 C7,12.553 7.447,13 8,13 L15,13 C15.553,13 16,12.553 16,12 L16,4 C16,3.447 15.553,3 15,3 L9,3 L9,2 C9,1.447 8.553,1 8,1 Z M9,11 L9,9.5 C9,9.224 8.776,9 8.5,9 L2,9 L2,3 L7,3 L7,4.5 C7,4.776 7.224,5 7.5,5 L14,5 L14,11 L9,11 Z"
    })))))))));
  }

}
// CONCATENATED MODULE: ./components/svg/mentions_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class mentions_icon_MentionsIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.mention",
      defaultMessage: "Mention Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "14px",
      height: "14px",
      viewBox: "0 0 20 20",
      version: "1.1",
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react_default.a.createElement("g", {
      transform: "translate(-1057.000000, -31.000000)",
      fill: "inherit"
    }, react_default.a.createElement("g", null, react_default.a.createElement("g", {
      transform: "translate(1049.000000, 22.000000)"
    }, react_default.a.createElement("path", {
      d: "M17.4296875,15.8867188 C15.9882812,15.8867188 15.1210938,17.0351562 15.1210938,18.96875 C15.1210938,20.8789062 15.9882812,22.0507812 17.4179688,22.0507812 C18.8945312,22.0507812 19.84375,20.8554688 19.84375,18.96875 C19.84375,17.0820312 18.90625,15.8867188 17.4296875,15.8867188 Z M17.8398438,9.125 C23.3242188,9.125 27.25,12.59375 27.25,17.7734375 C27.25,21.5117188 25.5625,23.9609375 22.7734375,23.9609375 C21.4023438,23.9609375 20.265625,23.1992188 20.078125,22.0390625 L19.9609375,22.0390625 C19.46875,23.2226562 18.4140625,23.8789062 17.0429688,23.8789062 C14.6054687,23.8789062 12.9648438,21.8867188 12.9648438,18.9101562 C12.9648438,16.0625 14.6171875,14.09375 16.9960938,14.09375 C18.25,14.09375 19.3632812,14.7382812 19.8085938,15.7460938 L19.9375,15.7460938 L19.9375,14.328125 L21.9179688,14.328125 L21.9179688,20.984375 C21.9179688,21.7578125 22.328125,22.2851562 23.171875,22.2851562 C24.4726562,22.2851562 25.421875,20.6679688 25.421875,17.8320312 C25.421875,13.5664062 22.2929688,10.7421875 17.7109375,10.7421875 C13.1640625,10.7421875 9.90625,14.140625 9.90625,18.96875 C9.90625,24.1367188 13.3515625,27.0429688 18.109375,27.0429688 C19.5625,27.0429688 21.0507812,26.84375 21.7773438,26.5390625 L21.7773438,28.15625 C20.78125,28.484375 19.4570312,28.671875 18.0273438,28.671875 C12.2382812,28.671875 8.078125,25.109375 8.078125,18.8984375 C8.078125,13.0625 12.0859375,9.125 17.8398438,9.125 Z"
    }))))))));
  }

}
// CONCATENATED MODULE: ./components/svg/pin_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class pin_icon_PinIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.pin",
      defaultMessage: "Pin Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "14px",
      height: "14px",
      viewBox: "0 0 16 16",
      version: "1.1",
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", {
      id: "Symbols",
      stroke: "inherit",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react_default.a.createElement("g", {
      transform: "translate(-775.000000, -32.000000)",
      fillRule: "nonzero",
      fill: "inherit"
    }, react_default.a.createElement("g", null, react_default.a.createElement("g", {
      transform: "translate(764.000000, 22.000000)"
    }, react_default.a.createElement("g", {
      transform: "translate(10.000000, 10.000000)"
    }, react_default.a.createElement("path", {
      d: "M16.456,7.291 L9.483,0.25 C9.31,0.078 9.178,0 9.08,0 C8.896,0 8.831,0.276 8.831,0.732 L8.831,3.044 L5.831,5.96 L2.578,6.268 C1.887,6.405 1.668,6.917 2.167,7.41 L4.781,10.011 L3.83,10.961 L1.05,15.511 C0.93,15.761 1.03,15.862 1.28,15.74 L5.83,12.961 L6.786,12.005 L9.359,14.565 C9.556,14.76 9.754,14.854 9.929,14.854 C10.197,14.854 10.413,14.634 10.497,14.219 L10.83,10.961 L13.746,7.961 L16.082,7.961 C16.788,7.961 16.955,7.785 16.456,7.291 Z M12.312,6.567 L9.396,9.567 L8.911,10.065 L8.84,10.757 L8.797,11.184 L5.589,7.992 L6.018,7.952 L6.72,7.886 L7.225,7.396 L10.225,4.48 L10.547,4.167 L12.616,6.256 L12.312,6.567 Z"
    })))))))));
  }

}
// EXTERNAL MODULE: ./components/svg/search_icon.jsx
var search_icon = __webpack_require__(1672);

// CONCATENATED MODULE: ./components/channel_header_dropdown/channel_header_dropdown.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class channel_header_dropdown_ChannelHeaderDropdown extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement(menu_menu["a" /* default */], {
      id: "channelHeaderDropdownMenu",
      ariaLabel: Object(utils["gb" /* localizeMessage */])('channel_header.menuAriaLabel', 'Channel Menu').toLowerCase()
    }, react_default.a.createElement(ChannelHeaderDropdownItems, {
      isMobile: false
    }));
  }

}
// CONCATENATED MODULE: ./plugins/mobile_channel_header_plug/mobile_channel_header_plug.jsx
function mobile_channel_header_plug_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class mobile_channel_header_plug_MobileChannelHeaderPlug extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    mobile_channel_header_plug_defineProperty(this, "createButton", plug => {
      return react_default.a.createElement("li", {
        key: 'mobileChannelHeaderItem' + plug.id,
        role: "presentation",
        className: "MenuItem"
      }, react_default.a.createElement("a", {
        role: "menuitem",
        href: "#",
        onClick: () => this.fireAction(plug)
      }, plug.dropdownText));
    });
  }

  createList(plugs) {
    return plugs.map(this.createButton);
  }

  fireAction(plug) {
    return plug.action(this.props.channel, this.props.channelMember);
  }

  render() {
    const components = this.props.components || [];

    if (components.length === 0) {
      return null;
    } else if (components.length === 1) {
      return this.createButton(components[0]);
    }

    if (!this.props.isDropdown) {
      return null;
    }

    return this.createList(components);
  }

}

mobile_channel_header_plug_defineProperty(mobile_channel_header_plug_MobileChannelHeaderPlug, "propTypes", {
  /*
   * Components or actions to add as channel header buttons
   */
  components: prop_types_default.a.array,

  /*
   * Set to true if the plug is in the dropdown
   */
  isDropdown: prop_types_default.a.bool.isRequired,
  channel: prop_types_default.a.object.isRequired,
  channelMember: prop_types_default.a.object.isRequired,

  /*
   * Logged in user's theme
   */
  theme: prop_types_default.a.object.isRequired
});
// CONCATENATED MODULE: ./plugins/mobile_channel_header_plug/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function mobile_channel_header_plug_mapStateToProps(state) {
  return {
    channelMember: Object(entities_channels["getMyCurrentChannelMembership"])(state),
    components: state.plugins.components.MobileChannelHeaderButton,
    theme: Object(entities_preferences["getTheme"])(state)
  };
}

/* harmony default export */ var mobile_channel_header_plug = (Object(es["connect"])(mobile_channel_header_plug_mapStateToProps)(mobile_channel_header_plug_MobileChannelHeaderPlug));
// CONCATENATED MODULE: ./components/channel_notifications_modal/components/describe.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function Describe({
  section,
  isCollapsed,
  memberNotifyLevel,
  globalNotifyLevel,
  ignoreChannelMentions
}) {
  if (memberNotifyLevel === constants["q" /* NotificationLevels */].DEFAULT && globalNotifyLevel) {
    Object(i18n["b" /* t */])('channel_notifications.levels.default');
    Object(i18n["b" /* t */])('channel_notifications.levels.all');
    Object(i18n["b" /* t */])('channel_notifications.levels.mention');
    Object(i18n["b" /* t */])('channel_notifications.levels.none');
    const levelsFormattedMessageId = 'channel_notifications.levels.' + globalNotifyLevel;
    return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.globalDefault",
      defaultMessage: "Global default"
    }), react_default.a.createElement("span", null, ' ('), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: levelsFormattedMessageId,
      defaultMessage: globalNotifyLevel
    }), react_default.a.createElement("span", null, ')'));
  } else if (memberNotifyLevel === constants["q" /* NotificationLevels */].MENTION && section === constants["r" /* NotificationSections */].MARK_UNREAD) {
    if (isCollapsed) {
      return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_notifications.muteChannel.on.title.collapse",
        defaultMessage: "Mute is enabled. Desktop, email and push notifications will not be sent for this channel."
      });
    }

    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.muteChannel.on.title",
      defaultMessage: "On"
    });
  } else if (section === constants["r" /* NotificationSections */].IGNORE_CHANNEL_MENTIONS && ignoreChannelMentions === constants["l" /* IgnoreChannelMentions */].ON) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.ignoreChannelMentions.on.title",
      defaultMessage: "On"
    });
  } else if (section === constants["r" /* NotificationSections */].IGNORE_CHANNEL_MENTIONS && ignoreChannelMentions === constants["l" /* IgnoreChannelMentions */].OFF) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.ignoreChannelMentions.off.title",
      defaultMessage: "Off"
    });
  } else if (memberNotifyLevel === constants["q" /* NotificationLevels */].MENTION) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.onlyMentions",
      defaultMessage: "Only for mentions"
    });
  } else if ((section === constants["r" /* NotificationSections */].DESKTOP || section === constants["r" /* NotificationSections */].PUSH) && memberNotifyLevel === constants["q" /* NotificationLevels */].ALL) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.allActivity",
      defaultMessage: "For all activity"
    });
  } else if (section === constants["r" /* NotificationSections */].MARK_UNREAD && memberNotifyLevel === constants["q" /* NotificationLevels */].ALL) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.muteChannel.off.title",
      defaultMessage: "Off"
    });
  }

  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "channel_notifications.never",
    defaultMessage: "Never"
  });
}
Describe.propTypes = {
  globalNotifyLevel: prop_types_default.a.string,
  ignoreChannelMentions: prop_types_default.a.string,
  memberNotifyLevel: prop_types_default.a.string.isRequired,
  section: prop_types_default.a.string.isRequired,
  isCollapsed: prop_types_default.a.bool
};
// CONCATENATED MODULE: ./components/channel_notifications_modal/components/section_title.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function SectionTitle({
  section
}) {
  if (section === constants["r" /* NotificationSections */].DESKTOP) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.sendDesktop",
      defaultMessage: "Send desktop notifications"
    });
  } else if (section === constants["r" /* NotificationSections */].PUSH) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.push",
      defaultMessage: "Send mobile push notifications"
    });
  } else if (section === constants["r" /* NotificationSections */].MARK_UNREAD) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.muteChannel.settings",
      defaultMessage: "Mute Channel"
    });
  } else if (section === constants["r" /* NotificationSections */].IGNORE_CHANNEL_MENTIONS) {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.ignoreChannelMentions",
      defaultMessage: "Ignore mentions for @channel, @here and @all"
    });
  }

  return null;
}
SectionTitle.propTypes = {
  section: prop_types_default.a.string.isRequired
};
// CONCATENATED MODULE: ./components/channel_notifications_modal/components/collapse_view.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function CollapseView({
  onExpandSection,
  globalNotifyLevel,
  memberNotifyLevel,
  section,
  ignoreChannelMentions
}) {
  return react_default.a.createElement(setting_item_min["a" /* default */], {
    title: react_default.a.createElement(SectionTitle, {
      section: section
    }),
    describe: react_default.a.createElement(Describe, {
      section: section,
      ignoreChannelMentions: ignoreChannelMentions,
      memberNotifyLevel: memberNotifyLevel,
      globalNotifyLevel: globalNotifyLevel,
      isCollapsed: true
    }),
    updateSection: onExpandSection,
    section: section
  });
}
CollapseView.propTypes = {
  ignoreChannelMentions: prop_types_default.a.string,
  onExpandSection: prop_types_default.a.func.isRequired,
  globalNotifyLevel: prop_types_default.a.string,
  memberNotifyLevel: prop_types_default.a.string.isRequired,
  section: prop_types_default.a.string.isRequired
};
// CONCATENATED MODULE: ./components/channel_notifications_modal/components/extra_info.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function ExtraInfo({
  section
}) {
  switch (section) {
    case constants["r" /* NotificationSections */].DESKTOP:
      return react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_notifications.override",
        defaultMessage: "Selecting an option other than \"Default\" will override the global notification settings. Desktop notifications are available on Firefox, Safari, and Chrome."
      }));

    case constants["r" /* NotificationSections */].PUSH:
      return react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_notifications.overridePush",
        defaultMessage: "Selecting an option other than \"Global default\" will override the global notification settings for mobile push notifications in account settings. Push notifications must be enabled by the System Admin."
      }));

    case constants["r" /* NotificationSections */].MARK_UNREAD:
      return react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_notifications.muteChannel.help",
        defaultMessage: "Muting turns off desktop, email and push notifications for this channel. The channel will not be marked as unread unless you are mentioned."
      }));

    case constants["r" /* NotificationSections */].IGNORE_CHANNEL_MENTIONS:
      return react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_notifications.ignoreChannelMentions.help",
        defaultMessage: "When enabled, @channel, @here and @all will not trigger mentions or mention notifications in this channel."
      }));

    default:
      return null;
  }
}
ExtraInfo.propTypes = {
  section: prop_types_default.a.string.isRequired
};
// CONCATENATED MODULE: ./components/channel_notifications_modal/components/expand_view.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function ExpandView({
  section,
  memberNotifyLevel,
  globalNotifyLevel,
  onChange,
  onSubmit,
  serverError,
  onCollapseSection,
  ignoreChannelMentions
}) {
  const inputs = [react_default.a.createElement("div", {
    key: "channel-notification-level-radio"
  }, (section === constants["r" /* NotificationSections */].DESKTOP || section === constants["r" /* NotificationSections */].PUSH) && react_default.a.createElement("div", null, react_default.a.createElement("div", {
    className: "radio"
  }, react_default.a.createElement("label", {
    className: ""
  }, react_default.a.createElement("input", {
    id: "channelNotificationGlobalDefault",
    type: "radio",
    value: constants["q" /* NotificationLevels */].DEFAULT,
    checked: memberNotifyLevel === constants["q" /* NotificationLevels */].DEFAULT,
    onChange: onChange
  }), react_default.a.createElement(Describe, {
    section: section,
    memberNotifyLevel: constants["q" /* NotificationLevels */].DEFAULT,
    globalNotifyLevel: globalNotifyLevel
  }))), react_default.a.createElement("div", {
    className: "radio"
  }, react_default.a.createElement("label", {
    className: ""
  }, react_default.a.createElement("input", {
    id: "channelNotificationAllActivity",
    type: "radio",
    value: constants["q" /* NotificationLevels */].ALL,
    checked: memberNotifyLevel === constants["q" /* NotificationLevels */].ALL,
    onChange: onChange
  }), react_default.a.createElement(Describe, {
    section: section,
    memberNotifyLevel: constants["q" /* NotificationLevels */].ALL
  }))), react_default.a.createElement("div", {
    className: "radio"
  }, react_default.a.createElement("label", {
    className: ""
  }, react_default.a.createElement("input", {
    id: "channelNotificationMentions",
    type: "radio",
    value: constants["q" /* NotificationLevels */].MENTION,
    checked: memberNotifyLevel === constants["q" /* NotificationLevels */].MENTION,
    onChange: onChange
  }), react_default.a.createElement(Describe, {
    section: section,
    memberNotifyLevel: constants["q" /* NotificationLevels */].MENTION
  }))), react_default.a.createElement("div", {
    className: "radio"
  }, react_default.a.createElement("label", null, react_default.a.createElement("input", {
    id: "channelNotificationNever",
    type: "radio",
    value: constants["q" /* NotificationLevels */].NONE,
    checked: memberNotifyLevel === constants["q" /* NotificationLevels */].NONE,
    onChange: onChange
  }), react_default.a.createElement(Describe, {
    section: section,
    memberNotifyLevel: constants["q" /* NotificationLevels */].NONE
  })))), section === constants["r" /* NotificationSections */].IGNORE_CHANNEL_MENTIONS && react_default.a.createElement("div", null, react_default.a.createElement("div", {
    className: "radio"
  }, react_default.a.createElement("label", null, react_default.a.createElement("input", {
    id: "ignoreChannelMentionsOn",
    type: "radio",
    value: constants["l" /* IgnoreChannelMentions */].ON,
    checked: ignoreChannelMentions === constants["l" /* IgnoreChannelMentions */].ON,
    onChange: onChange
  }), react_default.a.createElement(Describe, {
    section: section,
    ignoreChannelMentions: constants["l" /* IgnoreChannelMentions */].ON,
    memberNotifyLevel: memberNotifyLevel,
    globalNotifyLevel: globalNotifyLevel
  }))), react_default.a.createElement("div", {
    className: "radio"
  }, react_default.a.createElement("label", null, react_default.a.createElement("input", {
    id: "ignoreChannelMentionsOff",
    type: "radio",
    value: constants["l" /* IgnoreChannelMentions */].OFF,
    checked: ignoreChannelMentions === constants["l" /* IgnoreChannelMentions */].OFF,
    onChange: onChange
  }), react_default.a.createElement(Describe, {
    section: section,
    ignoreChannelMentions: constants["l" /* IgnoreChannelMentions */].OFF,
    memberNotifyLevel: memberNotifyLevel,
    globalNotifyLevel: globalNotifyLevel
  })))), section === constants["r" /* NotificationSections */].MARK_UNREAD && react_default.a.createElement("div", null, react_default.a.createElement("div", {
    className: "radio"
  }, react_default.a.createElement("label", {
    className: ""
  }, react_default.a.createElement("input", {
    id: "channelNotificationUnmute",
    type: "radio",
    value: constants["q" /* NotificationLevels */].MENTION,
    checked: memberNotifyLevel === constants["q" /* NotificationLevels */].MENTION,
    onChange: onChange
  }), react_default.a.createElement(Describe, {
    section: section,
    memberNotifyLevel: constants["q" /* NotificationLevels */].MENTION
  }))), react_default.a.createElement("div", {
    className: "radio"
  }, react_default.a.createElement("label", {
    className: ""
  }, react_default.a.createElement("input", {
    id: "channelNotificationMute",
    type: "radio",
    value: constants["q" /* NotificationLevels */].ALL,
    checked: memberNotifyLevel === constants["q" /* NotificationLevels */].ALL,
    onChange: onChange
  }), react_default.a.createElement(Describe, {
    section: section,
    memberNotifyLevel: constants["q" /* NotificationLevels */].ALL
  })))))];
  return react_default.a.createElement(setting_item_max["a" /* default */], {
    title: react_default.a.createElement(SectionTitle, {
      section: section
    }),
    inputs: inputs,
    submit: onSubmit,
    server_error: serverError,
    updateSection: onCollapseSection,
    extraInfo: react_default.a.createElement(ExtraInfo, {
      section: section
    })
  });
}
ExpandView.propTypes = {
  ignoreChannelMentions: prop_types_default.a.string,
  onChange: prop_types_default.a.func.isRequired,
  onCollapseSection: prop_types_default.a.func.isRequired,
  onSubmit: prop_types_default.a.func.isRequired,
  globalNotifyLevel: prop_types_default.a.string,
  memberNotifyLevel: prop_types_default.a.string.isRequired,
  section: prop_types_default.a.string.isRequired,
  serverError: prop_types_default.a.string
};
// CONCATENATED MODULE: ./components/channel_notifications_modal/components/notification_section.jsx
function notification_section_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class notification_section_NotificationSection extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    notification_section_defineProperty(this, "handleOnChange", e => {
      this.props.onChange(e.target.value);
    });

    notification_section_defineProperty(this, "handleExpandSection", () => {
      this.props.onUpdateSection(this.props.section);
    });

    notification_section_defineProperty(this, "handleCollapseSection", () => {
      this.props.onUpdateSection(constants["r" /* NotificationSections */].NONE);
    });
  }

  render() {
    const {
      expand,
      globalNotificationLevel,
      memberNotificationLevel,
      ignoreChannelMentions,
      onSubmit,
      section,
      serverError
    } = this.props;

    if (expand) {
      return react_default.a.createElement(ExpandView, {
        section: section,
        memberNotifyLevel: memberNotificationLevel,
        globalNotifyLevel: globalNotificationLevel,
        ignoreChannelMentions: ignoreChannelMentions,
        onChange: this.handleOnChange,
        onSubmit: onSubmit,
        serverError: serverError,
        onCollapseSection: this.handleCollapseSection
      });
    }

    return react_default.a.createElement(CollapseView, {
      section: section,
      onExpandSection: this.handleExpandSection,
      memberNotifyLevel: memberNotificationLevel,
      globalNotifyLevel: globalNotificationLevel,
      ignoreChannelMentions: ignoreChannelMentions
    });
  }

}

notification_section_defineProperty(notification_section_NotificationSection, "propTypes", {
  /**
   * Notification section
   */
  section: prop_types_default.a.string.isRequired,

  /**
   * Expand if true, else collapse the section
   */
  expand: prop_types_default.a.bool.isRequired,

  /**
   * Member's desktop notification level
   */
  memberNotificationLevel: prop_types_default.a.string.isRequired,

  /**
   * Ignore channel-wide mentions @channel, @here and @all
   */
  ignoreChannelMentions: prop_types_default.a.string,

  /**
   * User's global notification level
   */
  globalNotificationLevel: prop_types_default.a.string,

  /**
   * onChange handles update of desktop notification level
   */
  onChange: prop_types_default.a.func.isRequired,

  /**
   * Submit function to save notification level
   */
  onSubmit: prop_types_default.a.func.isRequired,

  /**
   * Update function to to expand or collapse a section
   */
  onUpdateSection: prop_types_default.a.func.isRequired,

  /**
   * Error string from the server
   */
  serverError: prop_types_default.a.string
});
// CONCATENATED MODULE: ./components/channel_notifications_modal/channel_notifications_modal.jsx
function channel_notifications_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class channel_notifications_modal_ChannelNotificationsModal extends react_default.a.PureComponent {
  constructor(_props) {
    super(_props);

    channel_notifications_modal_defineProperty(this, "handleHide", () => {
      this.setState({
        show: false
      });
    });

    channel_notifications_modal_defineProperty(this, "handleExit", () => {
      this.updateSection(constants["r" /* NotificationSections */].NONE);
      this.props.onHide();
    });

    channel_notifications_modal_defineProperty(this, "updateSection", (section = constants["r" /* NotificationSections */].NONE) => {
      if (jquery_default()('.section-max').length) {
        jquery_default()('.settings-modal .modal-body').scrollTop(0).perfectScrollbar('update');
      }

      this.setState({
        activeSection: section
      });

      if (section === constants["r" /* NotificationSections */].NONE) {
        const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props;
        this.resetStateFromNotifyProps(channelNotifyProps, this.props.currentUser.notify_props);
      }
    });

    channel_notifications_modal_defineProperty(this, "handleUpdateChannelNotifyProps", async props => {
      const {
        actions,
        channel,
        currentUser
      } = this.props;
      const {
        error
      } = await actions.updateChannelNotifyProps(currentUser.id, channel.id, props);

      if (error) {
        this.setState({
          serverError: error.message
        });
      } else {
        this.updateSection(constants["r" /* NotificationSections */].NONE);
      }
    });

    channel_notifications_modal_defineProperty(this, "handleSubmitDesktopNotifyLevel", () => {
      const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props;
      const {
        desktopNotifyLevel
      } = this.state;

      if (channelNotifyProps.desktop === desktopNotifyLevel) {
        this.updateSection(constants["r" /* NotificationSections */].NONE);
        return;
      }

      const props = {
        desktop: desktopNotifyLevel
      };
      this.handleUpdateChannelNotifyProps(props);
    });

    channel_notifications_modal_defineProperty(this, "handleUpdateDesktopNotifyLevel", desktopNotifyLevel => {
      this.setState({
        desktopNotifyLevel
      });
    });

    channel_notifications_modal_defineProperty(this, "handleSubmitMarkUnreadLevel", () => {
      const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props;
      const {
        markUnreadNotifyLevel
      } = this.state;

      if (channelNotifyProps.mark_unread === markUnreadNotifyLevel) {
        this.updateSection(constants["r" /* NotificationSections */].NONE);
        return;
      }

      const props = {
        mark_unread: markUnreadNotifyLevel
      };
      this.handleUpdateChannelNotifyProps(props);
    });

    channel_notifications_modal_defineProperty(this, "handleUpdateMarkUnreadLevel", markUnreadNotifyLevel => {
      this.setState({
        markUnreadNotifyLevel
      });
    });

    channel_notifications_modal_defineProperty(this, "handleSubmitPushNotificationLevel", () => {
      const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props;
      const {
        pushNotifyLevel
      } = this.state;

      if (channelNotifyProps.push === pushNotifyLevel) {
        this.updateSection(constants["r" /* NotificationSections */].NONE);
        return;
      }

      const props = {
        push: pushNotifyLevel
      };
      this.handleUpdateChannelNotifyProps(props);
    });

    channel_notifications_modal_defineProperty(this, "handleUpdatePushNotificationLevel", pushNotifyLevel => {
      this.setState({
        pushNotifyLevel
      });
    });

    channel_notifications_modal_defineProperty(this, "handleUpdateIgnoreChannelMentions", ignoreChannelMentions => {
      this.setState({
        ignoreChannelMentions
      });
    });

    channel_notifications_modal_defineProperty(this, "handleSubmitIgnoreChannelMentions", () => {
      const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props;
      const {
        ignoreChannelMentions
      } = this.state;

      if (channelNotifyProps.ignore_channel_mentions === ignoreChannelMentions) {
        this.updateSection('');
        return;
      }

      const props = {
        ignore_channel_mentions: ignoreChannelMentions
      };
      this.handleUpdateChannelNotifyProps(props);
    });

    const _channelNotifyProps = _props.channelMember && _props.channelMember.notify_props;

    this.state = {
      show: true,
      activeSection: constants["r" /* NotificationSections */].NONE,
      serverError: null,
      ...this.getStateFromNotifyProps(_channelNotifyProps, _props.currentUser.notify_props)
    };
  }

  componentDidUpdate(prevProps) {
    const prevChannelNotifyProps = prevProps.channelMember && prevProps.channelMember.notify_props;
    const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props;

    if (!utils["c" /* areObjectsEqual */](channelNotifyProps, prevChannelNotifyProps)) {
      this.resetStateFromNotifyProps(channelNotifyProps, this.props.currentUser.notify_props);
    }
  }

  resetStateFromNotifyProps(channelMemberNotifyProps, currentUserNotifyProps) {
    this.setState(this.getStateFromNotifyProps(channelMemberNotifyProps, currentUserNotifyProps));
  }

  getStateFromNotifyProps(channelMemberNotifyProps, currentUserNotifyProps) {
    let ignoreChannelMentionsDefault = constants["l" /* IgnoreChannelMentions */].OFF;

    if (currentUserNotifyProps.channel && currentUserNotifyProps.channel === 'false') {
      ignoreChannelMentionsDefault = constants["l" /* IgnoreChannelMentions */].ON;
    }

    let ignoreChannelMentions = channelMemberNotifyProps.ignore_channel_mentions;

    if (!ignoreChannelMentions || ignoreChannelMentions === constants["l" /* IgnoreChannelMentions */].DEFAULT) {
      ignoreChannelMentions = ignoreChannelMentionsDefault;
    }

    return {
      desktopNotifyLevel: channelMemberNotifyProps.desktop || constants["q" /* NotificationLevels */].DEFAULT,
      markUnreadNotifyLevel: channelMemberNotifyProps.mark_unread || constants["q" /* NotificationLevels */].ALL,
      pushNotifyLevel: channelMemberNotifyProps.push || constants["q" /* NotificationLevels */].DEFAULT,
      ignoreChannelMentions
    };
  }

  render() {
    const {
      activeSection,
      desktopNotifyLevel,
      markUnreadNotifyLevel,
      pushNotifyLevel,
      ignoreChannelMentions,
      serverError
    } = this.state;
    const {
      channel,
      channelMember,
      currentUser,
      sendPushNotifications
    } = this.props;
    let serverErrorTag = null;

    if (serverError) {
      serverErrorTag = react_default.a.createElement("div", {
        className: "form-group has-error"
      }, react_default.a.createElement("label", {
        className: "control-label"
      }, serverError));
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "settings-modal settings-modal--tabless",
      show: this.state.show,
      onHide: this.handleHide,
      onExited: this.handleExit,
      role: "dialog",
      "aria-labelledby": "channelNotificationModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "channelNotificationModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_notifications.preferences",
      defaultMessage: "Notification Preferences for "
    }), react_default.a.createElement("span", {
      className: "name"
    }, channel.display_name))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement("div", {
      className: "settings-table"
    }, react_default.a.createElement("div", {
      className: "settings-content"
    }, react_default.a.createElement("div", {
      ref: "wrapper",
      className: "user-settings"
    }, react_default.a.createElement("br", null), react_default.a.createElement("div", {
      className: "divider-dark first"
    }), react_default.a.createElement(notification_section_NotificationSection, {
      section: constants["r" /* NotificationSections */].MARK_UNREAD,
      expand: activeSection === constants["r" /* NotificationSections */].MARK_UNREAD,
      memberNotificationLevel: markUnreadNotifyLevel,
      onChange: this.handleUpdateMarkUnreadLevel,
      onSubmit: this.handleSubmitMarkUnreadLevel,
      onUpdateSection: this.updateSection,
      serverError: serverError
    }), react_default.a.createElement("div", {
      className: "divider-light"
    }), react_default.a.createElement(notification_section_NotificationSection, {
      section: constants["r" /* NotificationSections */].IGNORE_CHANNEL_MENTIONS,
      expand: activeSection === constants["r" /* NotificationSections */].IGNORE_CHANNEL_MENTIONS,
      memberNotificationLevel: markUnreadNotifyLevel,
      ignoreChannelMentions: ignoreChannelMentions,
      onChange: this.handleUpdateIgnoreChannelMentions,
      onSubmit: this.handleSubmitIgnoreChannelMentions,
      onUpdateSection: this.updateSection,
      serverError: serverError
    }), !Object(channel_utils["isChannelMuted"])(channelMember) && react_default.a.createElement("div", null, react_default.a.createElement("div", {
      className: "divider-light"
    }), react_default.a.createElement(notification_section_NotificationSection, {
      section: constants["r" /* NotificationSections */].DESKTOP,
      expand: activeSection === constants["r" /* NotificationSections */].DESKTOP,
      memberNotificationLevel: desktopNotifyLevel,
      globalNotificationLevel: currentUser.notify_props ? currentUser.notify_props.desktop : constants["q" /* NotificationLevels */].ALL,
      onChange: this.handleUpdateDesktopNotifyLevel,
      onSubmit: this.handleSubmitDesktopNotifyLevel,
      onUpdateSection: this.updateSection,
      serverError: serverError
    }), react_default.a.createElement("div", {
      className: "divider-light"
    }), sendPushNotifications && react_default.a.createElement(notification_section_NotificationSection, {
      section: constants["r" /* NotificationSections */].PUSH,
      expand: activeSection === constants["r" /* NotificationSections */].PUSH,
      memberNotificationLevel: pushNotifyLevel,
      globalNotificationLevel: currentUser.notify_props ? currentUser.notify_props.push : constants["q" /* NotificationLevels */].ALL,
      onChange: this.handleUpdatePushNotificationLevel,
      onSubmit: this.handleSubmitPushNotificationLevel,
      onUpdateSection: this.updateSection,
      serverError: serverError
    })), react_default.a.createElement("div", {
      className: "divider-dark"
    })))), serverErrorTag));
  }

}

channel_notifications_modal_defineProperty(channel_notifications_modal_ChannelNotificationsModal, "propTypes", {
  /**
   * Function that is called when modal is hidden
   */
  onHide: prop_types_default.a.func.isRequired,

  /**
   * Object with info about current channel
   */
  channel: prop_types_default.a.object.isRequired,

  /**
   * Object with info about current channel membership
   */
  channelMember: prop_types_default.a.object.isRequired,

  /**
   * Object with info about current user
   */
  currentUser: prop_types_default.a.object.isRequired,

  /**
   * Boolean whether server sends push notifications
   */
  sendPushNotifications: prop_types_default.a.bool.isRequired,

  /*
   * Object with redux action creators
   */
  actions: prop_types_default.a.shape({
    /*
     * Action creator to update channel notify props
     */
    updateChannelNotifyProps: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/channel_notifications_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const channel_notifications_modal_mapStateToProps = state => ({
  channelMember: Object(entities_channels["getMyCurrentChannelMembership"])(state),
  sendPushNotifications: Object(general["getConfig"])(state).SendPushNotifications === 'true'
});

const channel_notifications_modal_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    updateChannelNotifyProps: actions_channels["updateChannelNotifyProps"]
  }, dispatch)
});

/* harmony default export */ var channel_notifications_modal = (Object(es["connect"])(channel_notifications_modal_mapStateToProps, channel_notifications_modal_mapDispatchToProps)(channel_notifications_modal_ChannelNotificationsModal));
// CONCATENATED MODULE: ./components/channel_info_modal/channel_info_modal.jsx
function channel_info_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












const headerMarkdownOptions = {
  singleline: false,
  mentionHighlight: false
};
class channel_info_modal_ChannelInfoModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    channel_info_modal_defineProperty(this, "onHide", () => {
      this.setState({
        show: false
      });
    });

    this.state = {
      show: true
    };
    this.getHeaderMarkdownOptions = Object(helpers["memoizeResult"])(channelNamesMap => ({ ...headerMarkdownOptions,
      channelNamesMap
    }));
  }

  render() {
    let channel = this.props.channel;
    const channelIsArchived = channel.delete_at !== 0;
    let channelIcon;

    if (!channel) {
      const notFound = utils["gb" /* localizeMessage */]('channel_info.notFound', 'No Channel Found');
      channel = {
        display_name: notFound,
        name: notFound,
        purpose: notFound,
        header: notFound,
        id: notFound
      };
    }

    const channelNamesMap = this.props.channel.props && this.props.channel.props.channel_mentions;

    if (channelIsArchived) {
      channelIcon = react_default.a.createElement(archive_icon["a" /* default */], {
        className: "icon icon__archive"
      });
    } else if (channel.type === 'O') {
      channelIcon = react_default.a.createElement(globe_icon["a" /* default */], {
        className: "icon icon__globe icon--body"
      });
    } else if (channel.type === 'P') {
      channelIcon = react_default.a.createElement(lock_icon["a" /* default */], {
        className: "icon icon__globe icon--body"
      });
    }

    const channelURL = Object(utils_url["e" /* getSiteURL */])() + '/' + this.props.currentTeam.name + '/channels/' + channel.name;
    let channelPurpose;

    if (channel.purpose) {
      channelPurpose = channel.purpose;
    } else if (channel.name === constants["N" /* default */].DEFAULT_CHANNEL) {
      channelPurpose = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "default_channel.purpose",
        defaultMessage: "Post messages here that you want everyone to see. Everyone automatically becomes a permanent member of this channel when they join the team."
      });
    }

    let channelPurposeElement;

    if (channelPurpose) {
      channelPurposeElement = react_default.a.createElement("div", {
        className: "form-group"
      }, react_default.a.createElement("div", {
        className: "info__label"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_info.purpose",
        defaultMessage: "Purpose:"
      })), react_default.a.createElement("div", {
        className: "info__value"
      }, channelPurpose));
    }

    let channelHeader = null;

    if (channel.header) {
      channelHeader = react_default.a.createElement("div", {
        className: "form-group"
      }, react_default.a.createElement("div", {
        className: "info__label"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "channel_info.header",
        defaultMessage: "Header:"
      })), react_default.a.createElement("div", {
        className: "info__value"
      }, react_default.a.createElement(markdown["a" /* default */], {
        message: channel.header,
        options: this.getHeaderMarkdownOptions(channelNamesMap)
      })));
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      dialogClassName: "about-modal",
      show: this.state.show,
      onHide: this.onHide,
      onExited: this.props.onHide,
      role: "dialog",
      "aria-labelledby": "channelInfoModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "channelInfoModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_info.about",
      defaultMessage: "About"
    }), react_default.a.createElement("strong", null, channelIcon, channel.display_name))), react_default.a.createElement(Modal["a" /* default */].Body, {
      ref: "modalBody"
    }, channelPurposeElement, channelHeader, react_default.a.createElement("div", {
      className: "form-group"
    }, react_default.a.createElement("div", {
      className: "info__label"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_info.url",
      defaultMessage: "URL:"
    })), react_default.a.createElement("div", {
      className: "info__value"
    }, channelURL)), react_default.a.createElement("div", {
      className: "about-modal__hash form-group padding-top x2"
    }, react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_info.id",
      defaultMessage: "ID: "
    }), channel.id))));
  }

}

channel_info_modal_defineProperty(channel_info_modal_ChannelInfoModal, "propTypes", {
  /**
   * Function that is called when modal is hidden
   */
  onHide: prop_types_default.a.func.isRequired,

  /**
   * Channel object
   */
  channel: prop_types_default.a.object.isRequired,

  /**
   * Current team object
   */
  currentTeam: prop_types_default.a.object.isRequired
});
// CONCATENATED MODULE: ./components/channel_info_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function channel_info_modal_mapStateToProps(state) {
  return {
    currentTeam: Object(entities_teams["getCurrentTeam"])(state)
  };
}

/* harmony default export */ var channel_info_modal = (Object(es["connect"])(channel_info_modal_mapStateToProps)(channel_info_modal_ChannelInfoModal));
// CONCATENATED MODULE: ./components/edit_channel_purpose_modal/edit_channel_purpose_modal.jsx
function edit_channel_purpose_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class edit_channel_purpose_modal_EditChannelPurposeModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    edit_channel_purpose_modal_defineProperty(this, "setError", err => {
      if (err.id === 'api.context.invalid_param.app_error') {
        this.setState({
          serverError: utils["gb" /* localizeMessage */]('edit_channel_purpose_modal.error', 'This channel purpose is too long, please enter a shorter one')
        });
      } else {
        this.setState({
          serverError: err.message
        });
      }
    });

    edit_channel_purpose_modal_defineProperty(this, "unsetError", () => {
      this.setState({
        serverError: ''
      });
    });

    edit_channel_purpose_modal_defineProperty(this, "handleEntering", () => {
      utils["kb" /* placeCaretAtEnd */](this.purpose);
    });

    edit_channel_purpose_modal_defineProperty(this, "onHide", () => {
      this.setState({
        show: false
      });
    });

    edit_channel_purpose_modal_defineProperty(this, "handleKeyDown", e => {
      const {
        ctrlSend
      } = this.props;

      if (ctrlSend && utils["V" /* isKeyPressed */](e, constants["N" /* default */].KeyCodes.ENTER) && e.ctrlKey) {
        e.preventDefault();
        this.handleSave(e);
      } else if (!ctrlSend && utils["V" /* isKeyPressed */](e, constants["N" /* default */].KeyCodes.ENTER) && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        this.handleSave(e);
      }
    });

    edit_channel_purpose_modal_defineProperty(this, "handleSave", () => {
      const {
        channel,
        actions: {
          patchChannel
        }
      } = this.props;
      const {
        purpose
      } = this.state;

      if (!channel) {
        return;
      }

      patchChannel(channel.id, {
        purpose
      });
    });

    edit_channel_purpose_modal_defineProperty(this, "handleChange", e => {
      e.preventDefault();
      this.setState({
        purpose: e.target.value
      });
    });

    edit_channel_purpose_modal_defineProperty(this, "getPurpose", node => {
      this.purpose = node;
    });

    this.state = {
      purpose: props.channel.purpose || '',
      serverError: '',
      show: true,
      submitted: false
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    const {
      requestStatus: nextRequestStatus,
      serverError: nextServerError
    } = nextProps;
    const {
      requestStatus
    } = this.props;

    if (requestStatus !== nextRequestStatus && nextRequestStatus === mattermost_redux_constants["RequestStatus"].SUCCESS) {
      this.onHide();
    }

    if (requestStatus !== nextRequestStatus && nextRequestStatus === mattermost_redux_constants["RequestStatus"].FAILURE) {
      this.setError(nextServerError);
    } else {
      this.unsetError();
    }
  }

  render() {
    let serverError = null;

    if (this.state.serverError) {
      serverError = react_default.a.createElement("div", {
        className: "form-group has-error"
      }, react_default.a.createElement("br", null), react_default.a.createElement("label", {
        className: "control-label"
      }, this.state.serverError));
    }

    let title = react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "edit_channel_purpose_modal.title1",
      defaultMessage: "Edit Purpose"
    }));

    if (this.props.channel.display_name) {
      title = react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "edit_channel_purpose_modal.title2",
        defaultMessage: "Edit Purpose for "
      }), react_default.a.createElement("span", {
        className: "name"
      }, this.props.channel.display_name));
    }

    let channelPurposeModal = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "edit_channel_purpose_modal.body",
      defaultMessage: "Describe how this channel should be used. This text appears in the channel list in the \"More...\" menu and helps others decide whether to join."
    });

    if (this.props.channel.type === 'P') {
      channelPurposeModal = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "edit_channel_private_purpose_modal.body",
        defaultMessage: "This text appears in the \\\"View Info\\\" modal of the private channel."
      });
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      show: this.state.show,
      onHide: this.onHide,
      onEntering: this.handleEntering,
      onExited: this.props.onHide,
      role: "dialog",
      "aria-labelledby": "editChannelPurposeModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "editChannelPurposeModalLabel"
    }, title)), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement("p", null, channelPurposeModal), react_default.a.createElement("textarea", {
      ref: this.getPurpose,
      className: "form-control no-resize",
      rows: "6",
      maxLength: "250",
      value: this.state.purpose,
      onKeyDown: this.handleKeyDown,
      onChange: this.handleChange
    }), serverError), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-link cancel-button",
      onClick: this.onHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "edit_channel_purpose_modal.cancel",
      defaultMessage: "Cancel"
    })), react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-primary save-button",
      disabled: this.props.requestStatus === mattermost_redux_constants["RequestStatus"].STARTED,
      onClick: this.handleSave
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "edit_channel_purpose_modal.save",
      defaultMessage: "Save"
    }))));
  }

}

edit_channel_purpose_modal_defineProperty(edit_channel_purpose_modal_EditChannelPurposeModal, "propTypes", {
  /*
   * callback to call when modal will hide
   */
  onHide: prop_types_default.a.func.isRequired,

  /*
   * Channel info object
   */
  channel: prop_types_default.a.object,

  /*
   * Check should we send purpose on CTRL + ENTER
   */
  ctrlSend: prop_types_default.a.bool.isRequired,

  /*
   * Info about patch serverError
   */
  serverError: prop_types_default.a.object,

  /*
   *  Status of patch info about channel request
   */
  requestStatus: prop_types_default.a.string.isRequired,

  /*
   * Object with redux action creators
   */
  actions: prop_types_default.a.shape({
    /*
     * Action creator to patch current channel
     */
    patchChannel: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/edit_channel_purpose_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const edit_channel_purpose_modal_mapStateToProps = Object(reselect_es["a" /* createSelector */])(state => Object(entities_preferences["getBool"])(state, constants["N" /* default */].Preferences.CATEGORY_ADVANCED_SETTINGS, 'send_on_ctrl_enter'), ({
  requests
}) => {
  const {
    channels: {
      updateChannel
    }
  } = requests;
  return {
    serverError: updateChannel.error,
    requestStatus: updateChannel.status
  };
}, (ctrlSend, requestInfo) => ({
  ctrlSend,
  ...requestInfo
}));

function edit_channel_purpose_modal_mapDispatchToProps(dispatch) {
  return {
    actions: {
      patchChannel: Object(redux["bindActionCreators"])(actions_channels["patchChannel"], dispatch)
    }
  };
}

/* harmony default export */ var edit_channel_purpose_modal = (Object(es["connect"])(edit_channel_purpose_modal_mapStateToProps, edit_channel_purpose_modal_mapDispatchToProps)(edit_channel_purpose_modal_EditChannelPurposeModal));
// EXTERNAL MODULE: ./node_modules/antd/es/button/index.js + 3 modules
var es_button = __webpack_require__(234);

// EXTERNAL MODULE: ./node_modules/antd/es/input/index.js + 7 modules
var es_input = __webpack_require__(3484);

// CONCATENATED MODULE: ./components/rename_channel_modal/rename_channel_modal_new.jsx
function rename_channel_modal_new_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const rename_channel_modal_new_holders = Object(index_es["g" /* defineMessages */])({
  required: {
    id: Object(i18n["b" /* t */])('rename_channel.required'),
    defaultMessage: 'This field is required'
  },
  maxLength: {
    id: Object(i18n["b" /* t */])('rename_channel.maxLength'),
    defaultMessage: 'This field must be less than {maxLength, number} characters'
  },
  lowercase: {
    id: Object(i18n["b" /* t */])('rename_channel.lowercase'),
    defaultMessage: 'Must be lowercase alphanumeric characters'
  },
  url: {
    id: Object(i18n["b" /* t */])('rename_channel.url'),
    defaultMessage: 'URL'
  },
  defaultError: {
    id: Object(i18n["b" /* t */])('rename_channel.defaultError'),
    defaultMessage: ' - Cannot be changed for the default channel'
  },
  displayNameHolder: {
    id: Object(i18n["b" /* t */])('rename_channel.displayNameHolder'),
    defaultMessage: 'Enter display name'
  },
  handleHolder: {
    id: Object(i18n["b" /* t */])('rename_channel.handleHolder'),
    defaultMessage: 'lowercase alphanumeric characters'
  }
});
class rename_channel_modal_new_RenameChannelModalNew extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    rename_channel_modal_new_defineProperty(this, "componentWillUnmount", () => {
      this.setState = (state, callback) => {
        return;
      };
    });

    rename_channel_modal_new_defineProperty(this, "setError", err => {
      this.setState({
        serverError: err.message
      });
    });

    rename_channel_modal_new_defineProperty(this, "unsetError", () => {
      this.setState({
        serverError: ''
      });
    });

    rename_channel_modal_new_defineProperty(this, "handleEntering", () => {
      utils["kb" /* placeCaretAtEnd */](this.textbox);
    });

    rename_channel_modal_new_defineProperty(this, "handleHide", e => {
      if (e) {
        e.preventDefault();
      }

      this.setState({
        serverError: '',
        nameError: '',
        displayNameError: '',
        invalid: false,
        show: false
      });
      this.props.onHide();
    });

    rename_channel_modal_new_defineProperty(this, "handleSubmit", async e => {
      if (e) {
        e.preventDefault();
      }

      const channel = Object.assign({}, this.props.channel);
      const oldName = channel.name;
      const oldDisplayName = channel.display_name;
      const state = {
        serverError: ''
      };
      const {
        formatMessage
      } = this.props.intl;
      const {
        actions: {
          patchChannel
        }
      } = this.props;
      channel.display_name = this.state.displayName.trim();

      if (!channel.display_name) {
        state.displayNameError = formatMessage(rename_channel_modal_new_holders.required);
        state.invalid = true;
      } else if (channel.display_name.length > constants["N" /* default */].MAX_CHANNELNAME_LENGTH) {
        state.displayNameError = formatMessage(rename_channel_modal_new_holders.maxLength, {
          maxLength: constants["N" /* default */].MAX_CHANNELNAME_LENGTH
        });
        state.invalid = true;
      } else if (channel.display_name.length < constants["N" /* default */].MIN_CHANNELNAME_LENGTH) {
        state.displayNameError = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "rename_channel.minLength",
          defaultMessage: "Channel name must be {minLength, number} or more characters",
          values: {
            minLength: constants["N" /* default */].MIN_CHANNELNAME_LENGTH
          }
        });
        state.invalid = true;
      } else {
        state.displayNameError = '';
      }

      channel.name = this.state.channelName.trim();

      if (!channel.name) {
        state.nameError = formatMessage(rename_channel_modal_new_holders.required);
        state.invalid = true;
      } else if (channel.name.length > constants["N" /* default */].MAX_CHANNELNAME_LENGTH) {
        state.nameError = formatMessage(rename_channel_modal_new_holders.maxLength, {
          maxLength: constants["N" /* default */].MAX_CHANNELNAME_LENGTH
        });
        state.invalid = true;
      } else {
        const cleanedName = Object(utils_url["a" /* cleanUpUrlable */])(channel.name);

        if (cleanedName === channel.name) {
          state.nameError = '';
        } else {
          state.nameError = formatMessage(rename_channel_modal_new_holders.lowercase);
          state.invalid = true;
        }
      }

      this.setState(state);

      if (state.invalid) {
        return;
      }

      if (oldName === channel.name && oldDisplayName === channel.display_name) {
        this.onSaveSuccess();
        return;
      }

      const {
        data,
        error
      } = await patchChannel(channel.id, channel);

      if (data) {
        this.onSaveSuccess();
      } else if (error) {
        this.setError(error);
      }
    });

    rename_channel_modal_new_defineProperty(this, "onSaveSuccess", () => {
      this.handleHide();
      this.unsetError();
      browser_history["a" /* browserHistory */].push('/' + this.props.team.name + '/channels/' + this.state.channelName);
    });

    rename_channel_modal_new_defineProperty(this, "handleCancel", e => {
      this.setState({
        displayName: this.props.channel.display_name,
        channelName: this.props.channel.name
      });
      this.handleHide(e);
    });

    rename_channel_modal_new_defineProperty(this, "onNameChange", e => {
      this.setState({
        channelName: e.target.value
      });
    });

    rename_channel_modal_new_defineProperty(this, "onDisplayNameChange", e => {
      this.setState({
        displayName: e.target.value
      });
    });

    rename_channel_modal_new_defineProperty(this, "getTextbox", node => {
      this.textbox = node;
    });

    this.state = {
      displayName: props.channel.display_name,
      channelName: props.channel.name,
      serverError: '',
      nameError: '',
      displayNameError: '',
      invalid: false,
      show: true
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (!utils["c" /* areObjectsEqual */](nextProps.channel, this.props.channel)) {
      this.setState({
        displayName: nextProps.channel.display_name,
        channelName: nextProps.channel.name
      });
    }
  }

  render() {
    let displayNameError = null;
    let displayNameClass = 'form-group';

    if (this.state.displayNameError) {
      displayNameError = react_default.a.createElement("label", {
        className: "control-label has-error renmame_err"
      }, this.state.displayNameError);
    } // let serverError = null;
    // if (this.state.serverError) {
    //     serverError = <div className='form-group has-error renmame_err'><label className='control-label'>{this.state.serverError}</label></div>;
    // }


    const {
      formatMessage
    } = this.props.intl;
    const foot = [react_default.a.createElement(es_button["a" /* default */], {
      key: "0",
      type: "primary",
      onClick: this.handleSubmit
    }, "\u786E\u5B9A")];
    const inputClass = this.state.displayNameError ? "input_err" : '';
    return react_default.a.createElement(es_modal["a" /* default */], {
      className: "more-modal zoom-share-dialog",
      mask: false,
      centered: true,
      closeIcon: react_default.a.createElement(es_icon["a" /* default */], {
        type: "close-circle",
        theme: "filled"
      }),
      visible: this.state.show,
      onCancel: this.handleHide,
      maskClosable: false,
      role: "dialog" // title={formatMessage({id: 'channel_invite.addNewMembers', defaultMessage: 'Add New Members to '}) + this.props.channel.display_name}
      ,
      title: '修改频道名称',
      footer: foot,
      width: '520px'
    }, react_default.a.createElement("form", {
      role: "form",
      className: "con-class"
    }, react_default.a.createElement("div", {
      className: displayNameClass + ' con-title-class'
    }, react_default.a.createElement("div", {
      className: "con-class"
    }, react_default.a.createElement("label", {
      className: "control-label"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "rename_channel.displayName",
      defaultMessage: "Display Name"
    })), react_default.a.createElement("span", {
      className: "con-title-s-class"
    }, "*")), react_default.a.createElement(es_input["a" /* default */], {
      className: inputClass,
      placeholder: formatMessage(rename_channel_modal_new_holders.displayNameHolder),
      onChange: this.onDisplayNameChange,
      value: this.state.displayName
    }), displayNameError)));
  }

}

rename_channel_modal_new_defineProperty(rename_channel_modal_new_RenameChannelModalNew, "propTypes", {
  /**
   * react-intl helper object
   */
  intl: index_es["i" /* intlShape */].isRequired,

  /**
   * Function that is called when modal is hidden
   */
  onHide: prop_types_default.a.func.isRequired,

  /**
   * Object with info about current channel
   */
  channel: prop_types_default.a.object.isRequired,

  /**
   * Object with info about current team
   */
  team: prop_types_default.a.object.isRequired,

  /**
   * String with the current team URL
   */
  currentTeamUrl: prop_types_default.a.string.isRequired,

  /*
   * Object with redux action creators
   */
  actions: prop_types_default.a.shape({
    /*
     * Action creator to patch current channel
     */
    patchChannel: prop_types_default.a.func.isRequired
  }).isRequired
});

/* harmony default export */ var rename_channel_modal_new = (Object(index_es["h" /* injectIntl */])(rename_channel_modal_new_RenameChannelModalNew));
// CONCATENATED MODULE: ./components/rename_channel_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const rename_channel_modal_mapStateToProps = Object(reselect_es["a" /* createSelector */])(state => {
  const currentTeamId = state.entities.teams.currentTeamId;
  const team = Object(entities_teams["getTeam"])(state, currentTeamId);
  const currentTeamUrl = `${Object(utils_url["e" /* getSiteURL */])()}/${team.name}`;
  return {
    currentTeamUrl,
    team
  };
}, teamInfo => ({ ...teamInfo
}));

function rename_channel_modal_mapDispatchToProps(dispatch) {
  return {
    actions: {
      patchChannel: Object(redux["bindActionCreators"])(actions_channels["patchChannel"], dispatch)
    }
  };
}

/* harmony default export */ var rename_channel_modal = (Object(es["connect"])(rename_channel_modal_mapStateToProps, rename_channel_modal_mapDispatchToProps)(rename_channel_modal_new));
// CONCATENATED MODULE: ./components/convert_channel_modal/convert_channel_modal.jsx
function convert_channel_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class convert_channel_modal_ConvertChannelModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    convert_channel_modal_defineProperty(this, "handleConvert", () => {
      const {
        actions,
        channelId
      } = this.props;

      if (channelId.length !== constants["N" /* default */].CHANNEL_ID_LENGTH) {
        return;
      }

      actions.convertChannelToPrivate(channelId);
      Object(diagnostics_actions["d" /* trackEvent */])('actions', 'convert_to_private_channel', {
        channel_id: channelId
      });
      this.onHide();
    });

    convert_channel_modal_defineProperty(this, "onHide", () => {
      this.setState({
        show: false
      });
    });

    this.state = {
      show: true
    };
  }

  render() {
    const {
      channelDisplayName,
      onHide
    } = this.props;
    return react_default.a.createElement(Modal["a" /* default */], {
      show: this.state.show,
      onHide: this.onHide,
      onExited: onHide,
      role: "dialog",
      "aria-labelledby": "convertChannelModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "convertChannelModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "convert_channel.title",
      defaultMessage: "Convert {display_name} to a private channel?",
      values: {
        display_name: channelDisplayName
      }
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
      id: "convert_channel.question1",
      defaultMessage: "When you convert **{display_name}** to a private channel, history and membership are preserved. Publicly shared files remain accessible to anyone with the link. Membership in a private channel is by invitation only.",
      values: {
        display_name: channelDisplayName
      }
    })), react_default.a.createElement("p", null, react_default.a.createElement(index_es["b" /* FormattedHTMLMessage */], {
      id: "convert_channel.question2",
      defaultMessage: "The change is permanent and cannot be undone."
    })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
      id: "convert_channel.question3",
      defaultMessage: "Are you sure you want to convert **{display_name}** to a private channel?",
      values: {
        display_name: channelDisplayName
      }
    }))), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-link",
      onClick: this.onHide,
      tabIndex: "2"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "convert_channel.cancel",
      defaultMessage: "No, cancel"
    })), react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-primary",
      "data-dismiss": "modal",
      onClick: this.handleConvert,
      autoFocus: true,
      tabIndex: "1"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "convert_channel.confirm",
      defaultMessage: "Yes, convert to private channel"
    }))));
  }

}

convert_channel_modal_defineProperty(convert_channel_modal_ConvertChannelModal, "propTypes", {
  /**
  * Function called when modal is dismissed
  */
  onHide: prop_types_default.a.func.isRequired,
  channelId: prop_types_default.a.string.isRequired,
  channelDisplayName: prop_types_default.a.string.isRequired,
  actions: prop_types_default.a.shape({
    /**
    * Function called for converting channel to private,
    */
    convertChannelToPrivate: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/convert_channel_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function convert_channel_modal_mapStateToProps(state) {
  return {
    currentTeamDetails: Object(entities_teams["getCurrentTeam"])(state)
  };
}

function convert_channel_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      convertChannelToPrivate: actions_channels["convertChannelToPrivate"]
    }, dispatch)
  };
}

/* harmony default export */ var convert_channel_modal = (Object(es["connect"])(convert_channel_modal_mapStateToProps, convert_channel_modal_mapDispatchToProps)(convert_channel_modal_ConvertChannelModal));
// CONCATENATED MODULE: ./components/delete_channel_modal/delete_channel_modal.jsx
function delete_channel_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class delete_channel_modal_DeleteChannelModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.handleDelete = this.handleDelete.bind(this);
    this.onHide = this.onHide.bind(this);
    this.state = {
      show: true
    };
  }

  handleDelete() {
    if (this.props.channel.id.length !== constants["N" /* default */].CHANNEL_ID_LENGTH) {
      return;
    }

    if (!this.props.canViewArchivedChannels) {
      const {
        penultimateViewedChannelName
      } = this.props;
      browser_history["a" /* browserHistory */].push('/' + this.props.currentTeamDetails.name + '/channels/' + penultimateViewedChannelName);
    }

    this.props.actions.deleteChannel(this.props.channel.id);
    this.onHide();
  }

  onHide() {
    this.setState({
      show: false
    });
  }

  render() {
    const {
      canViewArchivedChannels
    } = this.props;
    return react_default.a.createElement(Modal["a" /* default */], {
      show: this.state.show,
      onHide: this.onHide,
      onExited: this.props.onHide,
      role: "dialog",
      "aria-labelledby": "deleteChannelModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "deleteChannelModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "delete_channel.confirm",
      defaultMessage: "Confirm ARCHIVE Channel"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement("div", {
      className: "alert alert-danger"
    }, !canViewArchivedChannels && react_default.a.createElement(formatted_markdown_message["b" /* default */], {
      id: "delete_channel.question",
      defaultMessage: "This will archive the channel from the team and make its contents inaccessible for all users. \\n \\nAre you sure you wish to archive the **{display_name}** channel?",
      values: {
        display_name: this.props.channel.display_name
      }
    }), canViewArchivedChannels && react_default.a.createElement(formatted_markdown_message["b" /* default */], {
      id: "delete_channel.viewArchived.question",
      defaultMessage: 'This will archive the channel from the team. Channel contents will still be accessible by channel members.\n \nAre you sure you wish to archive the **{display_name}** channel?',
      values: {
        display_name: this.props.channel.display_name
      }
    }))), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-link",
      onClick: this.onHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "delete_channel.cancel",
      defaultMessage: "Cancel"
    })), react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-danger",
      "data-dismiss": "modal",
      onClick: this.handleDelete,
      autoFocus: true
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "delete_channel.del",
      defaultMessage: "Archive"
    }))));
  }

}

delete_channel_modal_defineProperty(delete_channel_modal_DeleteChannelModal, "propTypes", {
  /**
  * Function called when modal is dismissed
  */
  onHide: prop_types_default.a.func.isRequired,

  /**
   * channel data
   */
  channel: prop_types_default.a.object.isRequired,

  /**
   * currentTeamDetails used for redirection after deleting channel
   */
  currentTeamDetails: prop_types_default.a.object.isRequired,
  canViewArchivedChannels: prop_types_default.a.bool,
  penultimateViewedChannelName: prop_types_default.a.string.isRequired,
  actions: prop_types_default.a.shape({
    /**
    * Function called for deleting channel,
    */
    deleteChannel: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/delete_channel_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function delete_channel_modal_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  return {
    canViewArchivedChannels: config.ExperimentalViewArchivedChannels === 'true',
    currentTeamDetails: Object(entities_teams["getCurrentTeam"])(state)
  };
}

function delete_channel_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      deleteChannel: actions_channels["deleteChannel"]
    }, dispatch)
  };
}

/* harmony default export */ var delete_channel_modal = (Object(es["connect"])(delete_channel_modal_mapStateToProps, delete_channel_modal_mapDispatchToProps)(delete_channel_modal_DeleteChannelModal));
// EXTERNAL MODULE: ./components/add_groups_to_channel_modal/index.js + 1 modules
var add_groups_to_channel_modal = __webpack_require__(1826);

// CONCATENATED MODULE: ./components/channel_groups_manage_modal/channel_groups_manage_modal.jsx
function channel_groups_manage_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class channel_groups_manage_modal_ChannelGroupsManageModal extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    channel_groups_manage_modal_defineProperty(this, "loadItems", async (pageNumber, searchTerm) => {
      const {
        data
      } = await this.props.actions.getGroupsAssociatedToChannel(this.props.channel.id, searchTerm, pageNumber, DEFAULT_NUM_PER_PAGE);
      return {
        items: data.groups,
        totalCount: data.totalGroupCount
      };
    });

    channel_groups_manage_modal_defineProperty(this, "onClickRemoveGroup", (item, listModal) => this.props.actions.unlinkGroupSyncable(item.id, this.props.channel.id, mattermost_redux_constants["Groups"].SYNCABLE_TYPE_CHANNEL).then(async () => {
      listModal.setState({
        loading: true
      });
      const {
        items
      } = await listModal.props.loadItems(listModal.setState.page, listModal.state.searchTerm);
      listModal.setState({
        loading: false,
        items
      });
    }));

    channel_groups_manage_modal_defineProperty(this, "onHide", () => {
      this.props.actions.closeModal(constants["p" /* ModalIdentifiers */].MANAGE_CHANNEL_GROUPS);
    });

    channel_groups_manage_modal_defineProperty(this, "titleButtonOnClick", () => {
      this.onHide();
      this.props.actions.openModal({
        modalId: constants["p" /* ModalIdentifiers */].ADD_GROUPS_TO_TEAM,
        dialogType: add_groups_to_channel_modal["a" /* default */]
      });
    });

    channel_groups_manage_modal_defineProperty(this, "renderRow", (item, listModal) => {
      return react_default.a.createElement("div", {
        key: item.id,
        className: "more-modal__row"
      }, react_default.a.createElement("img", {
        className: "more-modal__image",
        src: groups_avatar_default.a,
        alt: "group picture",
        width: "32",
        height: "32"
      }), react_default.a.createElement("div", {
        className: "more-modal__details"
      }, react_default.a.createElement("div", {
        className: "more-modal__name"
      }, item.display_name, " ", '-', " ", react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "numMembers",
        defaultMessage: "{num, number} {num, plural, one {member} other {members}}",
        values: {
          num: item.member_count
        }
      })))), react_default.a.createElement("div", {
        className: "more-modal__actions"
      }, react_default.a.createElement("button", {
        id: "removeMember",
        type: "button",
        className: "btn btn-danger btn-message",
        onClick: () => this.onClickRemoveGroup(item, listModal)
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "group_list_modal.removeGroupButton",
        defaultMessage: "Remove Group"
      }))));
    });
  }

  render() {
    const {
      formatMessage
    } = this.context.intl;
    return react_default.a.createElement(list_modal_ListModal, {
      titleText: formatMessage({
        id: 'groups',
        defaultMessage: '{channel} Groups'
      }, {
        channel: this.props.channel.display_name
      }),
      searchPlaceholderText: formatMessage({
        id: 'manage_channel_groups_modal.search_placeholder',
        defaultMessage: 'Search groups'
      }),
      renderRow: this.renderRow,
      loadItems: this.loadItems,
      onHide: this.onHide,
      titleBarButtonText: formatMessage({
        id: 'group_list_modal.addGroupButton',
        defaultMessage: 'Add Groups'
      }),
      titleBarButtonOnClick: this.titleButtonOnClick
    });
  }

}

channel_groups_manage_modal_defineProperty(channel_groups_manage_modal_ChannelGroupsManageModal, "propTypes", {
  channel: prop_types_default.a.object.isRequired,
  actions: prop_types_default.a.shape({
    getGroupsAssociatedToChannel: prop_types_default.a.func.isRequired,
    unlinkGroupSyncable: prop_types_default.a.func.isRequired,
    closeModal: prop_types_default.a.func.isRequired,
    openModal: prop_types_default.a.func.isRequired
  }).isRequired
});

channel_groups_manage_modal_defineProperty(channel_groups_manage_modal_ChannelGroupsManageModal, "contextTypes", {
  intl: index_es["i" /* intlShape */]
});
// CONCATENATED MODULE: ./components/channel_groups_manage_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const channel_groups_manage_modal_mapStateToProps = (state, ownProps) => {
  return {
    channel: state.entities.channels.channels[ownProps.channelID]
  };
};

const channel_groups_manage_modal_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    getGroupsAssociatedToChannel: groups["getGroupsAssociatedToChannel"],
    closeModal: modals["a" /* closeModal */],
    openModal: modals["b" /* openModal */],
    unlinkGroupSyncable: groups["unlinkGroupSyncable"]
  }, dispatch)
});

/* harmony default export */ var channel_groups_manage_modal = (Object(es["connect"])(channel_groups_manage_modal_mapStateToProps, channel_groups_manage_modal_mapDispatchToProps)(channel_groups_manage_modal_ChannelGroupsManageModal));
// CONCATENATED MODULE: ./components/channel_header_dropdown/menu_items/leave_channel/leave_channel.js
function leave_channel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class leave_channel_LeaveChannel extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    leave_channel_defineProperty(this, "handleLeave", e => {
      e.preventDefault();
      const {
        channel,
        actions: {
          leaveChannel
        }
      } = this.props;

      if (channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
        Object(global_actions["m" /* showLeavePrivateChannelModal */])(channel);
      } else {
        leaveChannel(channel.id);
      }
    });
  }

  render() {
    const {
      channel,
      isDefault,
      id
    } = this.props;
    return react_default.a.createElement(menu_item_action["a" /* default */], {
      id: id,
      show: !isDefault && channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL,
      onClick: this.handleLeave,
      text: Object(utils["gb" /* localizeMessage */])('channel_header.leave', 'Leave Channel')
    });
  }

}

leave_channel_defineProperty(leave_channel_LeaveChannel, "propTypes", {
  /**
   * Object with info about user
   */
  channel: prop_types_default.a.object.isRequired,

  /**
   * Boolean whether the channel is default
   */
  isDefault: prop_types_default.a.bool.isRequired,

  /**
   * Use for test selector
   */
  id: prop_types_default.a.string,

  /**
   * Object with action creators
   */
  actions: prop_types_default.a.shape({
    /**
     * Action creator to leave channel
     */
    leaveChannel: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_header_dropdown/menu_items/leave_channel/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const leave_channel_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    leaveChannel: views_channel["f" /* leaveChannel */]
  }, dispatch)
});

/* harmony default export */ var leave_channel = (Object(es["connect"])(null, leave_channel_mapDispatchToProps)(leave_channel_LeaveChannel));
// CONCATENATED MODULE: ./components/channel_header_dropdown/menu_items/close_channel/close_channel.js
function close_channel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class close_channel_CloseChannel extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    close_channel_defineProperty(this, "handleClose", () => {
      this.props.actions.goToLastViewedChannel();
    });
  }

  render() {
    return react_default.a.createElement(menu_item_action["a" /* default */], {
      show: this.props.isArchived,
      onClick: this.handleClose,
      text: Object(utils["gb" /* localizeMessage */])('center_panel.archived.closeChannel', 'Close Channel')
    });
  }

}

close_channel_defineProperty(close_channel_CloseChannel, "propTypes", {
  isArchived: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    goToLastViewedChannel: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_header_dropdown/menu_items/close_channel/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const close_channel_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    goToLastViewedChannel: views_channel["c" /* goToLastViewedChannel */]
  }, dispatch)
});

/* harmony default export */ var close_channel = (Object(es["connect"])(null, close_channel_mapDispatchToProps)(close_channel_CloseChannel));
// CONCATENATED MODULE: ./components/channel_header_dropdown/menu_items/toggle_mute_channel/toggle_mute_channel.js
function toggle_mute_channel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class toggle_mute_channel_MenuItemToggleMuteChannel extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    toggle_mute_channel_defineProperty(this, "handleClick", () => {
      const {
        user,
        channel,
        isMuted,
        actions: {
          updateChannelNotifyProps
        }
      } = this.props;
      updateChannelNotifyProps(user.id, channel.id, {
        mark_unread: isMuted ? constants["q" /* NotificationLevels */].ALL : constants["q" /* NotificationLevels */].MENTION
      });
    });
  }

  render() {
    const {
      channel,
      id,
      isMuted
    } = this.props;
    let text;

    if (isMuted) {
      text = Object(utils["gb" /* localizeMessage */])('channel_header.unmute', 'Unmute Channel');
    } else {
      text = Object(utils["gb" /* localizeMessage */])('channel_header.mute', 'Mute Channel');
    }

    return react_default.a.createElement(menu_item_action["a" /* default */], {
      id: id,
      show: channel.type !== constants["g" /* Constants */].DM_CHANNEL,
      onClick: this.handleClick,
      text: text
    });
  }

}

toggle_mute_channel_defineProperty(toggle_mute_channel_MenuItemToggleMuteChannel, "propTypes", {
  /**
   * Object with info about the current user
   */
  user: prop_types_default.a.object.isRequired,

  /**
   * Object with info about the current channel
   */
  channel: prop_types_default.a.object.isRequired,

  /**
   * Boolean whether the current channel is muted
   */
  isMuted: prop_types_default.a.bool.isRequired,

  /**
   * Use for test selector
   */
  id: prop_types_default.a.string,

  /**
   * Object with action creators
   */
  actions: prop_types_default.a.shape({
    updateChannelNotifyProps: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_header_dropdown/menu_items/toggle_mute_channel/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const toggle_mute_channel_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    updateChannelNotifyProps: actions_channels["updateChannelNotifyProps"]
  }, dispatch)
});

/* harmony default export */ var toggle_mute_channel = (Object(es["connect"])(null, toggle_mute_channel_mapDispatchToProps)(toggle_mute_channel_MenuItemToggleMuteChannel));
// CONCATENATED MODULE: ./components/channel_header_dropdown/menu_items/toggle_favorite_channel/toggle_favorite_channel.js
function toggle_favorite_channel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class toggle_favorite_channel_ToggleFavoriteChannel extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    toggle_favorite_channel_defineProperty(this, "toggleFavoriteChannel", channelId => {
      const {
        isFavorite,
        actions: {
          favoriteChannel,
          unfavoriteChannel
        }
      } = this.props;
      return isFavorite ? unfavoriteChannel(channelId) : favoriteChannel(channelId);
    });

    toggle_favorite_channel_defineProperty(this, "handleClick", e => {
      e.preventDefault();
      this.toggleFavoriteChannel(this.props.channel.id);
    });
  }

  render() {
    let text;

    if (this.props.isFavorite) {
      text = Object(utils["gb" /* localizeMessage */])('channelHeader.removeFromFavorites', 'Remove from Favorites');
    } else {
      text = Object(utils["gb" /* localizeMessage */])('channelHeader.addToFavorites', 'Add to Favorites');
    }

    return react_default.a.createElement(menu_item_action["a" /* default */], {
      show: this.props.show,
      onClick: this.handleClick,
      text: text
    });
  }

}

toggle_favorite_channel_defineProperty(toggle_favorite_channel_ToggleFavoriteChannel, "propTypes", {
  show: prop_types_default.a.bool.isRequired,
  channel: prop_types_default.a.object.isRequired,
  isFavorite: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    favoriteChannel: prop_types_default.a.func.isRequired,
    unfavoriteChannel: prop_types_default.a.func.isRequired
  }).isRequired
});

toggle_favorite_channel_defineProperty(toggle_favorite_channel_ToggleFavoriteChannel, "defaultProps", {
  show: true
});
// CONCATENATED MODULE: ./components/channel_header_dropdown/menu_items/toggle_favorite_channel/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const toggle_favorite_channel_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    favoriteChannel: actions_channels["favoriteChannel"],
    unfavoriteChannel: actions_channels["unfavoriteChannel"]
  }, dispatch)
});

/* harmony default export */ var toggle_favorite_channel = (Object(es["connect"])(null, toggle_favorite_channel_mapDispatchToProps)(toggle_favorite_channel_ToggleFavoriteChannel));
// CONCATENATED MODULE: ./components/channel_header_dropdown/menu_items/view_pinned_posts/view_pinned_posts.js
function view_pinned_posts_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class view_pinned_posts_ViewPinnedPosts extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    view_pinned_posts_defineProperty(this, "handleClick", e => {
      e.preventDefault();
      const {
        channel,
        hasPinnedPosts,
        actions: {
          closeRightHandSide,
          showPinnedPosts
        }
      } = this.props;

      if (hasPinnedPosts) {
        closeRightHandSide();
      } else {
        showPinnedPosts(channel.id);
      }
    });
  }

  render() {
    return react_default.a.createElement(menu_item_action["a" /* default */], {
      show: this.props.show,
      onClick: this.handleClick,
      text: Object(utils["gb" /* localizeMessage */])('navbar.viewPinnedPosts', 'View Pinned Posts')
    });
  }

}

view_pinned_posts_defineProperty(view_pinned_posts_ViewPinnedPosts, "propTypes", {
  show: prop_types_default.a.bool,
  channel: prop_types_default.a.object.isRequired,
  hasPinnedPosts: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    closeRightHandSide: prop_types_default.a.func.isRequired,
    showPinnedPosts: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_header_dropdown/menu_items/view_pinned_posts/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const view_pinned_posts_mapStateToProps = state => ({
  hasPinnedPosts: Object(selectors_rhs["m" /* getRhsState */])(state) === constants["x" /* RHSStates */].PIN
});

const view_pinned_posts_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    closeRightHandSide: rhs["b" /* closeRightHandSide */],
    showPinnedPosts: rhs["q" /* showPinnedPosts */]
  }, dispatch)
});

/* harmony default export */ var view_pinned_posts = (Object(es["connect"])(view_pinned_posts_mapStateToProps, view_pinned_posts_mapDispatchToProps)(view_pinned_posts_ViewPinnedPosts));
// CONCATENATED MODULE: ./components/channel_header_dropdown/channel_header_dropdown_items.js
function channel_header_dropdown_items_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



























class channel_header_dropdown_items_ChannelHeaderDropdown extends react_default.a.PureComponent {
  render() {
    const {
      user,
      channel,
      isDefault,
      isFavorite,
      isMuted,
      isReadonly,
      isArchived,
      isMobile,
      penultimateViewedChannelName
    } = this.props;
    const isPrivate = channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL;
    const isGroupConstrained = channel.group_constrained === true;
    const channelMembersPermission = isPrivate ? mattermost_redux_constants["Permissions"].MANAGE_PRIVATE_CHANNEL_MEMBERS : mattermost_redux_constants["Permissions"].MANAGE_PUBLIC_CHANNEL_MEMBERS;
    const channelPropertiesPermission = isPrivate ? mattermost_redux_constants["Permissions"].MANAGE_PRIVATE_CHANNEL_PROPERTIES : mattermost_redux_constants["Permissions"].MANAGE_PUBLIC_CHANNEL_PROPERTIES;
    const channelDeletePermission = isPrivate ? mattermost_redux_constants["Permissions"].DELETE_PRIVATE_CHANNEL : mattermost_redux_constants["Permissions"].DELETE_PUBLIC_CHANNEL;
    let divider;

    if (isMobile) {
      divider = react_default.a.createElement("li", {
        className: "MenuGroup mobile-menu-divider"
      }, react_default.a.createElement("hr", null));
    }

    return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(menu_group["a" /* default */], {
      divider: divider
    }, react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelViewInfo",
      show: channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL,
      modalId: constants["p" /* ModalIdentifiers */].CHANNEL_INFO,
      dialogType: channel_info_modal,
      dialogProps: {
        channel
      },
      text: Object(utils["gb" /* localizeMessage */])('navbar.viewInfo', 'View Info')
    }), react_default.a.createElement(toggle_favorite_channel, {
      id: "channelToggleFavorite",
      show: isMobile,
      channel: channel,
      isFavorite: isFavorite
    }), react_default.a.createElement(view_pinned_posts, {
      id: "channelViewPinnedPosts",
      show: isMobile,
      channel: channel
    }), react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelNotificationPreferences",
      show: channel.type !== constants["g" /* Constants */].DM_CHANNEL && !isArchived,
      modalId: constants["p" /* ModalIdentifiers */].CHANNEL_NOTIFICATIONS,
      dialogType: channel_notifications_modal,
      dialogProps: {
        channel,
        currentUser: user
      },
      text: Object(utils["gb" /* localizeMessage */])('navbar.preferences', 'Notification Preferences')
    }), react_default.a.createElement(toggle_mute_channel, {
      id: "channelToggleMuteChannel",
      user: user,
      channel: channel,
      isMuted: isMuted,
      isArchived: isArchived
    })), react_default.a.createElement(menu_group["a" /* default */], {
      divider: divider
    }, react_default.a.createElement(channel_permission_gate["a" /* default */], {
      channelId: channel.id,
      teamId: channel.team_id,
      permissions: [channelMembersPermission]
    }, react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelAddMembers",
      show: channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL && !isArchived && !isDefault && !isGroupConstrained,
      modalId: constants["p" /* ModalIdentifiers */].CHANNEL_INVITE,
      dialogType: channel_new_invite_modal["a" /* default */],
      dialogProps: {
        channel
      },
      text: Object(utils["gb" /* localizeMessage */])('navbar.addMembers', 'Add Members')
    }), react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelAddMembers",
      show: channel.type === constants["g" /* Constants */].GM_CHANNEL && !isArchived && !isGroupConstrained,
      modalId: constants["p" /* ModalIdentifiers */].CREATE_DM_CHANNEL,
      dialogType: more_direct_channels,
      dialogProps: {
        isExistingChannel: true
      },
      text: Object(utils["gb" /* localizeMessage */])('navbar.addMembers', 'Add Members')
    })), react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelViewMembers",
      show: channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL && (isArchived || isDefault),
      modalId: constants["p" /* ModalIdentifiers */].CHANNEL_MEMBERS,
      dialogType: channel_members_modal,
      dialogProps: {
        channel
      },
      text: Object(utils["gb" /* localizeMessage */])('channel_header.viewMembers', 'View Members')
    }), react_default.a.createElement(channel_permission_gate["a" /* default */], {
      channelId: channel.id,
      teamId: channel.team_id,
      permissions: [channelMembersPermission]
    }, react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelAddGroups",
      show: channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL && !isArchived && !isDefault && isGroupConstrained,
      modalId: constants["p" /* ModalIdentifiers */].ADD_GROUPS_TO_CHANNEL,
      dialogType: add_groups_to_channel_modal["a" /* default */],
      dialogProps: {},
      text: Object(utils["gb" /* localizeMessage */])('navbar.addGroups', 'Add Groups')
    }), react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelManageGroups",
      show: channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL && !isArchived && !isDefault && isGroupConstrained,
      modalId: constants["p" /* ModalIdentifiers */].MANAGE_CHANNEL_GROUPS,
      dialogType: channel_groups_manage_modal,
      dialogProps: {
        channelID: channel.id
      },
      text: Object(utils["gb" /* localizeMessage */])('navbar_dropdown.manageGroups', 'Manage Groups')
    }), react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelManageMembers",
      show: channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL && !isArchived && !isDefault,
      modalId: constants["p" /* ModalIdentifiers */].CHANNEL_MEMBERS,
      dialogType: channel_members_modal,
      dialogProps: {
        channel
      },
      text: Object(utils["gb" /* localizeMessage */])('channel_header.manageMembers', 'Manage Members')
    })), react_default.a.createElement(channel_permission_gate["a" /* default */], {
      channelId: channel.id,
      teamId: channel.team_id,
      permissions: [channelMembersPermission],
      invert: true
    }, react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelViewMembers",
      show: channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL && !isArchived && !isDefault,
      modalId: constants["p" /* ModalIdentifiers */].CHANNEL_MEMBERS,
      dialogType: channel_members_modal,
      dialogProps: {
        channel
      },
      text: Object(utils["gb" /* localizeMessage */])('channel_header.viewMembers', 'View Members')
    }))), react_default.a.createElement(menu_group["a" /* default */], {
      divider: divider
    }, react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelEditHeader",
      show: (channel.type === constants["g" /* Constants */].DM_CHANNEL || channel.type === constants["g" /* Constants */].GM_CHANNEL) && !isArchived && !isReadonly,
      modalId: constants["p" /* ModalIdentifiers */].EDIT_CHANNEL_HEADER,
      dialogType: components_edit_channel_header_modal,
      dialogProps: {
        channel
      },
      text: Object(utils["gb" /* localizeMessage */])('channel_header.setHeader', 'Edit Channel Header')
    }), react_default.a.createElement(channel_permission_gate["a" /* default */], {
      channelId: channel.id,
      teamId: channel.team_id,
      permissions: [channelPropertiesPermission]
    }, react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelEditHeader",
      show: channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL && !isArchived && !isReadonly,
      modalId: constants["p" /* ModalIdentifiers */].EDIT_CHANNEL_HEADER,
      dialogType: components_edit_channel_header_modal,
      dialogProps: {
        channel
      },
      text: Object(utils["gb" /* localizeMessage */])('channel_header.setHeader', 'Edit Channel Header')
    }), react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelEditPurpose",
      show: !isArchived && !isReadonly && channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL,
      modalId: constants["p" /* ModalIdentifiers */].EDIT_CHANNEL_PURPOSE,
      dialogType: edit_channel_purpose_modal,
      dialogProps: {
        channel
      },
      text: Object(utils["gb" /* localizeMessage */])('channel_header.setPurpose', 'Edit Channel Purpose')
    }), react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelRename",
      show: !isArchived && channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL,
      modalId: constants["p" /* ModalIdentifiers */].RENAME_CHANNEL,
      dialogType: rename_channel_modal,
      dialogProps: {
        channel
      },
      text: Object(utils["gb" /* localizeMessage */])('channel_header.rename', 'Rename Channel')
    })), react_default.a.createElement(team_permission_gate["a" /* default */], {
      teamId: channel.team_id,
      permissions: [mattermost_redux_constants["Permissions"].MANAGE_TEAM]
    }, react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelCovertToPrivate",
      show: !isArchived && !isDefault && channel.type === constants["g" /* Constants */].OPEN_CHANNEL,
      modalId: constants["p" /* ModalIdentifiers */].CONVERT_CHANNEL,
      dialogType: convert_channel_modal,
      dialogProps: {
        channelId: channel.id,
        channelDisplayName: channel.display_name
      },
      text: Object(utils["gb" /* localizeMessage */])('channel_header.convert', 'Convert to Private Channel')
    })), react_default.a.createElement(channel_permission_gate["a" /* default */], {
      channelId: channel.id,
      teamId: channel.team_id,
      permissions: [channelDeletePermission]
    }, react_default.a.createElement(menu_item_toggle_modal_redux["a" /* default */], {
      id: "channelArchiveChannel",
      show: !isArchived && !isDefault && channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.type !== constants["g" /* Constants */].GM_CHANNEL,
      modalId: constants["p" /* ModalIdentifiers */].DELETE_CHANNEL,
      dialogType: delete_channel_modal,
      dialogProps: {
        channel,
        penultimateViewedChannelName
      },
      text: Object(utils["gb" /* localizeMessage */])('channel_header.delete', 'Archive Channel')
    }))), react_default.a.createElement(menu_group["a" /* default */], {
      divider: divider
    }, isMobile && react_default.a.createElement(mobile_channel_header_plug, {
      channel: channel,
      isDropdown: true
    }), react_default.a.createElement(leave_channel, {
      id: "channelLeaveChannel",
      channel: channel,
      isDefault: isDefault
    }), react_default.a.createElement(close_channel, {
      id: "channelCloseChannel",
      isArchived: isArchived
    })));
  }

}

channel_header_dropdown_items_defineProperty(channel_header_dropdown_items_ChannelHeaderDropdown, "propTypes", {
  user: prop_types_default.a.object.isRequired,
  channel: prop_types_default.a.object.isRequired,
  isDefault: prop_types_default.a.bool.isRequired,
  isFavorite: prop_types_default.a.bool.isRequired,
  isReadonly: prop_types_default.a.bool.isRequired,
  isMuted: prop_types_default.a.bool.isRequired,
  isArchived: prop_types_default.a.bool.isRequired,
  isMobile: prop_types_default.a.bool.isRequired,
  penultimateViewedChannelName: prop_types_default.a.string.isRequired
});
// CONCATENATED MODULE: ./components/channel_header_dropdown/mobile_channel_header_dropdown_animation.jsx
function mobile_channel_header_dropdown_animation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



const mobile_channel_header_dropdown_animation_ANIMATION_DURATION = 350;
class mobile_channel_header_dropdown_animation_MobileChannelHeaderDropdownAnimation extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement(CSSTransition["a" /* default */], {
      in: this.props.show,
      classNames: "mobile-channel-header-dropdown",
      enter: true,
      exit: true,
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: {
        enter: mobile_channel_header_dropdown_animation_ANIMATION_DURATION,
        exit: mobile_channel_header_dropdown_animation_ANIMATION_DURATION
      }
    }, this.props.children);
  }

}

mobile_channel_header_dropdown_animation_defineProperty(mobile_channel_header_dropdown_animation_MobileChannelHeaderDropdownAnimation, "propTypes", {
  children: prop_types_default.a.node,
  show: prop_types_default.a.bool.isRequired
});
// CONCATENATED MODULE: ./components/channel_header_dropdown/mobile_channel_header_dropdown.js
function mobile_channel_header_dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










class mobile_channel_header_dropdown_MobileChannelHeaderDropdown extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    mobile_channel_header_dropdown_defineProperty(this, "getChannelTitle", () => {
      const {
        user,
        channel,
        teammateId
      } = this.props;

      if (channel.type === constants["g" /* Constants */].DM_CHANNEL) {
        const displayname = Object(utils["x" /* getDisplayNameByUserId */])(teammateId);

        if (user.id === teammateId) {
          return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "channel_header.directchannel.you",
            defaultMessage: "{displayname} (you)",
            values: {
              displayname
            }
          });
        }

        return displayname;
      }

      return channel.display_name;
    });
  }

  render() {
    const {
      teammateIsBot,
      teammateStatus
    } = this.props;
    let dmHeaderIconStatus;

    if (!teammateIsBot) {
      dmHeaderIconStatus = react_default.a.createElement(status_icon["a" /* default */], {
        status: teammateStatus
      });
    }

    return react_default.a.createElement(menu_wrapper["a" /* default */], {
      animationComponent: mobile_channel_header_dropdown_animation_MobileChannelHeaderDropdownAnimation
    }, react_default.a.createElement("a", null, react_default.a.createElement("span", {
      className: "heading"
    }, dmHeaderIconStatus, this.getChannelTitle()), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.dropdown",
      defaultMessage: "Dropdown Icon"
    }, title => react_default.a.createElement("span", {
      className: "fa fa-angle-down header-dropdown__icon",
      title: title
    }))), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channel_header.menuAriaLabel",
      defaultMessage: "Channel Menu"
    }, ariaLabel => react_default.a.createElement(menu_menu["a" /* default */], {
      ariaLabel: ariaLabel
    }, react_default.a.createElement(ChannelHeaderDropdownItems, {
      isMobile: true
    }), react_default.a.createElement("div", {
      className: "close visible-xs-block"
    }, '×'))));
  }

}

mobile_channel_header_dropdown_defineProperty(mobile_channel_header_dropdown_MobileChannelHeaderDropdown, "propTypes", {
  user: prop_types_default.a.object.isRequired,
  channel: prop_types_default.a.object.isRequired,
  teammateId: prop_types_default.a.string,
  teammateIsBot: prop_types_default.a.bool,
  teammateStatus: prop_types_default.a.string
});
// CONCATENATED MODULE: ./components/channel_header_dropdown/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











const getTeammateId = Object(reselect_es["a" /* createSelector */])(entities_channels["getCurrentChannel"], channel => {
  if (channel.type !== constants["g" /* Constants */].DM_CHANNEL) {
    return null;
  }

  return utils["G" /* getUserIdFromChannelName */](channel);
});
const getTeammateStatus = Object(reselect_es["a" /* createSelector */])(entities_users["getUserStatuses"], getTeammateId, (userStatuses, teammateId) => {
  if (!teammateId) {
    return null;
  }

  return userStatuses[teammateId];
});

const channel_header_dropdown_mapStateToProps = state => ({
  user: Object(entities_users["getCurrentUser"])(state),
  channel: Object(entities_channels["getCurrentChannel"])(state),
  isDefault: Object(entities_channels["isCurrentChannelDefault"])(state),
  isFavorite: Object(entities_channels["isCurrentChannelFavorite"])(state),
  isMuted: Object(entities_channels["isCurrentChannelMuted"])(state),
  isReadonly: Object(entities_channels["isCurrentChannelReadOnly"])(state),
  isArchived: Object(entities_channels["isCurrentChannelArchived"])(state),
  penultimateViewedChannelName: Object(selectors_local_storage["c" /* getPenultimateViewedChannelName */])(state) || Object(entities_channels["getRedirectChannelNameForTeam"])(state, Object(entities_teams["getCurrentTeamId"])(state))
});

const mobileMapStateToProps = state => {
  const user = Object(entities_users["getCurrentUser"])(state);
  const channel = Object(entities_channels["getCurrentChannel"])(state);
  const teammateId = getTeammateId(state);
  let teammateIsBot = false;

  if (teammateId) {
    const teammate = Object(entities_users["getUser"])(state, teammateId);
    teammateIsBot = teammate ? teammate.is_bot : false; //原因未明 先不报错
  }

  return {
    user,
    channel,
    teammateId,
    teammateIsBot,
    teammateStatus: getTeammateStatus(state)
  };
};

const components_channel_header_dropdown_ChannelHeaderDropdown = channel_header_dropdown_ChannelHeaderDropdown;
const ChannelHeaderDropdownItems = Object(es["connect"])(channel_header_dropdown_mapStateToProps)(channel_header_dropdown_items_ChannelHeaderDropdown);
const channel_header_dropdown_MobileChannelHeaderDropdown = Object(es["connect"])(mobileMapStateToProps)(mobile_channel_header_dropdown_MobileChannelHeaderDropdown);
// EXTERNAL MODULE: ./images/mention-btn.png
var mention_btn = __webpack_require__(2989);

// EXTERNAL MODULE: ./images/flag-btn.png
var images_flag_btn = __webpack_require__(2990);

// EXTERNAL MODULE: ./images/cloud-btn.png
var cloud_btn = __webpack_require__(2991);

// EXTERNAL MODULE: ./api/search.js
var api_search = __webpack_require__(1809);

// CONCATENATED MODULE: ./actions/views/search_chat.js

 // 更新搜索关键字

function updateSearchKeyword(keyword) {
  return async (dispatch, getState) => {
    return dispatch({
      type: constants["b" /* ActionTypes */].UPDATE_SEARCH_KEYWORD,
      keyword
    });
  };
} // 打开搜索

function openSearch() {
  return async (dispatch, getState) => {
    dispatch({
      type: constants["b" /* ActionTypes */].OPEN_SEARCH
    });
  };
} // 关闭搜索

function closeSearch() {
  return async (dispatch, getState) => {
    dispatch({
      type: constants["b" /* ActionTypes */].CLOSE_SEARCH
    });
  };
} // 搜索

function search_chat_search() {
  return async (dispatch, getState) => {
    const state = getState();
    const teamId = state.entities.teams.currentTeamId;
    const {
      keyword
    } = state.views.searchchat.searchchat;

    if (keyword.length === 0) {
      return dispatch({
        type: constants["b" /* ActionTypes */].UPDATE_SEARCH_RESULT,
        result: {
          keyword,
          contacts: [],
          channels: [],
          posts: [],
          clouds: []
        }
      });
    }

    dispatch({
      type: constants["b" /* ActionTypes */].START_SEARCH
    }); // call api

    const contactPromise = new Promise(resolve => {
      Object(api_search["e" /* searchContacts */])({
        team_id: teamId,
        term: keyword
      }).then(res => {
        console.log('contact res:', res);
        resolve(res.data);
      }, () => {
        resolve([]);
      });
    });
    const channelPromise = new Promise(resolve => {
      Object(api_search["c" /* searchChannels */])({
        team_id: teamId,
        term: keyword
      }).then(res => {
        console.log('channel res:', res);
        resolve(res.data);
      }, () => {
        resolve([]);
      });
    });
    const postPromise = new Promise(resolve => {
      Object(api_search["f" /* searchPosts */])({
        team_id: teamId,
        term: keyword
      }).then(res => {
        console.log('post res:', res);
        resolve(res.data);
      }, () => {
        resolve([]);
      });
    });
    const cloudPromise = new Promise(resolve => {
      Object(api_search["d" /* searchClouds */])({
        team_id: teamId,
        term: keyword
      }).then(res => {
        console.log('cloud res:', res);
        resolve(res.data);
      }, () => {
        resolve([]);
      });
    });
    const [contacts, channels, posts, clouds] = await Promise.all([contactPromise, channelPromise, postPromise, cloudPromise]); // const [contacts, channels, posts, clouds] = await new Promise((resolve, reject) => {
    //     setTimeout(() => {
    //         resolve([
    //             [1, 2, 3, 4, 5], 
    //             [1, 2, 3], 
    //             [], 
    //             [1],
    //         ]);
    //     }, 1000);
    // });

    dispatch({
      type: constants["b" /* ActionTypes */].UPDATE_SEARCH_RESULT,
      result: {
        keyword,
        contacts,
        channels,
        posts,
        clouds
      }
    });
  };
} // 打开聊天内容modal

function openPostModal({
  team_id,
  record
}) {
  return async (dispatch, getState) => {
    dispatch({
      type: constants["b" /* ActionTypes */].OPEN_POST_MODAL,
      team_id,
      record
    });
  };
} // 关闭聊天内容modal

function search_chat_closePostModal() {
  return async (dispatch, getState) => {
    dispatch({
      type: constants["b" /* ActionTypes */].CLOSE_POST_MODAL
    });
  };
} // 打开云盘modal

function openCloudModal({
  team_id,
  record
}) {
  return async (dispatch, getState) => {
    dispatch({
      type: constants["b" /* ActionTypes */].OPEN_CLOUD_MODAL,
      team_id,
      record
    });
  };
} // 关闭云盘modal

function search_chat_closeCloudModal() {
  return async (dispatch, getState) => {
    dispatch({
      type: constants["b" /* ActionTypes */].CLOSE_CLOUD_MODAL
    });
  };
}
// EXTERNAL MODULE: ./node_modules/react-outside-click-handler/index.js
var react_outside_click_handler = __webpack_require__(1863);
var react_outside_click_handler_default = /*#__PURE__*/__webpack_require__.n(react_outside_click_handler);

// EXTERNAL MODULE: ./node_modules/antd/es/tabs/index.js + 8 modules
var es_tabs = __webpack_require__(3434);

// EXTERNAL MODULE: ./components/search_chat/index.scss
var search_chat = __webpack_require__(2992);

// EXTERNAL MODULE: ./components/search_chat_contact_item/index.jsx
var search_chat_contact_item = __webpack_require__(2031);

// EXTERNAL MODULE: ./components/ao_keyword_highlight/index.js
var ao_keyword_highlight = __webpack_require__(1732);

// EXTERNAL MODULE: ./components/search_chat_channel_item/index.scss
var search_chat_channel_item = __webpack_require__(2993);

// CONCATENATED MODULE: ./components/search_chat_channel_item/index.jsx

 // import {Tabs} from 'antd';
// import * as Utils from "utils/utils.jsx";




/* harmony default export */ var components_search_chat_channel_item = (({
  data,
  keyword,
  getUserByChannel,
  onClick
}) => {
  // 频道图标处理
  let channelIcon = data.icon_id;
  const reg = /public_|private_/;

  if (!channelIcon || !reg.test(channelIcon)) {
    channelIcon = __webpack_require__(410)(`./${data.type === 'O' ? 'public_00.png' : 'private_00.png'}`);
  } else {
    channelIcon = __webpack_require__(410)(`./${channelIcon}`);
  }

  if (data.type === 'D') {
    const user = getUserByChannel(data.id);

    if (user) {
      channelIcon = utils["K" /* imageURLForUser */]({
        id: user.id
      });
    }
  }

  return react_default.a.createElement("div", {
    className: "search-channel-item",
    onClick: onClick
  }, react_default.a.createElement("img", {
    src: channelIcon
  }), react_default.a.createElement("div", null, react_default.a.createElement(ao_keyword_highlight["a" /* default */], {
    content: data.display_name,
    keyword: keyword
  })));
});
// EXTERNAL MODULE: ./components/search_chat_record_item/index.scss
var search_chat_record_item = __webpack_require__(2994);

// CONCATENATED MODULE: ./components/search_chat_record_item/index.jsx

 // import AoKeywordHighlight from 'components/ao_keyword_highlight';
// import {Tabs} from 'antd';
// import * as Utils from "utils/utils.jsx";



/* harmony default export */ var components_search_chat_record_item = (({
  data,
  keyword,
  getUserByChannel,
  onClick
}) => {
  // 频道图标处理
  let channelIcon = data.channel_icon_id;
  const reg = /public_|private_/;

  if (!channelIcon || !reg.test(channelIcon)) {
    channelIcon = __webpack_require__(410)(`./${data.channel_type === 'O' ? 'public_00.png' : 'private_00.png'}`);
  } else {
    channelIcon = __webpack_require__(410)(`./${channelIcon}`);
  }

  if (data.channel_type === 'D') {
    const user = getUserByChannel(data.channel_id);

    if (user) {
      channelIcon = utils["K" /* imageURLForUser */]({
        id: user.id
      });
    }
  }

  return react_default.a.createElement("div", {
    className: "search-record-item",
    onClick: onClick
  }, react_default.a.createElement("img", {
    src: channelIcon
  }), react_default.a.createElement("div", null, react_default.a.createElement("div", null, data.channel_display_name), react_default.a.createElement("div", {
    className: "sub-desc"
  }, data.count, "\u6761\u76F8\u5173\u804A\u5929\u8BB0\u5F55")));
});
// EXTERNAL MODULE: ./components/search_chat_clouddisk_item/index.scss
var search_chat_clouddisk_item = __webpack_require__(2995);

// CONCATENATED MODULE: ./components/search_chat_clouddisk_item/index.jsx


 // import {Tabs} from 'antd';



/* harmony default export */ var components_search_chat_clouddisk_item = (({
  data,
  keyword,
  getUserByChannel,
  onClick
}) => {
  // 频道图标处理
  let channelIcon = data.channel_icon_id;
  const reg = /public_|private_/;

  if (!channelIcon || !reg.test(channelIcon)) {
    channelIcon = __webpack_require__(410)(`./${data.channel_type === 'O' ? 'public_00.png' : 'private_00.png'}`);
  } else {
    channelIcon = __webpack_require__(410)(`./${channelIcon}`);
  }

  if (data.channel_type === 'D') {
    const user = getUserByChannel(data.channel_id);

    if (user) {
      channelIcon = utils["K" /* imageURLForUser */]({
        id: user.id
      });
    }
  }

  return react_default.a.createElement("div", {
    className: "search-colud-disk-item",
    onClick: onClick
  }, react_default.a.createElement("img", {
    src: channelIcon
  }), react_default.a.createElement("div", null, react_default.a.createElement(ao_keyword_highlight["a" /* default */], {
    content: data.channel_display_name,
    keyword: keyword
  }), react_default.a.createElement("div", {
    className: "sub-desc"
  }, data.count, "\u6761\u76F8\u5173\u8BB0\u5F55")));
});
// CONCATENATED MODULE: ./components/search_chat/search_chat.jsx











const NoData = ({
  keyword
}) => {
  return react_default.a.createElement("div", {
    style: {
      textAlign: 'center',
      paddingTop: '20px'
    }
  }, `没有关于“${keyword}”的结果`);
};

const count2preview = 2;
const TYPE = {
  CONTACT: '联系人',
  CHANNEL: '频道',
  POST: '聊天记录',
  CLOUD: '云盘'
};

const SearchChat = ({
  keyword,
  team_id,
  contacts,
  channels,
  posts,
  clouds,
  teamUrl,
  currentUserId,
  currentUser,
  getUserByChannel,
  getChannelPreference,
  actions
}) => {
  const [activeKey, setActiveKey] = Object(react["useState"])('全部');
  const config = [{
    title: TYPE.CONTACT,
    sc: search_chat_contact_item["a" /* default */],
    list: contacts
  }, {
    title: TYPE.CHANNEL,
    sc: components_search_chat_channel_item,
    list: channels
  }, {
    title: TYPE.POST,
    sc: components_search_chat_record_item,
    list: posts
  }, {
    title: TYPE.CLOUD,
    sc: components_search_chat_clouddisk_item,
    list: clouds
  }];

  const createItem = (title, data, Comp, idx, currentUser, getUserByChannel) => {
    const props = {
      key: idx,
      data,
      keyword,
      currentUser,
      getUserByChannel
    };

    if (title === TYPE.CONTACT) {
      const link = currentUserId !== data.id ? `${teamUrl}/messages/@${data.username}` : '';
      props.onClick = link ? () => {
        browser_history["a" /* browserHistory */].push(link);
        actions.closeSearch();
      } : null;
    }

    if (title === TYPE.POST) {
      props.onClick = () => {
        actions.closeSearch();
        actions.openPostModal({
          record: data,
          team_id
        });
      };
    }

    if (title === TYPE.CLOUD) {
      props.onClick = () => {
        actions.closeSearch();
        actions.openCloudModal({
          record: data,
          team_id
        });
      };
    }

    if (title === TYPE.CHANNEL) {
      props.onClick = () => {
        // 如果频道是关闭的，则设置打开
        if (!getChannelPreference(data.id)) {
          actions.setChannelVisible([data.id], 'true');
        }

        actions.closeSearch();
        browser_history["a" /* browserHistory */].push(`${teamUrl}/channels/${data.name}`);
      };
    }

    return react_default.a.createElement(Comp, props);
  };

  const hasRes = !!config.find(({
    list
  }) => list.length);
  const allPane = hasRes ? config.map(({
    title,
    sc: Comp,
    list
  }) => {
    if (list.length === 0) {
      return null;
    }

    return react_default.a.createElement("div", {
      className: "result-section",
      key: title
    }, react_default.a.createElement("div", {
      className: "result-section-title"
    }, title, react_default.a.createElement("div", {
      className: "result-section-more",
      onClick: e => setActiveKey(title)
    }, "\u67E5\u770B\u5168\u90E8")), list.slice(0, count2preview).map((item, idx) => createItem(title, item, Comp, idx, currentUser, getUserByChannel)));
  }) : react_default.a.createElement(NoData, {
    keyword: keyword
  });
  return react_default.a.createElement("div", {
    id: "search-result"
  }, react_default.a.createElement(es_tabs["a" /* default */], {
    activeKey: activeKey,
    onChange: setActiveKey
  }, react_default.a.createElement(es_tabs["a" /* default */].TabPane, {
    tab: "\u5168\u90E8",
    key: "\u5168\u90E8"
  }, allPane), config.map(({
    title,
    sc: Comp,
    list
  }) => {
    return react_default.a.createElement(es_tabs["a" /* default */].TabPane, {
      tab: title,
      key: title
    }, list.length ? list.map((item, idx) => createItem(title, item, Comp, idx, currentUser, getUserByChannel)) : react_default.a.createElement(NoData, {
      keyword: keyword
    }));
  })));
};

/* harmony default export */ var search_chat_search_chat = (SearchChat);
// CONCATENATED MODULE: ./components/search_chat/index.jsx











function search_chat_mapStateToProps(state) {
  // console.log('[search_chat]:', state);
  const {
    result: {
      keyword,
      contacts,
      channels,
      posts,
      clouds
    }
  } = state.views.searchchat.searchchat;
  const team = Object(entities_teams["getCurrentTeam"])(state); // console.log('team:', team);

  const getChannel = Object(entities_channels["makeGetChannel"])();
  return {
    keyword,
    contacts,
    channels,
    posts,
    clouds,
    teamUrl: Object(entities_teams["getCurrentRelativeTeamUrl"])(state),
    currentUserId: Object(entities_users["getCurrentUserId"])(state),
    currentUser: Object(entities_users["getCurrentUser"])(state),
    team_id: team ? team.id : '',
    getUserByChannel: channelId => {
      const channel = getChannel(state, {
        id: channelId
      }) || {};
      const user = Object(entities_users["getUser"])(state, channel.teammate_id);
      return user;
    },
    getChannelPreference: channelId => {
      return Object(entities_preferences["getBool"])(state, constants["g" /* Constants */].Preferences.CATEGORY_PRIVATE_CHANNEL_SHOW, channelId, true);
    }
  };
}

function search_chat_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      closeSearch: closeSearch,
      openPostModal: openPostModal,
      openCloudModal: openCloudModal,
      setChannelVisible: channel_actions["h" /* setChannelVisible */]
    }, dispatch)
  };
}

/* harmony default export */ var components_search_chat = (Object(es["connect"])(search_chat_mapStateToProps, search_chat_mapDispatchToProps)(search_chat_search_chat));
// EXTERNAL MODULE: ./node_modules/moment/moment.js
var moment = __webpack_require__(2);
var moment_default = /*#__PURE__*/__webpack_require__.n(moment);

// EXTERNAL MODULE: ./components/ao_modal/index.scss
var ao_modal = __webpack_require__(2996);

// CONCATENATED MODULE: ./components/ao_modal/index.js



/* harmony default export */ var components_ao_modal = (props => {
  return react_default.a.createElement("div", {
    className: "ao-modal"
  }, react_default.a.createElement(es_modal["a" /* default */], props));
});
// EXTERNAL MODULE: ./components/ao_fetch_more/index.scss
var ao_fetch_more = __webpack_require__(2997);

// CONCATENATED MODULE: ./components/ao_fetch_more/index.js



const FetchMore = ({
  hasMore,
  fetching,
  onFetchReq
}) => {
  const ele = (() => {
    if (!hasMore) {
      return '没有更多了';
    }

    return fetching ? '加载中...' : react_default.a.createElement("div", {
      onClick: onFetchReq,
      style: {
        cursor: 'pointer'
      }
    }, "\u52A0\u8F7D\u66F4\u591A");
  })();

  return react_default.a.createElement("div", {
    className: "ao-fetchmore"
  }, ele);
};

/* harmony default export */ var components_ao_fetch_more = (FetchMore);
// EXTERNAL MODULE: ./components/ao_post_cards/index.js + 35 modules
var ao_post_cards = __webpack_require__(1821);

// EXTERNAL MODULE: ./utils/text_formatting.jsx
var text_formatting = __webpack_require__(81);

// EXTERNAL MODULE: ./utils/message_html_to_component.jsx + 3 modules
var message_html_to_component = __webpack_require__(1684);

// EXTERNAL MODULE: ./components/ao_search_chat_record_modal/index.scss
var ao_search_chat_record_modal = __webpack_require__(2998);

// CONCATENATED MODULE: ./components/ao_search_chat_record_modal/ao_search_chat_record_modal.jsx














const per_page = 10;

const Other = ({
  post
}) => {
  const htmlFormattedText = text_formatting["e" /* formatText */](post.message);
  return Object(message_html_to_component["a" /* default */])(htmlFormattedText);
};

const SearchChatRecordModal = ({
  opened,
  keyword,
  team_id,
  record,
  getUser,
  currentUser,
  actions: {
    closePostModal
  }
}) => {
  const [page, setPage] = Object(react["useState"])(0);
  const [posts, setPosts] = Object(react["useState"])([]);
  const [fetching, setFetching] = Object(react["useState"])(false);
  const [hasMore, setHasMore] = Object(react["useState"])(true);
  Object(react["useEffect"])(() => {
    if (!opened) {
      return;
    }

    if (!record) {
      return;
    }

    Object(api_search["b" /* filterPost */])({
      team_id,
      channel_id: record.channel_id,
      term: keyword,
      page,
      per_page
    }).then(res => {
      const list = res.data;
      setPosts([...posts, ...list]);
      setHasMore(list.length === per_page);
    });
  }, [opened, keyword, team_id, record, page]);

  const clear = () => {
    setPage(0);
    setPosts([]);
    setFetching(false);
    setHasMore(true);
  };

  return react_default.a.createElement(components_ao_modal, {
    className: 'search-chat-record-modal',
    visible: opened,
    title: "\u67E5\u627E\u804A\u5929\u8BB0\u5F55",
    onCancel: () => closePostModal(),
    footer: null,
    afterClose: clear,
    closeIcon: react_default.a.createElement(es_icon["a" /* default */], {
      type: "close-circle",
      theme: "filled"
    }),
    mask: false,
    maskClosable: false,
    centered: true,
    width: '660px'
  }, react_default.a.createElement("div", {
    className: "search-record-modal-summary"
  }, record && record.count, "\u6761\u4E0E\u201C", keyword, "\u201D\u76F8\u5173\u7684\u641C\u7D22\u7ED3\u679C"), posts.map(post => {
    let avatarUrl = utils["K" /* imageURLForUser */]({
      id: post.user_id
    }); // 当前用户更改头像后需要刷新

    if (currentUser && post.user_id === currentUser.id) {
      avatarUrl = client["Client4"].getProfilePictureUrl(currentUser.id, currentUser.last_picture_update);
    }

    const user = getUser(post.user_id);
    const Card = Object(ao_post_cards["a" /* createCard */])(post);
    const nickname = user ? user.nickname ? user.nickname : "bot" : "账号不存在";
    return react_default.a.createElement("div", {
      className: "search-record-modal-item",
      key: post.id
    }, react_default.a.createElement("img", {
      src: avatarUrl
    }), react_default.a.createElement("div", {
      className: "chat-right"
    }, react_default.a.createElement("div", {
      className: "chat-sender"
    }, nickname, react_default.a.createElement("span", null, moment_default()(post.create_at).format('YYYY-MM-DD HH:mm:ss'))), Card ? react_default.a.createElement("div", {
      style: {
        border: '1px solid #E6E6E6',
        display: 'inline-block',
        margin: '5px 0 0 0'
      }
    }, react_default.a.createElement(Card, {
      post: post,
      channel: {
        id: record ? record.channel_id : ''
      }
    })) : react_default.a.createElement(Other, {
      post: post
    })));
  }), react_default.a.createElement(components_ao_fetch_more, {
    hasMore: hasMore,
    fetching: fetching,
    onFetchReq: () => setPage(page + 1)
  }));
};

/* harmony default export */ var ao_search_chat_record_modal_ao_search_chat_record_modal = (SearchChatRecordModal);
// CONCATENATED MODULE: ./components/ao_search_chat_record_modal/index.jsx







function ao_search_chat_record_modal_mapStateToProps(state) {
  // console.log('meeting_invitation:', state);
  const searchchat = state.views.searchchat;
  const {
    postModal: {
      opened,
      keyword,
      record,
      team_id
    }
  } = state.views.searchchat.searchchat;
  return {
    searchchat,
    team_id,
    opened,
    keyword,
    record,
    getUser: id => state.entities.users.profiles[id],
    currentUser: Object(entities_users["getCurrentUser"])(state)
  };
}

function ao_search_chat_record_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      closePostModal: search_chat_closePostModal
    }, dispatch)
  };
}

/* harmony default export */ var components_ao_search_chat_record_modal = (Object(es["connect"])(ao_search_chat_record_modal_mapStateToProps, ao_search_chat_record_modal_mapDispatchToProps)(ao_search_chat_record_modal_ao_search_chat_record_modal));
// EXTERNAL MODULE: ./components/ao_search_chat_clouddisk_modal/index.scss
var ao_search_chat_clouddisk_modal = __webpack_require__(2999);

// CONCATENATED MODULE: ./components/ao_search_chat_clouddisk_modal/search_chat_clouddisk_modal.jsx










const search_chat_clouddisk_modal_per_page = 10;

const SearchCloudDiskModal = ({
  opened,
  keyword,
  team_id,
  record,
  actions: {
    closeCloudModal
  }
}) => {
  const [page, setPage] = Object(react["useState"])(0);
  const [files, setFiles] = Object(react["useState"])([]);
  const [fetching, setFetching] = Object(react["useState"])(false);
  const [hasMore, setHasMore] = Object(react["useState"])(true);
  Object(react["useEffect"])(() => {
    if (!opened) {
      return;
    }

    Object(api_search["a" /* filterCloud */])({
      team_id,
      channel_id: record.channel_id,
      term: keyword,
      page,
      per_page: search_chat_clouddisk_modal_per_page
    }).then(res => {
      const list = res.data;
      setFiles([...files, ...list]);
      setHasMore(list.length === search_chat_clouddisk_modal_per_page);
    });
  }, [opened, keyword, team_id, record, page]);

  const clear = () => {
    setPage(0);
    setFiles([]);
    setFetching(false);
    setHasMore(true);
  };

  return react_default.a.createElement(components_ao_modal, {
    className: 'search-colud-disk-modal',
    visible: opened,
    title: "\u67E5\u627E\u4E91\u76D8\u5185\u5BB9",
    onCancel: () => closeCloudModal(),
    footer: null,
    afterClose: clear,
    closeIcon: react_default.a.createElement(es_icon["a" /* default */], {
      type: "close-circle",
      theme: "filled"
    }),
    mask: false,
    maskClosable: false,
    centered: true,
    width: '660px'
  }, react_default.a.createElement("div", {
    className: "search-record-modal-summary"
  }, record && record.count, "\u6761\u4E0E\u201C", keyword, "\u201D\u76F8\u5173\u7684\u641C\u7D22\u7ED3\u679C"), files.map(file => {
    // const avatarUrl = Utils.imageURLForUser({
    //     id: file.user_id,
    // });
    console.log("222", file.extension, utils["B" /* getIconClassName */](utils["z" /* getFileType */](file.extension)));
    return react_default.a.createElement("div", {
      className: "search-colud-disk-modal-item",
      key: file.id
    }, react_default.a.createElement("span", {
      className: 'file-icon search ' + utils["B" /* getIconClassName */](utils["z" /* getFileType */](file.extension))
    }), react_default.a.createElement("div", null, react_default.a.createElement(ao_keyword_highlight["a" /* default */], {
      content: file.name,
      keyword: keyword
    }), react_default.a.createElement("div", {
      className: "sub-desc"
    }, moment_default()(file.create_at).format('YYYY-MM-DD HH:mm:ss'))));
  }), react_default.a.createElement(components_ao_fetch_more, {
    hasMore: hasMore,
    fetching: fetching,
    onFetchReq: () => setPage(page + 1)
  }));
};

/* harmony default export */ var search_chat_clouddisk_modal = (SearchCloudDiskModal);
// CONCATENATED MODULE: ./components/ao_search_chat_clouddisk_modal/index.jsx





function ao_search_chat_clouddisk_modal_mapStateToProps(state) {
  // console.log('meeting_invitation:', state);
  const searchchat = state.views.searchchat;
  const {
    cloudModal: {
      opened,
      keyword,
      record,
      team_id
    }
  } = state.views.searchchat.searchchat;
  return {
    searchchat,
    team_id,
    opened,
    keyword,
    record
  };
}

function ao_search_chat_clouddisk_modal_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      closeCloudModal: search_chat_closeCloudModal
    }, dispatch)
  };
}

/* harmony default export */ var components_ao_search_chat_clouddisk_modal = (Object(es["connect"])(ao_search_chat_clouddisk_modal_mapStateToProps, ao_search_chat_clouddisk_modal_mapDispatchToProps)(search_chat_clouddisk_modal));
// CONCATENATED MODULE: ./components/search_box/search_box.jsx
function search_box_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






















const {
  KeyCodes: search_box_KeyCodes
} = constants["N" /* default */];
class search_box_SearchBar extends react_default.a.Component {
  constructor() {
    super();

    search_box_defineProperty(this, "handleClose", () => {
      this.props.actions.closeRightHandSide();
    });

    search_box_defineProperty(this, "handleKeyDown", e => {
      if (utils["V" /* isKeyPressed */](e, search_box_KeyCodes.ESCAPE)) {
        e.stopPropagation();
        e.preventDefault();
      }
    });

    search_box_defineProperty(this, "handleChange", e => {
      this.props.actions.updateSearchKeyword(e.target.value); // 搜索

      this.getDebounceSearch()();
    });

    search_box_defineProperty(this, "handleUserBlur", () => {
      // add time out so that the pinned and member buttons are clickable
      // when focus is released from the search box.
      setTimeout(() => {
        this.setState({
          focused: false
        });
      }, 200);
    });

    search_box_defineProperty(this, "handleClear", () => {
      this.props.actions.updateSearchKeyword('');
    });

    search_box_defineProperty(this, "handleUserFocus", () => {
      this.setState({
        focused: true
      });
      this.props.actions.openSearch();
    });

    search_box_defineProperty(this, "handleSubmit", e => {
      e.preventDefault();
      this.props.actions.search(); // this.search.blur();
    });

    search_box_defineProperty(this, "getSearch", node => {
      this.search = node;
    });

    this.state = {
      focused: false
    };
    this.suggestionProviders = [new search_channel_provider_SearchChannelProvider(), new search_user_provider_SearchUserProvider(), new search_date_provider_SearchDateProvider()];
  }

  componentDidMount() {
    if (utils["Y" /* isMobile */]()) {
      setTimeout(() => {
        const element = document.querySelector('.app__body .sidebar--menu');

        if (element) {
          element.classList.remove('visible');
        }
      });
    }
  }

  getDebounceSearch() {
    if (!this._debounceSearch) {
      this._debounceSearch = debounce_default()(this.props.actions.search, 300);
    }

    return this._debounceSearch;
  }

  render() {
    const showClear = !this.props.searching && this.props.keyword && this.props.keyword.trim() !== '';
    let searchFormClass = 'search__form';

    if (this.state.focused) {
      searchFormClass += ' focused';
    }

    const searchClearTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "searchClearTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "search_bar.clear",
      defaultMessage: "Clear search query"
    }));
    return react_default.a.createElement(react_outside_click_handler_default.a, {
      onOutsideClick: () => {
        this.props.actions.closeSearch();
      }
    }, react_default.a.createElement("div", {
      className: "search-box"
    }, react_default.a.createElement("div", {
      className: "sidebar-collapse__container"
    }, react_default.a.createElement("div", {
      id: "sidebarCollapse",
      className: "sidebar-collapse",
      onClick: this.handleClose
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.back",
      defaultMessage: "Back Icon"
    }, title => react_default.a.createElement("span", {
      className: "fa fa-2x fa-angle-left",
      title: title
    })))), react_default.a.createElement("div", {
      id: "searchFormContainer",
      className: 'search-form__container',
      show: `${!this.props.isCloudPosts}`
    }, react_default.a.createElement("form", {
      className: searchFormClass,
      onSubmit: this.handleSubmit,
      style: search_box_style.searchForm,
      autoComplete: "off"
    }, react_default.a.createElement(search_icon["a" /* default */], {
      id: "searchIcon",
      className: "search__icon",
      "aria-hidden": "true"
    }), react_default.a.createElement(suggestion_box["a" /* default */], {
      ref: this.getSearch,
      role: "application",
      id: "searchBox",
      className: "search-bar",
      "aria-describedby": "searchbar-help-popup",
      placeholder: utils["gb" /* localizeMessage */]('search_bar.search', 'Search'),
      value: this.props.keyword,
      onFocus: this.handleUserFocus,
      onBlur: this.handleUserBlur,
      onChange: this.handleChange,
      onKeyDown: this.handleKeyDown,
      listComponent: search_suggestion_list_SearchSuggestionList,
      dateComponent: suggestion_date_SuggestionDate,
      providers: this.suggestionProviders,
      type: "search" // autoFocus={this.props.isFocus && this.props.keyword === ''}
      ,
      delayInputUpdate: true,
      renderDividers: true
    }), showClear && react_default.a.createElement("div", {
      id: "searchClearButton",
      className: "sidebar__search-clear visible",
      onClick: this.handleClear
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "bottom",
      overlay: searchClearTooltip
    }, react_default.a.createElement("span", {
      className: "clear-btn"
    }))), this.props.searching && react_default.a.createElement(loading_spinner["a" /* default */], null)), this.props.opened && react_default.a.createElement(components_search_chat, null), react_default.a.createElement(components_ao_search_chat_record_modal, null), react_default.a.createElement(components_ao_search_chat_clouddisk_modal, null))));
  }

}

search_box_defineProperty(search_box_SearchBar, "propTypes", {
  opened: prop_types_default.a.bool,
  searching: prop_types_default.a.bool,
  keyword: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    openSearch: prop_types_default.a.func,
    closeSearch: prop_types_default.a.func,
    updateSearchKeyword: prop_types_default.a.func,
    search: prop_types_default.a.func
  })
});

const search_box_style = {
  searchForm: {
    overflow: 'visible'
  }
};
// CONCATENATED MODULE: ./components/search_box/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function search_box_mapStateToProps(state) {
  const {
    opened,
    keyword,
    searching
  } = state.views.searchchat.searchchat;
  return {
    opened,
    keyword,
    searching
  };
}

function search_box_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openSearch: openSearch,
      closeSearch: closeSearch,
      updateSearchKeyword: updateSearchKeyword,
      search: search_chat_search
    }, dispatch)
  };
}

/* harmony default export */ var search_box = (Object(es["connect"])(search_box_mapStateToProps, search_box_mapDispatchToProps)(search_box_SearchBar));
// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Dropdown.js + 1 modules
var Dropdown = __webpack_require__(1756);

// EXTERNAL MODULE: ./node_modules/react-overlays/es/index.js + 23 modules
var react_overlays_es = __webpack_require__(3430);

// CONCATENATED MODULE: ./plugins/channel_header_plug/channel_header_plug.jsx
function channel_header_plug_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable react/no-multi-comp */






class channel_header_plug_CustomMenu extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    channel_header_plug_defineProperty(this, "handleRootClose", () => {
      this.props.onClose();
    });
  }

  render() {
    const {
      open,
      rootCloseEvent,
      children
    } = this.props;
    return react_default.a.createElement(react_overlays_es["a" /* RootCloseWrapper */], {
      disabled: !open,
      onRootClose: this.handleRootClose,
      event: rootCloseEvent
    }, react_default.a.createElement("ul", {
      role: "menu",
      className: "dropdown-menu channel-header_plugin-dropdown"
    }, children));
  }

}

channel_header_plug_defineProperty(channel_header_plug_CustomMenu, "propTypes", {
  open: prop_types_default.a.bool,
  children: prop_types_default.a.node,
  onClose: prop_types_default.a.func.isRequired,
  rootCloseEvent: prop_types_default.a.oneOf(['click', 'mousedown'])
});

class channel_header_plug_CustomToggle extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    channel_header_plug_defineProperty(this, "handleClick", e => {
      this.props.onClick(e);
    });
  }

  render() {
    const {
      children
    } = this.props;
    let activeClass = '';

    if (this.props.dropdownOpen) {
      activeClass = ' active';
    }

    return react_default.a.createElement("button", {
      id: "pluginChannelHeaderButtonDropdown",
      className: 'channel-header__icon style--none' + activeClass,
      type: "button",
      onClick: this.handleClick
    }, children);
  }

}

channel_header_plug_defineProperty(channel_header_plug_CustomToggle, "propTypes", {
  children: prop_types_default.a.element,
  dropdownOpen: prop_types_default.a.bool,
  onClick: prop_types_default.a.func
});

class channel_header_plug_ChannelHeaderPlug extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    channel_header_plug_defineProperty(this, "toggleDropdown", dropdownOpen => {
      this.setState({
        dropdownOpen
      });
    });

    channel_header_plug_defineProperty(this, "onClose", () => {
      this.toggleDropdown(false);
    });

    channel_header_plug_defineProperty(this, "fireActionAndClose", action => {
      action(this.props.channel, this.props.channelMember);
      this.onClose();
    });

    channel_header_plug_defineProperty(this, "createButton", plug => {
      return react_default.a.createElement(HeaderIconWrapper, {
        buttonClass: "channel-header__icon style--none",
        iconComponent: plug.icon,
        onClick: () => plug.action(this.props.channel, this.props.channelMember),
        buttonId: plug.id,
        tooltipKey: 'plugin',
        tooltipText: plug.tooltipText ? plug.tooltipText : plug.dropdownText
      });
    });

    channel_header_plug_defineProperty(this, "createDropdown", plugs => {
      const items = plugs.map(plug => {
        return react_default.a.createElement("li", {
          key: 'channelHeaderPlug' + plug.id
        }, react_default.a.createElement("a", {
          href: "#",
          className: "overflow--ellipsis",
          onClick: () => this.fireActionAndClose(plug.action)
        }, react_default.a.createElement("span", null, plug.icon), plug.dropdownText));
      });
      return react_default.a.createElement("div", {
        className: "flex-child"
      }, react_default.a.createElement(Dropdown["a" /* default */], {
        ref: "dropdown",
        id: "channelHeaderPlugDropdown",
        onToggle: this.toggleDropdown,
        onSelect: this.onSelect,
        open: this.state.dropdownOpen
      }, react_default.a.createElement(channel_header_plug_CustomToggle, {
        dropdownOpen: this.state.dropdownOpen,
        bsRole: "toggle"
      }, react_default.a.createElement("span", {
        className: "fa fa-ellipsis-h icon__ellipsis"
      })), react_default.a.createElement(channel_header_plug_CustomMenu, {
        bsRole: "menu",
        open: this.state.dropdownOpen,
        onClose: this.onClose
      }, items)));
    });

    this.state = {
      dropdownOpen: false
    };
  }

  render() {
    const components = this.props.components || [];

    if (components.length === 0) {
      return null;
    } else if (components.length === 1) {
      return this.createButton(components[0]);
    }

    return this.createDropdown(components);
  }

}
/* eslint-enable react/no-multi-comp */

channel_header_plug_defineProperty(channel_header_plug_ChannelHeaderPlug, "propTypes", {
  /*
   * Components or actions to add as channel header buttons
   */
  components: prop_types_default.a.array,
  channel: prop_types_default.a.object.isRequired,
  channelMember: prop_types_default.a.object.isRequired,

  /*
   * Logged in user's theme
   */
  theme: prop_types_default.a.object.isRequired
});
// CONCATENATED MODULE: ./plugins/channel_header_plug/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function channel_header_plug_mapStateToProps(state) {
  return {
    components: state.plugins.components.ChannelHeaderButton,
    theme: Object(entities_preferences["getTheme"])(state)
  };
}

/* harmony default export */ var channel_header_plug = (Object(es["connect"])(channel_header_plug_mapStateToProps)(channel_header_plug_ChannelHeaderPlug));
// CONCATENATED MODULE: ./components/channel_header/channel_header.js
function channel_header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.































const channel_header_headerMarkdownOptions = {
  singleline: true,
  mentionHighlight: false,
  atMentions: true
};
const popoverMarkdownOptions = {
  singleline: false,
  mentionHighlight: false,
  atMentions: true
};
const SEARCH_BAR_MINIMUM_WINDOW_SIZE = 1140;
class channel_header_ChannelHeader extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    channel_header_defineProperty(this, "handleResize", () => {
      const windowWidth = utils["sb" /* windowWidth */]();
      this.setState({
        showSearchBar: windowWidth > SEARCH_BAR_MINIMUM_WINDOW_SIZE
      });
    });

    channel_header_defineProperty(this, "handleClose", () => {
      this.props.actions.goToLastViewedChannel();
    });

    channel_header_defineProperty(this, "toggleFavorite", e => {
      e.stopPropagation();

      if (this.props.isFavorite) {
        this.props.actions.unfavoriteChannel(this.props.channel.id);
      } else {
        this.props.actions.favoriteChannel(this.props.channel.id);
      }
    });

    channel_header_defineProperty(this, "unmute", () => {
      const {
        actions,
        channel,
        channelMember,
        currentUser
      } = this.props;

      if (!channelMember || !currentUser || !channel) {
        return;
      }

      const options = {
        mark_unread: constants["q" /* NotificationLevels */].ALL
      };
      actions.updateChannelNotifyProps(currentUser.id, channel.id, options);
    });

    channel_header_defineProperty(this, "mute", () => {
      const {
        actions,
        channel,
        channelMember,
        currentUser
      } = this.props;

      if (!channelMember || !currentUser || !channel) {
        return;
      }

      const options = {
        mark_unread: constants["q" /* NotificationLevels */].MENTION
      };
      actions.updateChannelNotifyProps(currentUser.id, channel.id, options);
    });

    channel_header_defineProperty(this, "searchMentions", e => {
      e.preventDefault();

      if (this.props.rhsState === constants["x" /* RHSStates */].MENTION) {
        this.props.actions.closeRightHandSide();
      } else {
        this.props.actions.showMentions();
      }
    });

    channel_header_defineProperty(this, "showPinnedPosts", e => {
      e.preventDefault();

      if (this.props.rhsState === constants["x" /* RHSStates */].PIN) {
        this.props.actions.closeRightHandSide();
      } else {
        this.props.actions.showPinnedPosts();
      }
    });

    channel_header_defineProperty(this, "getFlagged", e => {
      e.preventDefault();

      if (this.props.rhsState === constants["x" /* RHSStates */].FLAG) {
        this.props.actions.closeRightHandSide();
      } else {
        this.props.actions.showFlaggedPosts();
      }
    });

    channel_header_defineProperty(this, "showCloud", e => {
      e.preventDefault();

      if (this.props.rhsState === constants["x" /* RHSStates */].CLOUD) {
        this.props.actions.closeRightHandSide();
      } else {
        this.props.actions.showCloud();
      }
    });

    channel_header_defineProperty(this, "showWork", e => {
      e.preventDefault();
      window.open("https://workspace.zhonganinfo.com/workbench", "_blank");
    });

    channel_header_defineProperty(this, "searchButtonClick", e => {
      e.preventDefault();
      this.props.actions.updateRhsState(constants["x" /* RHSStates */].SEARCH);
    });

    channel_header_defineProperty(this, "handleShortcut", e => {
      if (utils["e" /* cmdOrCtrlPressed */](e) && e.shiftKey) {
        if (utils["V" /* isKeyPressed */](e, constants["g" /* Constants */].KeyCodes.M)) {
          e.preventDefault();
          this.searchMentions(e);
        }
      }
    });

    channel_header_defineProperty(this, "handleOnMouseOver", () => {
      if (this.refs.headerOverlay) {
        this.refs.headerOverlay.show();
      }
    });

    channel_header_defineProperty(this, "handleOnMouseOut", () => {
      if (this.refs.headerOverlay) {
        this.refs.headerOverlay.hide();
      }
    });

    channel_header_defineProperty(this, "handleQuickSwitchKeyPress", e => {
      if (utils["e" /* cmdOrCtrlPressed */](e) && !e.shiftKey && utils["V" /* isKeyPressed */](e, constants["g" /* Constants */].KeyCodes.K)) {
        if (!e.altKey) {
          e.preventDefault();
          this.toggleQuickSwitchModal();
        }
      }
    });

    channel_header_defineProperty(this, "toggleQuickSwitchModal", () => {
      const {
        isQuickSwitcherOpen
      } = this.props;

      if (isQuickSwitcherOpen) {
        this.props.actions.closeModal(constants["p" /* ModalIdentifiers */].QUICK_SWITCH);
      } else {
        this.props.actions.openModal({
          modalId: constants["p" /* ModalIdentifiers */].QUICK_SWITCH,
          dialogType: quick_switch_modal
        });
      }
    });

    channel_header_defineProperty(this, "showEditChannelHeaderModal", () => {
      if (this.refs.headerOverlay) {
        this.refs.headerOverlay.hide();
      }

      const {
        actions,
        channel
      } = this.props;
      const modalData = {
        modalId: constants["p" /* ModalIdentifiers */].EDIT_CHANNEL_HEADER,
        dialogType: components_edit_channel_header_modal,
        dialogProps: {
          channel
        }
      };
      actions.openModal(modalData);
    });

    const showSearchBar = utils["sb" /* windowWidth */]() > SEARCH_BAR_MINIMUM_WINDOW_SIZE;
    this.state = {
      showSearchBar
    };
    this.getHeaderMarkdownOptions = Object(helpers["memoizeResult"])(channelNamesMap => ({ ...channel_header_headerMarkdownOptions,
      channelNamesMap
    }));
    this.getPopoverMarkdownOptions = Object(helpers["memoizeResult"])(channelNamesMap => ({ ...popoverMarkdownOptions,
      channelNamesMap
    }));
  }

  componentDidMount() {
    this.props.actions.getCustomEmojisInText(this.props.channel ? this.props.channel.header : '');
    document.addEventListener('keydown', this.handleShortcut);
    document.addEventListener('keydown', this.handleQuickSwitchKeyPress);
    window.addEventListener('resize', this.handleResize);
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleShortcut);
    document.removeEventListener('keydown', this.handleQuickSwitchKeyPress);
    window.removeEventListener('resize', this.handleResize);
  }

  componentDidUpdate(prevProps) {
    const header = this.props.channel ? this.props.channel.header : '';
    const prevHeader = prevProps.channel ? prevProps.channel.header : '';

    if (header !== prevHeader) {
      this.props.actions.getCustomEmojisInText(header);
    }
  }

  render() {
    const {
      teamId,
      currentUser,
      channel,
      channelMember,
      isMuted: channelMuted,
      isReadOnly,
      isFavorite,
      dmUser,
      rhsState
    } = this.props;
    const {
      formatMessage
    } = this.context.intl;
    const ariaLabelChannelHeader = utils["gb" /* localizeMessage */]('accessibility.sections.channelHeader', 'channel header region');
    const channelIsArchived = channel.delete_at !== 0;

    if (utils["P" /* isEmptyObject */](channel) || utils["P" /* isEmptyObject */](channelMember) || utils["P" /* isEmptyObject */](currentUser) || !dmUser && channel.type === constants["g" /* Constants */].DM_CHANNEL) {
      // Use an empty div to make sure the header's height stays constant
      return react_default.a.createElement("div", {
        className: "channel-header"
      });
    }

    const channelNamesMap = channel.props && channel.props.channel_mentions;
    let channelTitle = channel.display_name;
    let archivedIcon = null;

    if (channelIsArchived) {
      archivedIcon = react_default.a.createElement(archive_icon["a" /* default */], {
        className: "icon icon__archive icon channel-header-archived-icon svg-text-color"
      });
    }

    const isDirect = channel.type === constants["g" /* Constants */].DM_CHANNEL;
    const isGroup = channel.type === constants["g" /* Constants */].GM_CHANNEL;
    const isPrivate = channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL;

    if (isDirect) {
      const teammateId = dmUser.id;

      if (currentUser.id === teammateId) {
        channelTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "channel_header.directchannel.you",
          defaultMessage: "{displayname} (you) ",
          values: {
            displayname: utils["x" /* getDisplayNameByUserId */](teammateId)
          }
        });
      } else {
        channelTitle = utils["x" /* getDisplayNameByUserId */](teammateId) + ' ';
      }
    }

    let popoverListMembers;

    if (!isDirect) {
      popoverListMembers = react_default.a.createElement(popover_list_members, {
        channel: channel
      });
    }

    let dmHeaderIconStatus;
    let dmHeaderTextStatus;

    if (isDirect && !dmUser.delete_at && !dmUser.is_bot) {
      dmHeaderIconStatus = react_default.a.createElement(status_icon["a" /* default */], {
        type: "avatar",
        status: channel.status
      });
      dmHeaderTextStatus = react_default.a.createElement("span", {
        className: "header-status__text"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: `status_dropdown.set_${channel.status}`,
        defaultMessage: utils["qb" /* toTitleCase */](channel.status)
      }));
    }

    let headerTextContainer;
    const headerText = isDirect && dmUser.is_bot ? dmUser.bot_description : channel.header;

    if (headerText) {
      const popoverContent = react_default.a.createElement(Popover["a" /* default */], {
        id: "header-popover",
        bStyle: "info",
        bSize: "large",
        placement: "bottom",
        className: "channel-header__popover",
        onMouseOver: this.handleOnMouseOver,
        onMouseOut: this.handleOnMouseOut
      }, react_default.a.createElement(markdown["a" /* default */], {
        message: headerText,
        options: this.getPopoverMarkdownOptions(channelNamesMap)
      }));
      headerTextContainer = react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: 'click',
        placement: "bottom",
        rootClose: true,
        overlay: popoverContent,
        ref: "headerOverlay"
      }, react_default.a.createElement("div", {
        id: "channelHeaderDescription",
        className: "channel-header__description",
        style: {
          display: 'none'
        }
      }, dmHeaderIconStatus, dmHeaderTextStatus, react_default.a.createElement("span", {
        onClick: utils["H" /* handleFormattedTextClick */]
      }, react_default.a.createElement(markdown["a" /* default */], {
        message: headerText,
        options: this.getHeaderMarkdownOptions(channelNamesMap)
      }))));
    } else {
      let editMessage;

      if (!isReadOnly && !channelIsArchived) {
        if (isDirect || isGroup) {
          if (!isDirect || !dmUser.is_bot) {
            editMessage = react_default.a.createElement("button", {
              className: "style--none",
              onClick: this.showEditChannelHeaderModal
            }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
              id: "channel_header.addChannelHeader",
              defaultMessage: "Add a channel description"
            }));
          }
        } else {
          editMessage = react_default.a.createElement(channel_permission_gate["a" /* default */], {
            channelId: channel.id,
            teamId: teamId,
            permissions: [isPrivate ? mattermost_redux_constants["Permissions"].MANAGE_PRIVATE_CHANNEL_PROPERTIES : mattermost_redux_constants["Permissions"].MANAGE_PUBLIC_CHANNEL_PROPERTIES]
          }, react_default.a.createElement("button", {
            className: "style--none",
            onClick: this.showEditChannelHeaderModal
          }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "channel_header.addChannelHeader",
            defaultMessage: "Add a channel description"
          })));
        }
      }

      headerTextContainer = react_default.a.createElement("div", {
        id: "channelHeaderDescription",
        className: "channel-header__description light"
      }, dmHeaderIconStatus, dmHeaderTextStatus, editMessage);
    }

    let toggleFavoriteTooltip;
    let toggleFavorite = null;
    let ariaLabel = '';

    if (!channelIsArchived) {
      if (isFavorite) {
        toggleFavoriteTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
          id: "favoriteTooltip"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "channelHeader.removeFromFavorites",
          defaultMessage: "Remove from Favorites"
        }));
        ariaLabel = formatMessage({
          id: 'channelHeader.removeFromFavorites',
          defaultMessage: 'Remove from Favorites'
        }).toLowerCase();
      } else {
        toggleFavoriteTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
          id: "favoriteTooltip"
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "channelHeader.addToFavorites",
          defaultMessage: "Add to Favorites"
        }));
        ariaLabel = formatMessage({
          id: 'channelHeader.addToFavorites',
          defaultMessage: 'Add to Favorites'
        }).toLowerCase();
      }

      toggleFavorite = react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        delayShow: constants["g" /* Constants */].OVERLAY_TIME_DELAY,
        placement: "bottom",
        overlay: toggleFavoriteTooltip
      }, react_default.a.createElement("button", {
        id: "toggleFavorite",
        onClick: this.toggleFavorite,
        className: 'style--none color--link channel-header__favorites ' + (this.props.isFavorite ? 'active' : 'inactive'),
        "aria-label": ariaLabel
      }, react_default.a.createElement("i", {
        className: 'icon fa ' + (this.props.isFavorite ? 'fa-star' : 'fa-star-o')
      })));
    }

    const channelMutedTooltip = react_default.a.createElement(Tooltip["a" /* default */], {
      id: "channelMutedTooltip"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "channelHeader.unmute",
      defaultMessage: "Unmute"
    }));
    let muteTrigger;

    if (channelMuted) {
      muteTrigger = react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        delayShow: constants["g" /* Constants */].OVERLAY_TIME_DELAY,
        placement: "bottom",
        overlay: channelMutedTooltip
      }, react_default.a.createElement("button", {
        id: "toggleMute",
        onClick: this.unmute,
        className: 'style--none color--link channel-header__mute inactive',
        "aria-label": formatMessage({
          id: 'generic_icons.muted',
          defaultMessage: 'Muted Icon'
        })
      }, react_default.a.createElement("i", {
        className: 'icon fa fa-bell-slash-o'
      })));
    }

    let pinnedIconClass = 'channel-header__icon';

    if (rhsState === constants["x" /* RHSStates */].PIN) {
      pinnedIconClass += ' active';
    }

    let title = react_default.a.createElement(menu_wrapper["a" /* default */], null, react_default.a.createElement("div", {
      id: "channelHeaderDropdownButton",
      className: "channel-header__top"
    }, toggleFavorite, react_default.a.createElement("button", {
      className: "channel-header__trigger style--none",
      "aria-label": formatMessage({
        id: 'channel_header.menuAriaLabel',
        defaultMessage: 'Channel Menu'
      }).toLowerCase()
    }, react_default.a.createElement("strong", {
      id: "channelHeaderTitle",
      className: "heading"
    }, react_default.a.createElement("span", null, archivedIcon, channelTitle)), react_default.a.createElement("span", {
      id: "channelHeaderDropdownIcon",
      className: "fa fa-angle-down header-dropdown__icon",
      "aria-label": formatMessage({
        id: 'generic_icons.dropdown',
        defaultMessage: 'Dropdown Icon'
      }).toLowerCase()
    }))), react_default.a.createElement(components_channel_header_dropdown_ChannelHeaderDropdown, null));

    if (isDirect && dmUser.is_bot) {
      title = react_default.a.createElement("div", {
        id: "channelHeaderDropdownButton",
        className: "channel-header__top"
      }, toggleFavorite, react_default.a.createElement("strong", {
        id: "channelHeaderTitle",
        className: "heading"
      }, react_default.a.createElement("span", null, archivedIcon, channelTitle)), react_default.a.createElement(bot_badge["a" /* default */], {
        className: "badge-popoverlist"
      }));
    }

    let mentionBtnClass = this.props.isMentioned || this.props.isBeingInvited ? ' is-mentioned' : ''; // console.log('isMentioned',this.props.isMentioned || this.props.isBeingInvited)

    return react_default.a.createElement("div", {
      id: "channel-header",
      "aria-label": ariaLabelChannelHeader,
      role: "navigation",
      tabIndex: "-1",
      "data-channelid": `${channel.id}`,
      className: "channel-header alt"
    }, react_default.a.createElement("div", {
      className: "flex-parent"
    }, react_default.a.createElement("div", {
      className: "flex-child"
    }, react_default.a.createElement(search_box, null)), react_default.a.createElement("div", {
      className: "flex-child"
    }, popoverListMembers), react_default.a.createElement(HeaderIconWrapper, {
      iconComponent: react_default.a.createElement("span", {
        className: "flag-btn"
      }),
      ariaLabel: true,
      buttonClass: 'channel-header__icon icon--hidden style--none',
      buttonId: 'channelHeaderFlagButton',
      onClick: this.getFlagged,
      tooltipKey: 'flaggedPosts'
    }), react_default.a.createElement(HeaderIconWrapper, {
      iconComponent: react_default.a.createElement("span", {
        className: 'mention-btn' + mentionBtnClass
      }),
      ariaLabel: true,
      buttonClass: 'channel-header__icon icon--hidden style--none',
      buttonId: 'channelHeaderMentionButton',
      onClick: this.searchMentions,
      tooltipKey: 'recentMentions'
    }), react_default.a.createElement(HeaderIconWrapper, {
      iconComponent: react_default.a.createElement("span", {
        className: "work-btn"
      }),
      ariaLabel: true,
      buttonClass: 'channel-header__icon icon--hidden style--none',
      buttonId: 'channelWorkFlagButton',
      onClick: this.showWork,
      tooltipKey: 'workPosts'
    }), react_default.a.createElement(HeaderIconWrapper, {
      iconComponent: react_default.a.createElement("span", {
        className: "cloud-btn"
      }),
      ariaLabel: true,
      buttonClass: 'channel-header__icon icon--hidden style--none',
      buttonId: 'channelColudFlagButton',
      onClick: this.showCloud,
      tooltipKey: 'cloudPosts'
    }), !this.props.rhsState ? react_default.a.createElement("div", {
      className: "flex-child user"
    }, react_default.a.createElement(headerCloneTwo, null)) : null));
  }

}

channel_header_defineProperty(channel_header_ChannelHeader, "propTypes", {
  teamId: prop_types_default.a.string.isRequired,
  currentUser: prop_types_default.a.object.isRequired,
  channel: prop_types_default.a.object,
  channelMember: prop_types_default.a.object,
  dmUser: prop_types_default.a.object,
  isFavorite: prop_types_default.a.bool,
  isReadOnly: prop_types_default.a.bool,
  isMuted: prop_types_default.a.bool,
  rhsState: prop_types_default.a.oneOf(Object.values(constants["x" /* RHSStates */])),
  isQuickSwitcherOpen: prop_types_default.a.bool,
  isMentioned: prop_types_default.a.bool,
  isBeingInvited: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    favoriteChannel: prop_types_default.a.func.isRequired,
    unfavoriteChannel: prop_types_default.a.func.isRequired,
    showFlaggedPosts: prop_types_default.a.func.isRequired,
    showPinnedPosts: prop_types_default.a.func.isRequired,
    showMentions: prop_types_default.a.func.isRequired,
    showCloud: prop_types_default.a.func.isRequired,
    closeRightHandSide: prop_types_default.a.func.isRequired,
    updateRhsState: prop_types_default.a.func.isRequired,
    getCustomEmojisInText: prop_types_default.a.func.isRequired,
    updateChannelNotifyProps: prop_types_default.a.func.isRequired,
    goToLastViewedChannel: prop_types_default.a.func.isRequired,
    openModal: prop_types_default.a.func.isRequired,
    closeModal: prop_types_default.a.func.isRequired
  }).isRequired
});

channel_header_defineProperty(channel_header_ChannelHeader, "contextTypes", {
  intl: index_es["i" /* intlShape */].isRequired
});
// CONCATENATED MODULE: ./components/channel_header/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


















const channel_header_mapStateToProps = state => {
  const channel = Object(entities_channels["getCurrentChannel"])(state) || {};
  const user = Object(entities_users["getCurrentUser"])(state);
  let dmUser;

  if (channel && channel.type === mattermost_redux_constants["General"].DM_CHANNEL) {
    const dmUserId = Object(channel_utils["getUserIdFromChannelName"])(user.id, channel.name);
    dmUser = Object(entities_users["getUser"])(state, dmUserId);
  } // console.log('unreads',getUnreads(state))
  // console.log('unreadMeetingIds',state.views.meeting.unreadMeetingIds)


  return {
    teamId: Object(entities_teams["getCurrentTeamId"])(state),
    channel,
    channelMember: Object(entities_channels["getMyCurrentChannelMembership"])(state),
    currentUser: user,
    dmUser,
    rhsState: Object(selectors_rhs["m" /* getRhsState */])(state),
    isFavorite: Object(entities_channels["isCurrentChannelFavorite"])(state),
    isReadOnly: Object(entities_channels["isCurrentChannelReadOnly"])(state),
    isMuted: Object(entities_channels["isCurrentChannelMuted"])(state),
    isQuickSwitcherOpen: Object(views_modals["a" /* isModalOpen */])(state, constants["p" /* ModalIdentifiers */].QUICK_SWITCH),
    isMentioned: Object(entities_channels["getUnreads"])(state).mentionCount > 0,
    isBeingInvited: state.views.meeting.unreadMeetingIds.length > 0
  };
};

const channel_header_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    favoriteChannel: actions_channels["favoriteChannel"],
    unfavoriteChannel: actions_channels["unfavoriteChannel"],
    showFlaggedPosts: rhs["n" /* showFlaggedPosts */],
    showPinnedPosts: rhs["q" /* showPinnedPosts */],
    showMentions: rhs["p" /* showMentions */],
    showCloud: rhs["m" /* showCloud */],
    closeRightHandSide: rhs["b" /* closeRightHandSide */],
    updateRhsState: rhs["v" /* updateRhsState */],
    getCustomEmojisInText: actions_emojis["getCustomEmojisInText"],
    updateChannelNotifyProps: actions_channels["updateChannelNotifyProps"],
    goToLastViewedChannel: views_channel["c" /* goToLastViewedChannel */],
    openModal: modals["b" /* openModal */],
    closeModal: modals["a" /* closeModal */]
  }, dispatch)
});

/* harmony default export */ var channel_header = (Object(react_router["f" /* withRouter */])(Object(es["connect"])(channel_header_mapStateToProps, channel_header_mapDispatchToProps)(channel_header_ChannelHeader)));
// EXTERNAL MODULE: ./mattermost-redux/actions/helpers.js
var actions_helpers = __webpack_require__(117);

// EXTERNAL MODULE: ./mattermost-redux/utils/event_emitter.js
var event_emitter = __webpack_require__(414);
var event_emitter_default = /*#__PURE__*/__webpack_require__.n(event_emitter);

// CONCATENATED MODULE: ./components/post_view/floating_timestamp/floating_timestamp.jsx
function floating_timestamp_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class floating_timestamp_FloatingTimestamp extends react_default.a.PureComponent {
  render() {
    if (!this.props.isMobile) {
      return react_default.a.createElement("noscript", null);
    }

    if (this.props.createAt === 0) {
      return react_default.a.createElement("noscript", null);
    }

    const dateString = react_default.a.createElement(index_es["a" /* FormattedDate */], {
      value: this.props.createAt,
      weekday: "short",
      day: "2-digit",
      month: "short",
      year: "numeric"
    });
    let className = 'post-list__timestamp';

    if (this.props.isScrolling) {
      className += ' scrolling';
    }

    if (this.props.isRhsPost) {
      className += ' rhs';
    }

    return react_default.a.createElement("div", {
      className: className
    }, react_default.a.createElement("div", null, react_default.a.createElement("span", null, dateString)));
  }

}

floating_timestamp_defineProperty(floating_timestamp_FloatingTimestamp, "propTypes", {
  isScrolling: prop_types_default.a.bool.isRequired,
  isMobile: prop_types_default.a.bool,
  createAt: prop_types_default.a.oneOfType([prop_types_default.a.instanceOf(Date), prop_types_default.a.number]).isRequired,
  isRhsPost: prop_types_default.a.bool
});
// CONCATENATED MODULE: ./components/post_view/floating_timestamp/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function floating_timestamp_mapStateToProps(state, ownProps) {
  let postId = ownProps.postId;

  if (post_list["isCombinedUserActivityPost"](postId)) {
    const combinedIds = post_list["getPostIdsForCombinedUserActivityPost"](postId);
    postId = combinedIds[combinedIds.length - 1];
  }

  const post = Object(entities_posts["getPost"])(state, postId);
  return {
    createAt: post ? post.create_at : 0
  };
}

/* harmony default export */ var floating_timestamp = (Object(es["connect"])(floating_timestamp_mapStateToProps)(floating_timestamp_FloatingTimestamp));
// CONCATENATED MODULE: ./components/post_view/new_messages_below/new_messages_below.jsx
function new_messages_below_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class new_messages_below_NewMessagesBelow extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      visible: false,
      rendered: false
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.newMessages > 0 && !nextProps.atBottom) {
      this.setState({
        rendered: true
      }, () => {
        this.setState({
          visible: true
        });
      });
    } else {
      this.setState({
        visible: false
      });
    }
  }

  render() {
    let className = 'new-messages__button';

    if (this.state.visible) {
      className += ' visible';
    }

    if (!this.state.rendered) {
      className += ' disabled';
    }

    return react_default.a.createElement("div", {
      className: className,
      onTransitionEnd: this.setRendered.bind(this),
      ref: "indicator"
    }, react_default.a.createElement("div", {
      onClick: this.props.onClick
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "posts_view.newMsgBelow",
      defaultMessage: "New {count, plural, one {message} other {messages}}",
      values: {
        count: this.props.newMessages
      }
    }), react_default.a.createElement(unread_below_icon_UnreadBelowIcon, {
      className: "icon icon__unread"
    })));
  } // Sync 'rendered' state with visibility param, only after transitions
  // have ended


  setRendered() {
    this.setState({
      rendered: this.state.visible
    });
  }

}

new_messages_below_defineProperty(new_messages_below_NewMessagesBelow, "propTypes", {
  atBottom: prop_types_default.a.bool,
  onClick: prop_types_default.a.func.isRequired,
  newMessages: prop_types_default.a.number
});

new_messages_below_defineProperty(new_messages_below_NewMessagesBelow, "defaultProps", {
  newMessages: 0
});
// CONCATENATED MODULE: ./components/post_view/new_messages_below/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function makeCountUnreadsBelow() {
  return Object(reselect_es["a" /* createSelector */])(entities_posts["getAllPosts"], entities_users["getCurrentUserId"], (state, postIds) => postIds, (state, postIds, lastViewedBottom) => lastViewedBottom, (allPosts, currentUserId, postIds, lastViewedBottom) => {
    if (!postIds) {
      return 0;
    } // Count the number of new posts made by other users that haven't been deleted


    return postIds.map(id => allPosts[id]).filter(post => {
      return post && post.user_id !== currentUserId && post.state !== mattermost_redux_constants["Posts"].POST_DELETED && post.create_at > lastViewedBottom;
    }).length;
  });
}

function new_messages_below_makeMapStateToProps() {
  const countUnreadsBelow = makeCountUnreadsBelow();
  const preparePostIdsForPostList = Object(post_list["makePreparePostIdsForPostList"])();
  return (state, ownProps) => {
    let postIds = Object(entities_posts["getPostIdsInChannel"])(state, ownProps.channelId);

    if (postIds) {
      postIds = preparePostIdsForPostList(state, {
        postIds,
        lastViewedAt: ownProps.lastViewedBottom
      });
    }

    return {
      newMessages: countUnreadsBelow(state, postIds, ownProps.lastViewedBottom)
    };
  };
}

/* harmony default export */ var new_messages_below = (Object(es["connect"])(new_messages_below_makeMapStateToProps)(new_messages_below_NewMessagesBelow));
// EXTERNAL MODULE: ./utils/markdown/index.js + 2 modules
var utils_markdown = __webpack_require__(141);

// CONCATENATED MODULE: ./components/post_view/commented_on_files_message/commented_on_files_message.jsx
function commented_on_files_message_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class commented_on_files_message_CommentedOnFilesMessage extends react_default.a.PureComponent {
  render() {
    if (!this.props.fileInfos || this.props.fileInfos.length === 0) {
      return null;
    }

    let plusMore = null;

    if (this.props.fileInfos.length > 1) {
      plusMore = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "post_body.plusMore",
        defaultMessage: " plus {count, number} other {count, plural, one {file} other {files}}",
        values: {
          count: this.props.fileInfos.length - 1
        }
      });
    }

    return react_default.a.createElement("span", null, this.props.fileInfos[0].name, plusMore);
  }

}

commented_on_files_message_defineProperty(commented_on_files_message_CommentedOnFilesMessage, "propTypes", {
  /*
   * The id of the post that was commented on
   */
  parentPostId: prop_types_default.a.string.isRequired,

  /*
   * An array of file metadata for the parent post
   */
  fileInfos: prop_types_default.a.arrayOf(prop_types_default.a.object)
});
// CONCATENATED MODULE: ./components/post_view/commented_on_files_message/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function commented_on_files_message_makeMapStateToProps() {
  const selectFileInfosForPost = Object(entities_files["makeGetFilesForPost"])();
  return function mapStateToProps(state, ownProps) {
    let fileInfos;

    if (ownProps.parentPostId) {
      fileInfos = selectFileInfosForPost(state, ownProps.parentPostId);
    }

    return {
      fileInfos
    };
  };
}

/* harmony default export */ var commented_on_files_message = (Object(es["connect"])(commented_on_files_message_makeMapStateToProps)(commented_on_files_message_CommentedOnFilesMessage));
// CONCATENATED MODULE: ./components/post_view/commented_on/commented_on.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






class commented_on_CommentedOn extends react["PureComponent"] {
  // static propTypes = {
  //     displayName: PropTypes.string,
  //     enablePostUsernameOverride: PropTypes.bool,
  //     onCommentClick: PropTypes.func.isRequired,
  //     post: PropTypes.object.isRequired,
  //     actions: PropTypes.shape({
  //         showSearchResults: PropTypes.func.isRequired,
  //         updateSearchTerms: PropTypes.func.isRequired,
  //     }).isRequired,
  // }
  // handleOnClick = () => {
  //     const {actions} = this.props;
  //     const displayName = this.makeUsername();
  //     actions.updateSearchTerms(displayName);
  //     actions.showSearchResults();
  // }
  // makeUsername = () => {
  //     const postProps = this.props.post.props;
  //     let username = this.props.displayName;
  //     if (this.props.enablePostUsernameOverride && postProps && postProps.from_webhook === 'true' && postProps.override_username) {
  //         username = postProps.override_username;
  //     }
  //     return username;
  // }
  // makeCommentedOnMessage = () => {
  //     const {post} = this.props;
  //     let message = '';
  //     if (post.message) {
  //         message = Utils.replaceHtmlEntities(post.message);
  //     } else if (post.file_ids && post.file_ids.length > 0) {
  //         message = (
  //             <CommentedOnFilesMessage parentPostId={post.id}/>
  //         );
  //     } else if (post.props && post.props.attachments && post.props.attachments.length > 0) {
  //         const attachment = post.props.attachments[0];
  //         const webhookMessage = attachment.pretext || attachment.title || attachment.text || attachment.fallback || '';
  //         message = Utils.replaceHtmlEntities(webhookMessage);
  //     }
  //     return message;
  // }
  render() {
    // const username = this.makeUsername();
    // const message = this.makeCommentedOnMessage();
    // const name = (
    //     <a
    //         className='theme'
    //         onClick={this.handleOnClick}
    //     >
    //         {username}
    //     </a>
    // );
    const msg = this.props.post.parent_message;
    return msg ? // <span className="reply__content__text">回复 {username}：{stripMarkdown(message)}</span>
    react_default.a.createElement("span", {
      className: "reply__content__text"
    }, msg) // <div className='post__link'>
    //     <span>
    //         <FormattedMessage
    //             id='post_body.commentedOn'
    //             defaultMessage="Commented on {name}'s message: "
    //             values={{
    //                 name,
    //             }}
    //         />
    //         <a
    //             className='theme'
    //             onClick={this.props.onCommentClick}
    //         >
    //             {stripMarkdown(message)}
    //         </a>
    //     </span>
    // </div>
    : null;
  }

}
// CONCATENATED MODULE: ./components/post_view/commented_on/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function commented_on_mapStateToProps(state, ownProps) {
  let displayName = '';

  if (ownProps.post) {
    const user = Object(entities_users["getUser"])(state, ownProps.post.user_id);
    displayName = Object(utils["w" /* getDisplayNameByUser */])(user);

    if (user) {
      displayName = user.nickname;
    }
  }

  const config = Object(general["getConfig"])(state);
  const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
  return {
    displayName,
    enablePostUsernameOverride
  };
}

function commented_on_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      showSearchResults: rhs["s" /* showSearchResults */],
      updateSearchTerms: rhs["w" /* updateSearchTerms */]
    }, dispatch)
  };
}

/* harmony default export */ var commented_on = (Object(es["connect"])(commented_on_mapStateToProps, commented_on_mapDispatchToProps)(commented_on_CommentedOn));
// EXTERNAL MODULE: ./components/widgets/loading/loading_bars.jsx
var loading_bars = __webpack_require__(1776);

// CONCATENATED MODULE: ./components/post_view/post_body/post_body.jsx
function post_body_extends() { post_body_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return post_body_extends.apply(this, arguments); }

function post_body_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.














const SENDING_ANIMATION_DELAY = 3000;
class post_body_PostBody extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.sendingAction = new delayed_action["a" /* default */](() => {
      const post = this.props.post;

      if (post && post.id === post.pending_post_id) {
        this.setState({
          sending: true
        });
      }
    });
    this.state = {
      sending: false
    };
  }

  componentDidMount() {
    const post = this.props.post;

    if (post && post.id === post.pending_post_id) {
      this.sendingAction.fireAfter(SENDING_ANIMATION_DELAY);
    }
  }

  componentWillUnmount() {
    this.sendingAction.cancel();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    const post = nextProps.post;

    if (post && post.id !== post.pending_post_id) {
      this.sendingAction.cancel();
      this.setState({
        sending: false
      });
    }
  }

  formatMessage(latestPost) {
    let message = latestPost.message;

    if (latestPost.id) {
      const emojiList = message.match(/:(\w+): /g);

      if (emojiList) {
        emojiList.forEach(val => {
          if (this.props.emojiMap.get(val.substr(1, val.length - 3))) {
            message = message.replace(val, '[表情]');
          }
        });
      }

      if (latestPost.delete_at > 0) {
        message = '[已撤回] ';
      } else if (latestPost.card_type == 5 || latestPost.message && utils["X" /* isMeet */](latestPost.message)) {
        message = '[会议邀请] ';
      } else if (latestPost.card_type) {
        message = '[卡片消息] ';
      } else if (latestPost.file_ids && latestPost.file_ids.length > 0) {
        const reg = /^(png|jpg|jpeg|gif)$/; // 如果是 channel 接口拿到的数据，则不会有metadata字段，就拿file_ids字段作匹配
        // 如果是 post 接口拿到当数据，则有metadata字段，就取metadata

        if (!latestPost.metadata && reg.test(latestPost.file_ids[0])) {
          message = '[图片] ' + message;
        } else if (latestPost.metadata && latestPost.metadata.files && reg.test(latestPost.metadata.files[0].extension)) {
          message = '[图片] ' + message;
        } else {
          message = '[文件] ' + message;
        }
      } else if (latestPost.type === 'system_join_team') {
        message = `${latestPost.props.username} 加入了团队`;
      } else if (latestPost.type === 'system_remove_from_team') {
        message = `${latestPost.props.username} 被移出此团队`;
      } else if (latestPost.type === 'system_join_channel') {
        message = `${latestPost.props.username} 加入了频道`;
      } else if (latestPost.type === 'system_remove_from_channel') {
        message = `${latestPost.props.removedUsername} 离开了频道`;
      } // // 发最后一条信息的人员姓名
      // const fromWebhook = latestPost.props && latestPost.props.from_webhook === 'true';
      // const isSystemMessage = PostUtils.isSystemMessage(latestPost)
      // const isBot = Boolean(this.props.latestPostUser && this.props.latestPostUser.is_bot);
      // const {formatMessage} = this.props.intl;
      // if (fromWebhook && !isBot) {
      //   message = latestPost.props.override_username + '：' + message
      // } else if (isSystemMessage && !isBot) {
      //   message = formatMessage({id: 'post_info.system', defaultMessage: 'System'}) + '：'  + message
      // } else if (this.props.channelType !== Constants.DM_CHANNEL && this.props.latestPostUser) {
      //   message = this.props.latestPostUser.nickname=="" ? this.props.latestPostUser.first_name : this.props.latestPostUser.nickname + '：' + message
      // }
      // if(isBot){
      //   console.log("isbot---",this.props.latestPostUser);
      // }
      // // 如果当前有@
      // if (this.props.unreadMsgs > 0 && (message.indexOf('@' + this.props.user.username) > -1 || message.indexOf('@all') > -1)) {
      //   message = (
      //     <span className='special-message-txt'><i>[有人@我]</i> {message}</span>
      //   )
      // }

    }

    return message;
  }

  render() {
    const post = this.props.post;
    const parentPost = this.props.parentPost; // console.log(post)

    let comment;
    let postClass = '';
    const isEphemeral = utils["Z" /* isPostEphemeral */](post);

    if (parentPost && !isEphemeral) {
      comment = react_default.a.createElement(commented_on // post={parentPost}
      , {
        post: post,
        onCommentClick: this.props.handleCommentClick
      });
    }

    let failedOptions;

    if (this.props.post.failed) {
      postClass += ' post--fail';
      failedOptions = react_default.a.createElement(failed_post_options, {
        post: this.props.post
      });
    }

    if (post_utils["i" /* isEdited */](this.props.post)) {
      postClass += ' post--edited';
    }

    let fileAttachmentHolder = null;

    if ((post.file_ids && post.file_ids.length > 0 || post.filenames && post.filenames.length > 0) && this.props.post.state !== mattermost_redux_constants["Posts"].POST_DELETED) {
      // console.log(post);
      fileAttachmentHolder = react_default.a.createElement(file_attachment_list["a" /* default */], {
        post: post,
        compactDisplay: this.props.compactDisplay
      });
    }

    if (this.state.sending) {
      postClass += ' post-waiting';
    }

    const messageWrapper = react_default.a.createElement(react_default.a.Fragment, null, failedOptions, this.state.sending && react_default.a.createElement(loading_bars["a" /* default */], null), react_default.a.createElement(post_message_view["a" /* default */], {
      post: this.props.post,
      compactDisplay: this.props.compactDisplay,
      hasMention: true
    }));
    const hasPlugin = post.type && this.props.pluginPostTypes.hasOwnProperty(post.type) || post.props && post.props.type && this.props.pluginPostTypes.hasOwnProperty(post.props.type);
    let messageWithAdditionalContent;

    if (this.props.post.state === mattermost_redux_constants["Posts"].POST_DELETED || hasPlugin) {
      messageWithAdditionalContent = messageWrapper;
    } else {
      messageWithAdditionalContent = react_default.a.createElement(post_body_additional_content["a" /* default */], {
        post: this.props.post,
        isEmbedVisible: this.props.isEmbedVisible
      }, messageWrapper);
    }

    let mentionHighlightClass = '';

    if (this.props.isCommentMention) {
      mentionHighlightClass = 'mention-comment';
    }

    let ephemeralPostClass = '';

    if (isEphemeral) {
      ephemeralPostClass = 'post--ephemeral';
    }

    const _post = this.props.post; // console.log(_post, '-----xxx')

    const dotMenuProps = {
      text: `回复 ${this.props.displayName}：${this.formatMessage(post)}`,
      post: _post,
      channelId: _post.channel_id,
      rootId: _post.root_id || _post.id,
      commentCount: this.props.replyCount // onClick() {},
      // console.log(_post.message, _post, _post.user_id);

    };
    const isBot = _post.props && _post.props.from_bot || /^system_/.test(_post.type) || false;

    const _dotNewMenu = (isCurrent, cls, isMe) => {
      return this.props.hover && !this.props.hasCheckbox && _post.user_id && !isBot ? isCurrent && react_default.a.createElement(components_dot_new_menu, post_body_extends({
        className: cls
      }, dotMenuProps, {
        isMe: isMe,
        hasFlag: true,
        hasRecall: true,
        hasForward: true,
        hasMulitSelect: true
      })) : null;
    };

    const isDel = post.state === mattermost_redux_constants["Posts"].POST_DELETED;
    return react_default.a.createElement("div", {
      className: `post__msg__content ${comment ? `post__has__reply` : ''}`
    }, !isDel && _dotNewMenu(this.props.isCurrentUser, 'fl', 'me'), react_default.a.createElement("div", {
      className: "post__msg"
    }, react_default.a.createElement("p", {
      className: "post__head__reply",
      onClick: this.props.handleCommentClick
    }, comment), react_default.a.createElement("div", {
      id: `${post.id}_message`,
      className: `post__body ${mentionHighlightClass} ${ephemeralPostClass} ${postClass}`
    }, messageWithAdditionalContent, post.card_type ? '' : fileAttachmentHolder, react_default.a.createElement(reaction_list, {
      post: post,
      isReadOnly: this.props.isReadOnly
    }))), !isDel && _dotNewMenu(!this.props.isCurrentUser, 'fr'));
  }

}

post_body_defineProperty(post_body_PostBody, "propTypes", {
  /**
   * The post to render the body of
   */
  post: prop_types_default.a.object.isRequired,

  /**
   * The parent post of the thread this post is in
   */
  parentPost: prop_types_default.a.object,

  /**
   * The poster of the parent post, if exists
   */
  parentPostUser: prop_types_default.a.object,

  /**
   * The function called when the comment icon is clicked
   */
  handleCommentClick: prop_types_default.a.func.isRequired,

  /**
   * Set to render post body compactly
   */
  compactDisplay: prop_types_default.a.bool,

  /**
   * Set to highlight comment as a mention
   */
  isCommentMention: prop_types_default.a.bool,

  /**
   * Set to render a preview of the parent post above this reply
   */
  isFirstReply: prop_types_default.a.bool,

  /*
   * Post type components from plugins
   */
  pluginPostTypes: prop_types_default.a.object,

  /**
   * Flag passed down to PostBodyAdditionalContent for determining if post embed is visible
   */
  isEmbedVisible: prop_types_default.a.bool,

  /**
   * Whether or not the post username can be overridden.
   */
  enablePostUsernameOverride: prop_types_default.a.bool.isRequired,

  /**
   * Set not to allow edits on post
   */
  isReadOnly: prop_types_default.a.bool
});

post_body_defineProperty(post_body_PostBody, "defaultProps", {
  isReadOnly: false
});
// CONCATENATED MODULE: ./components/post_view/post_body/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








function post_body_mapStateToProps(state, ownProps) {
  let parentPost;
  let parentPostUser;
  let displayName = '';

  if (ownProps.post.root_id) {
    parentPost = Object(entities_posts["getPost"])(state, ownProps.post.root_id);
    parentPostUser = parentPost ? Object(entities_users["getUser"])(state, parentPost.user_id) : null;
  }

  if (ownProps.post.user_id) {
    let user = Object(entities_users["getUser"])(state, ownProps.post.user_id) || {}; // console.log(user, user.is_bot, '0000x0x0')

    displayName = user.nickname || user.username || '';
  }

  const config = Object(general["getConfig"])(state);
  const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
  const currentChannel = Object(entities_channels["getCurrentChannel"])(state);
  const channelIsArchived = currentChannel.delete_at !== 0;
  const emojiMap = Object(selectors_emojis["a" /* getEmojiMap */])(state);
  return {
    parentPost,
    parentPostUser,
    pluginPostTypes: state.plugins.postTypes,
    enablePostUsernameOverride,
    isReadOnly: Object(entities_channels["isCurrentChannelReadOnly"])(state) || channelIsArchived,
    emojiMap,
    displayName
  };
}

/* harmony default export */ var post_body = (Object(es["connect"])(post_body_mapStateToProps)(post_body_PostBody));
// EXTERNAL MODULE: ./components/common/comment_icon.jsx + 1 modules
var comment_icon = __webpack_require__(2272);

// CONCATENATED MODULE: ./components/post_view/post_info/post_info.jsx
function post_info_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.















 // import RecallIcon from 'components/icons/recall_icon';
// import ForwardIcon from 'components/icons/forward_icon';

class post_info_PostInfo extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    post_info_defineProperty(this, "toggleEmojiPicker", () => {
      const showEmojiPicker = !this.state.showEmojiPicker;
      this.setState({
        showEmojiPicker
      });
      this.props.handleDropdownOpened(showEmojiPicker || this.state.showDotMenu);
    });

    post_info_defineProperty(this, "removePost", () => {
      this.props.actions.removePost(this.props.post);
    });

    post_info_defineProperty(this, "createRemovePostButton", () => {
      return react_default.a.createElement("button", {
        className: "post__remove theme color--link style--none",
        type: "button",
        onClick: this.removePost
      }, '×');
    });

    post_info_defineProperty(this, "handleDotMenuOpened", open => {
      this.setState({
        showDotMenu: open
      });
      this.props.handleDropdownOpened(open || this.state.showEmojiPicker);
    });

    post_info_defineProperty(this, "getDotMenu", () => {
      return this.refs.dotMenu;
    });

    post_info_defineProperty(this, "buildOptions", (post, isSystemMessage, fromAutoResponder) => {
      if (!post_utils["o" /* shouldShowDotMenu */](post)) {
        return null;
      }

      const {
        isMobile,
        isReadOnly
      } = this.props;
      const hover = this.props.hover || this.state.showEmojiPicker || this.state.showDotMenu;
      const showCommentIcon = fromAutoResponder || !isSystemMessage && (isMobile || hover || !post.root_id && Boolean(this.props.replyCount) || this.props.isFirstReply);
      const commentIconExtraClass = isMobile ? '' : 'pull-right';
      let commentIcon;

      if (showCommentIcon) {
        commentIcon = react_default.a.createElement(comment_icon["a" /* default */], {
          handleCommentClick: this.props.handleCommentClick,
          commentCount: this.props.replyCount,
          postId: post.id,
          extraClass: commentIconExtraClass
        });
      }

      const showReactionIcon = !isSystemMessage && hover && !isReadOnly && this.props.enableEmojiPicker;
      let postReaction;

      if (showReactionIcon) {
        postReaction = react_default.a.createElement(post_reaction, {
          channelId: post.channel_id,
          postId: post.id,
          teamId: this.props.teamId,
          getDotMenuRef: this.getDotMenu,
          showEmojiPicker: this.state.showEmojiPicker,
          toggleEmojiPicker: this.toggleEmojiPicker
        });
      }

      const showDotMenuIcon = isMobile || hover;
      let dotMenu;

      if (showDotMenuIcon) {
        dotMenu = react_default.a.createElement(dot_menu["a" /* default */], {
          post: post,
          commentCount: this.props.replyCount,
          isFlagged: this.props.isFlagged,
          handleCommentClick: this.props.handleCommentClick,
          handleDropdownOpened: this.handleDotMenuOpened,
          handleAddReactionClick: this.toggleEmojiPicker,
          isReadOnly: isReadOnly,
          enableEmojiPicker: this.props.enableEmojiPicker
        });
      }

      return react_default.a.createElement("div", {
        ref: "dotMenu",
        className: 'col col__reply'
      }, dotMenu, postReaction);
    });

    this.state = {
      showEmojiPicker: false
    };
  }

  render() {
    const post = this.props.post;
    const isEphemeral = utils["Z" /* isPostEphemeral */](post);
    const isSystemMessage = post_utils["l" /* isSystemMessage */](post);
    const fromAutoResponder = post_utils["d" /* fromAutoResponder */](post);
    const showFlagIcon = !isEphemeral && !post.failed && !isSystemMessage && (this.props.hover || this.props.isFlagged);
    let postFlagIcon;

    if (showFlagIcon && !this.props.isBot) {
      postFlagIcon = react_default.a.createElement(post_flag_icon["a" /* default */], {
        postId: post.id,
        isFlagged: this.props.isFlagged,
        isEphemeral: isEphemeral
      });
    }

    let postInfoIcon;

    if (post.props && post.props.card) {
      postInfoIcon = react_default.a.createElement(OverlayTrigger["a" /* default */], {
        trigger: ['hover', 'focus'],
        delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
        placement: "top",
        overlay: react_default.a.createElement(Tooltip["a" /* default */], null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "post_info.info.view_additional_info",
          defaultMessage: "View additional info"
        }))
      }, react_default.a.createElement("button", {
        className: 'card-icon__container icon--show style--none ' + (this.props.isCardOpen ? 'active' : ''),
        onClick: e => {
          e.preventDefault();
          this.props.handleCardClick(this.props.post);
        }
      }, react_default.a.createElement(info_small_icon["a" /* default */], {
        className: "icon icon__info",
        "aria-hidden": "true"
      })));
    } // let options;
    // if (isEphemeral) {
    //     options = (
    //         <div className='col col__remove'>
    //             {this.createRemovePostButton()}
    //             333
    //         </div>
    //     );
    // } else if (!post.failed) {
    //     options = this.buildOptions(post, isSystemMessage, fromAutoResponder);
    // }


    let visibleMessage;

    if (isEphemeral && !this.props.compactDisplay && post.state !== mattermost_redux_constants["Posts"].POST_DELETED) {
      visibleMessage = react_default.a.createElement("span", {
        className: "post__visibility"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "post_info.message.visible",
        defaultMessage: "(Only visible to you)"
      }));
    }

    let pinnedBadge;

    if (post.is_pinned) {
      pinnedBadge = react_default.a.createElement("span", {
        className: "post__pinned-badge"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "post_info.pinned",
        defaultMessage: "Pinned"
      }));
    }

    const showPostTime = this.props.hover || this.props.showTimeWithoutHover;
    let postTime;

    if (showPostTime) {
      // timestamp should not be a permalink if the post has been deleted, is ephemeral message, is pending, or is combined activity
      const isPermalink = !(isEphemeral || mattermost_redux_constants["Posts"].POST_DELETED === post.state || utils_post_utils["isPostPendingOrFailed"](post) || post.type === mattermost_redux_constants["Posts"].POST_TYPES.COMBINED_USER_ACTIVITY);
      postTime = react_default.a.createElement(post_time["a" /* default */], {
        isPermalink: isPermalink,
        eventTime: post.create_at,
        postId: post.id
      });
    }

    const replyCount = !this.props.post.root_id && this.props.replyCount > 0 && react_default.a.createElement("span", {
      className: "reply__count",
      onClick: this.props.handleCommentClick
    }, react_default.a.createElement(reply_icon, {
      style: {
        verticalAlign: 'middle',
        marginRight: 3
      },
      fill: "#00bc70"
    }), this.props.replyCount, "\u6761\u56DE\u590D");
    return react_default.a.createElement("div", {
      className: "post__header--info"
    }, react_default.a.createElement("div", {
      className: "col"
    }, postTime, replyCount, pinnedBadge, postInfoIcon, postFlagIcon, visibleMessage));
  }

}

post_info_defineProperty(post_info_PostInfo, "propTypes", {
  /*
   * The post to render the info for
   */
  post: prop_types_default.a.object.isRequired,

  /*
   * The id of the team which belongs the post
   */
  teamId: prop_types_default.a.string,

  /*
   * Function called when the comment icon is clicked
   */
  handleCommentClick: prop_types_default.a.func.isRequired,

  /*
   * Function called when the card icon is clicked
   */
  handleCardClick: prop_types_default.a.func.isRequired,

  /*
   * Funciton called when the post options dropdown is opened
   */
  handleDropdownOpened: prop_types_default.a.func.isRequired,

  /*
   * Set to mark the post as flagged
   */
  isFlagged: prop_types_default.a.bool,

  /*
   * Set to mark the post as open the extra info in the rhs
   */
  isCardOpen: prop_types_default.a.bool,

  /*
   * The number of replies in the same thread as this post
   */
  replyCount: prop_types_default.a.number,

  /**
   * Set to indicate that this is previous post was not a reply to the same thread
   */
  isFirstReply: prop_types_default.a.bool,

  /**
   * Set to render in mobile view
   */
  isMobile: prop_types_default.a.bool,

  /**
   * Set to render in compact view
   */
  compactDisplay: prop_types_default.a.bool,

  /**
   * Set to mark post as being hovered over
   */
  hover: prop_types_default.a.bool.isRequired,

  /**
   * Set to render the post time when not hovering
   */
  showTimeWithoutHover: prop_types_default.a.bool.isRequired,

  /**
   * Whether to show the emoji picker.
   */
  enableEmojiPicker: prop_types_default.a.bool.isRequired,

  /**
   * Set not to allow edits on post
   */
  isReadOnly: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    /*
     * Function to remove the post
     */
    removePost: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/post_view/post_info/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











function post_info_mapStateToProps(state, ownProps) {
  const selectedCard = Object(selectors_rhs["r" /* getSelectedPostCard */])(state);
  const config = Object(general["getConfig"])(state);
  const channel = state.entities.channels.channels[ownProps.post.channel_id];
  const channelIsArchived = channel ? channel.delete_at !== 0 : null;
  const enableEmojiPicker = config.EnableEmojiPicker === 'true' && !channelIsArchived;
  const teamId = Object(entities_teams["getCurrentTeamId"])(state);
  return {
    teamId,
    isFlagged: Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_FLAGGED_POST, ownProps.post.id, null) != null,
    isMobile: state.views.channel.mobileView,
    isCardOpen: selectedCard && selectedCard.id === ownProps.post.id,
    enableEmojiPicker,
    isReadOnly: Object(entities_channels["isCurrentChannelReadOnly"])(state) || channelIsArchived
  };
}

function post_info_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      removePost: actions_posts["removePost"]
    }, dispatch)
  };
}

/* harmony default export */ var post_info = (Object(es["connect"])(post_info_mapStateToProps, post_info_mapDispatchToProps)(post_info_PostInfo));
// CONCATENATED MODULE: ./components/post_view/post_header/post_header.jsx
function post_header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class post_header_PostHeader extends react_default.a.PureComponent {
  render() {
    const {
      post
    } = this.props;
    const isSystemMessage = post_utils["l" /* isSystemMessage */](post);
    const fromAutoResponder = post_utils["d" /* fromAutoResponder */](post);
    const fromWebhook = post && post.props && post.props.from_webhook === 'true';
    let userProfile = react_default.a.createElement(user_profile["a" /* default */], {
      userId: post.user_id,
      hasMention: true
    });
    let indicator;
    let colon;

    if (fromWebhook && !this.props.isBot) {
      if (post.props.override_username && this.props.enablePostUsernameOverride) {
        userProfile = react_default.a.createElement(user_profile["a" /* default */], {
          userId: post.user_id,
          hideStatus: true,
          overwriteName: post.props.override_username
        });
      } else {
        userProfile = react_default.a.createElement(user_profile["a" /* default */], {
          userId: post.user_id,
          hideStatus: true
        });
      }

      indicator = react_default.a.createElement(bot_badge["a" /* default */], null);
    } else if (fromAutoResponder) {
      userProfile = react_default.a.createElement(user_profile["a" /* default */], {
        userId: post.user_id,
        hideStatus: true,
        hasMention: true
      });
      indicator = react_default.a.createElement(badges_badge["a" /* default */], null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "post_info.auto_responder",
        defaultMessage: "AUTOMATIC REPLY"
      }));
    } else if (isSystemMessage && this.props.isBot) {
      userProfile = react_default.a.createElement(user_profile["a" /* default */], {
        userId: post.user_id,
        hideStatus: true
      });
    } else if (isSystemMessage) {
      userProfile = react_default.a.createElement(user_profile["a" /* default */], {
        overwriteName: react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "post_info.system",
          defaultMessage: "System"
        }),
        overwriteImage: constants["N" /* default */].SYSTEM_MESSAGE_PROFILE_IMAGE,
        disablePopover: true
      });
    }

    if (this.props.compactDisplay) {
      colon = react_default.a.createElement("strong", {
        className: "colon"
      }, ':');
    }

    return react_default.a.createElement("div", {
      className: "post__header"
    }, react_default.a.createElement("div", {
      className: "col col__name"
    }, userProfile, colon, indicator), react_default.a.createElement("div", {
      className: "col"
    }, react_default.a.createElement(post_info, {
      isBot: this.props.isBot,
      post: post,
      handleCommentClick: this.props.handleCommentClick,
      handleCardClick: this.props.handleCardClick,
      handleDropdownOpened: this.props.handleDropdownOpened,
      compactDisplay: this.props.compactDisplay,
      replyCount: this.props.replyCount,
      isFirstReply: this.props.isFirstReply,
      showTimeWithoutHover: this.props.showTimeWithoutHover,
      hover: this.props.hover
    })));
  }

}

post_header_defineProperty(post_header_PostHeader, "propTypes", {
  /*
   * The post to render the header for
   */
  post: prop_types_default.a.object.isRequired,

  /*
   * Function called when the comment icon is clicked
   */
  handleCommentClick: prop_types_default.a.func.isRequired,

  /*
   * Function called when the card icon is clicked
   */
  handleCardClick: prop_types_default.a.func.isRequired,

  /*
   * Function called when the post options dropdown is opened
   */
  handleDropdownOpened: prop_types_default.a.func.isRequired,

  /*
   * Set to render compactly
   */
  compactDisplay: prop_types_default.a.bool,

  /*
   * The number of replies in the same thread as this post
   */
  replyCount: prop_types_default.a.number,

  /**
   * Set to indicate that this is previous post was not a reply to the same thread
   */
  isFirstReply: prop_types_default.a.bool,

  /**
   * Set to mark post as being hovered over
   */
  hover: prop_types_default.a.bool.isRequired,

  /*
   * Set to render the post time when not hovering
   */
  showTimeWithoutHover: prop_types_default.a.bool,

  /**
   * Whether or not the post username can be overridden.
   */
  enablePostUsernameOverride: prop_types_default.a.bool.isRequired,

  /**
   * If the user that made the post is a bot.
   */
  isBot: prop_types_default.a.bool.isRequired
});
// CONCATENATED MODULE: ./components/post_view/post_header/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function post_header_mapStateToProps(state, ownProps) {
  const config = Object(general["getConfig"])(state);
  const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
  const user = Object(entities_users["getUser"])(state, ownProps.post.user_id);
  const isBot = Boolean(user && user.is_bot);
  return {
    enablePostUsernameOverride,
    isBot
  };
}

/* harmony default export */ var post_header = (Object(es["connect"])(post_header_mapStateToProps)(post_header_PostHeader));
// EXTERNAL MODULE: ./node_modules/antd/es/checkbox/index.js + 2 modules
var es_checkbox = __webpack_require__(3492);

// CONCATENATED MODULE: ./components/post_view/post/post.jsx
function post_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









class post_Post extends react_default.a.PureComponent {
  constructor(_props) {
    super(_props);

    post_defineProperty(this, "handleCommentClick", e => {
      e.preventDefault();
      const post = this.props.post;

      if (!post) {
        return;
      }

      this.props.actions.selectPost(post);
    });

    post_defineProperty(this, "handleCardClick", post => {
      if (!post) {
        return;
      }

      this.props.actions.selectPostCard(post);
    });

    post_defineProperty(this, "handleDropdownOpened", opened => {
      if (this.props.togglePostMenu) {
        this.props.togglePostMenu(opened);
      }

      this.setState({
        dropdownOpened: opened
      });
    });

    post_defineProperty(this, "hasSameRoot", props => {
      const post = props.post;

      if (props.isFirstReply) {
        return false;
      } else if (!post.root_id && !props.previousPostIsComment && props.consecutivePostByUser) {
        return true;
      } else if (post.root_id) {
        return true;
      }

      return false;
    });

    post_defineProperty(this, "isCurrentUser", (post, isSystemMessage, fromWebhook) => this.props.currentUserId === post.user_id && !fromWebhook && !isSystemMessage);

    post_defineProperty(this, "getClassName", (post, isSystemMessage, isMeMessage, fromWebhook, fromAutoResponder, fromBot) => {
      let className = 'post';

      if (post.failed || post.state === mattermost_redux_constants["Posts"].POST_DELETED) {
        className += ' post--hide-controls';
      }

      if (this.props.shouldHighlight) {
        className += ' post--highlight';
      }

      let rootUser = '';

      if (this.state.sameRoot && !fromBot) {
        // rootUser = 'same--root';
        // fix: visibile post-head
        rootUser = 'other--root';
      } else {
        rootUser = 'other--root';
      }

      let currentUserCss = '';

      if (this.props.currentUserId === post.user_id && !fromWebhook && !isSystemMessage) {
        currentUserCss = 'current--user';
      }

      let sameUserClass = '';

      if (this.props.consecutivePostByUser) {
        sameUserClass = 'same--user';
      }

      let postType = '';

      if (post.root_id && post.root_id.length > 0) {
        postType = 'post--comment';
      } else if (this.props.replyCount > 0) {
        postType = 'post--root';
        sameUserClass = '';
        rootUser = '';
      }

      if (isSystemMessage || isMeMessage) {
        className += ' post--system';

        if (isSystemMessage) {
          currentUserCss = '';
          postType = '';
          rootUser = '';
        }
      }

      if (fromAutoResponder) {
        postType = 'post--comment same--root';
      }

      if (this.props.compactDisplay) {
        className += ' post--compact';
      }

      if (this.state.dropdownOpened) {
        className += ' post--hovered';
      }

      if (post.is_pinned) {
        className += ' post--pinned';
      }

      if (this.state.hover) {
        className += ' post--hover--active';
      }

      return className + ' ' + sameUserClass + ' ' + rootUser + ' ' + postType + ' ' + currentUserCss;
    });

    post_defineProperty(this, "getRef", node => {
      this.domNode = node;
    });

    post_defineProperty(this, "setHover", () => {
      this.setState({
        hover: true
      });
    });

    post_defineProperty(this, "unsetHover", () => {
      this.setState({
        hover: false
      });
    });

    this.state = {
      dropdownOpened: false,
      hover: false,
      sameRoot: this.hasSameRoot(_props)
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    this.setState({
      sameRoot: this.hasSameRoot(nextProps)
    });
  }

  render() {
    const {
      post,
      hasCheckbox
    } = this.props;

    if (!post.id) {
      return null;
    }

    const isSystemMessage = post_utils["l" /* isSystemMessage */](post);
    const isMeMessage = Object(utils_post_utils["isMeMessage"])(post);
    const fromAutoResponder = post_utils["d" /* fromAutoResponder */](post);
    const fromWebhook = post && post.props && post.props.from_webhook === 'true';
    const fromBot = post && post.props && post.props.from_bot === 'true';
    let profilePic; // const hideProfilePicture = this.state.sameRoot && this.props.consecutivePostByUser && (!post.root_id && this.props.replyCount === 0) && !fromBot;
    // fix: visibile profile picture

    const hideProfilePicture = false;

    if (!hideProfilePicture) {
      profilePic = react_default.a.createElement(post_profile_picture["a" /* default */], {
        compactDisplay: this.props.compactDisplay,
        post: post,
        userId: post.user_id
      });

      if (fromAutoResponder) {
        profilePic = react_default.a.createElement("span", {
          className: "auto-responder"
        }, profilePic);
      }
    }

    let centerClass = '';

    if (this.props.center) {
      centerClass = 'center';
    }

    const hasCheckboxCls = hasCheckbox ? 'post__select' : '';
    const isBot = post.props && post.props.from_bot || /^system_/.test(post.type) || false; // 二级嵌套不可选

    let isTwo = false;

    if (post.card_type === '11-1') {
      let cardData = post.message;

      try {
        cardData = JSON.parse(post.message);
      } catch (e) {}

      if (typeof cardData === 'object') {
        if (cardData.data) {
          cardData.data.map(item => {
            if (item.card_type === '11-1') {
              isTwo = true;
            }
          });
        }
      }
    }

    return react_default.a.createElement("div", {
      ref: this.getRef,
      id: 'post_' + post.id,
      role: "listitem",
      className: `${this.getClassName(post, isSystemMessage, isMeMessage, fromWebhook, fromAutoResponder, fromBot)} ${hasCheckboxCls}`,
      tabIndex: "-1",
      onFocus: this.setFocus,
      onBlur: this.removeFocus,
      onMouseOver: this.setHover,
      onMouseLeave: this.unsetHover,
      onTouchStart: this.setHover
    }, hasCheckbox && !isTwo && !isBot && react_default.a.createElement(es_checkbox["a" /* default */], {
      className: "post__msg__checkbox",
      value: post,
      onChange: e => this.props.actions.setMessageMergeForward(e.target.value)
    }), react_default.a.createElement("div", {
      id: "postContent",
      className: 'post__content ' + centerClass + ' post__msg__selecting'
    }, react_default.a.createElement("div", {
      className: "post__img"
    }, profilePic), react_default.a.createElement("div", {
      style: {
        width: '100%'
      }
    }, react_default.a.createElement(post_header, {
      post: post,
      handleCommentClick: this.handleCommentClick,
      handleCardClick: this.handleCardClick,
      handleDropdownOpened: this.handleDropdownOpened,
      compactDisplay: this.props.compactDisplay,
      isFirstReply: this.props.isFirstReply,
      replyCount: this.props.replyCount,
      showTimeWithoutHover: !hideProfilePicture,
      hover: this.state.hover,
      isBot: isBot
    }), react_default.a.createElement(post_body, {
      post: post,
      hasCheckbox: hasCheckbox,
      handleCommentClick: this.handleCommentClick,
      compactDisplay: this.props.compactDisplay,
      isCommentMention: this.props.isCommentMention,
      isFirstReply: this.props.isFirstReply,
      isCurrentUser: this.isCurrentUser(post, isSystemMessage, fromWebhook),
      replyCount: this.props.replyCount,
      hover: this.state.hover
    }))));
  }

}

post_defineProperty(post_Post, "propTypes", {
  /**
   * The post to render
   */
  post: prop_types_default.a.object.isRequired,

  /**
   * The logged in user ID
   */
  currentUserId: prop_types_default.a.string.isRequired,

  /**
   * Set to center the post
   */
  center: prop_types_default.a.bool,

  /**
   * Set to render post compactly
   */
  compactDisplay: prop_types_default.a.bool,

  /**
   * Set to render a preview of the parent post above this reply
   */
  isFirstReply: prop_types_default.a.bool,

  /**
   * Set to highlight the background of the post
   */
  shouldHighlight: prop_types_default.a.bool,

  /**
   * Set to render this post as if it was attached to the previous post
   */
  consecutivePostByUser: prop_types_default.a.bool,

  /**
   * Set if the previous post is a comment
   */
  previousPostIsComment: prop_types_default.a.bool,

  /*
   * Function called when the post options dropdown is opened
   */
  togglePostMenu: prop_types_default.a.func,

  /**
   * Set to render this comment as a mention
   */
  isCommentMention: prop_types_default.a.bool,

  /**
   * The number of replies in the same thread as this post
   */
  replyCount: prop_types_default.a.number,
  actions: prop_types_default.a.shape({
    selectPost: prop_types_default.a.func.isRequired,
    selectPostCard: prop_types_default.a.func.isRequired
  }).isRequired
});

post_defineProperty(post_Post, "defaultProps", {
  post: {}
});
// CONCATENATED MODULE: ./components/post_view/post/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











 // isFirstReply returns true when the given post a comment that isn't part of the same thread as the previous post.

function isFirstReply(post, previousPost) {
  if (post.root_id) {
    if (previousPost) {
      // Returns true as long as the previous post is part of a different thread
      return post.root_id !== previousPost.id && post.root_id !== previousPost.root_id;
    } // The previous post is not a real post


    return true;
  } // This post is not a reply


  return false;
}
function makeGetReplyCount() {
  return Object(reselect_es["a" /* createSelector */])(state => state.entities.posts.posts, (state, post) => state.entities.posts.postsInThread[post.root_id || post.id], (allPosts, postIds) => {
    if (!postIds) {
      return 0;
    } // Count the number of non-ephemeral posts in the thread


    return postIds.map(id => allPosts[id]).filter(post => post && !Object(utils_post_utils["isPostEphemeral"])(post)).length;
  });
}

function post_makeMapStateToProps() {
  const getReplyCount = makeGetReplyCount();
  const isPostCommentMention = Object(entities_posts["makeIsPostCommentMention"])();
  return (state, ownProps) => {
    const post = ownProps.post || Object(entities_posts["getPost"])(state, ownProps.postId);
    let previousPost = null;

    if (ownProps.previousPostId) {
      previousPost = Object(entities_posts["getPost"])(state, ownProps.previousPostId);
    }

    let consecutivePostByUser = false;
    let previousPostIsComment = false;

    if (previousPost) {
      consecutivePostByUser = post.user_id === previousPost.user_id && // The post is by the same user
      post.create_at - previousPost.create_at <= mattermost_redux_constants["Posts"].POST_COLLAPSE_TIMEOUT && // And was within a short time period
      !(post.props && post.props.from_webhook) && !(previousPost.props && previousPost.props.from_webhook) && // And neither is from a webhook
      !Object(utils_post_utils["isSystemMessage"])(post) && !Object(utils_post_utils["isSystemMessage"])(previousPost); // And neither is a system message

      previousPostIsComment = Boolean(previousPost.root_id);
    }

    let channelPostSelect;
    let hasCheckbox = false;

    if (state.views.posts) {
      channelPostSelect = state.views.posts.channelPostSelect;

      if (channelPostSelect) {
        if (constants["f" /* ChannelPostSelectType */].MERGE === channelPostSelect.type) {
          hasCheckbox = channelPostSelect.visibleCheckbox;
        }
      }
    } else {
      channelPostSelect = {};
    }

    return {
      post,
      currentUserId: Object(entities_users["getCurrentUserId"])(state),
      isFirstReply: isFirstReply(post, previousPost),
      consecutivePostByUser,
      previousPostIsComment,
      replyCount: getReplyCount(state, post),
      isCommentMention: isPostCommentMention(state, post.id),
      center: Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].CHANNEL_DISPLAY_MODE, constants["w" /* Preferences */].CHANNEL_DISPLAY_MODE_DEFAULT) === constants["w" /* Preferences */].CHANNEL_DISPLAY_MODE_CENTERED,
      compactDisplay: Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].MESSAGE_DISPLAY, constants["w" /* Preferences */].MESSAGE_DISPLAY_DEFAULT) === constants["w" /* Preferences */].MESSAGE_DISPLAY_COMPACT,
      channelPostSelect,
      hasCheckbox
    };
  };
}

function post_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      selectPost: rhs["g" /* selectPost */],
      selectPostCard: rhs["h" /* selectPostCard */],
      setMessageMergeForward: views_posts["d" /* setMessageMergeForward */]
    }, dispatch)
  };
}

/* harmony default export */ var post_view_post = (Object(es["connect"])(post_makeMapStateToProps, post_mapDispatchToProps)(post_Post));
// CONCATENATED MODULE: ./components/post_view/combined_user_activity_post/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



function combined_user_activity_post_makeMapStateToProps() {
  const generateCombinedPost = Object(post_list["makeGenerateCombinedPost"])();
  return (state, ownProps) => {
    return {
      post: generateCombinedPost(state, ownProps.combinedId),
      postId: ownProps.combinedId
    };
  };
} // Note that this also passes through Post's mapStateToProps

/* harmony default export */ var combined_user_activity_post = (Object(es["connect"])(combined_user_activity_post_makeMapStateToProps)(post_view_post));
// CONCATENATED MODULE: ./components/svg/scroll_to_bottom_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class scroll_to_bottom_icon_ScrollToBottomIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.arrow.down",
      defaultMessage: "Down Arrow Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      id: "Layer_1",
      x: "0px",
      y: "0px",
      viewBox: "-239 239 21 23",
      style: scroll_to_bottom_icon_style,
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("path", {
      d: "M-239,241.4l2.4-2.4l8.1,8.2l8.1-8.2l2.4,2.4l-10.5,10.6L-239,241.4z M-228.5,257.2l8.1-8.2l2.4,2.4l-10.5,10.6l-10.5-10.6 l2.4-2.4L-228.5,257.2z"
    }))));
  }

}
const scroll_to_bottom_icon_style = {
  enableBackground: 'new -239 239 21 23'
};
// CONCATENATED MODULE: ./components/post_view/scroll_to_bottom_arrows.jsx
function scroll_to_bottom_arrows_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class scroll_to_bottom_arrows_ScrollToBottomArrows extends react_default.a.PureComponent {
  render() {
    // only show on mobile
    if (jquery_default()(window).width() > 768) {
      return null;
    }

    let className = 'post-list__arrows';

    if (this.props.isScrolling && !this.props.atBottom) {
      className += ' scrolling';
    }

    return react_default.a.createElement("div", {
      className: className,
      onClick: this.props.onClick
    }, react_default.a.createElement(scroll_to_bottom_icon_ScrollToBottomIcon, null));
  }

}

scroll_to_bottom_arrows_defineProperty(scroll_to_bottom_arrows_ScrollToBottomArrows, "propTypes", {
  isScrolling: prop_types_default.a.bool.isRequired,
  atBottom: prop_types_default.a.bool.isRequired,
  onClick: prop_types_default.a.func.isRequired
});
// EXTERNAL MODULE: ./components/toggle_modal_button_redux/index.js + 1 modules
var toggle_modal_button_redux = __webpack_require__(1824);

// EXTERNAL MODULE: ./components/toggle_modal_button.jsx
var toggle_modal_button = __webpack_require__(1712);

// EXTERNAL MODULE: ./components/icon/edit_icon.jsx
var edit_icon = __webpack_require__(2184);

// CONCATENATED MODULE: ./components/post_view/channel_intro_message/channel_intro_message.jsx
function channel_intro_message_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




















class channel_intro_message_ChannelIntroMessage extends react_default.a.PureComponent {
  render() {
    const {
      currentUserId,
      channel,
      fullWidth,
      locale,
      enableUserCreation,
      isReadOnly,
      channelProfiles,
      teamIsGroupConstrained
    } = this.props;
    let centeredIntro = "";

    if (!fullWidth) {
      centeredIntro = "channel-intro--centered";
    }

    if (channel.type === constants["g" /* Constants */].DM_CHANNEL) {
      return createDMIntroMessage(channel, centeredIntro);
    } else if (channel.type === constants["g" /* Constants */].GM_CHANNEL) {
      return createGMIntroMessage(channel, centeredIntro, channelProfiles, currentUserId);
    } else if (channel.name === constants["g" /* Constants */].DEFAULT_CHANNEL) {
      return createDefaultIntroMessage(channel, centeredIntro, enableUserCreation, isReadOnly, teamIsGroupConstrained);
    } else if (channel.name === constants["g" /* Constants */].OFFTOPIC_CHANNEL) {
      return createOffTopicIntroMessage(channel, centeredIntro);
    } else if (channel.type === constants["g" /* Constants */].OPEN_CHANNEL || channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
      return createStandardIntroMessage(channel, centeredIntro, locale);
    }

    return null;
  }

}

channel_intro_message_defineProperty(channel_intro_message_ChannelIntroMessage, "propTypes", {
  currentUserId: prop_types_default.a.string.isRequired,
  channel: prop_types_default.a.object.isRequired,
  fullWidth: prop_types_default.a.bool.isRequired,
  locale: prop_types_default.a.string.isRequired,
  channelProfiles: prop_types_default.a.array.isRequired,
  enableUserCreation: prop_types_default.a.bool,
  isReadOnly: prop_types_default.a.bool,
  teamIsGroupConstrained: prop_types_default.a.bool
});

function createGMIntroMessage(channel, centeredIntro, profiles, currentUserId) {
  const channelIntroId = "channelIntro";

  if (profiles.length > 0) {
    const pictures = profiles.filter(profile => profile.id !== currentUserId).map(profile => react_default.a.createElement(profile_picture["a" /* default */], {
      key: "introprofilepicture" + profile.id,
      src: utils["K" /* imageURLForUser */](profile),
      width: "50",
      height: "50",
      userId: profile.id,
      username: profile.username
    }));
    return react_default.a.createElement("div", {
      id: channelIntroId,
      className: "channel-intro " + centeredIntro
    }, react_default.a.createElement("div", {
      className: "post-profile-img__container channel-intro-img"
    }, pictures), react_default.a.createElement("p", {
      className: "channel-intro-text"
    }, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
      id: "intro_messages.GM",
      defaultMessage: "This is the start of your group message history with {names}.\\nMessages and files shared here are not shown to people outside this area.",
      values: {
        names: channel.display_name
      }
    })), createSetHeaderButton(channel));
  }

  return react_default.a.createElement("div", {
    id: channelIntroId,
    className: "channel-intro " + centeredIntro
  }, react_default.a.createElement("p", {
    className: "channel-intro-text"
  }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "intro_messages.group_message",
    defaultMessage: "This is the start of your group message history with these teammates. Messages and files shared here are not shown to people outside this area."
  })));
}

function createDMIntroMessage(channel, centeredIntro) {
  var teammate = utils["v" /* getDirectTeammate */](channel.id);
  const channelIntroId = "channelIntro";

  if (teammate) {
    var teammateName = teammate.username;

    if (teammate.nickname.length > 0) {
      teammateName = teammate.nickname;
    }

    return react_default.a.createElement("div", {
      id: channelIntroId,
      className: "channel-intro " + centeredIntro
    }, react_default.a.createElement("div", {
      className: "post-profile-img__container channel-intro-img"
    }, react_default.a.createElement(profile_picture["a" /* default */], {
      src: utils["K" /* imageURLForUser */](teammate),
      width: "50",
      height: "50",
      userId: teammate.id,
      username: teammate.username,
      hasMention: true
    })), react_default.a.createElement("div", {
      className: "channel-intro-profile d-flex"
    }, react_default.a.createElement(user_profile["a" /* default */], {
      userId: teammate.id,
      disablePopover: false,
      hasMention: true
    })), react_default.a.createElement("p", {
      className: "channel-intro-text"
    }, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
      id: "intro_messages.DM",
      defaultMessage: "This is the start of your direct message history with {teammate}.\\nDirect messages and files shared here are not shown to people outside this area.",
      values: {
        teammate: teammateName
      }
    })), teammate.is_bot ? null : createSetHeaderButton(channel));
  }

  return react_default.a.createElement("div", {
    id: channelIntroId,
    className: "channel-intro " + centeredIntro
  }, react_default.a.createElement("p", {
    className: "channel-intro-text"
  }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "intro_messages.teammate",
    defaultMessage: "This is the start of your direct message history with this teammate. Direct messages and files shared here are not shown to people outside this area."
  })));
}

function createOffTopicIntroMessage(channel, centeredIntro) {
  const isPrivate = channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL;
  const children = createSetHeaderButton(channel);
  let setHeaderButton = null;

  if (children) {
    setHeaderButton = react_default.a.createElement(channel_permission_gate["a" /* default */], {
      teamId: channel.team_id,
      channelId: channel.id,
      permissions: [isPrivate ? mattermost_redux_constants["Permissions"].MANAGE_PRIVATE_CHANNEL_PROPERTIES : mattermost_redux_constants["Permissions"].MANAGE_PUBLIC_CHANNEL_PROPERTIES]
    }, children);
  }

  const channelInviteButton = createInviteChannelButton(channel);
  return react_default.a.createElement("div", {
    id: "channelIntro",
    className: "channel-intro " + centeredIntro
  }, react_default.a.createElement("h4", {
    className: "channel-intro__title"
  }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "intro_messages.beginning",
    defaultMessage: "Beginning of {name}",
    values: {
      name: channel.display_name
    }
  })), react_default.a.createElement("p", {
    className: "channel-intro__content"
  }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "intro_messages.offTopic",
    defaultMessage: "This is the start of {display_name}, a channel for non-work-related conversations.",
    values: {
      display_name: channel.display_name
    }
  })), channelInviteButton, setHeaderButton);
}

function createDefaultIntroMessage(channel, centeredIntro, enableUserCreation, isReadOnly, teamIsGroupConstrained) {
  let teamInviteLink = null;

  if (!isReadOnly && enableUserCreation) {
    teamInviteLink = react_default.a.createElement(team_permission_gate["a" /* default */], {
      teamId: channel.team_id,
      permissions: [mattermost_redux_constants["Permissions"].INVITE_USER]
    }, react_default.a.createElement(team_permission_gate["a" /* default */], {
      teamId: channel.team_id,
      permissions: [mattermost_redux_constants["Permissions"].ADD_USER_TO_TEAM]
    }, !teamIsGroupConstrained && react_default.a.createElement("span", {
      className: "intro-links color--link cursor--pointer",
      onClick: global_actions["l" /* showGetTeamInviteLinkModal */]
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.add",
      defaultMessage: "Add Icon"
    }, title => react_default.a.createElement("i", {
      className: "fa fa-user-plus",
      title: title
    })), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "intro_messages.inviteOthers",
      defaultMessage: "Invite others to this team"
    })), teamIsGroupConstrained && react_default.a.createElement(toggle_modal_button["a" /* default */], {
      className: "intro-links color--link",
      dialogType: add_groups_to_team_modal["a" /* default */],
      dialogProps: {
        channel
      }
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.add",
      defaultMessage: "Add Icon"
    }, title => react_default.a.createElement("i", {
      className: "fa fa-user-plus",
      title: title
    })), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "intro_messages.addGroupsToTeam",
      defaultMessage: "Add other groups to this team"
    }))));
  }

  const isPrivate = channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL;
  let setHeaderButton = null;

  if (!isReadOnly) {
    const children = createSetHeaderButton(channel);

    if (children) {
      setHeaderButton = react_default.a.createElement(channel_permission_gate["a" /* default */], {
        teamId: channel.team_id,
        channelId: channel.id,
        permissions: [isPrivate ? mattermost_redux_constants["Permissions"].MANAGE_PRIVATE_CHANNEL_PROPERTIES : mattermost_redux_constants["Permissions"].MANAGE_PUBLIC_CHANNEL_PROPERTIES]
      }, children);
    }
  }

  return react_default.a.createElement("div", {
    id: "channelIntro",
    className: "channel-intro " + centeredIntro
  }, react_default.a.createElement("h4", {
    className: "channel-intro__title"
  }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "intro_messages.beginning",
    defaultMessage: "Beginning of {name}",
    values: {
      name: channel.display_name
    }
  })), react_default.a.createElement("p", {
    className: "channel-intro__content"
  }, !isReadOnly && react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "intro_messages.default",
    defaultMessage: "**Welcome to {display_name}!**\\n \\nPost messages here that you want everyone to see. Everyone automatically becomes a permanent member of this channel when they join the team.",
    values: {
      display_name: channel.display_name
    }
  }), isReadOnly && react_default.a.createElement(formatted_markdown_message["b" /* default */], {
    id: "intro_messages.readonly.default",
    defaultMessage: "**Welcome to {display_name}!**\\n \\nMessages can only be posted by system admins. Everyone automatically becomes a permanent member of this channel when they join the team.",
    values: {
      display_name: channel.display_name
    }
  })), teamInviteLink, setHeaderButton, react_default.a.createElement("br", null));
}

function createStandardIntroMessage(channel, centeredIntro, locale) {
  var uiName = channel.display_name;
  var creatorName = utils["x" /* getDisplayNameByUserId */](channel.creator_id);
  var memberMessage;
  const channelIsArchived = channel.delete_at !== 0;

  if (channelIsArchived) {
    memberMessage = "";
  } else if (channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
    memberMessage = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "intro_messages.onlyInvited",
      defaultMessage: " Only invited members can see this private channel."
    });
  } else {
    memberMessage = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "intro_messages.anyMember",
      defaultMessage: " Any member can join and read this channel."
    });
  }

  const date = react_default.a.createElement(index_es["a" /* FormattedDate */], {
    value: channel.create_at,
    month: Object(i18n["a" /* getMonthLong */])(locale),
    day: "2-digit",
    year: "numeric"
  });
  var createMessage;

  if (creatorName === "") {
    if (channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
      createMessage = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "intro_messages.noCreatorPrivate",
        defaultMessage: "This is the start of the {name} private channel, created on {date}.",
        values: {
          name: uiName,
          date
        }
      });
    } else if (channel.type === constants["g" /* Constants */].OPEN_CHANNEL) {
      createMessage = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "intro_messages.noCreator",
        defaultMessage: "This is the start of the {name} channel, created on {date}.",
        values: {
          name: uiName,
          date
        }
      });
    }
  } else if (channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
    createMessage = react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "intro_messages.creatorPrivate",
      defaultMessage: "This is the start of the {name} private channel, created by {creator} on {date}.",
      values: {
        name: uiName,
        creator: creatorName,
        date
      }
    }));
  } else if (channel.type === constants["g" /* Constants */].OPEN_CHANNEL) {
    createMessage = react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "intro_messages.creator",
      defaultMessage: "This is the start of the {name} channel, created by {creator} on {date}.",
      values: {
        name: uiName,
        creator: creatorName,
        date,
        type: ''
      }
    }));
  }

  var purposeMessage = "";

  if (channel.purpose && channel.purpose !== "") {
    if (channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
      purposeMessage = react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "intro_messages.purposePrivate",
        defaultMessage: " This private channel's purpose is: {purpose}",
        values: {
          purpose: channel.purpose
        }
      }));
    } else if (channel.type === constants["g" /* Constants */].OPEN_CHANNEL) {
      purposeMessage = react_default.a.createElement("span", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "intro_messages.purpose",
        defaultMessage: " This channel's purpose is: {purpose}",
        values: {
          purpose: channel.purpose,
          type: ''
        }
      }));
    }
  }

  const isPrivate = channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL;
  let setHeaderButton = null;
  const children = createSetHeaderButton(channel);

  if (children) {
    setHeaderButton = react_default.a.createElement(channel_permission_gate["a" /* default */], {
      teamId: channel.team_id,
      channelId: channel.id,
      permissions: [isPrivate ? mattermost_redux_constants["Permissions"].MANAGE_PRIVATE_CHANNEL_PROPERTIES : mattermost_redux_constants["Permissions"].MANAGE_PUBLIC_CHANNEL_PROPERTIES]
    }, children);
  }

  const channelInviteButton = createInviteChannelButton(channel);
  return react_default.a.createElement("div", {
    id: "channelIntro",
    className: "channel-intro " + centeredIntro
  }, react_default.a.createElement("h4", {
    className: "channel-intro__title"
  }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "intro_messages.beginning",
    defaultMessage: "Beginning of {name}",
    values: {
      name: uiName
    }
  })), react_default.a.createElement("p", {
    className: "channel-intro__content"
  }, createMessage, memberMessage, purposeMessage, react_default.a.createElement("br", null)), channelInviteButton, setHeaderButton);
}

function createInviteChannelButton(channel) {
  const modal = channel.group_constrained ? add_groups_to_channel_modal["a" /* default */] : channel_new_invite_modal["a" /* default */];
  const channelIsArchived = channel.delete_at !== 0;

  if (channelIsArchived) {
    return null;
  }

  const isPrivate = channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL;
  return react_default.a.createElement(channel_permission_gate["a" /* default */], {
    channelId: channel.id,
    teamId: channel.team_id,
    permissions: [isPrivate ? mattermost_redux_constants["Permissions"].MANAGE_PRIVATE_CHANNEL_MEMBERS : mattermost_redux_constants["Permissions"].MANAGE_PUBLIC_CHANNEL_MEMBERS]
  }, react_default.a.createElement(toggle_modal_button["a" /* default */], {
    className: "intro-links color--link",
    dialogType: modal,
    dialogProps: {
      channel
    }
  }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "generic_icons.add",
    defaultMessage: "Add Icon"
  }, title => react_default.a.createElement("i", {
    className: "fa fa-user-plus",
    title: title
  })), isPrivate && channel.group_constrained && react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "intro_messages.addGroups",
    defaultMessage: "Add groups to this private channel"
  }), isPrivate && !channel.group_constrained && react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "intro_messages.invitePrivate",
    defaultMessage: "Invite others to this private channel"
  }), !isPrivate && react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "intro_messages.invite",
    defaultMessage: "Invite others to this channel",
    values: {
      type: ''
    }
  })));
}

function createSetHeaderButton(channel) {
  return null;
  const channelIsArchived = channel.delete_at !== 0;

  if (channelIsArchived) {
    return null;
  }

  return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
    id: "intro_messages.setHeader",
    defaultMessage: "Set a Header"
  }, message => react_default.a.createElement(toggle_modal_button_redux["a" /* default */], {
    accessibilityLabel: message,
    className: "intro-links color--link",
    dialogType: components_edit_channel_header_modal,
    dialogProps: {
      channel
    }
  }, react_default.a.createElement(edit_icon["a" /* default */], null), message));
}
// CONCATENATED MODULE: ./components/post_view/channel_intro_message/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










function channel_intro_message_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const enableUserCreation = config.EnableUserCreation === "true";
  const isReadOnly = Object(entities_channels["isCurrentChannelReadOnly"])(state);
  const team = Object(entities_teams["getCurrentTeam"])(state);
  return {
    currentUserId: Object(entities_users["getCurrentUserId"])(state),
    locale: Object(selectors_i18n["a" /* getCurrentLocale */])(state),
    channelProfiles: Object(entities_users["getProfilesInCurrentChannel"])(state),
    enableUserCreation,
    isReadOnly,
    fullWidth: Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].CHANNEL_DISPLAY_MODE, constants["w" /* Preferences */].CHANNEL_DISPLAY_MODE_DEFAULT) === constants["w" /* Preferences */].CHANNEL_DISPLAY_MODE_FULL_SCREEN,
    teamIsGroupConstrained: Boolean(team.group_constrained)
  };
}

/* harmony default export */ var channel_intro_message = (Object(es["connect"])(channel_intro_message_mapStateToProps)(channel_intro_message_ChannelIntroMessage));
// CONCATENATED MODULE: ./components/post_view/post_list_ie/post_list_ie.jsx
function post_list_ie_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




















const CLOSE_TO_BOTTOM_SCROLL_MARGIN = 10;
const POSTS_PER_PAGE = constants["N" /* default */].POST_CHUNK_SIZE / 2;
const MAX_EXTRA_PAGES_LOADED = 10;
class post_list_ie_PostList extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    post_list_ie_defineProperty(this, "loadPostsToFillScreenIfNecessary", () => {
      if (this.props.focusedPostId) {
        return;
      }

      if (this.state.isDoingInitialLoad) {
        // Should already be loading posts
        return;
      }

      if (this.state.atEnd || !this.refs.postListContent || !this.refs.postlist) {
        // No posts to load
        return;
      }

      if (this.refs.postListContent.scrollHeight >= this.refs.postlist.clientHeight) {
        // Screen is full
        return;
      }

      if (this.extraPagesLoaded > MAX_EXTRA_PAGES_LOADED) {
        // Prevent this from loading a lot of pages in a channel with only hidden messages
        return;
      }

      this.doLoadPostsToFillScreen();
    });

    post_list_ie_defineProperty(this, "doLoadPostsToFillScreen", Object(actions_helpers["debounce"])(() => {
      this.extraPagesLoaded += 1;
      this.loadMorePosts();
    }, 100));

    post_list_ie_defineProperty(this, "initialScroll", () => {
      if (this.hasScrolledToNewMessageSeparator) {
        // Already scrolled to new messages indicator
        return false;
      }

      const postList = this.refs.postlist;
      const posts = this.props.posts;

      if (!postList || !posts) {
        // Not able to do initial scroll yet
        return false;
      }

      const messageSeparator = this.refs.newMessageSeparator; // Scroll to new message indicator since we have unread posts and we can't show every new post in the screen

      if (messageSeparator && postList.scrollHeight - messageSeparator.offsetTop > postList.clientHeight) {
        messageSeparator.scrollIntoView();
        this.setUnreadsBelow(posts, this.props.currentUserId);
        return true;
      } // Scroll to bottom since we don't have unread posts or we can show every new post in the screen


      postList.scrollTop = postList.scrollHeight;
      this.atBottom = true;
      return true;
    });

    post_list_ie_defineProperty(this, "setUnreadsBelow", (posts, currentUserId) => {
      const unViewedCount = posts.reduce((count, post) => {
        if (post.create_at > this.state.lastViewed && post.user_id !== currentUserId && post.state !== constants["N" /* default */].POST_DELETED) {
          return count + 1;
        }

        return count;
      }, 0);

      if (this.mounted) {
        this.setState({
          unViewedCount
        });
      }
    });

    post_list_ie_defineProperty(this, "handleScrollStop", () => {
      if (this.mounted) {
        this.setState({
          isScrolling: false
        });
      }
    });

    post_list_ie_defineProperty(this, "checkBottom", () => {
      if (!this.refs.postlist) {
        return true;
      } // No scroll bar so we're at the bottom


      if (this.refs.postlist.scrollHeight <= this.refs.postlist.clientHeight) {
        return true;
      }

      return this.refs.postlist.clientHeight + this.refs.postlist.scrollTop >= this.refs.postlist.scrollHeight - CLOSE_TO_BOTTOM_SCROLL_MARGIN;
    });

    post_list_ie_defineProperty(this, "handleWindowResize", () => {
      this.handleResize();
    });

    post_list_ie_defineProperty(this, "handleResize", forceScrollToBottom => {
      const postList = this.refs.postlist;
      const messageSeparator = this.refs.newMessageSeparator;
      const doScrollToBottom = this.atBottom || forceScrollToBottom;

      if (postList) {
        if (doScrollToBottom) {
          postList.scrollTop = postList.scrollHeight;
        } else if (!this.hasScrolled && messageSeparator) {
          const element = react_dom_default.a.findDOMNode(messageSeparator);
          element.scrollIntoView();
        }

        this.previousScrollHeight = postList.scrollHeight;
        this.previousScrollTop = postList.scrollTop;
        this.previousClientHeight = postList.clientHeight;
        this.atBottom = this.checkBottom();
      }

      this.props.actions.checkAndSetMobileView();
    });

    post_list_ie_defineProperty(this, "loadPosts", async (channelId, focusedPostId) => {
      if (!channelId) {
        return;
      }

      let posts;
      const {
        hasMoreBefore
      } = await this.props.actions.loadInitialPosts(channelId, focusedPostId);

      if (this.mounted) {
        this.setState({
          isDoingInitialLoad: false,
          atEnd: !hasMoreBefore
        });
      }

      if (focusedPostId) {
        this.hasScrolledToFocusedPost = true;
      } else {
        if (!this.checkBottom()) {
          const postsArray = posts.order.map(id => posts.posts[id]);
          this.setUnreadsBelow(postsArray, this.props.currentUserId);
        }

        this.hasScrolledToNewMessageSeparator = true;
      }
    });

    post_list_ie_defineProperty(this, "loadMorePosts", async e => {
      if (e) {
        e.preventDefault();
      }

      const {
        posts,
        channel
      } = this.props;
      const postsLength = posts.length;

      if (!posts) {
        return;
      }

      const {
        moreToLoad
      } = await this.props.actions.increasePostVisibility(channel.id, posts[postsLength - 1].id);
      this.setState({
        atEnd: !moreToLoad
      });
    });

    post_list_ie_defineProperty(this, "handleScroll", () => {
      // Only count as user scroll if we've already performed our first load scroll
      this.hasScrolled = this.hasScrolledToNewMessageSeparator || this.hasScrolledToFocusedPost;

      if (!this.refs.postlist) {
        return;
      }

      this.updateFloatingTimestamp();
      this.previousScrollTop = this.refs.postlist.scrollTop;

      if (this.refs.postlist.scrollHeight === this.previousScrollHeight) {
        this.atBottom = this.checkBottom();
      }

      if (!this.state.isScrolling) {
        this.setState({
          isScrolling: true
        });
      }

      if (this.checkBottom()) {
        this.setState({
          lastViewed: new Date().getTime(),
          unViewedCount: 0,
          isScrolling: false
        });
      }

      this.scrollStopAction.fireAfter(constants["N" /* default */].SCROLL_DELAY);
    });

    post_list_ie_defineProperty(this, "updateFloatingTimestamp", () => {
      // skip this in non-mobile view since that's when the timestamp is visible
      if (!utils["Y" /* isMobile */]()) {
        return;
      }

      if (this.props.posts) {
        // iterate through posts starting at the bottom since users are more likely to be viewing newer posts
        for (let i = 0; i < this.props.posts.length; i++) {
          const post = this.props.posts[i];
          const element = this.refs[post.id];
          const domNode = react_dom_default.a.findDOMNode(element);

          if (!element || !domNode || domNode.offsetTop + domNode.clientHeight <= this.refs.postlist.scrollTop) {
            // this post is off the top of the screen so the last one is at the top of the screen
            let topPost;

            if (i > 0) {
              topPost = this.props.posts[i - 1];
            } else {
              // the first post we look at should always be on the screen, but handle that case anyway
              topPost = post;
            }

            if (!this.state.topPost || topPost.id !== this.state.topPost.id) {
              this.setState({
                topPost
              });
            }

            break;
          }
        }
      }
    });

    post_list_ie_defineProperty(this, "scrollToBottom", () => {
      if (this.refs.postlist) {
        this.refs.postlist.scrollTop = this.refs.postlist.scrollHeight;
      }
    });

    post_list_ie_defineProperty(this, "createPosts", posts => {
      const postCtls = [];
      let previousPostDay = new Date(0);
      let previousPostId = '';
      const currentUserId = this.props.currentUserId;
      const lastViewed = this.props.lastViewedAt || 0;
      let renderedLastViewed = false;

      for (let i = posts.length - 1; i >= 0; i--) {
        const post = posts[i];
        let postCtl;

        if (post == null || post.type === constants["v" /* PostTypes */].EPHEMERAL_ADD_TO_CHANNEL) {
          continue;
        }

        if (Object(post_list["isCombinedUserActivityPost"])(post.id)) {
          postCtl = react_default.a.createElement(combined_user_activity_post, {
            combinedId: post.id,
            previousPostId: previousPostId
          });
        } else {
          postCtl = react_default.a.createElement(post_view_post, {
            ref: post.id,
            key: 'post ' + (post.id || post.pending_post_id),
            post: post,
            shouldHighlight: this.props.focusedPostId === post.id,
            previousPostId: previousPostId
          });
        }

        const currentPostDay = utils["t" /* getDateForUnixTicks */](post.create_at);

        if (currentPostDay.toDateString() !== previousPostDay.toDateString()) {
          postCtls.push(react_default.a.createElement(date_separator["a" /* default */], {
            key: currentPostDay,
            date: currentPostDay
          }));
        }

        const isNotCurrentUser = post.user_id !== currentUserId || Object(post_utils["k" /* isFromWebhook */])(post);

        if (isNotCurrentUser && lastViewed !== 0 && post.create_at > lastViewed && !utils["Z" /* isPostEphemeral */](post) && !renderedLastViewed) {
          renderedLastViewed = true; // Temporary fix to solve ie11 rendering issue

          let newSeparatorId = '';

          if (!user_agent["f" /* isInternetExplorer */]()) {
            newSeparatorId = 'new_message_' + post.id;
          }

          postCtls.push(react_default.a.createElement("div", {
            id: newSeparatorId,
            key: "unviewed",
            ref: "newMessageSeparator",
            className: "new-separator"
          }, react_default.a.createElement("hr", {
            className: "separator__hr"
          }), react_default.a.createElement("div", {
            className: "separator__text"
          }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "posts_view.newMsg",
            defaultMessage: "New Messages"
          }))));
        }

        postCtls.push(postCtl);
        previousPostDay = currentPostDay;
        previousPostId = post.id;
      }

      return postCtls;
    });

    this.scrollStopAction = new delayed_action["a" /* default */](this.handleScrollStop);
    this.previousScrollTop = Number.MAX_SAFE_INTEGER;
    this.previousScrollHeight = 0;
    this.previousClientHeight = 0;
    this.atBottom = false;
    this.extraPagesLoaded = 0;
    this.loadingPosts = false;
    this.state = {
      atEnd: false,
      unViewedCount: 0,
      isDoingInitialLoad: true,
      isScrolling: false,
      lastViewed: props.lastViewedAt
    };
  }

  componentDidMount() {
    this.mounted = true;
    this.loadPosts(this.props.channel.id, this.props.focusedPostId);
    this.props.actions.checkAndSetMobileView();
    event_emitter_default.a.addListener(constants["j" /* EventTypes */].POST_LIST_SCROLL_CHANGE, this.handleResize);
    window.addEventListener('resize', this.handleWindowResize);
    this.initialScroll();
  }

  componentWillUnmount() {
    this.mounted = false;
    event_emitter_default.a.removeListener(constants["j" /* EventTypes */].POST_LIST_SCROLL_CHANGE, this.handleResize);
    window.removeEventListener('resize', this.handleWindowResize);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    // Focusing on a new post so load posts around it
    if (nextProps.focusedPostId && this.props.focusedPostId !== nextProps.focusedPostId) {
      this.hasScrolledToFocusedPost = false;
      this.hasScrolledToNewMessageSeparator = false;
      this.setState({
        atEnd: false,
        isDoingInitialLoad: !nextProps.posts
      });
      this.loadPosts(nextProps.channel.id, nextProps.focusedPostId);
      return;
    }

    const channel = this.props.channel || {};
    const nextChannel = nextProps.channel || {};

    if (nextProps.focusedPostId == null) {
      // Channel changed so load posts for new channel
      if (channel.id !== nextChannel.id) {
        this.hasScrolled = false;
        this.hasScrolledToFocusedPost = false;
        this.hasScrolledToNewMessageSeparator = false;
        this.atBottom = false;
        this.extraPagesLoaded = 0;
        this.setState({
          atEnd: false,
          lastViewed: nextProps.lastViewedAt,
          isDoingInitialLoad: !nextProps.posts,
          unViewedCount: 0
        });

        if (nextChannel.id) {
          this.loadPosts(nextChannel.id);
        }
      }
    }
  }

  UNSAFE_componentWillUpdate() {
    // eslint-disable-line camelcase
    if (this.refs.postlist) {
      this.previousScrollTop = this.refs.postlist.scrollTop;
      this.previousScrollHeight = this.refs.postlist.scrollHeight;
      this.previousClientHeight = this.refs.postlist.clientHeight;
    }
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.focusedPostId && this.props.focusedPostId !== prevProps.focusedPostId) {
      this.hasScrolledToFocusedPost = false;
      this.hasScrolledToNewMessageSeparator = false;
      this.loadPosts(this.props.channel.id, this.props.focusedPostId);
    } else if (this.props.channel && (!prevProps.channel || this.props.channel.id !== prevProps.channel.id)) {
      this.hasScrolled = false;
      this.hasScrolledToFocusedPost = false;
      this.hasScrolledToNewMessageSeparator = false;
      this.extraPagesLoaded = 0;
      this.setState({
        atEnd: false,
        isDoingInitialLoad: !this.props.posts,
        unViewedCount: 0
      }); // eslint-disable-line react/no-did-update-set-state

      this.loadPosts(this.props.channel.id);
    }

    this.loadPostsToFillScreenIfNecessary(); // Do not update scrolling unless posts, visibility or intro message change

    if (this.props.posts === prevProps.posts && this.props.postVisibility === prevProps.postVisibility && this.state.atEnd === prevState.atEnd) {
      return;
    }

    const prevPosts = prevProps.posts || [];
    const posts = this.props.posts || [];

    if (this.props.focusedPostId == null) {
      const hasNewPosts = prevPosts.length === 0 && posts.length > 0 || prevPosts.length > 0 && posts.length > 0 && prevPosts[0].id !== posts[0].id;

      if (!this.checkBottom() && hasNewPosts) {
        this.setUnreadsBelow(posts, this.props.currentUserId);
      }
    }

    const postList = this.refs.postlist;

    if (!postList) {
      return;
    } // Scroll to focused post on first load


    const focusedPost = this.refs[this.props.focusedPostId];

    if (focusedPost && this.props.posts) {
      if (!this.hasScrolledToFocusedPost) {
        const element = react_dom_default.a.findDOMNode(focusedPost);
        const rect = element.getBoundingClientRect();
        const listHeight = postList.clientHeight / 2;
        postList.scrollTop += rect.top - listHeight;
        this.atBottom = this.checkBottom();
      } else if (this.previousScrollHeight !== postList.scrollHeight && posts[0].id === prevPosts[0].id) {
        postList.scrollTop = this.previousScrollTop + (postList.scrollHeight - this.previousScrollHeight);
      }

      return;
    }

    const didInitialScroll = this.initialScroll();

    if (posts.length >= POSTS_PER_PAGE) {
      this.hasScrolledToNewMessageSeparator = true;
    }

    if (didInitialScroll) {
      return;
    }

    if (postList && prevPosts && posts && posts[0] && prevPosts[0]) {
      // A new message was posted, so scroll to bottom if user
      // was already scrolled close to bottom
      let doScrollToBottom = false;
      const postId = posts[0].id;
      const prevPostId = prevPosts[0].id;
      const pendingPostId = posts[0].pending_post_id;

      if (postId !== prevPostId && pendingPostId !== prevPostId) {
        // If already scrolled to bottom
        if (this.atBottom) {
          doScrollToBottom = true;
        } // If new post was ephemeral


        if (utils["Z" /* isPostEphemeral */](posts[0])) {
          doScrollToBottom = true;
        }
      }

      if (doScrollToBottom) {
        this.atBottom = true;
        postList.scrollTop = postList.scrollHeight;
        return;
      } // New posts added at the top, maintain scroll position


      if (this.previousScrollHeight !== postList.scrollHeight && posts[0].id === prevPosts[0].id) {
        postList.scrollTop = this.previousScrollTop + (postList.scrollHeight - this.previousScrollHeight);
      }
    }
  }

  render() {
    const posts = this.props.posts || [];
    const channel = this.props.channel;

    if (posts.length === 0 && this.state.isDoingInitialLoad || channel == null) {
      return react_default.a.createElement("div", {
        id: "post-list"
      }, react_default.a.createElement(loading_screen["a" /* default */], {
        position: "absolute",
        key: "loading"
      }));
    }

    let topRow;

    if (this.state.atEnd) {
      topRow = react_default.a.createElement(channel_intro_message, {
        channel: channel
      });
    } else if (this.props.postVisibility >= constants["N" /* default */].MAX_POST_VISIBILITY) {
      topRow = react_default.a.createElement("div", {
        className: "post-list__loading post-list__loading-search"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "posts_view.maxLoaded",
        defaultMessage: "Looking for a specific message? Try searching for it"
      }));
    } else {
      topRow = react_default.a.createElement("button", {
        ref: "loadmoretop",
        className: "more-messages-text theme style--none color--link",
        onClick: this.loadMorePosts
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "posts_view.loadMore",
        defaultMessage: "Load more messages"
      }));
    }

    const topPostCreateAt = this.state.topPost ? this.state.topPost.create_at : 0;
    let postVisibility = this.props.postVisibility; // In focus mode there's an extra (Constants.POST_CHUNK_SIZE / 2) posts to show

    if (this.props.focusedPostId) {
      postVisibility += constants["N" /* default */].POST_CHUNK_SIZE / 2;
    }

    return react_default.a.createElement("div", {
      id: "post-list"
    }, react_default.a.createElement(floating_timestamp, {
      isScrolling: this.state.isScrolling,
      isMobile: utils["Y" /* isMobile */](),
      createAt: topPostCreateAt
    }), react_default.a.createElement(scroll_to_bottom_arrows_ScrollToBottomArrows, {
      isScrolling: this.state.isScrolling,
      atBottom: this.atBottom,
      onClick: this.scrollToBottom
    }), !this.props.focusedPostId && react_default.a.createElement(new_messages_below, {
      atBottom: this.atBottom,
      lastViewedBottom: this.state.lastViewed,
      onClick: this.scrollToBottom,
      channelId: this.props.channel.id
    }), react_default.a.createElement("div", {
      ref: "postlist",
      className: "post-list-holder-by-time normal_post_list",
      key: 'postlist-' + channel.id,
      onScroll: this.handleScroll
    }, react_default.a.createElement("div", {
      className: "post-list__table"
    }, react_default.a.createElement("div", {
      id: "postListContent",
      ref: "postListContent",
      className: "post-list__content"
    }, topRow, this.createPosts(posts.slice(0, postVisibility))))));
  }

}

post_list_ie_defineProperty(post_list_ie_PostList, "propTypes", {
  /**
   * Array of posts in the channel, ordered from oldest to newest
   */
  posts: prop_types_default.a.array,

  /**
   * The number of posts that should be rendered
   */
  postVisibility: prop_types_default.a.number,

  /**
   * The channel the posts are in
   */
  channel: prop_types_default.a.object.isRequired,

  /**
   * The last time the channel was viewed, sets the new message separator
   */
  lastViewedAt: prop_types_default.a.number,

  /**
   * The user id of the logged in user
   */
  currentUserId: prop_types_default.a.string,

  /**
   * Set to focus this post
   */
  focusedPostId: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    loadInitialPosts: prop_types_default.a.func.isRequired,

    /**
     * Function to increase the number of posts being rendered
     */
    increasePostVisibility: prop_types_default.a.func.isRequired,

    /**
     * Function to check and set if app is in mobile view
     */
    checkAndSetMobileView: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/post_view/post_list_ie/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function post_list_ie_makeMapStateToProps() {
  const getPostsInChannel = Object(entities_posts["makeGetPostsInChannel"])();
  const getPostsAroundPost = Object(entities_posts["makeGetPostsAroundPost"])();
  const combineUserActivityPosts = Object(selectors_posts["c" /* makeCombineUserActivityFromPosts */])();
  return function mapStateToProps(state, ownProps) {
    let posts;

    if (ownProps.focusedPostId) {
      posts = getPostsAroundPost(state, ownProps.focusedPostId, ownProps.channelId);
    } else {
      posts = getPostsInChannel(state, ownProps.channelId, ownProps.postVisibility);
    }

    return {
      posts: combineUserActivityPosts(posts || []),
      currentUserId: Object(entities_users["getCurrentUserId"])(state),
      lastViewedAt: state.views.channel.lastChannelViewTime[ownProps.channelId]
    };
  };
}

/* harmony default export */ var post_list_ie = (Object(es["connect"])(post_list_ie_makeMapStateToProps)(post_list_ie_PostList));
// EXTERNAL MODULE: ./node_modules/react-virtualized-auto-sizer/dist/index.esm.js
var index_esm = __webpack_require__(3010);

// EXTERNAL MODULE: ./node_modules/react-window/dist/index.esm.js + 1 modules
var dist_index_esm = __webpack_require__(3476);

// CONCATENATED MODULE: ./components/post_view/new_message_separator/new_message_separator.jsx
function new_message_separator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class new_message_separator_NewMessageSeparator extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("div", {
      id: this.props.separatorId,
      className: "new-separator"
    }, react_default.a.createElement("hr", {
      className: "separator__hr"
    }), react_default.a.createElement("div", {
      className: "separator__text"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "posts_view.newMsg",
      defaultMessage: "New Messages"
    })));
  }

}

new_message_separator_defineProperty(new_message_separator_NewMessageSeparator, "propTypes", {
  separatorId: prop_types_default.a.string.isRequired
});
// CONCATENATED MODULE: ./components/post_view/post_list_row/post_list_row.jsx
function post_list_row_extends() { post_list_row_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return post_list_row_extends.apply(this, arguments); }

function post_list_row_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










class post_list_row_PostListRow extends react_default.a.PureComponent {
  render() {
    const {
      listId,
      previousListId
    } = this.props;

    if (post_list["isDateLine"](listId)) {
      const date = post_list["getDateForDateLine"](listId);
      return react_default.a.createElement(date_separator["a" /* default */], {
        key: date,
        date: date
      });
    }

    if (post_list["isStartOfNewMessages"](listId)) {
      return react_default.a.createElement(new_message_separator_NewMessageSeparator, {
        separatorId: listId
      });
    }

    if (listId === constants["u" /* PostListRowListIds */].CHANNEL_INTRO_MESSAGE) {
      return react_default.a.createElement(channel_intro_message, {
        channel: this.props.channel
      });
    }

    if (listId === constants["u" /* PostListRowListIds */].MANUAL_TRIGGER_LOAD_MESSAGES) {
      return react_default.a.createElement("button", {
        className: "more-messages-text theme style--none color--link",
        onClick: this.props.loadMorePosts
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "posts_view.loadMore",
        defaultMessage: "Load more messages"
      }));
    }

    if (listId === constants["u" /* PostListRowListIds */].MORE_MESSAGES_LOADER) {
      return react_default.a.createElement("div", {
        className: "loading-screen"
      }, react_default.a.createElement("div", {
        className: "loading__content"
      }, react_default.a.createElement("div", {
        className: "round round-1"
      }), react_default.a.createElement("div", {
        className: "round round-2"
      }), react_default.a.createElement("div", {
        className: "round round-3"
      })));
    }

    const postProps = {
      previousPostId: previousListId,
      shouldHighlight: this.props.shouldHighlight,
      togglePostMenu: this.props.togglePostMenu
    };

    if (post_list["isCombinedUserActivityPost"](listId)) {
      return react_default.a.createElement(combined_user_activity_post, post_list_row_extends({
        combinedId: listId
      }, postProps));
    }

    return react_default.a.createElement(post_view_post, post_list_row_extends({
      postId: listId
    }, postProps));
  }

}

post_list_row_defineProperty(post_list_row_PostListRow, "propTypes", {
  listId: prop_types_default.a.string.isRequired,
  previousListId: prop_types_default.a.string,
  channel: prop_types_default.a.object,
  fullWidth: prop_types_default.a.bool,
  shouldHighlight: prop_types_default.a.bool,
  loadMorePosts: prop_types_default.a.func,
  togglePostMenu: prop_types_default.a.func
});
// CONCATENATED MODULE: ./components/post_view/post_list_row/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



function post_list_row_mapStateToProps(state, ownProps) {
  return {
    post: ownProps.post,
    channel: ownProps.channel
  };
}

/* harmony default export */ var post_list_row = (Object(es["connect"])(post_list_row_mapStateToProps)(post_list_row_PostListRow));
// CONCATENATED MODULE: ./components/post_view/post_list_virtualized/post_list_virtualized.jsx
function post_list_virtualized_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
















const MAX_NUMBER_OF_AUTO_RETRIES = 3;
const post_list_virtualized_MAX_EXTRA_PAGES_LOADED = 10;
const OVERSCAN_COUNT_BACKWARD = window.OVERSCAN_COUNT_BACKWARD || 80; // Exposing the value for PM to test will be removed soon

const OVERSCAN_COUNT_FORWARD = window.OVERSCAN_COUNT_FORWARD || 80; // Exposing the value for PM to test will be removed soon

const HEIGHT_TRIGGER_FOR_MORE_POSTS = window.HEIGHT_TRIGGER_FOR_MORE_POSTS || 1000; // Exposing the value for PM to test will be removed soon

const BUFFER_TO_BE_CONSIDERED_BOTTOM = 10;
const MAXIMUM_POSTS_FOR_SLICING = {
  channel: 50,
  permalink: 100
};
const postListStyle = {
  padding: '14px 0px 7px'
};
const virtListStyles = {
  position: 'absolute',
  bottom: '0',
  maxHeight: '100%'
};
class post_list_virtualized_PostList extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    post_list_virtualized_defineProperty(this, "getNewMessagesSeparatorIndex", postListIds => {
      return postListIds.findIndex(item => item.indexOf(constants["u" /* PostListRowListIds */].START_OF_NEW_MESSAGES) === 0);
    });

    post_list_virtualized_defineProperty(this, "scrollChange", toBottom => {
      if (toBottom) {
        this.scrollToBottom();
      }
    });

    post_list_virtualized_defineProperty(this, "handleWindowResize", () => {
      this.props.actions.checkAndSetMobileView();
      const isMobile = utils["Y" /* isMobile */]();

      if (isMobile !== this.state.isMobile) {
        const dynamicListStyle = this.state.dynamicListStyle;

        if (this.state.postMenuOpened) {
          if (!isMobile && dynamicListStyle.willChange === 'unset') {
            dynamicListStyle.willChange = 'transform';
          } else if (isMobile && dynamicListStyle.willChange === 'transform') {
            dynamicListStyle.willChange = 'unset';
          }
        }

        this.setState({
          isMobile,
          dynamicListStyle
        });
        this.scrollStopAction = new delayed_action["a" /* default */](this.handleScrollStop);
      }
    });

    post_list_virtualized_defineProperty(this, "loadPosts", async (channelId, focusedPostId) => {
      if (!channelId) {
        return;
      }

      if (this.state.loadingFirstSetOfPosts) {
        const {
          hasMoreBefore
        } = await this.props.actions.loadInitialPosts(channelId, focusedPostId);

        if (this.mounted) {
          this.setState({
            loadingFirstSetOfPosts: false,
            atEnd: !hasMoreBefore
          });
        }
      } else {
        await this.props.actions.syncPostsInChannel(channelId, this.props.latestPostTimeStamp);
      }
    });

    post_list_virtualized_defineProperty(this, "loadMorePosts", async () => {
      const oldestPostId = this.getOldestVisiblePostId();

      if (!oldestPostId) {
        // loadMorePosts shouldn't be called if we don't already have posts
        return;
      }

      this.loadingMorePosts = true;
      const {
        moreToLoad,
        error
      } = await this.props.actions.increasePostVisibility(this.props.channel.id, oldestPostId);

      if (error) {
        if (this.autoRetriesCount < MAX_NUMBER_OF_AUTO_RETRIES) {
          this.autoRetriesCount++;
          Object(actions_helpers["debounce"])(this.loadMorePosts());
        } else if (this.mounted) {
          this.setState({
            autoRetryEnable: false
          });
        }
      } else {
        this.loadingMorePosts = false;

        if (this.mounted && this.props.postListIds) {
          this.setState({
            atEnd: !moreToLoad,
            autoRetryEnable: true
          });
        }

        if (!this.state.autoRetryEnable) {
          this.autoRetriesCount = 0;
        }
      }
    });

    post_list_virtualized_defineProperty(this, "getOldestVisiblePostId", () => {
      return Object(post_utils["g" /* getOldestPostId */])(this.state.postListIds);
    });

    post_list_virtualized_defineProperty(this, "togglePostMenu", opened => {
      const dynamicListStyle = this.state.dynamicListStyle;

      if (this.state.isMobile) {
        dynamicListStyle.willChange = opened ? 'unset' : 'transform';
      }

      this.setState({
        postMenuOpened: opened,
        dynamicListStyle
      });
    });

    post_list_virtualized_defineProperty(this, "renderRow", ({
      data,
      itemId,
      style
    }) => {
      const index = data.indexOf(itemId);
      let className = '';
      const basePaddingClass = 'post-row__padding';
      const previousItemId = index !== -1 && index < data.length - 1 ? data[index + 1] : '';
      const nextItemId = index > 0 && index < data.length ? data[index - 1] : '';

      if (Object(post_list["isDateLine"])(nextItemId) || Object(post_list["isStartOfNewMessages"])(nextItemId)) {
        className += basePaddingClass + ' bottom';
      }

      if (Object(post_list["isDateLine"])(previousItemId) || Object(post_list["isStartOfNewMessages"])(previousItemId)) {
        if (className.includes(basePaddingClass)) {
          className += ' top';
        } else {
          className += basePaddingClass + ' top';
        }
      }

      return react_default.a.createElement("div", {
        style: style,
        className: className
      }, react_default.a.createElement(post_list_row, {
        listId: itemId,
        previousListId: Object(post_utils["h" /* getPreviousPostId */])(data, index),
        channel: this.props.channel,
        shouldHighlight: itemId === this.props.focusedPostId,
        loadMorePosts: this.loadMorePosts,
        togglePostMenu: this.togglePostMenu
      }));
    });

    post_list_virtualized_defineProperty(this, "itemKey", index => {
      const {
        postListIds
      } = this.state;
      return postListIds[index] ? postListIds[index] : index;
    });

    post_list_virtualized_defineProperty(this, "onScroll", ({
      scrollDirection,
      scrollOffset,
      scrollUpdateWasRequested,
      clientHeight,
      scrollHeight
    }) => {
      const isNotLoadingPosts = !this.state.loadingFirstSetOfPosts && !this.loadingMorePosts;
      const didUserScrollBackwards = scrollDirection === 'backward' && !scrollUpdateWasRequested;
      const isOffsetWithInRange = scrollOffset < HEIGHT_TRIGGER_FOR_MORE_POSTS;

      if (isNotLoadingPosts && didUserScrollBackwards && isOffsetWithInRange && !this.state.atEnd) {
        this.loadMorePosts();
      }

      if (this.state.isMobile) {
        if (!this.state.isScrolling) {
          this.setState({
            isScrolling: true
          });
        }

        if (this.scrollStopAction) {
          this.scrollStopAction.fireAfter(constants["N" /* default */].SCROLL_DELAY);
        }
      }

      this.checkBottom(scrollOffset, scrollHeight, clientHeight);
    });

    post_list_virtualized_defineProperty(this, "checkBottom", (scrollOffset, scrollHeight, clientHeight) => {
      this.updateAtBottom(this.isAtBottom(scrollOffset, scrollHeight, clientHeight));
    });

    post_list_virtualized_defineProperty(this, "isAtBottom", (scrollOffset, scrollHeight, clientHeight) => {
      // Calculate how far the post list is from being scrolled to the bottom
      const offsetFromBottom = scrollHeight - clientHeight - scrollOffset;
      return offsetFromBottom <= BUFFER_TO_BE_CONSIDERED_BOTTOM;
    });

    post_list_virtualized_defineProperty(this, "updateAtBottom", atBottom => {
      if (atBottom !== this.state.atBottom) {
        // Update lastViewedBottom when the list reaches or leaves the bottom
        let lastViewedBottom = Date.now();

        if (this.props.latestPostTimeStamp > lastViewedBottom) {
          lastViewedBottom = this.props.latestPostTimeStamp;
        }

        this.setState({
          atBottom,
          lastViewedBottom
        });
      }
    });

    post_list_virtualized_defineProperty(this, "handleScrollStop", () => {
      if (this.mounted) {
        this.setState({
          isScrolling: false
        });
      }
    });

    post_list_virtualized_defineProperty(this, "updateFloatingTimestamp", visibleTopItem => {
      if (!this.state.isMobile) {
        return;
      }

      if (!this.props.postListIds) {
        return;
      }

      this.setState({
        topPostId: Object(post_utils["f" /* getLatestPostId */])(this.props.postListIds.slice(visibleTopItem))
      });
    });

    post_list_virtualized_defineProperty(this, "onItemsRendered", ({
      visibleStartIndex
    }) => {
      this.updateFloatingTimestamp(visibleStartIndex);
    });

    post_list_virtualized_defineProperty(this, "initScrollToIndex", () => {
      if (this.props.focusedPostId) {
        const index = this.state.postListIds.findIndex(item => item === this.props.focusedPostId);
        return {
          index,
          position: 'center'
        };
      }

      const newMessagesSeparatorIndex = this.getNewMessagesSeparatorIndex(this.state.postListIds);

      if (newMessagesSeparatorIndex > 0) {
        const topMostPostIndex = this.state.postListIds.indexOf(Object(post_utils["g" /* getOldestPostId */])(this.state.postListIds));

        if (newMessagesSeparatorIndex === topMostPostIndex + 1) {
          this.loadMorePosts();
          return {
            index: this.state.postListIds.length - 1,
            position: 'start'
          };
        }

        return {
          index: newMessagesSeparatorIndex,
          position: 'start'
        };
      }

      return {
        index: 0,
        position: 'end'
      };
    });

    post_list_virtualized_defineProperty(this, "scrollToBottom", () => {
      this.listRef.current.scrollToItem(0, 'end');
    });

    post_list_virtualized_defineProperty(this, "canLoadMorePosts", async () => {
      if (this.props.focusedPostId) {
        return;
      }

      if (this.state.loadingFirstSetOfPosts || this.loadingMorePosts) {
        // Should already be loading posts
        return;
      }

      if (this.state.atEnd) {
        // Screen is full
        return;
      }

      if (this.extraPagesLoaded > post_list_virtualized_MAX_EXTRA_PAGES_LOADED) {
        // Prevent this from loading a lot of pages in a channel with only hidden messages
        // Enable load more messages manual link
        this.setState({
          autoRetryEnable: false
        });
        return;
      }

      await this.loadMorePosts();
      this.extraPagesLoaded += 1;
    });

    this.loadingMorePosts = false;
    this.extraPagesLoaded = 0;
    const channelIntroMessage = constants["u" /* PostListRowListIds */].CHANNEL_INTRO_MESSAGE;

    const _isMobile = utils["Y" /* isMobile */]();

    this.state = {
      atEnd: false,
      loadingFirstSetOfPosts: Boolean(!props.postListIds || props.channelLoading),
      isScrolling: false,
      autoRetryEnable: true,
      isMobile: _isMobile,
      atBottom: true,
      lastViewedBottom: Date.now(),
      postListIds: [channelIntroMessage],
      topPostId: '',
      postMenuOpened: false,
      dynamicListStyle: {
        willChange: 'transform'
      }
    };
    this.listRef = react_default.a.createRef();
    this.postListRef = react_default.a.createRef();

    if (_isMobile) {
      this.scrollStopAction = new delayed_action["a" /* default */](this.handleScrollStop);
    }

    this.initRangeToRender = this.props.focusedPostId ? [0, MAXIMUM_POSTS_FOR_SLICING.permalink] : [0, MAXIMUM_POSTS_FOR_SLICING.channel];

    if (!this.state.loadingFirstSetOfPosts) {
      const newMessagesSeparatorIndex = this.getNewMessagesSeparatorIndex(props.postListIds);
      this.initRangeToRender = [Math.max(newMessagesSeparatorIndex - 30, 0), Math.max(newMessagesSeparatorIndex + 30, Math.min(props.postListIds.length - 1, MAXIMUM_POSTS_FOR_SLICING.channel))];
    }
  }

  componentDidMount() {
    this.mounted = true;

    if (!this.props.channelLoading) {
      this.loadPosts(this.props.channel.id, this.props.focusedPostId);
    }

    this.props.actions.checkAndSetMobileView();
    window.addEventListener('resize', this.handleWindowResize);
    event_emitter_default.a.addListener(constants["j" /* EventTypes */].POST_LIST_SCROLL_CHANGE, this.scrollChange);
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    if (this.postListRef && this.postListRef.current) {
      const postsAddedAtTop = this.state.postListIds.length !== prevState.postListIds.length && this.state.postListIds[0] === prevState.postListIds[0];
      const channelHeaderAdded = this.state.atEnd !== prevState.atEnd;

      if ((postsAddedAtTop || channelHeaderAdded) && !this.state.atBottom) {
        const previousScrollTop = this.postListRef.current.scrollTop;
        const previousScrollHeight = this.postListRef.current.scrollHeight;
        return {
          previousScrollTop,
          previousScrollHeight
        };
      }
    }

    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    if (prevProps.channelLoading && !this.props.channelLoading) {
      this.loadPosts(this.props.channel.id, this.props.focusedPostId);
    }

    if (!this.postListRef.current || !snapshot) {
      return;
    }

    const postlistScrollHeight = this.postListRef.current.scrollHeight;
    const postsAddedAtTop = this.state.postListIds.length !== prevState.postListIds.length && this.state.postListIds[0] === prevState.postListIds[0];
    const channelHeaderAdded = this.state.atEnd !== prevState.atEnd;

    if ((postsAddedAtTop || channelHeaderAdded) && !this.state.atBottom) {
      const scrollValue = snapshot.previousScrollTop + (postlistScrollHeight - snapshot.previousScrollHeight);

      if (scrollValue !== 0 && scrollValue - snapshot.previousScrollTop !== 0) {
        //true as third param so chrome can use animationFrame when correcting scroll
        this.listRef.current.scrollTo(scrollValue, scrollValue - snapshot.previousScrollTop, true);
      }
    }
  }

  componentWillUnmount() {
    this.mounted = false;
    window.removeEventListener('resize', this.handleWindowResize);
    event_emitter_default.a.removeListener(constants["j" /* EventTypes */].POST_LIST_SCROLL_CHANGE, this.scrollChange);
  }

  static getDerivedStateFromProps(props, state) {
    const postListIds = props.postListIds || [];
    let newPostListIds;

    if (state.atEnd) {
      newPostListIds = [...postListIds, constants["u" /* PostListRowListIds */].CHANNEL_INTRO_MESSAGE];
    } else if (props.postVisibility >= constants["N" /* default */].MAX_POST_VISIBILITY) {
      newPostListIds = [...postListIds, constants["u" /* PostListRowListIds */].MAX_MESSAGES_LOADED];
    } else if (state.autoRetryEnable) {
      newPostListIds = [...postListIds, constants["u" /* PostListRowListIds */].MORE_MESSAGES_LOADER];
    } else {
      newPostListIds = [...postListIds, constants["u" /* PostListRowListIds */].MANUAL_TRIGGER_LOAD_MESSAGES];
    }

    return {
      postListIds: newPostListIds
    };
  }

  handleOnMouseOver() {
    document.getElementsByClassName('post-list__dynamic')[0].classList.add('show-scroll');
  }

  handleOnMouseOut() {
    document.getElementsByClassName('post-list__dynamic')[0].classList.remove('show-scroll');
  }

  render() {
    const channel = this.props.channel;
    const {
      dynamicListStyle
    } = this.state;

    if (this.state.loadingFirstSetOfPosts) {
      return react_default.a.createElement("div", {
        id: "post-list"
      }, react_default.a.createElement(loading_screen["a" /* default */], {
        position: "absolute",
        key: "loading"
      }));
    }

    let newMessagesBelow = null;

    if (!this.props.focusedPostId) {
      newMessagesBelow = react_default.a.createElement(new_messages_below, {
        atBottom: this.state.atBottom,
        lastViewedBottom: this.state.lastViewedBottom,
        postIds: this.state.postListIds,
        onClick: this.scrollToBottom,
        channelId: this.props.channel.id
      });
    }

    return react_default.a.createElement("div", {
      id: "post-list",
      "aria-label": utils["gb" /* localizeMessage */]('accessibility.sections.centerContent', 'message list main region')
    }, this.state.isMobile && react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(floating_timestamp, {
      isScrolling: this.state.isScrolling,
      isMobile: true,
      postId: this.state.topPostId
    }), react_default.a.createElement(scroll_to_bottom_arrows_ScrollToBottomArrows, {
      isScrolling: this.state.isScrolling,
      atBottom: this.state.atBottom,
      onClick: this.scrollToBottom
    })), newMessagesBelow, react_default.a.createElement("div", {
      role: "presentation",
      className: "post-list-holder-by-time",
      key: 'postlist-' + channel.id
    }, react_default.a.createElement("div", {
      role: "presentation",
      className: "post-list__table"
    }, react_default.a.createElement("div", {
      role: "presentation",
      id: "postListContent",
      className: "post-list__content",
      onMouseOver: this.handleOnMouseOver,
      onMouseOut: this.handleOnMouseOut
    }, react_default.a.createElement(index_esm["a" /* default */], null, ({
      height,
      width
    }) => react_default.a.createElement(dist_index_esm["a" /* DynamicSizeList */], {
      role: "presentation",
      ref: this.listRef,
      height: height,
      width: width,
      className: `post-list__dynamic ${this.props.hasCheckbox ? 'has__checkbox' : ''}`,
      itemCount: this.state.postListIds.length,
      itemData: this.state.postListIds,
      itemKey: this.itemKey,
      overscanCountForward: OVERSCAN_COUNT_FORWARD,
      overscanCountBackward: OVERSCAN_COUNT_BACKWARD,
      onScroll: this.onScroll,
      onItemsRendered: this.onItemsRendered,
      initScrollToIndex: this.initScrollToIndex,
      canLoadMorePosts: this.canLoadMorePosts,
      skipResizeClass: "col__reply",
      innerRef: this.postListRef,
      style: { ...virtListStyles,
        ...dynamicListStyle
      },
      innerListStyle: postListStyle,
      initRangeToRender: this.initRangeToRender,
      loaderId: constants["u" /* PostListRowListIds */].MORE_MESSAGES_LOADER
    }, this.renderRow))))));
  }

}

post_list_virtualized_defineProperty(post_list_virtualized_PostList, "propTypes", {
  /**
   * Array of Ids in the channel including date separators, new message indicator, more messages loader,
   * manual load messages trigger and postId in the order of newest to oldest for populating virtual list rows
   */
  postListIds: prop_types_default.a.array,

  /**
   * The number of posts that should be rendered
   */
  postVisibility: prop_types_default.a.number,

  /**
   * The channel the posts are in
   */
  channel: prop_types_default.a.object.isRequired,

  /**
   * Set to focus this post
   */
  focusedPostId: prop_types_default.a.string,

  /**
   * When switching teams we might end up in a state where we select channel from previous team
   * This flag is explicitly added for adding a loader in these cases to not mounting post list
   */
  channelLoading: prop_types_default.a.bool,
  latestPostTimeStamp: prop_types_default.a.number,
  actions: prop_types_default.a.shape({
    loadInitialPosts: prop_types_default.a.func.isRequired,

    /**
     * Function to increase the number of posts being rendered
     */
    increasePostVisibility: prop_types_default.a.func.isRequired,

    /**
     * Function to check and set if app is in mobile view
     */
    checkAndSetMobileView: prop_types_default.a.func.isRequired,

    /**
     * Function to be called on recurring channel visits to get any possible missing latest posts
     */
    syncPostsInChannel: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/post_view/post_list_virtualized/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const post_list_virtualized_memoizedGetLatestPostId = Object(helpers["memoizeResult"])(postIds => Object(post_utils["f" /* getLatestPostId */])(postIds));

function post_list_virtualized_makeMapStateToProps() {
  const getPostIdsAroundPost = Object(entities_posts["makeGetPostIdsAroundPost"])();
  const preparePostIdsForPostList = Object(post_list["makePreparePostIdsForPostList"])();
  return function mapStateToProps(state, ownProps) {
    let postIds;
    let latestPostTimeStamp = 0;
    const lastViewedAt = state.views.channel.lastChannelViewTime[ownProps.channelId];

    if (ownProps.focusedPostId) {
      postIds = getPostIdsAroundPost(state, ownProps.focusedPostId, ownProps.channelId, {
        postsBeforeCount: -1
      });
    } else {
      postIds = Object(entities_posts["getPostIdsInChannel"])(state, ownProps.channelId);
    }

    if (postIds) {
      postIds = preparePostIdsForPostList(state, {
        postIds,
        lastViewedAt,
        indicateNewMessages: true
      });
      const latestPostId = post_list_virtualized_memoizedGetLatestPostId(postIds);
      const latestPost = Object(entities_posts["getPost"])(state, latestPostId);
      latestPostTimeStamp = latestPost.create_at; //console.log("latestPost----->",JSON.stringify(latestPost));
    }

    let hasCheckbox = false;

    if (state.views.posts) {
      let channelPostSelect = state.views.posts.channelPostSelect;

      if (channelPostSelect) {
        if (constants["f" /* ChannelPostSelectType */].MERGE === channelPostSelect.type) {
          hasCheckbox = channelPostSelect.visibleCheckbox;
        }
      }
    }

    return {
      postListIds: postIds,
      latestPostTimeStamp,
      hasCheckbox
    };
  };
}

/* harmony default export */ var post_list_virtualized = (Object(es["connect"])(post_list_virtualized_makeMapStateToProps)(post_list_virtualized_PostList));
// CONCATENATED MODULE: ./components/post_view/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.











let post_view_PostList = post_list_virtualized;

if (Object(utils["k" /* disableVirtList */])()) {
  post_view_PostList = post_list_ie;
} // This function is added as a fail safe for the channel sync issue we have.
// When the user switches to a team for the first time we show the channel of previous team and then settle for the right channel after that
// This causes the scroll correction etc an issue because post_list is not mounted for new channel instead it is updated


const isChannelLoading = (params, channel, team, teammate) => {
  if (params.postid) {
    return false;
  }

  if (channel && team) {
    if (channel.type !== constants["g" /* Constants */].DM_CHANNEL && channel.name !== params.identifier) {
      return true;
    } else if (channel.type === constants["g" /* Constants */].DM_CHANNEL && teammate && params.identifier !== `@${teammate.username}`) {
      return true;
    }

    if (channel.team_id && channel.team_id !== team.id) {
      return true;
    }

    return false;
  }

  return true;
};

function post_view_makeMapStateToProps() {
  return function mapStateToProps(state, ownProps) {
    const postVisibility = state.views.channel.postVisibility[ownProps.channelId];
    const channel = Object(entities_channels["getChannel"])(state, ownProps.channelId);
    const team = Object(entities_teams["getTeamByName"])(state, ownProps.match.params.team);
    let teammate;

    if (channel && channel.type === constants["g" /* Constants */].DM_CHANNEL && channel.teammate_id) {
      teammate = Object(entities_users["getUser"])(state, channel.teammate_id);
    }

    const channelLoading = isChannelLoading(ownProps.match.params, channel, team, teammate);
    return {
      channel,
      postVisibility,
      channelLoading
    };
  };
}

function post_view_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      loadInitialPosts: views_channel["g" /* loadInitialPosts */],
      increasePostVisibility: views_channel["d" /* increasePostVisibility */],
      checkAndSetMobileView: views_channel["b" /* checkAndSetMobileView */],
      syncPostsInChannel: views_channel["m" /* syncPostsInChannel */]
    }, dispatch)
  };
}

/* harmony default export */ var post_view = (Object(react_router["f" /* withRouter */])(Object(es["connect"])(post_view_makeMapStateToProps, post_view_mapDispatchToProps)(post_view_PostList)));
// CONCATENATED MODULE: ./components/permalink_view/permalink_view.jsx
function permalink_view_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class permalink_view_PermalinkView extends react_default.a.PureComponent {
  constructor(_props) {
    super(_props);

    permalink_view_defineProperty(this, "doPermalinkEvent", async props => {
      this.setState({
        valid: false
      });
      const postId = props.match.params.postid;
      await this.props.actions.focusPost(postId, this.props.returnTo);
      this.setState({
        valid: true
      });
    });

    permalink_view_defineProperty(this, "isStateValid", () => {
      return this.state.valid && this.props.channelId && this.props.teamName;
    });

    this.state = {
      valid: false
    };
  }

  componentDidMount() {
    this.doPermalinkEvent(this.props);
    document.body.classList.add('app__body');
  }

  componentWillUnmount() {
    document.body.classList.remove('app__body');
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.match.params.postid !== nextProps.match.params.postid) {
      this.doPermalinkEvent(nextProps);
    }
  }

  render() {
    const {
      channelId,
      channelName,
      channelIsArchived,
      match,
      teamName
    } = this.props;
    const {
      formatMessage
    } = this.context.intl;

    if (!this.isStateValid()) {
      return react_default.a.createElement("div", {
        id: "app-content",
        className: "app__content"
      });
    }

    return react_default.a.createElement("div", {
      id: "app-content",
      className: "app__content"
    }, react_default.a.createElement(channel_header, {
      channelId: channelId
    }), react_default.a.createElement(post_view, {
      channelId: channelId,
      focusedPostId: match.params.postid
    }), react_default.a.createElement("div", {
      id: "archive-link-home"
    }, react_default.a.createElement(react_router_dom["a" /* Link */], {
      to: '/' + teamName + '/channels/' + channelName
    }, channelIsArchived && react_default.a.createElement(formatted_markdown_message["b" /* default */], {
      id: "center_panel.permalink.archivedChannel",
      defaultMessage: "You are viewing an **archived channel**. "
    }), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "center_panel.recent",
      defaultMessage: "Click here to jump to recent messages. "
    }), react_default.a.createElement("i", {
      className: "fa fa-arrow-down",
      title: formatMessage({
        id: 'center_panel.recent.icon',
        defaultMessage: 'Jump to recent messages Icon'
      })
    }))));
  }

}

permalink_view_defineProperty(permalink_view_PermalinkView, "propTypes", {
  channelId: prop_types_default.a.string,
  channelName: prop_types_default.a.string,
  channelIsArchived: prop_types_default.a.bool,

  /*
   * Object from react-router
   */
  match: prop_types_default.a.shape({
    params: prop_types_default.a.shape({
      postid: prop_types_default.a.string.isRequired
    }).isRequired
  }).isRequired,
  returnTo: prop_types_default.a.string.isRequired,
  teamName: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    focusPost: prop_types_default.a.func.isRequired
  }).isRequired
});

permalink_view_defineProperty(permalink_view_PermalinkView, "contextTypes", {
  intl: index_es["i" /* intlShape */].isRequired
});
// CONCATENATED MODULE: ./components/permalink_view/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function permalink_view_mapStateToProps(state) {
  const team = Object(entities_teams["getCurrentTeam"])(state);
  const channel = Object(entities_channels["getCurrentChannel"])(state);
  let channelId = '';
  let channelName = '';
  let channelIsArchived;

  if (channel) {
    channelId = channel.id;
    channelName = channel.name;
    channelIsArchived = channel.delete_at !== 0;
  }

  let teamName = '';

  if (team) {
    teamName = team.name;
  }

  return {
    channelId,
    channelName,
    teamName,
    channelIsArchived
  };
}

function permalink_view_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      focusPost: focusPost
    }, dispatch)
  };
}

/* harmony default export */ var permalink_view = (Object(es["connect"])(permalink_view_mapStateToProps, permalink_view_mapDispatchToProps)(permalink_view_PermalinkView));
// CONCATENATED MODULE: ./components/notify_counts/notify_counts.jsx
function notify_counts_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class notify_counts_NotifyCounts extends react_default.a.PureComponent {
  render() {
    if (this.props.mentionCount) {
      return react_default.a.createElement("span", {
        className: "badge badge-notify"
      }, this.props.mentionCount);
    } else if (this.props.messageCount) {
      return react_default.a.createElement("span", {
        className: "badge badge-notify"
      }, '•');
    }

    return null;
  }

}

notify_counts_defineProperty(notify_counts_NotifyCounts, "propTypes", {
  mentionCount: prop_types_default.a.number.isRequired,
  messageCount: prop_types_default.a.number.isRequired
});
// CONCATENATED MODULE: ./components/notify_counts/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function notify_counts_mapStateToProps(state) {
  const {
    mentionCount,
    messageCount
  } = Object(entities_channels["getUnreadsInCurrentTeam"])(state);
  return {
    mentionCount,
    messageCount
  };
}

/* harmony default export */ var notify_counts = (Object(es["connect"])(notify_counts_mapStateToProps)(notify_counts_NotifyCounts));
// CONCATENATED MODULE: ./components/channel_header_mobile/collapse_lhs_button/collapse_lhs_button.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






const CollapseLhsButton = ({
  actions: {
    toggleLhs
  }
}) => react_default.a.createElement("button", {
  key: "navbar-toggle-sidebar",
  type: "button",
  className: "navbar-toggle",
  "data-toggle": "collapse",
  "data-target": "#sidebar-nav",
  onClick: toggleLhs
}, react_default.a.createElement("span", {
  className: "sr-only"
}, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
  id: "navbar.toggle2",
  defaultMessage: "Toggle sidebar"
})), react_default.a.createElement(menu_icon["a" /* default */], {
  className: "style--none icon icon__menu icon--sidebarHeaderTextColor"
}), react_default.a.createElement(notify_counts, null));

CollapseLhsButton.propTypes = {
  actions: prop_types_default.a.shape({
    toggleLhs: prop_types_default.a.func.isRequired
  }).isRequired
};
/* harmony default export */ var collapse_lhs_button = (CollapseLhsButton);
// CONCATENATED MODULE: ./components/channel_header_mobile/collapse_lhs_button/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const collapse_lhs_button_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    toggleLhs: lhs["c" /* toggle */]
  }, dispatch)
});

/* harmony default export */ var channel_header_mobile_collapse_lhs_button = (Object(es["connect"])(null, collapse_lhs_button_mapDispatchToProps)(collapse_lhs_button));
// CONCATENATED MODULE: ./components/channel_header_mobile/collapse_rhs_button/collapse_rhs_button.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




const CollapseRhsButton = ({
  actions: {
    toggleRhsMenu
  }
}) => react_default.a.createElement("button", {
  key: "navbar-toggle-menu",
  type: "button",
  className: "navbar-toggle navbar-right__icon menu-toggle pull-right",
  "data-toggle": "collapse",
  "data-target": "#sidebar-nav",
  onClick: toggleRhsMenu
}, react_default.a.createElement(menu_icon["a" /* default */], null));

CollapseRhsButton.propTypes = {
  actions: prop_types_default.a.shape({
    toggleRhsMenu: prop_types_default.a.func.isRequired
  }).isRequired
};
/* harmony default export */ var collapse_rhs_button = (CollapseRhsButton);
// CONCATENATED MODULE: ./components/channel_header_mobile/collapse_rhs_button/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const collapse_rhs_button_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    toggleRhsMenu: rhs["t" /* toggleMenu */]
  }, dispatch)
});

/* harmony default export */ var channel_header_mobile_collapse_rhs_button = (Object(es["connect"])(null, collapse_rhs_button_mapDispatchToProps)(collapse_rhs_button));
// CONCATENATED MODULE: ./components/svg/info_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class info_icon_InfoIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement("span", this.props, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.info",
      defaultMessage: "Info Icon"
    }, ariaLabel => react_default.a.createElement("svg", {
      width: "18px",
      height: "18px",
      viewBox: "0 0 22 22",
      role: "icon",
      "aria-label": ariaLabel
    }, react_default.a.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "inherit",
      fillRule: "evenodd"
    }, react_default.a.createElement("g", {
      transform: "translate(-388.000000, -18.000000)",
      fill: "inherit"
    }, react_default.a.createElement("g", null, react_default.a.createElement("g", {
      transform: "translate(381.000000, 11.000000)"
    }, react_default.a.createElement("g", {
      transform: "translate(7.000000, 7.000000)"
    }, react_default.a.createElement("path", {
      d: "M11,22 C4.92486775,22 0,17.0751322 0,11 C0,4.92486775 4.92486775,0 11,0 C17.0751322,0 22,4.92486775 22,11 C22,17.0751322 17.0751322,22 11,22 Z M11,20.7924685 C16.408231,20.7924685 20.7924685,16.408231 20.7924685,11 C20.7924685,5.59176898 16.408231,1.20753149 11,1.20753149 C5.59176898,1.20753149 1.20753149,5.59176898 1.20753149,11 C1.20753149,16.408231 5.59176898,20.7924685 11,20.7924685 Z M10.1572266,16.0625 L10.1572266,8.69335938 L11.3466797,8.69335938 L11.3466797,16.0625 L10.1572266,16.0625 Z M10.7519531,7.50390625 C10.3417969,7.50390625 10,7.16210938 10,6.75195312 C10,6.33496094 10.3417969,6 10.7519531,6 C11.1689453,6 11.5039062,6.33496094 11.5039062,6.75195312 C11.5039062,7.16210938 11.1689453,7.50390625 10.7519531,7.50390625 Z"
    })))))))));
  }

}
// CONCATENATED MODULE: ./components/channel_header_mobile/channel_info_button/channel_info_button.js
function channel_info_button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








const channel_info_button_headerMarkdownOptions = {
  mentionHighlight: false
};
class channel_info_button_NavbarInfoButton extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    channel_info_button_defineProperty(this, "showEditChannelHeaderModal", () => {
      if (this.refs.headerOverlay) {
        this.refs.headerOverlay.hide();
      }

      const {
        actions,
        channel
      } = this.props;
      const modalData = {
        modalId: constants["p" /* ModalIdentifiers */].EDIT_CHANNEL_HEADER,
        dialogType: components_edit_channel_header_modal,
        dialogProps: {
          channel
        }
      };
      actions.openModal(modalData);
    });

    channel_info_button_defineProperty(this, "hide", () => {
      if (this.refs.headerOverlay) {
        this.refs.headerOverlay.hide();
      }
    });
  }

  render() {
    const {
      channel,
      isReadOnly
    } = this.props;
    let popoverContent = null;

    if (channel.header) {
      popoverContent = react_default.a.createElement(markdown["a" /* default */], {
        message: channel.header,
        options: channel_info_button_headerMarkdownOptions
      });
    } else {
      let addOne;

      if (!isReadOnly) {
        const link = react_default.a.createElement("a", {
          href: "#",
          onClick: this.showEditChannelHeaderModal
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "navbar.click",
          defaultMessage: "Click here"
        }));
        addOne = react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("br", null), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "navbar.clickToAddHeader",
          defaultMessage: "{clickHere} to add one.",
          values: {
            clickHere: link
          }
        }));
      }

      popoverContent = react_default.a.createElement("div", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "navbar.noHeader",
        defaultMessage: "No channel header yet."
      }), addOne);
    }

    const popover = react_default.a.createElement(Popover["a" /* default */], {
      bsStyle: "info",
      placement: "bottom",
      className: "navbar__popover",
      id: "header-popover"
    }, popoverContent, react_default.a.createElement("div", {
      className: "close visible-xs-block",
      onClick: this.hide
    }, '×'));
    return react_default.a.createElement(OverlayTrigger["a" /* default */], {
      ref: "headerOverlay",
      trigger: "click",
      placement: "bottom",
      overlay: popover,
      className: "description",
      rootClose: true
    }, react_default.a.createElement("button", {
      className: "navbar-toggle navbar-right__icon navbar-info-button pull-right"
    }, react_default.a.createElement(info_icon_InfoIcon, {
      className: "icon icon__info",
      "aria-hidden": "true"
    })));
  }

}

channel_info_button_defineProperty(channel_info_button_NavbarInfoButton, "propTypes", {
  channel: prop_types_default.a.object.isRequired,
  isReadOnly: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    openModal: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_header_mobile/channel_info_button/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function channel_info_button_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      openModal: modals["b" /* openModal */]
    }, dispatch)
  };
}

/* harmony default export */ var channel_info_button = (Object(es["connect"])(null, channel_info_button_mapDispatchToProps)(channel_info_button_NavbarInfoButton));
// CONCATENATED MODULE: ./components/channel_header_mobile/show_search_button/show_search_button.js
function show_search_button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class show_search_button_ShowSearchButton extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    show_search_button_defineProperty(this, "handleClick", () => {
      this.props.actions.updateRhsState(constants["x" /* RHSStates */].SEARCH);
    });
  }

  render() {
    return react_default.a.createElement("button", {
      type: "button",
      className: "navbar-toggle navbar-right__icon navbar-search pull-right",
      onClick: this.handleClick
    }, react_default.a.createElement(search_icon["a" /* default */], {
      className: "icon icon__search",
      "aria-hidden": "true"
    }));
  }

}

show_search_button_defineProperty(show_search_button_ShowSearchButton, "propTypes", {
  actions: prop_types_default.a.shape({
    updateRhsState: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_header_mobile/show_search_button/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const show_search_button_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    updateRhsState: rhs["v" /* updateRhsState */]
  }, dispatch)
});

/* harmony default export */ var show_search_button = (Object(es["connect"])(null, show_search_button_mapDispatchToProps)(show_search_button_ShowSearchButton));
// CONCATENATED MODULE: ./components/channel_header_mobile/unmute_channel_button/unmute_channel_button.js
function unmute_channel_button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class unmute_channel_button_UnmuteChannelButton extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    unmute_channel_button_defineProperty(this, "handleClick", () => {
      const {
        user,
        channel,
        actions: {
          updateChannelNotifyProps
        }
      } = this.props;
      updateChannelNotifyProps(user.id, channel.id, {
        mark_unread: constants["q" /* NotificationLevels */].ALL
      });
    });
  }

  render() {
    return react_default.a.createElement("button", {
      type: "button",
      className: "navbar-toggle icon icon__mute",
      onClick: this.handleClick
    }, react_default.a.createElement("span", {
      className: "fa fa-bell-slash-o icon"
    }));
  }

}

unmute_channel_button_defineProperty(unmute_channel_button_UnmuteChannelButton, "propTypes", {
  user: prop_types_default.a.shape({
    id: prop_types_default.a.string.isRequired
  }).isRequired,
  channel: prop_types_default.a.shape({
    id: prop_types_default.a.string.isRequired
  }).isRequired,
  actions: prop_types_default.a.shape({
    updateChannelNotifyProps: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_header_mobile/unmute_channel_button/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const unmute_channel_button_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    updateChannelNotifyProps: actions_channels["updateChannelNotifyProps"]
  }, dispatch)
});

/* harmony default export */ var unmute_channel_button = (Object(es["connect"])(null, unmute_channel_button_mapDispatchToProps)(unmute_channel_button_UnmuteChannelButton));
// CONCATENATED MODULE: ./components/channel_header_mobile/channel_header_mobile.js
function channel_header_mobile_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










class channel_header_mobile_ChannelHeaderMobile extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    channel_header_mobile_defineProperty(this, "hideSidebars", e => {
      if (utils["Y" /* isMobile */]()) {
        this.props.actions.closeRhs();

        if (e.target.className !== 'navbar-toggle' && e.target.className !== 'icon-bar') {
          this.props.actions.closeLhs();
          this.props.actions.closeRhsMenu();
        }
      }
    });
  }

  componentDidMount() {
    document.querySelector('.inner-wrap').addEventListener('click', this.hideSidebars);
  }

  componentWillUnmount() {
    document.querySelector('.inner-wrap').removeEventListener('click', this.hideSidebars);
  }

  render() {
    const {
      user,
      channel,
      isMuted
    } = this.props;
    return react_default.a.createElement("nav", {
      id: "navbar",
      className: "navbar navbar-default navbar-fixed-top",
      role: "navigation"
    }, react_default.a.createElement("div", {
      className: "container-fluid theme"
    }, react_default.a.createElement("div", {
      className: "navbar-header"
    }, react_default.a.createElement(channel_header_mobile_collapse_lhs_button, null), channel && react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("div", {
      className: "navbar-brand"
    }, react_default.a.createElement(channel_header_dropdown_MobileChannelHeaderDropdown, null), isMuted && react_default.a.createElement(unmute_channel_button, {
      user: user,
      channel: channel
    })), react_default.a.createElement(channel_info_button, {
      ref: "headerOverlay",
      channel: channel,
      isReadOnly: this.props.isReadOnly
    }), react_default.a.createElement(show_search_button, null), react_default.a.createElement(mobile_channel_header_plug, {
      channel: channel,
      isDropdown: false
    })), react_default.a.createElement(channel_header_mobile_collapse_rhs_button, null))));
  }

}

channel_header_mobile_defineProperty(channel_header_mobile_ChannelHeaderMobile, "propTypes", {
  /**
   *
   */
  user: prop_types_default.a.object.isRequired,

  /**
   * Object with info about current channel
   */
  channel: prop_types_default.a.object,

  /**
   * Bool whether the current channel is read only
   */
  isReadOnly: prop_types_default.a.bool,

  /**
   * Bool whether the current channel is muted
   */
  isMuted: prop_types_default.a.bool,

  /**
   * Object with action creators
   */
  actions: prop_types_default.a.shape({
    closeLhs: prop_types_default.a.func.isRequired,
    closeRhs: prop_types_default.a.func.isRequired,
    closeRhsMenu: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_header_mobile/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









const isCurrentChannelMuted = Object(reselect_es["a" /* createSelector */])(entities_channels["getMyCurrentChannelMembership"], membership => Object(channel_utils["isChannelMuted"])(membership));

const channel_header_mobile_mapStateToProps = state => ({
  user: Object(entities_users["getCurrentUser"])(state),
  channel: Object(entities_channels["getCurrentChannel"])(state),
  isMuted: isCurrentChannelMuted(state),
  isReadOnly: Object(entities_channels["isCurrentChannelReadOnly"])(state)
});

const channel_header_mobile_mapDispatchToProps = dispatch => ({
  actions: Object(redux["bindActionCreators"])({
    closeLhs: lhs["a" /* close */],
    closeRhs: rhs["b" /* closeRightHandSide */],
    closeRhsMenu: rhs["a" /* closeMenu */]
  }, dispatch)
});

/* harmony default export */ var channel_header_mobile = (Object(es["connect"])(channel_header_mobile_mapStateToProps, channel_header_mobile_mapDispatchToProps)(channel_header_mobile_ChannelHeaderMobile));
// CONCATENATED MODULE: ./components/channel_layout/channel_identifier_router/actions.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









const LENGTH_OF_ID = 26;
const LENGTH_OF_GROUP_ID = 40;
const LENGTH_OF_USER_ID_PAIR = 54;
function onChannelByIdentifierEnter({
  match,
  history
}) {
  return (dispatch, getState) => {
    const state = getState();
    const {
      path,
      identifier,
      team
    } = match.params;

    if (!identifier) {
      return;
    }

    const teamObj = Object(entities_teams["getTeamByName"])(state, team);

    if (!teamObj) {
      return;
    }

    if (path === 'channels') {
      if (identifier.length === LENGTH_OF_ID) {
        // It's hard to tell an ID apart from a channel name of the same length, so check first if
        // the identifier matches a channel that we have
        const channelsByName = Object(entities_channels["getChannelByName"])(state, identifier);
        const moreChannelsByName = Object(entities_channels["getOtherChannels"])(state).find(chan => chan.name === identifier);

        if (channelsByName || moreChannelsByName) {
          dispatch(goToChannelByChannelName(match, history));
        } else {
          dispatch(goToChannelByChannelId(match, history));
        }
      } else if (identifier.length === LENGTH_OF_GROUP_ID) {
        dispatch(goToGroupChannelByGroupId(match, history));
      } else if (identifier.length === LENGTH_OF_USER_ID_PAIR) {
        dispatch(goToDirectChannelByUserIds(match, history));
      } else {
        if (identifier !== "[object Object]") //不清楚为什么先容错吧
          dispatch(goToChannelByChannelName(match, history));
      }
    } else if (path === 'messages') {
      if (identifier.indexOf('@') === 0) {
        dispatch(goToDirectChannelByUsername(match, history));
      } else if (identifier.indexOf('@') > 0) {
        dispatch(goToDirectChannelByEmail(match, history));
      } else if (identifier.length === LENGTH_OF_ID) {
        dispatch(goToDirectChannelByUserId(match, history, identifier));
      } else if (identifier.length === LENGTH_OF_GROUP_ID) {
        dispatch(goToGroupChannelByGroupId(match, history));
      } else {
        handleError(match, history, Object(entities_channels["getRedirectChannelNameForTeam"])(state, teamObj.id));
      }
    }
  };
}
function goToChannelByChannelId(match, history) {
  return async (dispatch, getState) => {
    const state = getState();
    const {
      team,
      identifier
    } = match.params;
    const channelId = identifier.toLowerCase();
    let channel = Object(entities_channels["getChannel"])(state, channelId);
    const member = state.entities.channels.myMembers[channelId];
    const teamObj = Object(entities_teams["getTeamByName"])(state, team);

    if (!channel || !member) {
      const {
        data,
        error
      } = await dispatch(Object(actions_channels["joinChannel"])(Object(entities_users["getCurrentUserId"])(state), teamObj.id, channelId, null));

      if (error) {
        handleChannelJoinError(match, history, Object(entities_channels["getRedirectChannelNameForTeam"])(state, teamObj.id));
        return;
      }

      channel = data.channel;
    }

    if (channel.type === constants["g" /* Constants */].DM_CHANNEL) {
      dispatch(goToDirectChannelByUserId(match, history, utils["F" /* getUserIdFromChannelId */](channel.name)));
    } else if (channel.type === constants["g" /* Constants */].GM_CHANNEL) {
      history.replace(`/${team}/messages/${channel.name}`);
    } else {
      history.replace(`/${team}/channels/${channel.name}`);
    }
  };
}
function goToChannelByChannelName(match, history) {
  return async (dispatch, getState) => {
    const state = getState();
    const {
      team,
      identifier
    } = match.params;
    const channelName = identifier.toLowerCase();
    const teamObj = Object(entities_teams["getTeamByName"])(state, team);

    if (!teamObj) {
      return;
    }

    let channel = Object(entities_channels["getChannelsNameMapInTeam"])(state, teamObj.id)[channelName];
    let member;

    if (channel) {
      member = state.entities.channels.myMembers[channel.id];
    }

    if (!channel || !member) {
      // const currentUser=getCurrentUser(state);
      // const userId = JSON.stringify({
      //     userId: getCurrentUserId(state),
      //     companyId: currentUser.ou
      //   });//新加的接口
      const {
        data,
        error: joinError
      } = await dispatch(Object(actions_channels["joinChannel"])(Object(entities_users["getCurrentUserId"])(state), teamObj.id, null, channelName));

      if (joinError) {
        const {
          data: data2,
          error: getChannelError
        } = await dispatch(Object(actions_channels["getChannelByNameAndTeamName"])(team, channelName, true));

        if (getChannelError || data2.delete_at === 0) {
          handleChannelJoinError(match, history, Object(entities_channels["getRedirectChannelNameForTeam"])(state, teamObj.id));
          return;
        }

        channel = data2;
      } else {
        channel = data.channel;
      }
    }

    if (channel.type === constants["g" /* Constants */].DM_CHANNEL) {
      dispatch(goToDirectChannelByUserIds(match, history));
    } else if (channel.type === constants["g" /* Constants */].GM_CHANNEL) {
      history.replace(`/${team}/messages/${channel.name}`);
    } else {
      doChannelChange(channel);
    }
  };
}

function goToDirectChannelByUsername(match, history) {
  return async (dispatch, getState) => {
    const state = getState();
    const {
      team,
      identifier
    } = match.params;
    const username = identifier.slice(1, identifier.length).toLowerCase();
    const teamObj = Object(entities_teams["getTeamByName"])(state, team);
    let user = Object(entities_users["getUserByUsername"])(state, username);

    if (!user) {
      const {
        data,
        error
      } = await dispatch(Object(actions_users["getUserByUsername"])(username));

      if (error) {
        handleError(match, history, Object(entities_channels["getRedirectChannelNameForTeam"])(state, teamObj.id));
        return;
      }

      user = data;
    }

    const {
      error,
      data
    } = await dispatch(Object(channel_actions["e" /* openDirectChannelToUserId */])(user.id));

    if (error) {
      handleError(match, history, Object(entities_channels["getRedirectChannelNameForTeam"])(state, teamObj.id));
      return;
    }

    doChannelChange(data);
  };
}

function goToDirectChannelByUserId(match, history, userId) {
  return async (dispatch, getState) => {
    const state = getState();
    const {
      team
    } = match.params;
    const teamObj = Object(entities_teams["getTeamByName"])(state, team);
    let user = Object(entities_users["getUser"])(state, userId);

    if (!user) {
      const {
        data,
        error
      } = await dispatch(Object(actions_users["getUser"])(userId));

      if (error) {
        handleError(match, history, Object(entities_channels["getRedirectChannelNameForTeam"])(state, teamObj.id));
        return;
      }

      user = data;
    }

    history.replace(`/${team}/messages/@${user.username}`);
  };
}
function goToDirectChannelByUserIds(match, history) {
  return async (dispatch, getState) => {
    const state = getState();
    const {
      team,
      identifier
    } = match.params;
    const userId = utils["F" /* getUserIdFromChannelId */](identifier.toLowerCase(), Object(entities_users["getCurrentUserId"])(getState()));
    const teamObj = Object(entities_teams["getTeamByName"])(state, team);
    let user = Object(entities_users["getUser"])(state, userId);

    if (!user) {
      const {
        data,
        error
      } = await dispatch(Object(actions_users["getUser"])(userId));

      if (error) {
        handleError(match, history, Object(entities_channels["getRedirectChannelNameForTeam"])(state, teamObj.id));
        return;
      }

      user = data;
    }

    history.replace(`/${team}/messages/@${user.username}`);
  };
}
function goToDirectChannelByEmail(match, history) {
  return async (dispatch, getState) => {
    const state = getState();
    const {
      team,
      identifier
    } = match.params;
    const email = identifier.toLowerCase();
    const teamObj = Object(entities_teams["getTeamByName"])(state, team);
    let user = Object(entities_users["getUserByEmail"])(state, email);

    if (!user) {
      const {
        data,
        error
      } = await dispatch(Object(actions_users["getUserByEmail"])(email));

      if (error) {
        handleError(match, history, Object(entities_channels["getRedirectChannelNameForTeam"])(state, teamObj.id));
        return;
      }

      user = data;
    }

    history.replace(`/${team}/messages/@${user.username}`);
  };
}

function goToGroupChannelByGroupId(match, history) {
  return async (dispatch, getState) => {
    const state = getState();
    const {
      identifier,
      team
    } = match.params;
    const groupId = identifier.toLowerCase();
    history.replace(match.url.replace('/channels/', '/messages/'));
    let channel = Object(entities_channels["getChannelByName"])(state, groupId);
    const teamObj = Object(entities_teams["getTeamByName"])(state, team);

    if (!channel) {
      const {
        data,
        error
      } = await dispatch(Object(actions_channels["joinChannel"])(Object(entities_users["getCurrentUserId"])(state), teamObj.id, null, groupId));

      if (error) {
        handleError(match, history, Object(entities_channels["getRedirectChannelNameForTeam"])(state, teamObj.id));
        return;
      }

      channel = data.channel;
    }

    dispatch(Object(actions_channels["markGroupChannelOpen"])(channel.id));
    doChannelChange(channel);
  };
}

function doChannelChange(channel) {
  global_actions["b" /* emitChannelClickEvent */](channel);
}

function handleError(match, history, defaultChannel) {
  const {
    team
  } = match.params;
  history.push(team ? `/${team}/channels/${defaultChannel}` : '/');
}

function handleChannelJoinError(match, history, defaultChannel) {
  const {
    team
  } = match.params;
  history.push(team ? `/error?type=channel_not_found&returnTo=/${team}/channels/${defaultChannel}` : '/');
}
// EXTERNAL MODULE: ./actions/views/meeting.js
var meeting = __webpack_require__(182);

// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var hoist_non_react_statics_cjs = __webpack_require__(195);
var hoist_non_react_statics_cjs_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics_cjs);

// CONCATENATED MODULE: ./components/deferComponentRender.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


/**
 * Allows two animation frames to complete to allow other components to update
 * and re-render before mounting and rendering an expensive `WrappedComponent`.
 * If provided, `PreRenderComponent` will be rendered instead of null when not
 * rendering the `Wrapped Component`.
 *
 * Based on this Twitter built component
 * https://gist.github.com/paularmstrong/cc2ead7e2a0dec37d8b2096fc8d85759#file-defercomponentrender-js
 */

function deferComponentRender(WrappedComponent, PreRenderComponent = null) {
  class DeferredRenderWrapper extends react_default.a.Component {
    constructor(props, context) {
      super(props, context);
      this.state = {
        shouldRender: false
      };
    }

    componentDidMount() {
      window.requestAnimationFrame(() => {
        window.requestAnimationFrame(() => this.setState({
          shouldRender: true
        }));
      });
    }

    render() {
      return this.state.shouldRender ? react_default.a.createElement(WrappedComponent, this.props) : PreRenderComponent;
    }

  }

  return hoist_non_react_statics_cjs_default()(DeferredRenderWrapper, WrappedComponent);
}
// CONCATENATED MODULE: ./selectors/views/system.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
function connectionErrorCount(state) {
  return state.views.system.websocketConnectionErrorCount;
}
// CONCATENATED MODULE: ./actions/command.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

















function executeCommand(message, args) {
  return async (dispatch, getState) => {
    const state = getState();
    let msg = message;
    let cmdLength = msg.indexOf(' ');

    if (cmdLength < 0) {
      cmdLength = msg.length;
    }

    const cmd = msg.substring(0, cmdLength).toLowerCase();
    msg = cmd + ' ' + msg.substring(cmdLength, msg.length).trim();

    switch (cmd) {
      case '/search':
        dispatch(post_actions["m" /* searchForTerm */](msg.substring(cmdLength + 1, msg.length)));
        return {
          data: true
        };

      case '/shortcuts':
        if (user_agent["m" /* isMobile */]()) {
          const error = {
            message: Object(utils["gb" /* localizeMessage */])('create_post.shortcutsNotSupported', 'Keyboard shortcuts are not supported on your device')
          };
          return {
            error
          };
        }

        global_actions["n" /* toggleShortcutsModal */]();
        return {
          data: true
        };

      case '/leave':
        {
          // /leave command not supported in reply threads.
          if (args.channel_id && (args.root_id || args.parent_id)) {
            global_actions["h" /* sendEphemeralPost */]('/leave is not supported in reply threads. Use it in the center channel instead.', args.channel_id, args.parent_id);
            return {
              data: true
            };
          }

          const channel = Object(entities_channels["getCurrentChannel"])(state);

          if (channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
            global_actions["m" /* showLeavePrivateChannelModal */](channel);
            return {
              data: true
            };
          } else if (channel.type === constants["g" /* Constants */].DM_CHANNEL || channel.type === constants["g" /* Constants */].GM_CHANNEL) {
            let name;
            let category;

            if (channel.type === constants["g" /* Constants */].DM_CHANNEL) {
              name = Object(utils["G" /* getUserIdFromChannelName */])(channel);
              category = constants["g" /* Constants */].Preferences.CATEGORY_DIRECT_CHANNEL_SHOW;
            } else {
              name = channel.id;
              category = constants["g" /* Constants */].Preferences.CATEGORY_GROUP_CHANNEL_SHOW;
            }

            const currentUserId = Object(entities_users["getCurrentUserId"])(state);
            dispatch(Object(actions_preferences["savePreferences"])(currentUserId, [{
              category,
              name,
              user_id: currentUserId,
              value: 'false'
            }]));

            if (Object(utils_channel_utils["isFavoriteChannel"])(channel)) {
              dispatch(Object(actions_channels["unfavoriteChannel"])(channel.id));
            }

            const currentTeamId = Object(entities_teams["getCurrentTeamId"])(state);
            const redirectChannel = Object(entities_channels["getRedirectChannelNameForTeam"])(state, currentTeamId);
            browser_history["a" /* browserHistory */].push(`${Object(entities_teams["getCurrentRelativeTeamUrl"])(state)}/channels/${redirectChannel}`);
            return {
              data: true
            };
          }

          break;
        }

      case '/settings':
        dispatch(Object(modals["b" /* openModal */])({
          ModalId: constants["p" /* ModalIdentifiers */].USER_SETTINGS,
          dialogType: components_new_user_settings_modal
        }));
        return {
          data: true
        };

      case '/collapse':
      case '/expand':
        dispatch(post_actions["l" /* resetEmbedVisibility */]());
    }

    let data;

    try {
      data = await client["Client4"].executeCommand(msg, args);

      if (data && data.card_type === "9999" && data.command_url != "") {
        window.open(data.command_url, "_blank");
      }
    } catch (err) {
      return {
        error: err
      };
    }

    const hasGotoLocation = data.goto_location && Object(utils_url["f" /* isUrlSafe */])(data.goto_location);

    if (msg.trim() === '/logout') {
      global_actions["e" /* emitUserLoggedOutEvent */](hasGotoLocation ? data.goto_location : '/');
      return {
        data: true
      };
    }

    if (data.trigger_id) {
      dispatch({
        type: action_types["IntegrationTypes"].RECEIVED_DIALOG_TRIGGER_ID,
        data: data.trigger_id
      });
    }

    if (hasGotoLocation) {
      if (data.goto_location.startsWith('/')) {
        browser_history["a" /* browserHistory */].push(data.goto_location);
      } else if (data.goto_location.startsWith(Object(utils_url["e" /* getSiteURL */])())) {
        browser_history["a" /* browserHistory */].push(data.goto_location.substr(Object(utils_url["e" /* getSiteURL */])().length));
      } else {
        window.open(data.goto_location);
      }
    }

    return {
      data: true
    };
  };
}
// CONCATENATED MODULE: ./actions/hooks.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
function runMessageWillBePostedHooks(originalPost) {
  return async (dispatch, getState) => {
    const hooks = getState().plugins.components.MessageWillBePosted;

    if (!hooks || hooks.length === 0) {
      return {
        data: originalPost
      };
    }

    let post = originalPost;

    for (const hook of hooks) {
      const result = await hook.hook(post); // eslint-disable-line no-await-in-loop

      if (result) {
        if (result.error) {
          return {
            error: result.error
          };
        }

        post = result.post;
      }
    }

    return {
      data: post
    };
  };
}
function runSlashCommandWillBePostedHooks(originalMessage, originalArgs) {
  return async (dispatch, getState) => {
    const hooks = getState().plugins.components.SlashCommandWillBePosted;

    if (!hooks || hooks.length === 0) {
      return {
        data: {
          message: originalMessage,
          args: originalArgs
        }
      };
    }

    let message = originalMessage;
    let args = originalArgs;

    for (const hook of hooks) {
      const result = await hook.hook(message, args); // eslint-disable-line no-await-in-loop

      if (result) {
        if (result.error) {
          return {
            error: result.error
          };
        }

        message = result.message;
        args = result.args;
      }
    }

    return {
      data: {
        message,
        args
      }
    };
  };
}
// EXTERNAL MODULE: ./actions/storage.js
var storage = __webpack_require__(139);

// EXTERNAL MODULE: ./utils/file_utils.jsx
var file_utils = __webpack_require__(1601);

// EXTERNAL MODULE: ./node_modules/uuid/v4.js
var v4 = __webpack_require__(1780);
var v4_default = /*#__PURE__*/__webpack_require__.n(v4);

// EXTERNAL MODULE: ./mattermost-redux/utils/file_utils.js
var utils_file_utils = __webpack_require__(1611);

// CONCATENATED MODULE: ./utils/paste.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
function parseTable(html) {
  const el = document.createElement('div');
  el.innerHTML = html;
  return el.querySelector('table');
}
function getTable(clipboardData) {
  if (Array.from(clipboardData.types).indexOf('text/html') === -1) {
    return false;
  }

  const html = clipboardData.getData('text/html');

  if (!/<table/i.test(html)) {
    return false;
  }

  const table = parseTable(html);

  if (!table) {
    return false;
  }

  return table;
}

function columnText(column) {
  const noBreakSpace = '\u00A0';
  const text = column.textContent.trim().replace(/\|/g, '\\|').replace(/\n/g, ' ');
  return text || noBreakSpace;
}

function tableHeaders(row) {
  return Array.from(row.querySelectorAll('td, th')).map(columnText);
}

function formatMarkdownTableMessage(table, message) {
  const rows = Array.from(table.querySelectorAll('tr'));
  const headers = tableHeaders(rows.shift());
  const spacers = headers.map(() => '---');
  const header = `|${headers.join(' | ')}|\n|${spacers.join(' | ')}|\n`;
  const body = rows.map(row => {
    return `|${Array.from(row.querySelectorAll('td')).map(columnText).join(' | ')}|`;
  }).join('\n');
  const formattedTable = `${header}${body}\n`;
  return message ? `${message}\n\n${formattedTable}` : formattedTable;
}
// EXTERNAL MODULE: ./components/file_attachment/filename_overlay.jsx
var filename_overlay = __webpack_require__(1862);

// CONCATENATED MODULE: ./components/icon/remove_icon.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class remove_icon_RemoveIcon extends react_default.a.PureComponent {
  render() {
    return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "generic_icons.remove",
      defaultMessage: "Remove Icon"
    }, title => react_default.a.createElement("i", {
      className: "fa fa-remove",
      title: title
    }));
  }

}
// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/ProgressBar.js
var ProgressBar = __webpack_require__(2005);

// CONCATENATED MODULE: ./components/file_preview/file_progress_preview.jsx
function file_progress_preview_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class file_progress_preview_FileProgressPreview extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    file_progress_preview_defineProperty(this, "handleRemove", () => {
      this.props.handleRemove(this.props.clientId);
    });
  }

  render() {
    let percent = 0;
    let fileNameComponent;
    let previewImage;
    const {
      fileInfo,
      clientId
    } = this.props;

    if (fileInfo) {
      percent = fileInfo.percent;
      const percentTxt = percent && ` (${percent.toFixed(0)}%)`;
      const fileType = Object(file_utils["f" /* getFileTypeFromMime */])(fileInfo.type);
      previewImage = react_default.a.createElement("div", {
        className: 'file-icon ' + utils["B" /* getIconClassName */](fileType)
      });
      fileNameComponent = react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(filename_overlay["a" /* default */], {
        fileInfo: fileInfo,
        index: clientId,
        handleImageClick: null,
        compactDisplay: false,
        canDownload: false
      }), react_default.a.createElement("span", {
        className: "post-image__uploadingTxt"
      }, percent === 100 ? react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "create_post.fileProcessing",
        defaultMessage: "Processing..."
      }) : react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "admin.plugin.uploading",
        defaultMessage: "Uploading..."
      }), react_default.a.createElement("span", null, percentTxt))), percent && react_default.a.createElement(ProgressBar["a" /* default */], {
        className: "post-image__progressBar",
        now: percent,
        active: percent === 100
      }));
    }

    return react_default.a.createElement("div", {
      ref: clientId,
      key: clientId,
      className: "file-preview post-image__column",
      "data-client-id": clientId
    }, react_default.a.createElement("div", {
      className: "post-image__thumbnail"
    }, previewImage), react_default.a.createElement("div", {
      className: "post-image__details"
    }, react_default.a.createElement("div", {
      className: "post-image__detail_wrapper"
    }, react_default.a.createElement("div", {
      className: "post-image__detail"
    }, fileNameComponent)), react_default.a.createElement("div", null, react_default.a.createElement("a", {
      className: "file-preview__remove",
      onClick: this.handleRemove
    }, react_default.a.createElement(remove_icon_RemoveIcon, null)))));
  }

}

file_progress_preview_defineProperty(file_progress_preview_FileProgressPreview, "propTypes", {
  handleRemove: prop_types_default.a.func.isRequired,
  clientId: prop_types_default.a.string.isRequired,
  fileInfo: prop_types_default.a.object
});
// CONCATENATED MODULE: ./components/file_preview/file_preview.jsx
function file_preview_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








class file_preview_FilePreview extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    file_preview_defineProperty(this, "handleRemove", id => {
      this.props.onRemove(id);
    });
  }

  render() {
    const previews = [];
    this.props.fileInfos.forEach((info, idx) => {
      const type = utils["z" /* getFileType */](info.extension);
      let className = 'file-preview post-image__column';
      let previewImage;

      if (type === constants["k" /* FileTypes */].SVG) {
        previewImage = react_default.a.createElement("img", {
          alt: 'file preview',
          className: "post-image normal",
          src: Object(utils_file_utils["getFileUrl"])(info.id)
        });
      } else if (type === constants["k" /* FileTypes */].IMAGE) {
        let imageClassName = 'post-image';

        if (info.width < constants["N" /* default */].THUMBNAIL_WIDTH && info.height < constants["N" /* default */].THUMBNAIL_HEIGHT) {
          imageClassName += ' small';
        } else {
          imageClassName += ' normal';
        }

        let thumbnailUrl = Object(utils_file_utils["getFileThumbnailUrl"])(info.id);

        if (utils["T" /* isGIFImage */](info.extension) && !info.has_preview_image) {
          thumbnailUrl = Object(utils_file_utils["getFileUrl"])(info.id);
        }

        previewImage = react_default.a.createElement("div", {
          className: imageClassName,
          style: {
            backgroundImage: `url(${thumbnailUrl})`,
            backgroundSize: 'cover'
          }
        });
      } else {
        className += ' custom-file';
        previewImage = react_default.a.createElement("div", {
          className: 'file-icon ' + utils["B" /* getIconClassName */](type)
        });
      }

      previews.push(react_default.a.createElement("div", {
        key: info.id,
        className: className
      }, react_default.a.createElement("div", {
        className: "post-image__thumbnail"
      }, previewImage), react_default.a.createElement("div", {
        className: "post-image__details"
      }, react_default.a.createElement("div", {
        className: "post-image__detail_wrapper"
      }, react_default.a.createElement("div", {
        className: "post-image__detail"
      }, react_default.a.createElement(filename_overlay["a" /* default */], {
        fileInfo: info,
        index: idx,
        handleImageClick: null,
        compactDisplay: false,
        canDownload: false
      }), react_default.a.createElement("span", {
        className: "post-image__type"
      }, info.extension.toUpperCase()), react_default.a.createElement("span", {
        className: "post-image__size"
      }, utils["p" /* fileSizeToString */](info.size)))), react_default.a.createElement("div", null, react_default.a.createElement("a", {
        className: "file-preview__remove",
        onClick: this.handleRemove.bind(this, info.id)
      }, react_default.a.createElement(remove_icon_RemoveIcon, null))))));
    });
    this.props.uploadsInProgress.forEach(clientId => {
      previews.push(react_default.a.createElement(file_progress_preview_FileProgressPreview, {
        key: clientId,
        clientId: clientId,
        fileInfo: this.props.uploadsProgressPercent[clientId],
        handleRemove: this.handleRemove
      }));
    });
    return react_default.a.createElement("div", {
      className: "file-preview__container",
      ref: "container"
    }, previews);
  }

}

file_preview_defineProperty(file_preview_FilePreview, "propTypes", {
  onRemove: prop_types_default.a.func.isRequired,
  fileInfos: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,
  uploadsInProgress: prop_types_default.a.array,
  uploadsProgressPercent: prop_types_default.a.object
});

file_preview_defineProperty(file_preview_FilePreview, "defaultProps", {
  fileInfos: [],
  uploadsInProgress: [],
  uploadsProgressPercent: {}
});
// EXTERNAL MODULE: ./node_modules/redux-batched-actions/lib/index.js
var redux_batched_actions_lib = __webpack_require__(65);

// EXTERNAL MODULE: ./node_modules/superagent/lib/client.js
var lib_client = __webpack_require__(2060);
var lib_client_default = /*#__PURE__*/__webpack_require__.n(lib_client);

// CONCATENATED MODULE: ./actions/file_actions.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function uploadFile(file, name, channelId, rootId, clientId) {
  return dispatch => {
    dispatch({
      type: action_types["FileTypes"].UPLOAD_FILES_REQUEST
    });
    return lib_client_default.a.post(client["Client4"].getFilesRoute()).set(client["Client4"].getOptions({
      method: 'post'
    }).headers).attach('files', file, name).field('channel_id', channelId).field('client_ids', clientId).accept('application/json');
  };
}
function handleFileUploadEnd(file, name, channelId, rootId, clientId, {
  err,
  res
}) {
  return (dispatch, getState) => {
    if (err) {
      let e;

      if (res && res.body && res.body.id) {
        e = res.body;
      } else if (err.status === 0 || !err.status) {
        e = {
          message: utils["gb" /* localizeMessage */]('file_upload.generic_error', 'There was a problem uploading your files.')
        };
      } else {
        e = {
          message: utils["gb" /* localizeMessage */]('channel_loader.unknown_error', 'We received an unexpected status code from the server.') + ' (' + err.status + ')'
        };
      }

      Object(actions_helpers["forceLogoutIfNecessary"])(err, dispatch, getState);
      const failure = {
        type: action_types["FileTypes"].UPLOAD_FILES_FAILURE,
        clientIds: [clientId],
        channelId,
        rootId,
        error: err
      };
      dispatch(Object(redux_batched_actions_lib["batchActions"])([failure, Object(actions_errors["getLogErrorAction"])(err)]));
      return {
        error: e
      };
    }

    const data = res.body.file_infos.map((fileInfo, index) => {
      return { ...fileInfo,
        clientId: res.body.client_ids[index]
      };
    });
    dispatch(Object(redux_batched_actions_lib["batchActions"])([{
      type: action_types["FileTypes"].RECEIVED_UPLOAD_FILES,
      data,
      channelId,
      rootId
    }, {
      type: action_types["FileTypes"].UPLOAD_FILES_SUCCESS
    }]));
    return {
      data: res.body
    };
  };
}
// EXTERNAL MODULE: ./non_npm_dependencies/jquery-dragster/jquery.dragster.js
var jquery_dragster = __webpack_require__(3011);

// EXTERNAL MODULE: ./components/svg/attachment_icon.jsx
var attachment_icon = __webpack_require__(2016);

// CONCATENATED MODULE: ./components/file_upload/file_upload.jsx
function file_upload_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.















const file_upload_holders = Object(index_es["g" /* defineMessages */])({
  limited: {
    id: Object(i18n["b" /* t */])('file_upload.limited'),
    defaultMessage: 'Uploads limited to {count, number} files maximum. Please use additional posts for more files.'
  },
  filesAbove: {
    id: Object(i18n["b" /* t */])('file_upload.filesAbove'),
    defaultMessage: 'Files above {max}MB could not be uploaded: {filenames}'
  },
  fileAbove: {
    id: Object(i18n["b" /* t */])('file_upload.fileAbove'),
    defaultMessage: 'File above {max}MB could not be uploaded: {filename}'
  },
  zeroBytesFiles: {
    id: Object(i18n["b" /* t */])('file_upload.zeroBytesFiles'),
    defaultMessage: 'You are uploading empty files: {filenames}'
  },
  zeroBytesFile: {
    id: Object(i18n["b" /* t */])('file_upload.zeroBytesFile'),
    defaultMessage: 'You are uploading an empty file: {filename}'
  },
  pasted: {
    id: Object(i18n["b" /* t */])('file_upload.pasted'),
    defaultMessage: 'Image Pasted at '
  },
  uploadFile: {
    id: Object(i18n["b" /* t */])('file_upload.upload_files'),
    defaultMessage: 'Upload files'
  }
});
const OVERLAY_TIMEOUT = 500;
const customStyles = {
  left: 'inherit',
  right: 0,
  bottom: '100%',
  top: 'auto'
};
class file_upload_FileUpload extends react["PureComponent"] {
  constructor(props) {
    super(props);

    file_upload_defineProperty(this, "fileUploadSuccess", (data, channelId, currentRootId) => {
      if (data) {
        this.props.onFileUpload(data.file_infos, data.client_ids, channelId, currentRootId);
        const requests = Object.assign({}, this.state.requests);

        for (var j = 0; j < data.client_ids.length; j++) {
          Reflect.deleteProperty(requests, data.client_ids[j]);
        }

        this.setState({
          requests
        });
      }
    });

    file_upload_defineProperty(this, "fileUploadFail", (err, clientId, channelId, currentRootId) => {
      this.props.onUploadError(err, clientId, channelId, currentRootId);
    });

    file_upload_defineProperty(this, "pluginUploadFiles", files => {
      // clear any existing errors
      this.props.onUploadError(null);
      this.uploadFiles(files);
    });

    file_upload_defineProperty(this, "checkPluginHooksAndUploadFiles", files => {
      // clear any existing errors
      this.props.onUploadError(null);
      let sortedFiles = Array.from(files).sort((a, b) => a.name.localeCompare(b.name, this.props.locale, {
        numeric: true
      }));
      const willUploadHooks = this.props.pluginFilesWillUploadHooks;

      for (const h of willUploadHooks) {
        const result = h.hook(sortedFiles, this.pluginUploadFiles); // Display an error message if there is one but don't reject the upload

        if (result.message) {
          this.props.onUploadError(result.message);
        }

        sortedFiles = result.files;
      }

      if (sortedFiles) {
        this.uploadFiles(sortedFiles);
      }
    });

    file_upload_defineProperty(this, "uploadFiles", sortedFiles => {
      const {
        currentChannelId,
        rootId
      } = this.props;
      const uploadsRemaining = constants["N" /* default */].MAX_UPLOAD_FILES - this.props.fileCount;
      let numUploads = 0; // keep track of how many files have been too large

      const tooLargeFiles = [];
      const zeroFiles = [];
      const clientIds = [];

      for (let i = 0; i < sortedFiles.length && numUploads < uploadsRemaining; i++) {
        if (sortedFiles[i].size > this.props.maxFileSize) {
          tooLargeFiles.push(sortedFiles[i]);
          continue;
        }

        if (sortedFiles[i].size === 0) {
          zeroFiles.push(sortedFiles[i]);
        } // generate a unique id that can be used by other components to refer back to this upload


        const clientId = Object(utils["s" /* generateId */])();
        const request = this.props.actions.uploadFile(sortedFiles[i], sortedFiles[i].name, currentChannelId, rootId, clientId);
        request.on('progress', progressEvent => {
          this.props.onUploadProgress({
            clientId,
            name: sortedFiles[i].name,
            percent: progressEvent.percent,
            type: sortedFiles[i].type
          });
        });
        request.end((err, res) => {
          const {
            error,
            data
          } = this.props.actions.handleFileUploadEnd(sortedFiles[i], sortedFiles[i].name, currentChannelId, rootId, clientId, {
            err,
            res
          });

          if (error) {
            this.fileUploadFail(error, clientId, currentChannelId, rootId);
          } else if (data) {
            this.fileUploadSuccess(data, currentChannelId, rootId);
          }
        });
        this.setState({
          requests: { ...this.state.requests,
            [clientId]: request
          }
        });
        clientIds.push(clientId);
        numUploads += 1;
      }

      this.props.onUploadStart(clientIds, currentChannelId);
      const {
        formatMessage
      } = this.context.intl;
      const errors = [];

      if (sortedFiles.length > uploadsRemaining) {
        errors.push(formatMessage(file_upload_holders.limited, {
          count: constants["N" /* default */].MAX_UPLOAD_FILES
        }));
      }

      if (tooLargeFiles.length > 1) {
        var tooLargeFilenames = tooLargeFiles.map(file => file.name).join(', ');
        errors.push(formatMessage(file_upload_holders.filesAbove, {
          max: this.props.maxFileSize / 1048576,
          filenames: tooLargeFilenames
        }));
      } else if (tooLargeFiles.length > 0) {
        errors.push(formatMessage(file_upload_holders.fileAbove, {
          max: this.props.maxFileSize / 1048576,
          filename: tooLargeFiles[0].name
        }));
      }

      if (zeroFiles.length > 1) {
        var zeroFilenames = zeroFiles.map(file => file.name).join(', ');
        errors.push(formatMessage(file_upload_holders.zeroBytesFiles, {
          filenames: zeroFilenames
        }));
      } else if (zeroFiles.length > 0) {
        errors.push(formatMessage(file_upload_holders.zeroBytesFile, {
          filename: zeroFiles[0].name
        }));
      }

      if (errors.length > 0) {
        this.props.onUploadError(errors.join(', '));
      }
    });

    file_upload_defineProperty(this, "handleChange", e => {
      if (e.target.files.length > 0) {
        this.checkPluginHooksAndUploadFiles(e.target.files);
        Object(utils["d" /* clearFileInput */])(e.target);
      }

      this.props.onFileUploadChange();
    });

    file_upload_defineProperty(this, "handleDrop", e => {
      if (!this.props.canUploadFiles) {
        this.props.onUploadError(Object(utils["gb" /* localizeMessage */])('file_upload.disabled', 'File attachments are disabled.'));
        return;
      }

      this.props.onUploadError(null);
      const items = e.originalEvent.dataTransfer.items || [];
      const droppedFiles = e.originalEvent.dataTransfer.files;
      const files = [];
      Array.from(droppedFiles).forEach((file, index) => {
        const item = items[index];

        if (item && item.webkitGetAsEntry && item.webkitGetAsEntry().isDirectory) {
          return;
        }

        files.push(file);
      });
      const types = e.originalEvent.dataTransfer.types;

      if (types) {
        // For non-IE browsers
        if (types.includes && !types.includes('Files')) {
          return;
        } // For IE browsers


        if (types.contains && !types.contains('Files')) {
          return;
        }
      }

      if (files.length === 0) {
        this.props.onUploadError(Object(utils["gb" /* localizeMessage */])('file_upload.drag_folder', 'Folders cannot be uploaded. Please drag all files separately.'));
        return;
      }

      if (files.length) {
        this.checkPluginHooksAndUploadFiles(files);
      }

      this.props.onFileUploadChange();
    });

    file_upload_defineProperty(this, "registerDragEvents", (containerSelector, overlaySelector) => {
      const self = this;
      const overlay = jquery_default()(overlaySelector);
      const dragTimeout = new delayed_action["a" /* default */](() => {
        if (!overlay.hasClass('hidden')) {
          overlay.addClass('hidden');
        }
      });
      let dragsterActions = {};

      if (this.props.canUploadFiles) {
        dragsterActions = {
          enter(dragsterEvent, e) {
            var files = e.originalEvent.dataTransfer;

            if (Object(utils["S" /* isFileTransfer */])(files)) {
              jquery_default()(overlaySelector).removeClass('hidden');
            }
          },

          leave(dragsterEvent, e) {
            var files = e.originalEvent.dataTransfer;

            if (Object(utils["S" /* isFileTransfer */])(files) && !overlay.hasClass('hidden')) {
              overlay.addClass('hidden');
            }

            dragTimeout.cancel();
          },

          over() {
            dragTimeout.fireAfter(OVERLAY_TIMEOUT);
          },

          drop(dragsterEvent, e) {
            if (!overlay.hasClass('hidden')) {
              overlay.addClass('hidden');
            }

            dragTimeout.cancel();
            self.handleDrop(e);
          }

        };
      } else {
        dragsterActions = {
          drop(dragsterEvent, e) {
            self.handleDrop(e);
          }

        };
      }

      jquery_default()(containerSelector).dragster(dragsterActions);
    });

    file_upload_defineProperty(this, "containsEventTarget", (targetElement, eventTarget) => targetElement && targetElement.contains(eventTarget));

    file_upload_defineProperty(this, "pasteUpload", e => {
      const {
        formatMessage
      } = this.context.intl;

      if (!e.clipboardData || !e.clipboardData.items || getTable(e.clipboardData)) {
        return;
      }

      const target = this.props.getTarget();
      const textarea = react_dom_default.a.findDOMNode(target);

      if (!this.containsEventTarget(textarea, e.target)) {
        return;
      }

      this.props.onUploadError(null);
      const items = [];

      for (let i = 0; i < e.clipboardData.items.length; i++) {
        const item = e.clipboardData.items[i];

        if (item.kind !== 'file') {
          continue;
        }

        items.push(item);
      }

      if (items && items.length > 0) {
        if (!this.props.canUploadFiles) {
          this.props.onUploadError(Object(utils["gb" /* localizeMessage */])('file_upload.disabled', 'File attachments are disabled.'));
          return;
        }

        const files = [];

        for (let i = 0; i < items.length; i++) {
          const file = items[i].getAsFile();

          if (!file) {
            continue;
          }

          var d = new Date();
          let hour = d.getHours();
          hour = hour < 10 ? `0${hour}` : `${hour}`;
          let minute = d.getMinutes();
          minute = minute < 10 ? `0${minute}` : `${minute}`;
          var ext = '';

          if (file.name) {
            if (file.name.includes('.')) {
              ext = file.name.substr(file.name.lastIndexOf('.'));
            }
          } else if (items[i].type.includes('/')) {
            ext = '.' + items[i].type.split('/')[1].toLowerCase();
          }

          const name = formatMessage(file_upload_holders.pasted) + d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate() + ' ' + hour + '-' + minute + ext;
          const newFile = new Blob([file], {
            type: file.type
          });
          newFile.name = name;
          files.push(newFile);
        }

        if (files.length > 0) {
          this.checkPluginHooksAndUploadFiles(files);
          this.props.onFileUploadChange();
        }
      }
    });

    file_upload_defineProperty(this, "keyUpload", e => {
      if (Object(utils["e" /* cmdOrCtrlPressed */])(e) && Object(utils["V" /* isKeyPressed */])(e, constants["N" /* default */].KeyCodes.U)) {
        e.preventDefault();

        if (!this.props.canUploadFiles) {
          this.props.onUploadError(Object(utils["gb" /* localizeMessage */])('file_upload.disabled', 'File attachments are disabled.'));
          return;
        }

        const postTextbox = this.props.postType === 'post' && document.activeElement.id === 'post_textbox';
        const commentTextbox = this.props.postType === 'comment' && document.activeElement.id === 'reply_textbox';

        if (postTextbox || commentTextbox) {
          this.fileInput.current.focus();
          this.fileInput.current.click();
        }
      }
    });

    file_upload_defineProperty(this, "cancelUpload", clientId => {
      const requests = Object.assign({}, this.state.requests);
      const request = requests[clientId];

      if (request) {
        request.abort();
        Reflect.deleteProperty(requests, clientId);
        this.setState({
          requests
        });
      }
    });

    file_upload_defineProperty(this, "handleMaxUploadReached", e => {
      if (e) {
        e.preventDefault();
      }

      const {
        onUploadError
      } = this.props;
      const {
        formatMessage
      } = this.context.intl;
      onUploadError(formatMessage(file_upload_holders.limited, {
        count: constants["N" /* default */].MAX_UPLOAD_FILES
      }));
    });

    file_upload_defineProperty(this, "toggleMenu", open => {
      this.setState({
        menuOpen: open
      });
    });

    file_upload_defineProperty(this, "handleLocalFileUploaded", e => {
      const uploadsRemaining = constants["N" /* default */].MAX_UPLOAD_FILES - this.props.fileCount;

      if (uploadsRemaining > 0) {
        if (this.props.onClick) {
          this.props.onClick();
        }
      } else {
        this.handleMaxUploadReached(e);
      }

      this.setState({
        menuOpen: false
      });
    });

    file_upload_defineProperty(this, "simulateInputClick", () => {
      this.fileInput.current.click();
    });

    this.state = {
      requests: {},
      menuOpen: false
    };
    this.fileInput = react_default.a.createRef();
  }

  componentDidMount() {
    if (this.props.postType === 'post') {
      this.registerDragEvents('.row.main', '.center-file-overlay');
    } else if (this.props.postType === 'comment') {
      this.registerDragEvents('.post-right__container', '.right-file-overlay');
    }

    document.addEventListener('paste', this.pasteUpload);
    document.addEventListener('keydown', this.keyUpload);
  }

  componentWillUnmount() {
    let target;

    if (this.props.postType === 'post') {
      target = jquery_default()('.row.main');
    } else {
      target = jquery_default()('.post-right__container');
    }

    document.removeEventListener('paste', this.pasteUpload);
    document.removeEventListener('keydown', this.keyUpload); // jquery-dragster doesn't provide a function to unregister itself so do it manually

    target.off('dragenter dragleave dragover drop dragster:enter dragster:leave dragster:over dragster:drop');
  }

  render() {
    const {
      formatMessage
    } = this.context.intl;
    let multiple = true;

    if (Object(user_agent["n" /* isMobileApp */])()) {
      // iOS WebViews don't upload videos properly in multiple mode
      multiple = false;
    }

    let accept = '';

    if (Object(user_agent["h" /* isIosChrome */])()) {
      // iOS Chrome can't upload videos at all
      accept = 'image/*';
    }

    const uploadsRemaining = constants["N" /* default */].MAX_UPLOAD_FILES - this.props.fileCount;
    let bodyAction;

    if (this.props.pluginFileUploadMethods.length === 0) {
      bodyAction = react_default.a.createElement("div", {
        id: "fileUploadButton",
        className: "icon icon--attachment"
      }, react_default.a.createElement("span", {
        className: "attachment-icon"
      }), react_default.a.createElement("input", {
        "aria-label": formatMessage(file_upload_holders.uploadFile),
        ref: this.fileInput,
        type: "file",
        onChange: this.handleChange,
        onClick: this.handleLocalFileUploaded,
        multiple: multiple,
        accept: accept
      }));
    } else {
      const pluginFileUploadMethods = this.props.pluginFileUploadMethods.map(item => {
        return react_default.a.createElement("li", {
          key: item.pluginId + '_fileuploadpluginmenuitem',
          onClick: () => {
            if (item.action) {
              item.action(this.checkPluginHooksAndUploadFiles);
            }

            this.setState({
              menuOpen: false
            });
          }
        }, react_default.a.createElement("a", null, react_default.a.createElement("span", {
          className: "margin-right"
        }, item.icon), item.text));
      });
      bodyAction = react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement("input", {
        "aria-label": formatMessage(file_upload_holders.uploadFile),
        ref: this.fileInput,
        type: "file",
        className: "file-attachment-menu-item-input",
        onChange: this.handleChange,
        onClick: this.handleLocalFileUploaded,
        multiple: multiple,
        accept: accept
      }), react_default.a.createElement(menu_wrapper["a" /* default */], null, react_default.a.createElement("button", {
        type: "button",
        className: "style--none"
      }, react_default.a.createElement("div", {
        id: "fileUploadButton",
        className: "icon icon--attachment"
      }, react_default.a.createElement("span", {
        className: "attachment-icon"
      }))), react_default.a.createElement(menu_menu["a" /* default */], {
        openLeft: true,
        openUp: true,
        ariaLabel: formatMessage({
          id: 'file_upload.menuAriaLabel',
          defaultMessage: 'Upload type selector'
        }),
        customStyles: customStyles
      }, react_default.a.createElement("li", null, react_default.a.createElement("a", {
        onClick: this.simulateInputClick
      }, react_default.a.createElement("span", {
        className: "margin-right"
      }, react_default.a.createElement("i", {
        className: "fa fa-laptop"
      })), react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "yourcomputer",
        defaultMessage: "Your computer"
      }))), pluginFileUploadMethods)));
    }

    if (!this.props.canUploadFiles) {
      bodyAction = null;
    }

    return react_default.a.createElement("span", {
      ref: "input",
      className: uploadsRemaining <= 0 ? ' btn-file__disabled' : ''
    }, bodyAction);
  }

}

file_upload_defineProperty(file_upload_FileUpload, "propTypes", {
  /**
   * Current channel's ID
   */
  currentChannelId: prop_types_default.a.string.isRequired,

  /**
   * Current root post's ID
   */
  rootId: prop_types_default.a.string,

  /**
   * Number of files to attach
   */
  fileCount: prop_types_default.a.number.isRequired,

  /**
   * Function to get file upload targeted input
   */
  getTarget: prop_types_default.a.func.isRequired,
  locale: prop_types_default.a.string.isRequired,

  /**
   * Function to be called when file upload input is clicked
   */
  onClick: prop_types_default.a.func,

  /**
   * Function to be called when file upload is complete
   */
  onFileUpload: prop_types_default.a.func,

  /**
   * Function to be called when file upload input's change event is fired
   */
  onFileUploadChange: prop_types_default.a.func,

  /**
   * Function to be called when upload fails
   */
  onUploadError: prop_types_default.a.func,

  /**
   * Function to be called when file upload starts
   */
  onUploadStart: prop_types_default.a.func,

  /**
   * Type of the object which the uploaded file is attached to
   */
  postType: prop_types_default.a.string,

  /**
   * The maximum uploaded file size.
   */
  maxFileSize: prop_types_default.a.number,

  /**
   * Whether or not file upload is allowed.
   */
  canUploadFiles: prop_types_default.a.bool.isRequired,

  /**
   * Plugin file upload methods to be added
   */
  pluginFileUploadMethods: prop_types_default.a.arrayOf(prop_types_default.a.object),
  pluginFilesWillUploadHooks: prop_types_default.a.arrayOf(prop_types_default.a.object),

  /**
   * Function called when superAgent fires progress event.
   */
  onUploadProgress: prop_types_default.a.func.isRequired,
  actions: prop_types_default.a.shape({
    /**
     * Function to be called to upload file
     */
    uploadFile: prop_types_default.a.func.isRequired,

    /**
     * Function to be called when file is uploaded or failed
     */
    handleFileUploadEnd: prop_types_default.a.func.isRequired
  }).isRequired
});

file_upload_defineProperty(file_upload_FileUpload, "contextTypes", {
  intl: index_es["i" /* intlShape */]
});

file_upload_defineProperty(file_upload_FileUpload, "defaultProps", {
  pluginFileUploadMethods: [],
  pluginFilesWillUploadHooks: []
});
// CONCATENATED MODULE: ./components/file_upload/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









function file_upload_mapStateToProps(state) {
  const config = Object(general["getConfig"])(state);
  const maxFileSize = parseInt(config.MaxFileSize, 10);
  return {
    currentChannelId: Object(entities_channels["getCurrentChannelId"])(state),
    maxFileSize,
    canUploadFiles: Object(file_utils["d" /* canUploadFiles */])(config),
    locale: Object(selectors_i18n["a" /* getCurrentLocale */])(state),
    pluginFileUploadMethods: state.plugins.components.FileUploadMethod,
    pluginFilesWillUploadHooks: state.plugins.components.FilesWillUploadHook
  };
}

function file_upload_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      uploadFile: uploadFile,
      handleFileUploadEnd: handleFileUploadEnd
    }, dispatch)
  };
}

/* harmony default export */ var file_upload = (Object(es["connect"])(file_upload_mapStateToProps, file_upload_mapDispatchToProps, null, {
  withRef: true
})(file_upload_FileUpload));
// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/typing.js
var typing = __webpack_require__(3012);

// CONCATENATED MODULE: ./components/msg_typing/msg_typing.jsx
function msg_typing_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class msg_typing_MsgTyping extends react_default.a.Component {
  constructor(...args) {
    super(...args);

    msg_typing_defineProperty(this, "getTypingText", () => {
      let users = [];
      let numUsers = 0;

      if (this.props.typingUsers) {
        users = [...this.props.typingUsers];
        numUsers = users.length;
      }

      if (numUsers === 0) {
        return '';
      }

      if (numUsers === 1) {
        return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "msg_typing.isTyping",
          defaultMessage: "{user} is typing...",
          values: {
            user: users[0]
          }
        });
      }

      const last = users.pop();
      return react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "msg_typing.areTyping",
        defaultMessage: "{users} and {last} are typing...",
        values: {
          users: users.join(', '),
          last
        }
      });
    });
  }

  render() {
    return react_default.a.createElement("span", {
      className: "msg-typing"
    }, this.getTypingText());
  }

}

msg_typing_defineProperty(msg_typing_MsgTyping, "propTypes", {
  typingUsers: prop_types_default.a.array.isRequired
});
// CONCATENATED MODULE: ./components/msg_typing/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function msg_typing_makeMapStateToProps() {
  const getUsersTypingByChannelAndPost = Object(typing["makeGetUsersTypingByChannelAndPost"])();
  return function mapStateToProps(state, ownProps) {
    const typingUsers = getUsersTypingByChannelAndPost(state, {
      channelId: ownProps.channelId,
      postId: ownProps.postId
    });
    return {
      typingUsers
    };
  };
}

/* harmony default export */ var msg_typing = (Object(es["connect"])(msg_typing_makeMapStateToProps)(msg_typing_MsgTyping));
// CONCATENATED MODULE: ./components/post_deleted_modal.jsx
function post_deleted_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class post_deleted_modal_PostDeletedModal extends react_default.a.Component {
  shouldComponentUpdate(nextProps) {
    return nextProps.show !== this.props.show;
  }

  render() {
    return react_default.a.createElement(Modal["a" /* default */], {
      show: this.props.show,
      onHide: this.props.onHide,
      role: "dialog",
      "aria-labelledby": "postDeletedModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "postDeletedModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "post_delete.notPosted",
      defaultMessage: "Comment could not be posted"
    }))), react_default.a.createElement(Modal["a" /* default */].Body, null, react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "post_delete.someone",
      defaultMessage: "Someone deleted the message on which you tried to post a comment."
    }))), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-primary",
      autoFocus: true,
      onClick: this.props.onHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "post_delete.okay",
      defaultMessage: "Okay"
    }))));
  }

}

post_deleted_modal_defineProperty(post_deleted_modal_PostDeletedModal, "propTypes", {
  /**
   * Determines whether this modal should be shown or not
   */
  show: prop_types_default.a.bool.isRequired,

  /**
   * Function that is called when modal is hidden
   */
  onHide: prop_types_default.a.func.isRequired
});
// CONCATENATED MODULE: ./components/message_submit_error.jsx
function message_submit_error_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class message_submit_error_MessageSubmitError extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    message_submit_error_defineProperty(this, "renderSlashCommandError", () => {
      if (!this.props.submittedMessage) {
        return this.props.error.message;
      }

      const command = this.props.submittedMessage.split(' ')[0];
      return react_default.a.createElement(react_default.a.Fragment, null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "message_submit_error.invalidCommand",
        defaultMessage: 'Command with a trigger of \'{command}\' not found. ',
        values: {
          command
        }
      }), react_default.a.createElement("a", {
        href: "#",
        onClick: this.props.handleSubmit
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "message_submit_error.sendAsMessageLink",
        defaultMessage: "Click here to send as a message."
      })));
    });
  }

  render() {
    const error = this.props.error;

    if (!error) {
      return null;
    }

    let errorContent = error.message;

    if (Object(post_utils["j" /* isErrorInvalidSlashCommand */])(error)) {
      errorContent = this.renderSlashCommandError();
    }

    return react_default.a.createElement("div", {
      className: "has-error"
    }, react_default.a.createElement("label", {
      className: "control-label"
    }, errorContent));
  }

}

message_submit_error_defineProperty(message_submit_error_MessageSubmitError, "propTypes", {
  error: prop_types_default.a.object.isRequired,
  handleSubmit: prop_types_default.a.func.isRequired,
  submittedMessage: prop_types_default.a.string
});

/* harmony default export */ var message_submit_error = (message_submit_error_MessageSubmitError);
// EXTERNAL MODULE: ./images/loading_share.gif
var loading_share = __webpack_require__(3013);
var loading_share_default = /*#__PURE__*/__webpack_require__.n(loading_share);

// EXTERNAL MODULE: ./node_modules/copy-to-clipboard/index.js
var copy_to_clipboard = __webpack_require__(1918);
var copy_to_clipboard_default = /*#__PURE__*/__webpack_require__.n(copy_to_clipboard);

// EXTERNAL MODULE: ./api/post.js
var api_post = __webpack_require__(67);

// EXTERNAL MODULE: ./api/zoom.js
var zoom = __webpack_require__(1698);

// CONCATENATED MODULE: ./components/new_zoom_share_model/new_zoom_share_model.jsx
function new_zoom_share_model_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

















class new_zoom_share_model_NewChannelModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    new_zoom_share_model_defineProperty(this, "onHide", () => {
      this.setState({
        type: 0,
        meetName: ""
      });
      this.props.handleClose();
    });

    new_zoom_share_model_defineProperty(this, "onChange", e => {
      this.setState({
        meetName: e.target.value
      });
    });

    new_zoom_share_model_defineProperty(this, "handleCopy", e => {
      copy_to_clipboard_default()(this.state.urlStr);
      this.onHide();
    });

    new_zoom_share_model_defineProperty(this, "onEnterKeyDown", e => {
      const enterPressed = utils["V" /* isKeyPressed */](e, constants["N" /* default */].KeyCodes.ENTER);
      const {
        ctrlSend
      } = this.props; // Enter pressed alone without required cmd or ctrl key

      if (ctrlSend && enterPressed && !e.ctrlKey) {
        e.preventDefault();
      } else if (ctrlSend && enterPressed && e.ctrlKey || !ctrlSend && enterPressed && !e.shiftKey && !e.altKey) {
        this.handleSubmit(e);
      }
    });

    new_zoom_share_model_defineProperty(this, "handleSubmit", e => {
      e.preventDefault();

      if (this.props.isMeeting) {
        //如果本身在会议中
        Object(api_post["m" /* meetingModal */])("您已有在进行的会议,请结束后再加入新会议!");
        this.onHide();
        return;
      }

      if (this.state.meetName === "") {
        this.setState({
          meetName: this.getMeetName()
        }, () => {
          this.creatMeeting();
        });
      } else {
        this.creatMeeting();
      }
    });

    this.state = {
      displayNameError: '',
      handleSubmit: null,
      handleClose: null,
      show: false,
      type: this.props.type,
      //进度
      meetName: this.props.channelName,
      //会议名称
      meetId: -1,
      //会议id
      meetingNo: -1,
      //zoomid
      fromName: '',
      //发起人名,
      urlStr: '',
      copyStr: '',
      urlStrOut: ""
    };
  }

  UNSAFE_componentWillReceiveProps() {// setTimeout(() => {
    //     if(!this.props.show){
    //         this.setState({type:0,meetName:""});
    //     }
    // }, 300);
  }

  getMeetName() {
    let meetName = "";

    if (this.props.currentChannel) {
      if (this.props.currentChannel.type == "D") {
        //私聊
        if (this.props.users && this.props.users.length > 1) {
          meetName = `${this.props.users[0].nickname}和${this.props.users[1].nickname}的会议`;
        }
      } else {
        meetName = this.props.currentChannel.display_name;
      }
    }

    return meetName;
  }

  componentDidUpdate() {
    if (!this.props.show) {
      this.setState({
        type: 0,
        meetName: this.getMeetName()
      });
    }
  }

  componentDidMount() {
    // ???
    if (user_agent["f" /* isInternetExplorer */]() || user_agent["d" /* isEdge */]()) {//$('body').addClass('browser--ie');
    }

    this.setState({
      type: this.props.type,
      meetName: this.getMeetName()
    });
  } //关闭弹出


  creatMeeting() {
    const ovData = {
      channel_id: this.props.channel_id,
      meeting_name: this.state.meetName
    };
    Object(api_post["h" /* meetCreate */])(ovData).then(res2 => {
      //通知oa创建了会议
      if (res2.status === 226) {
        Object(api_post["m" /* meetingModal */])("抱歉,您当前频道已经有一个会议,不能重复发起会议!");
        this.props.handleClose();
      } else {
        let urlStr = `/video?id=${res2.data.id}&meetingNo=${res2.data.meeting_no}&nickName=${this.props.currentUser.nickname}&userName=${this.props.currentUser.username}&meetingName=${this.state.meetName}&voice_status=1&server_host=${res2.data.server_host}&beginUser=true`;
        window.open(urlStr, "_blank");
        this.props.handleClose(urlStr); // urlStr = JSON.stringify({
        //     id: res2.data.id,
        //     meetId: res2.data.meeting_no,
        //     meetName: this.state.meetName,
        //     from: this.props.currentUser.nickname,
        //     to: [],
        //     meeting_id:res2.data.id,
        //     channel_id:this.props.channel_id ,
        //     time: this.getFormatDate()
        // })
        // const invitation = {data:{
        //     channel_id: this.props.channel_id,
        //     meeting_id: res2.data.id,
        //     meeting_name: this.state.meetName,
        //     meeting_no: res2.data.meeting_no,
        //     user_id: this.props.currentUser.id,
        //     nick_name: this.props.currentUser.nickname
        // }}
        // this.props.actions.addInvitationList(invitation);
        //this.props.actions.setMyMeeting(true);
      }
    });
  }

  render() {
    let con = null; //内容

    let foot = null; //脚

    let moreClass = "zoom-share-dialog";

    if (this.state.type == 0) {
      //初始化
      con = react_default.a.createElement("div", {
        className: "con-class"
      }, react_default.a.createElement("div", {
        className: "con-title-class"
      }, react_default.a.createElement("span", null, "\u4F1A\u8BAE\u540D\u79F0"), react_default.a.createElement("span", {
        className: "con-title-s-class"
      }, "*")), react_default.a.createElement(es_input["a" /* default */], {
        placeholder: this.getMeetName(),
        onChange: this.onChange,
        value: this.state.meetName
      }));
      foot = [react_default.a.createElement(es_button["a" /* default */], {
        key: "0",
        type: "primary",
        onClick: this.handleSubmit
      }, "\u521B\u5EFA")];
    } else if (this.state.type == 1) {
      //加载中
      moreClass += "-none";
      con = react_default.a.createElement("div", {
        className: "con-class-doing"
      }, react_default.a.createElement("img", {
        className: "icon icon__flag",
        src: loading_share_default.a,
        width: "92px",
        height: "92px"
      }), react_default.a.createElement("div", null, "\u89C6\u9891\u4F1A\u8BAE\u51C6\u5907\u4E2D..."));
      foot = null;
    } else if (this.state.type == 2) {
      //分享
      con = react_default.a.createElement("div", {
        className: "con-class"
      }, react_default.a.createElement("div", {
        className: "con-title2-class"
      }, "\u9080\u8BF7\u6210\u5458\u52A0\u5165", this.props.channelName, "\u89C6\u9891\u4F1A\u8BAE"), react_default.a.createElement("div", {
        className: "con-con-class"
      }, react_default.a.createElement("span", {
        class: "con-span-1"
      }, "\u94FE\u63A5"), react_default.a.createElement("span", {
        class: "con-span-2"
      }, this.state.urlStrOut)));
      foot = [react_default.a.createElement(es_button["a" /* default */], {
        key: "0",
        type: "primary",
        onClick: this.handleCopy
      }, "\u590D\u5236\u94FE\u63A5")];
    }

    return react_default.a.createElement("span", null, react_default.a.createElement(es_modal["a" /* default */], {
      title: "\u53D1\u8D77\u89C6\u9891\u4F1A\u8BAE",
      className: "more-modal new-invite-modal zoom-share-dialog",
      mask: false,
      centered: true,
      closeIcon: react_default.a.createElement(es_icon["a" /* default */], {
        type: "close-circle",
        theme: "filled"
      }),
      visible: this.props.show,
      onCancel: this.onHide,
      footer: foot,
      maskClosable: false,
      role: "dialog",
      width: '520px'
    }, con));
  }

}

new_zoom_share_model_defineProperty(new_zoom_share_model_NewChannelModal, "propTypes", {
  currentUser: prop_types_default.a.object,
  channelName: prop_types_default.a.string,
  currentChannel: prop_types_default.a.object,
  // users:PropTypes.Array,
  isMeeting: prop_types_default.a.bool,
  actions: prop_types_default.a.shape({
    setMyMeeting: prop_types_default.a.func.isRequired,
    addInvitationList: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/new_zoom_share_model/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.













function getChannelIcon(state, _channel) {
  let channelIcon = _channel.icon_id;
  let channelDisplayName = _channel.display_name;
  const reg = /public_|private_/;

  if (!channelIcon || !reg.test(channelIcon)) {
    channelIcon = __webpack_require__(410)(`./${_channel.type === 'O' ? 'public_00.png' : 'private_00.png'}`);
  } else {
    channelIcon = __webpack_require__(410)(`./${channelIcon}`);
  }

  if (_channel.type === constants["g" /* Constants */].DM_CHANNEL) {
    const teammate = Object(entities_users["getUser"])(state, _channel.teammate_id);

    if (teammate) {
      // channelTeammateId = teammate.id;
      // channelTeammateDeletedAt = teammate.delete_at;
      // channelTeammateUsername = teammate.username;
      // channelTeammateIsBot = teammate.is_bot;
      channelIcon = utils["K" /* imageURLForUser */]({
        id: teammate.id
      });
      channelDisplayName = teammate.nickname == "" ? teammate.first_name == "" ? teammate.username : teammate.first_name : teammate.nickname; //console.log("sssssss----state",state,"ownProps",ownProps,"member----",member,"channel----",channel,"teammate----",teammate,"teammateNameDisplay----",teammateNameDisplay,"channelDisplayName----",channelDisplayName)
    }
  }

  return [channelIcon, channelDisplayName];
}

function new_zoom_share_model_mapStateToProps(state) {
  // const getChannel = makeGetChannel();
  // const sidebarPrefs = getSidebarPreferences(state);
  // const lastUnreadChannel = state.views.channel.keepChannelIdAsUnread;
  // const orderedChannelIds = getOrderedChannelIds(
  //   state,
  //   lastUnreadChannel,
  //   sidebarPrefs.grouping,
  //   sidebarPrefs.sorting,
  //   sidebarPrefs.unreads_at_top === "true",
  //   sidebarPrefs.favorite_at_top === "true"
  // );
  let members = []; // Array.isArray(orderedChannelIds)
  //   && orderedChannelIds.map(item => members = [...members, ...item.items]);
  // members = members.map(channelId => {
  //   const _channel = getChannel(state, {id: channelId}) || {};
  //   const [channelIcon, channelDisplayName] = getChannelIcon(state, _channel);
  //   return {
  //     channelId,
  //     channelIcon,
  //     channelDisplayName,
  //     type: 'lately',
  //   }
  // });

  const currentChannel = Object(entities_channels["getCurrentChannel"])(state) || null; //const currentUserId = getCurrentUserId(state);

  const channelName = currentChannel ? currentChannel.display_name : '';
  const doGetProfilesInChannel = Object(entities_users["makeGetProfilesInChannel"])();
  const isMeeting = state.views.meeting.invitation.isMeeting || false; //const stats = getAllChannelStats(state)[ownProps.channel.id] || {};

  let user = currentChannel ? doGetProfilesInChannel(state, currentChannel.id, true) : [];
  const currentTeamId = Object(entities_teams["getCurrentTeamId"])(state); //getCurrentTeamId

  return {
    members,
    currentUser: Object(entities_users["getCurrentUser"])(state),
    channelName,
    currentChannel,
    isMeeting,
    currentTeamId,
    users: !user || user === undefined ? [] : user
  };
}

function new_zoom_share_model_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      setMyMeeting: meeting["l" /* setMyMeeting */],
      addInvitationList: meeting["a" /* addInvitationList */]
    }, dispatch)
  };
}

/* harmony default export */ var new_zoom_share_model = (Object(es["connect"])(new_zoom_share_model_mapStateToProps, new_zoom_share_model_mapDispatchToProps)(new_zoom_share_model_NewChannelModal));
// EXTERNAL MODULE: ./node_modules/core-js/index.js
var core_js = __webpack_require__(3014);

// CONCATENATED MODULE: ./components/icons/close_icon.jsx
function close_icon_extends() { close_icon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return close_icon_extends.apply(this, arguments); }

/* harmony default export */ var close_icon = (({
  fill = '#909090',
  ...rest
}) => React.createElement("svg", close_icon_extends({
  height: "9",
  viewBox: "0 0 9 9",
  width: "9",
  xmlns: "http://www.w3.org/2000/svg"
}, rest), React.createElement("path", {
  d: "m316.096194 801.596194-.000107 5.207 4.793.000107v1l-4.793-.000107.000107 4.793h-1l-.000107-4.793-5.207.000107v-1l5.207-.000107.000107-5.207z",
  fill: fill,
  transform: "matrix(.70710678 .70710678 -.70710678 .70710678 352.078517 -789.62076)"
})));
// CONCATENATED MODULE: ./components/create_post/reply_text.jsx



/* harmony default export */ var reply_text = (Object(react["forwardRef"])((props, ref) => {
  const {
    dispatch,
    channelMsgReply
  } = props;

  const hide = () => {
    dispatch({
      type: constants["b" /* ActionTypes */].CHANNEL_MESSAGE_REPLY,
      data: {
        isReply: false,
        msg: ''
      }
    });
  };

  Object(react["useImperativeHandle"])(ref, () => ({
    hide
  }));
  return channelMsgReply.isReply ? react_default.a.createElement("p", null, react_default.a.createElement("i", {
    onClick: hide
  }, react_default.a.createElement(close_icon, null)), react_default.a.createElement("span", null, channelMsgReply.msg)) : null;
})); // export default forwardRef((props, ref) => {
//   const { onReply } = props;
//   const [isDel, setDel] = useState(false);
//   const hide = () => {
//     setDel(true);
//     onReply({ isReply: false })
//   }
//   // useImperativeHandle(ref, () => ({
//   //   hide,
//   //   show() {
//   //     setDel(false);
//   //   }
//   // }))
//   return !isDel && (
//     <p>
//       <i onClick={hide}>xxx</i>
//       <span>test content.....</span>
//     </p>
//   )
// })
// CONCATENATED MODULE: ./components/create_post/create_post.jsx
function create_post_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

































const create_post_KeyCodes = constants["N" /* default */].KeyCodes; // Temporary fix for IE-11, see MM-13423

function trimRight(str) {
  if (String.prototype.trimRight) {
    return str.trimRight();
  }

  return str.replace(/\s*$/, '');
}

class create_post_CreatePost extends react_default.a.Component {
  constructor(props) {
    super(props);

    create_post_defineProperty(this, "setOrientationListeners", () => {
      if (window.screen.orientation && 'onchange' in window.screen.orientation) {
        window.screen.orientation.addEventListener('change', this.onOrientationChange);
      } else if ('onorientationchange' in window) {
        window.addEventListener('orientationchange', this.onOrientationChange);
      }
    });

    create_post_defineProperty(this, "removeOrientationListeners", () => {
      if (window.screen.orientation && 'onchange' in window.screen.orientation) {
        window.screen.orientation.removeEventListener('change', this.onOrientationChange);
      } else if ('onorientationchange' in window) {
        window.removeEventListener('orientationchange', this.onOrientationChange);
      }
    });

    create_post_defineProperty(this, "onOrientationChange", () => {
      if (!user_agent["k" /* isIosWeb */]()) {
        return;
      } //Hide keyboard on iOS when orientation changes


      const {
        orientation: prevOrientation
      } = this.state;
      const LANDSCAPE_ANGLE = 90;
      let orientation = 'portrait';

      if (window.orientation) {
        orientation = Math.abs(window.orientation) === LANDSCAPE_ANGLE ? 'landscape' : 'portrait';
      }

      if (window.screen.orientation) {
        orientation = window.screen.orientation.type.split('-')[0];
      }

      this.setState({
        orientation
      });

      if (prevOrientation && orientation !== prevOrientation && (document.activeElement || {}).id === 'post_textbox') {
        this.refs.textbox.getWrappedInstance().blur();
      }
    });

    create_post_defineProperty(this, "handlePostError", postError => {
      this.setState({
        postError
      });
    });

    create_post_defineProperty(this, "toggleEmojiPicker", () => {
      this.setState({
        showEmojiPicker: !this.state.showEmojiPicker
      });
    });

    create_post_defineProperty(this, "hideEmojiPicker", () => {
      this.setState({
        showEmojiPicker: false
      });
    });

    create_post_defineProperty(this, "doSubmit", async e => {
      const channelId = this.props.currentChannel.id;

      if (e) {
        e.preventDefault();
      }

      if (this.props.draft.uploadsInProgress.length > 0 || this.state.submitting) {
        return;
      }

      let message = this.state.message;
      let ignoreSlash = false;
      const serverError = this.state.serverError;

      if (serverError && Object(post_utils["j" /* isErrorInvalidSlashCommand */])(serverError) && serverError.submittedMessage === message) {
        message = serverError.submittedMessage;
        ignoreSlash = true;
      }

      const post = {};
      post.file_ids = [];
      post.message = message;

      if (post.message.trim().length === 0 && this.props.draft.fileInfos.length === 0) {
        return;
      }

      if (this.state.postError) {
        this.setState({
          errorClass: 'animation--highlight'
        });
        setTimeout(() => {
          this.setState({
            errorClass: null
          });
        }, constants["N" /* default */].ANIMATION_TIMEOUT);
        return;
      }

      this.props.actions.addMessageIntoHistory(this.state.message);
      this.setState({
        submitting: true,
        serverError: null
      });
      const isReaction = utils["a" /* REACTION_PATTERN */].exec(post.message);

      if (post.message.indexOf('/') === 0 && !ignoreSlash) {
        this.setState({
          message: '',
          postError: null,
          enableSendButton: false
        });
        let args = {};
        args.channel_id = channelId;
        args.team_id = this.props.currentTeamId;
        const hookResult = await this.props.actions.runSlashCommandWillBePostedHooks(post.message, args);

        if (hookResult.error) {
          this.setState({
            serverError: { ...hookResult.error,
              submittedMessage: post.message
            },
            message: post.message
          });
        } else if (!hookResult.data.message && !hookResult.data.args) {// do nothing with an empty return from a hook
        } else {
          post.message = hookResult.data.message;
          args = hookResult.data.args;
          const {
            error
          } = await this.props.actions.executeCommand(post.message, args);

          if (error) {
            if (error.sendMessage) {
              await this.sendMessage(post);
            } else {
              this.setState({
                serverError: { ...error,
                  submittedMessage: post.message
                },
                message: post.message
              });
            }
          }
        }
      } else if (isReaction && this.props.emojiMap.has(isReaction[2])) {
        this.sendReaction(isReaction);
        this.setState({
          message: ''
        });
      } else {
        const {
          error
        } = await this.sendMessage(post);

        if (!error) {
          this.setState({
            message: ''
          });
        }
      }

      this.setState({
        submitting: false,
        postError: null,
        enableSendButton: false
      });
      this.props.actions.setDraft(constants["F" /* StoragePrefixes */].DRAFT + channelId, null);
      this.draftsForChannel[channelId] = null;
      const fasterThanHumanWillClick = 150;
      const forceFocus = Date.now() - this.lastBlurAt < fasterThanHumanWillClick;
      this.focusTextbox(forceFocus);
    });

    create_post_defineProperty(this, "handleNotifyAllConfirmation", e => {
      this.hideNotifyAllModal();
      this.doSubmit(e);
    });

    create_post_defineProperty(this, "hideNotifyAllModal", () => {
      this.setState({
        showConfirmModal: false
      });
    });

    create_post_defineProperty(this, "showNotifyAllModal", () => {
      this.setState({
        showConfirmModal: true
      });
    });

    create_post_defineProperty(this, "getStatusFromSlashCommand", () => {
      const {
        message
      } = this.state;
      const tokens = message.split(' ');

      if (tokens.length > 0) {
        return tokens[0].substring(1);
      }

      return '';
    });

    create_post_defineProperty(this, "isStatusSlashCommand", command => {
      return command === 'online' || command === 'away' || command === 'dnd' || command === 'offline';
    });

    create_post_defineProperty(this, "getVideo", () => {
      Object(api_post["e" /* isCanMeet */])(this.props.currentChannel.id, this.props.currentUser.username).then(res => {
        if (!res) {
          if (this.props.isMeeting) {
            Object(api_post["m" /* meetingModal */])("您已有在进行的会议,请结束后再发起新会议");
          } else this.setState({
            showCreat: true
          });
        } else {
          Object(api_post["m" /* meetingModal */])("已有在进行的会议,请结束后再发起新会议");
        }
      });
    });

    create_post_defineProperty(this, "shareHandleClose", e => {
      this.setState({
        showCreat: false
      }); // if(e){
      //     this.setState({message:e,card_type:"5",showCreat:false},()=>{
      //         this.handleSubmit(null);
      //         this.setState({card_type:""})
      //     });
      // }else
      //     this.setState({showCreat:false})
    });

    create_post_defineProperty(this, "shareHandleSubmit", e => {
      //console.log("shareHandleSubmit",e)
      this.setState({
        showCreat: false
      });
    });

    create_post_defineProperty(this, "handleSubmit", async e => {
      // if (this.props.channelMsgReply.isReply) {
      //     const { channelId, rootId } = this.props.channelMsgReply;
      //     // 回复消息
      //     // "irhgijq1s7889c7iowmq5gj8wy"
      //     console.log(this.state, this.props.channelMsgReply, 222)
      //     this.props.actions.onSubmitReply(
      //         channelId,
      //         rootId,
      //         { message: this.state.message }
      //     );
      //     this.setState({message: ''});
      //     this.replyTextRef.current.hide();
      // } else {
      // }
      // 创建消息
      const {
        currentChannel: updateChannel,
        userIsOutOfOffice
      } = this.props;
      const currentMembersCount = this.props.currentChannelMembersCount;
      const notificationsToChannel = this.props.enableConfirmNotificationsToChannel;

      if (notificationsToChannel && currentMembersCount > constants["N" /* default */].NOTIFY_ALL_MEMBERS && Object(post_utils["c" /* containsAtChannel */])(this.state.message)) {
        if (this.props.isTimezoneEnabled) {
          const {
            data
          } = await this.props.actions.getChannelTimezones(this.props.currentChannel.id);

          if (data) {
            this.setState({
              channelTimezoneCount: data.length
            });
          } else {
            this.setState({
              channelTimezoneCount: 0
            });
          }
        }

        this.showNotifyAllModal();
        return;
      }

      const status = this.getStatusFromSlashCommand();

      if (userIsOutOfOffice && this.isStatusSlashCommand(status)) {
        const resetStatusModalData = {
          ModalId: constants["p" /* ModalIdentifiers */].RESET_STATUS,
          dialogType: reset_status_modal,
          dialogProps: {
            newStatus: status
          }
        }; // 取消上线提醒 2019926this.props.actions.openModal(resetStatusModalData);

        this.setState({
          message: ''
        });
        return;
      }

      if (trimRight(this.state.message) === '/header') {
        const editChannelHeaderModalData = {
          modalId: constants["p" /* ModalIdentifiers */].EDIT_CHANNEL_HEADER,
          dialogType: components_edit_channel_header_modal,
          dialogProps: {
            channel: updateChannel
          }
        };
        this.props.actions.openModal(editChannelHeaderModalData);
        this.setState({
          message: ''
        });
        return;
      }

      const isDirectOrGroup = updateChannel.type === constants["N" /* default */].DM_CHANNEL || updateChannel.type === constants["N" /* default */].GM_CHANNEL;

      if (!isDirectOrGroup && trimRight(this.state.message) === '/purpose') {
        const editChannelPurposeModalData = {
          modalId: constants["p" /* ModalIdentifiers */].EDIT_CHANNEL_PURPOSE,
          dialogType: edit_channel_purpose_modal,
          dialogProps: {
            channel: updateChannel
          }
        };
        this.props.actions.openModal(editChannelPurposeModalData);
        this.setState({
          message: ''
        });
        return;
      }

      if (!isDirectOrGroup && trimRight(this.state.message) === '/rename') {
        global_actions["i" /* showChannelNameUpdateModal */](updateChannel);
        this.setState({
          message: ''
        });
        return;
      }

      await this.doSubmit(e);
    });

    create_post_defineProperty(this, "sendMessage", async originalPost => {
      const {
        actions,
        currentChannel,
        currentUserId,
        draft
      } = this.props;
      let post = originalPost;
      post.channel_id = currentChannel.id;
      const time = utils["E" /* getTimestamp */]();
      const userId = currentUserId;
      post.pending_post_id = `${userId}:${time}`;
      post.user_id = userId;
      post.create_at = time;
      post.parent_id = this.state.parentId;
      post.card_type = this.state.card_type;
      post.metadata = {};
      const hookResult = await actions.runMessageWillBePostedHooks(post);

      if (hookResult.error) {
        this.setState({
          serverError: hookResult.error,
          submitting: false
        });
        return hookResult;
      }

      post = hookResult.data;

      if (this.props.channelMsgReply) {
        if (this.props.channelMsgReply.isReply) {
          post.parent_message = this.props.channelMsgReply.msg || '';
        }
      }

      if (this.props.channelMsgReply.isReply) {
        // 回复消息
        const {
          channelId,
          rootId
        } = this.props.channelMsgReply;
        post.root_id = rootId;
        post.parent_id = rootId;
        post.channel_id = channelId; // console.log(this.state, this.props.channelMsgReply, 222)
        // this.props.actions.onSubmitReply(
        //     channelId,
        //     rootId,
        //     { message: this.state.message }
        // );
        // this.setState({message: ''});

        this.replyTextRef.current.hide();
      }

      if (post.message) {
        post.create_at = utils["E" /* getTimestamp */]();
        await actions.onSubmitPost(post, []);
      }

      if (draft.fileInfos.length > 0) {
        post.message = ''; // console.log(draft.fileInfos.length)

        for (let i = 0; i < draft.fileInfos.length; i++) {
          // console.log(draft.fileInfos[i], 'file')
          post.pending_post_id = `${userId}:${v4_default()()}`;
          await actions.onSubmitPost(post, [draft.fileInfos[i]]);
        }
      }

      actions.scrollPostListToBottom();
      this.setState({
        submitting: false
      });
      return {
        data: true
      };
    });

    create_post_defineProperty(this, "focusTextbox", (keepFocus = false, isBlur = false) => {
      if (!isBlur) {
        if (this.refs.textbox && (keepFocus || !user_agent["m" /* isMobile */]())) {
          this.refs.textbox.getWrappedInstance().focus();
        }
      } else if (this.refs.textbox) {
        this.refs.textbox.getWrappedInstance().blur();
      }
    });

    create_post_defineProperty(this, "postMsgKeyPress", e => {
      const {
        ctrlSend,
        codeBlockOnCtrlEnter
      } = this.props;
      const {
        allowSending,
        withClosedCodeBlock,
        ignoreKeyPress,
        message
      } = Object(post_utils["m" /* postMessageOnKeyPress */])(e, this.state.message, ctrlSend, codeBlockOnCtrlEnter, Date.now(), this.lastChannelSwitchAt);

      if (ignoreKeyPress) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }

      if (allowSending) {
        e.persist();

        if (this.refs.textbox) {
          this.refs.textbox.getWrappedInstance().blur();
        }

        if (withClosedCodeBlock && message) {
          this.setState({
            message
          }, () => this.handleSubmit(e));
        } else {
          this.handleSubmit(e);
        }
      }

      this.emitTypingEvent();
    });

    create_post_defineProperty(this, "emitTypingEvent", () => {
      const channelId = this.props.currentChannel.id;
      global_actions["d" /* emitLocalUserTypingEvent */](channelId, '');
    });

    create_post_defineProperty(this, "handleChange", e => {
      const message = e.target.value;
      const channelId = this.props.currentChannel.id;
      const enableSendButton = this.handleEnableSendButton(message, this.props.draft.fileInfos);
      let serverError = this.state.serverError;

      if (Object(post_utils["j" /* isErrorInvalidSlashCommand */])(serverError)) {
        serverError = null;
      }

      this.setState({
        message,
        enableSendButton,
        serverError
      });
      const draft = { ...this.props.draft,
        message
      };
      this.props.actions.setDraft(constants["F" /* StoragePrefixes */].DRAFT + channelId, draft);
      this.draftsForChannel[channelId] = draft;
    });

    create_post_defineProperty(this, "pasteHandler", e => {
      if (!e.clipboardData || !e.clipboardData.items || e.target.id !== 'post_textbox') {
        return;
      }

      const table = getTable(e.clipboardData);

      if (!table) {
        return;
      }

      e.preventDefault();
      const message = formatMarkdownTableMessage(table, this.state.message.trim());
      this.setState({
        message
      });
    });

    create_post_defineProperty(this, "handleFileUploadChange", () => {
      this.focusTextbox();
    });

    create_post_defineProperty(this, "handleUploadStart", (clientIds, channelId) => {
      const uploadsInProgress = [...this.props.draft.uploadsInProgress, ...clientIds];
      const draft = { ...this.props.draft,
        uploadsInProgress
      };
      this.props.actions.setDraft(constants["F" /* StoragePrefixes */].DRAFT + channelId, draft);
      this.draftsForChannel[channelId] = draft; // this is a bit redundant with the code that sets focus when the file input is clicked,
      // but this also resets the focus after a drag and drop

      this.focusTextbox();
    });

    create_post_defineProperty(this, "handleUploadProgress", ({
      clientId,
      name,
      percent,
      type
    }) => {
      const uploadsProgressPercent = { ...this.state.uploadsProgressPercent,
        [clientId]: {
          percent,
          name,
          type
        }
      };
      this.setState({
        uploadsProgressPercent
      });
    });

    create_post_defineProperty(this, "handleFileUploadComplete", (fileInfos, clientIds, channelId) => {
      const draft = { ...this.draftsForChannel[channelId]
      }; // remove each finished file from uploads

      for (let i = 0; i < clientIds.length; i++) {
        if (draft.uploadsInProgress) {
          const index = draft.uploadsInProgress.indexOf(clientIds[i]);

          if (index !== -1) {
            draft.uploadsInProgress = draft.uploadsInProgress.filter((item, itemIndex) => index !== itemIndex);
          }
        }
      }

      if (draft.fileInfos) {
        draft.fileInfos = Object(utils_file_utils["sortFileInfos"])(draft.fileInfos.concat(fileInfos), this.props.locale);
      }

      this.draftsForChannel[channelId] = draft;
      this.props.actions.setDraft(constants["F" /* StoragePrefixes */].DRAFT + channelId, draft);
      const enableSendButton = this.handleEnableSendButton(this.state.message, draft.fileInfos);
      this.setState({
        enableSendButton
      });
    });

    create_post_defineProperty(this, "handleUploadError", (err, clientId, channelId) => {
      const draft = { ...this.draftsForChannel[channelId]
      };
      let serverError = err;

      if (typeof err === 'string') {
        serverError = new Error(err);
      }

      if (clientId !== -1 && draft.uploadsInProgress) {
        const index = draft.uploadsInProgress.indexOf(clientId);

        if (index !== -1) {
          const uploadsInProgress = draft.uploadsInProgress.filter((item, itemIndex) => index !== itemIndex);
          const modifiedDraft = { ...draft,
            uploadsInProgress
          };
          this.props.actions.setDraft(constants["F" /* StoragePrefixes */].DRAFT + channelId, modifiedDraft);
          this.draftsForChannel[channelId] = modifiedDraft;
        }
      }

      this.setState({
        serverError
      });
    });

    create_post_defineProperty(this, "removePreview", id => {
      let modifiedDraft = {};
      const draft = { ...this.props.draft
      };
      const channelId = this.props.currentChannel.id; // Clear previous errors

      this.setState({
        serverError: null
      }); // id can either be the id of an uploaded file or the client id of an in progress upload

      let index = draft.fileInfos.findIndex(info => info.id === id);

      if (index === -1) {
        index = draft.uploadsInProgress.indexOf(id);

        if (index !== -1) {
          const uploadsInProgress = draft.uploadsInProgress.filter((item, itemIndex) => index !== itemIndex);
          modifiedDraft = { ...draft,
            uploadsInProgress
          };

          if (this.refs.fileUpload && this.refs.fileUpload.getWrappedInstance()) {
            this.refs.fileUpload.getWrappedInstance().cancelUpload(id);
          }
        }
      } else {
        const fileInfos = draft.fileInfos.filter((item, itemIndex) => index !== itemIndex);
        modifiedDraft = { ...draft,
          fileInfos
        };
      }

      this.props.actions.setDraft(constants["F" /* StoragePrefixes */].DRAFT + channelId, modifiedDraft);
      this.draftsForChannel[channelId] = modifiedDraft;
      const enableSendButton = this.handleEnableSendButton(this.state.message, modifiedDraft.fileInfos);
      this.setState({
        enableSendButton
      });
      this.handleFileUploadChange();
    });

    create_post_defineProperty(this, "focusTextboxIfNecessary", e => {
      // Focus should go to the RHS when it is expanded
      if (this.props.rhsExpanded) {
        return;
      } // Bit of a hack to not steal focus from the channel switch modal if it's open
      // This is a special case as the channel switch modal does not enforce focus like
      // most modals do


      if (document.getElementsByClassName('channel-switch-modal').length) {
        return;
      }

      if (Object(post_utils["n" /* shouldFocusMainTextbox */])(e, document.activeElement)) {
        this.focusTextbox();
      }
    });

    create_post_defineProperty(this, "documentKeyHandler", e => {
      if ((e.ctrlKey || e.metaKey) && utils["V" /* isKeyPressed */](e, create_post_KeyCodes.FORWARD_SLASH)) {
        e.preventDefault();
        global_actions["n" /* toggleShortcutsModal */]();
        return;
      }

      this.focusTextboxIfNecessary(e);
    });

    create_post_defineProperty(this, "getFileCount", () => {
      const draft = this.props.draft;
      return draft.fileInfos.length + draft.uploadsInProgress.length;
    });

    create_post_defineProperty(this, "getFileUploadTarget", () => {
      if (this.refs.textbox) {
        return this.refs.textbox.getWrappedInstance();
      }

      return null;
    });

    create_post_defineProperty(this, "getCreatePostControls", () => {
      return this.refs.createPostControls;
    });

    create_post_defineProperty(this, "handleKeyDown", e => {
      const ctrlOrMetaKeyPressed = e.ctrlKey || e.metaKey;
      const messageIsEmpty = this.state.message.length === 0;
      const draftMessageIsEmpty = this.props.draft.message.length === 0;
      const ctrlEnterKeyCombo = (this.props.ctrlSend || this.props.codeBlockOnCtrlEnter) && utils["V" /* isKeyPressed */](e, create_post_KeyCodes.ENTER) && ctrlOrMetaKeyPressed;
      const upKeyOnly = !ctrlOrMetaKeyPressed && !e.altKey && !e.shiftKey && utils["V" /* isKeyPressed */](e, create_post_KeyCodes.UP);
      const shiftUpKeyCombo = !ctrlOrMetaKeyPressed && !e.altKey && e.shiftKey && utils["V" /* isKeyPressed */](e, create_post_KeyCodes.UP);
      const ctrlKeyCombo = ctrlOrMetaKeyPressed && !e.altKey && !e.shiftKey;

      if (ctrlEnterKeyCombo) {
        this.postMsgKeyPress(e);
      } else if (upKeyOnly && messageIsEmpty) {//this.editLastPost(e);
      } else if (shiftUpKeyCombo && messageIsEmpty) {
        this.replyToLastPost(e);
      } else if (ctrlKeyCombo && draftMessageIsEmpty && utils["V" /* isKeyPressed */](e, create_post_KeyCodes.UP)) {
        this.loadPrevMessage(e);
      } else if (ctrlKeyCombo && draftMessageIsEmpty && utils["V" /* isKeyPressed */](e, create_post_KeyCodes.DOWN)) {
        this.loadNextMessage(e);
      }
    });

    create_post_defineProperty(this, "editLastPost", e => {
      e.preventDefault();
      const lastPost = this.props.currentUsersLatestPost;

      if (!lastPost) {
        return;
      }

      let type;

      if (lastPost.root_id && lastPost.root_id.length > 0) {
        type = utils["gb" /* localizeMessage */]('create_post.comment', mattermost_redux_constants["Posts"].MESSAGE_TYPES.COMMENT);
      } else {
        type = utils["gb" /* localizeMessage */]('create_post.post', mattermost_redux_constants["Posts"].MESSAGE_TYPES.POST);
      }

      if (this.refs.textbox) {
        this.refs.textbox.getWrappedInstance().blur();
      }

      this.props.actions.setEditingPost(lastPost.id, this.props.commentCountForPost, 'post_textbox', type);
    });

    create_post_defineProperty(this, "replyToLastPost", e => {
      e.preventDefault();
      const latestReplyablePostId = this.props.latestReplyablePostId;
      const replyBox = document.getElementById('reply_textbox');

      if (replyBox) {
        replyBox.focus();
      }

      if (latestReplyablePostId) {
        this.props.actions.selectPostFromRightHandSideSearchByPostId(latestReplyablePostId);
      }
    });

    create_post_defineProperty(this, "loadPrevMessage", e => {
      e.preventDefault();
      this.props.actions.moveHistoryIndexBack(mattermost_redux_constants["Posts"].MESSAGE_TYPES.POST).then(() => this.fillMessageFromHistory());
    });

    create_post_defineProperty(this, "loadNextMessage", e => {
      e.preventDefault();
      this.props.actions.moveHistoryIndexForward(mattermost_redux_constants["Posts"].MESSAGE_TYPES.POST).then(() => this.fillMessageFromHistory());
    });

    create_post_defineProperty(this, "handleBlur", () => {
      this.lastBlurAt = Date.now();
    });

    create_post_defineProperty(this, "showPostDeletedModal", () => {
      this.setState({
        showPostDeletedModal: true
      });
    });

    create_post_defineProperty(this, "hidePostDeletedModal", () => {
      this.setState({
        showPostDeletedModal: false
      });
    });

    create_post_defineProperty(this, "handleEmojiClose", () => {
      this.setState({
        showEmojiPicker: false
      });
      this.focusTextbox();
    });

    create_post_defineProperty(this, "handleEmojiClick", emoji => {
      const emojiAlias = emoji.name || emoji.aliases[0];

      if (!emojiAlias) {
        //Oops.. There went something wrong
        return;
      }

      if (this.state.message === '') {
        this.setState({
          message: ':' + emojiAlias + ': '
        });
      } else {
        //check whether there is already a blank at the end of the current message
        const newMessage = /\s+$/.test(this.state.message) ? this.state.message + ':' + emojiAlias + ': ' : this.state.message + ' :' + emojiAlias + ': ';
        this.setState({
          message: newMessage
        });
      }

      this.setState({
        showEmojiPicker: false
      });
      this.focusTextbox();
    });

    create_post_defineProperty(this, "handleGifClick", gif => {
      if (this.state.message === '') {
        this.setState({
          message: gif
        });
      } else {
        const newMessage = /\s+$/.test(this.state.message) ? this.state.message + gif : this.state.message + ' ' + gif;
        this.setState({
          message: newMessage
        });
      }

      this.setState({
        showEmojiPicker: false
      });
      this.focusTextbox();
    });

    create_post_defineProperty(this, "handleHeightChange", (height, maxHeight) => {
      this.setState({
        renderScrollbar: height > maxHeight
      });
    });

    this.state = {
      message: this.props.draft.message,
      card_type: "",
      //卡片约定
      submitting: false,
      showPostDeletedModal: false,
      enableSendButton: false,
      showEmojiPicker: false,
      showConfirmModal: false,
      channelTimezoneCount: 0,
      uploadsProgressPercent: {},
      renderScrollbar: false,
      orientation: null,
      numUsers: this.props.users,
      userInit: false,
      show: false,
      showCreat: false //显示创建会议

    };
    this.lastBlurAt = 0;
    this.lastChannelSwitchAt = 0;
    this.draftsForChannel = {};
    this.initReply = true;
    this.replyTextRef = react_default.a.createRef();
  }

  UNSAFE_componentWillMount() {
    // eslint-disable-line camelcase
    const enableSendButton = this.handleEnableSendButton(this.state.message, this.props.draft.fileInfos);
    this.props.actions.clearDraftUploads(constants["F" /* StoragePrefixes */].DRAFT, (key, value) => {
      if (value) {
        return { ...value,
          uploadsInProgress: []
        };
      }

      return value;
    });
    this.onOrientationChange(); // wait to load these since they may have changed since the component was constructed (particularly in the case of skipping the tutorial)

    this.setState({
      enableSendButton
    });
  }

  componentDidMount() {
    this.focusTextbox();
    document.addEventListener('paste', this.pasteHandler);
    document.addEventListener('keydown', this.documentKeyHandler);
    this.setOrientationListeners();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (nextProps.currentChannel.id !== this.props.currentChannel.id) {
      const draft = nextProps.draft;
      this.setState({
        message: draft.message,
        submitting: false,
        serverError: null
      });
      this.replyTextRef.current.hide();
      this.props.actions.closeRightHandSide();
    }

    if (nextProps.channelMsgReply.msg !== this.props.channelMsgReply.msg) {
      this.initReply = true;
    }

    if (nextProps.channelMsgReply.isReply === false || this.props.channelMsgReply.isReply === false) {
      this.initReply = true;
    }

    if (nextProps.channelMsgReply.isReply && this.initReply) {
      this.focusTextbox();
      this.initReply = false;
    }
  }

  componentDidUpdate(prevProps) {
    if (prevProps.currentChannel.id !== this.props.currentChannel.id) {
      this.lastChannelSwitchAt = Date.now();
      this.focusTextbox();
    } // disable input when the post merger


    if (prevProps.hasCheckbox) {
      this.focusTextbox(null, true);
    }
  }

  componentWillUnmount() {
    document.removeEventListener('paste', this.pasteHandler);
    document.removeEventListener('keydown', this.documentKeyHandler);
    this.removeOrientationListeners();
  }

  sendReaction(isReaction) {
    const channelId = this.props.currentChannel.id;
    const action = isReaction[1];
    const emojiName = isReaction[2];
    const postId = this.props.latestReplyablePostId;

    if (postId && action === '+') {
      this.props.actions.addReaction(postId, emojiName);
    } else if (postId && action === '-') {
      this.props.actions.removeReaction(postId, emojiName);
    }

    this.props.actions.setDraft(constants["F" /* StoragePrefixes */].DRAFT + channelId, null);
    this.draftsForChannel[channelId] = null;
  }

  fillMessageFromHistory() {
    const lastMessage = this.props.messageInHistoryItem;

    if (lastMessage) {
      this.setState({
        message: lastMessage
      });
    }
  }

  createTutorialTip() {
    const screens = [];
    screens.push(react_default.a.createElement("div", null, react_default.a.createElement("h4", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "create_post.tutorialTip.title",
      defaultMessage: "Sending Messages"
    })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
      id: "create_post.tutorialTip1",
      defaultMessage: "Type here to write a message and press **Enter** to post it."
    })), react_default.a.createElement("p", null, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
      id: "create_post.tutorialTip2",
      defaultMessage: "Click the **Attachment** button to upload an image or a file."
    }))));
    return react_default.a.createElement(tutorial_tip, {
      id: "postTextboxTipMessage",
      placement: "top",
      screens: screens,
      overlayClass: "tip-overlay--chat",
      diagnosticsTag: "tutorial_tip_1_sending_messages"
    });
  }

  handleEnableSendButton(message, fileInfos) {
    return message.trim().length !== 0 || fileInfos.length !== 0;
  }

  //更新选择 listIndex分组id 分组下的人员角标 选择状态
  updateSetting(index, value, isClick = true) {
    // console.log("updateSettingupdateSettingupdateSettingupdateSetting")
    const numUsers = this.state.numUsers; //console.log("mmmmmm",index,value,isClick)

    const endValue = value.toString();

    if (!isClick && !this.state.userInit) {
      //console.log("mmmmmm111111",index,value,isClick,this.state.userInit)
      numUsers[index] = "false";
      this.setState({
        userInit: true
      });
    }

    if (isClick) {
      //console.log("mmmmmm22222",index,value,isClick,this.state.userInit)
      numUsers[index] = endValue;
    }

    setTimeout(() => {
      this.setState({
        numUsers
      });
    }, 0);
  }

  render() {
    const {
      currentChannel,
      currentChannelMembersCount,
      draft,
      fullWidthTextBox,
      showTutorialTip,
      readOnlyChannel
    } = this.props;
    const {
      formatMessage
    } = this.context.intl;
    const members = currentChannelMembersCount - 1;
    const {
      renderScrollbar
    } = this.state;
    const ariaLabelMessageInput = utils["gb" /* localizeMessage */]('accessibility.sections.centerFooter', 'message input complimentary region');
    const notifyAllTitle = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "notify_all.title.confirm",
      defaultMessage: "Confirm sending notifications to entire channel"
    });
    const notifyAllConfirm = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "notify_all.confirm",
      defaultMessage: "Confirm"
    });
    let notifyAllMessage = '';

    if (this.state.channelTimezoneCount && this.props.isTimezoneEnabled) {
      notifyAllMessage = react_default.a.createElement(formatted_markdown_message["b" /* default */], {
        id: "notify_all.question_timezone",
        defaultMessage: "By using @all or @channel you are about to send notifications to **{totalMembers} people** in **{timezones, number} {timezones, plural, one {timezone} other {timezones}}**. Are you sure you want to do this?",
        values: {
          totalMembers: members,
          timezones: this.state.channelTimezoneCount
        }
      });
    } else {
      notifyAllMessage = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "notify_all.question",
        defaultMessage: "By using @all or @channel you are about to send notifications to {totalMembers} people. Are you sure you want to do this?",
        values: {
          totalMembers: members
        }
      });
    }

    let serverError = null;

    if (this.state.serverError) {
      serverError = react_default.a.createElement(message_submit_error, {
        id: "postServerError",
        error: this.state.serverError,
        submittedMessage: this.state.serverError.submittedMessage,
        handleSubmit: this.handleSubmit
      });
    }

    let postError = null;

    if (this.state.postError) {
      const postErrorClass = 'post-error' + (this.state.errorClass ? ' ' + this.state.errorClass : '');
      postError = react_default.a.createElement("label", {
        className: postErrorClass
      }, this.state.postError);
    }

    let preview = null;

    if (!readOnlyChannel && (draft.fileInfos.length > 0 || draft.uploadsInProgress.length > 0)) {
      preview = react_default.a.createElement(file_preview_FilePreview, {
        fileInfos: draft.fileInfos,
        onRemove: this.removePreview,
        uploadsInProgress: draft.uploadsInProgress,
        uploadsProgressPercent: this.state.uploadsProgressPercent
      });
    }

    let postFooterClassName = 'post-create-footer';

    if (postError) {
      postFooterClassName += ' has-error';
    }

    let tutorialTip = null;

    if (showTutorialTip) {
      tutorialTip = this.createTutorialTip();
    }

    let centerClass = '';

    if (!fullWidthTextBox) {
      centerClass = 'center';
    }

    let sendButtonClass = 'send-button theme';

    if (!this.state.enableSendButton) {
      sendButtonClass += ' disabled';
    }

    let attachmentsDisabled = '';

    if (!this.props.canUploadFiles) {
      attachmentsDisabled = ' post-create--attachment-disabled';
    }

    let fileUpload;

    if (!readOnlyChannel) {
      fileUpload = react_default.a.createElement(file_upload, {
        ref: "fileUpload",
        fileCount: this.getFileCount(),
        getTarget: this.getFileUploadTarget,
        onFileUploadChange: this.handleFileUploadChange,
        onUploadStart: this.handleUploadStart,
        onFileUpload: this.handleFileUploadComplete,
        onUploadError: this.handleUploadError,
        onUploadProgress: this.handleUploadProgress,
        postType: "post"
      });
    }

    let emojiPicker = null;

    if (this.props.enableEmojiPicker && !readOnlyChannel) {
      emojiPicker = react_default.a.createElement("span", {
        role: "button",
        tabIndex: "0",
        "aria-label": formatMessage({
          id: 'create_post.open_emoji_picker',
          defaultMessage: 'Open emoji picker'
        }),
        className: "emoji-picker__container"
      }, react_default.a.createElement(emoji_picker_overlay_EmojiPickerOverlay, {
        show: this.state.showEmojiPicker,
        target: this.getCreatePostControls,
        onHide: this.hideEmojiPicker,
        onEmojiClose: this.handleEmojiClose,
        onEmojiClick: this.handleEmojiClick,
        onGifClick: this.handleGifClick,
        enableGifPicker: this.props.enableGifPicker,
        topOffset: -7
      }), react_default.a.createElement("div", null, react_default.a.createElement("i", {
        id: "emojiPickerButton",
        className: 'emoji-icon ' + (this.state.showEmojiPicker ? 'active' : ''),
        onClick: this.toggleEmojiPicker
      })));
    }

    let createMessage;

    if (readOnlyChannel) {
      createMessage = utils["gb" /* localizeMessage */]('create_post.read_only', 'This channel is read-only. Only members with permission can post here.');
    } else {
      createMessage = formatMessage({
        id: 'create_post.write',
        defaultMessage: 'Write to {channelDisplayName}'
      }, {
        channelDisplayName: currentChannel.display_name
      });
    }

    let scrollbarClass = '';

    if (renderScrollbar) {
      scrollbarClass = ' scroll';
    } // let contentList;
    // //console.log("cxcccccccccc",this.state.numUsers,this.props.users)
    // if (this.props.users.length > 0) {
    //     contentList = this.props.users.map((op,index) => {
    //         this.updateSetting(index, "false",false)
    //     return (
    //         <div key={"list" + index}>
    //             <div className="checkbox">
    //             <label>
    //                 <input
    //                 id="nameAtTopOption"
    //                 type="checkbox"
    //                 checked={this.state.numUsers[index] === "true"}
    //                 onChange={e =>
    //                     this.updateSetting(index, e.target.checked)
    //                 }
    //                 />
    //                 <div>{op.username}</div>
    //             </label>
    //             </div>
    //         </div>
    //     );
    // }, this);
    // } else {
    //     contentList = <div className="no-uaList">没有成员!</div>;
    // }
    // console.log(this.props.actions.runMessageWillBePostedHooks(), '---9');


    return react_default.a.createElement("div", null, react_default.a.createElement("form", {
      id: "create_post",
      ref: "topDiv",
      className: centerClass,
      onSubmit: this.handleSubmit
    }, react_default.a.createElement("div", {
      className: 'post-create' + attachmentsDisabled + scrollbarClass
    }, react_default.a.createElement("div", {
      className: "post-create-body"
    }, react_default.a.createElement("div", {
      className: "post__create__content"
    }, react_default.a.createElement(reply_text, {
      ref: this.replyTextRef,
      dispatch: this.props.dispatch,
      channelMsgReply: this.props.channelMsgReply
    }), react_default.a.createElement("div", {
      id: "centerChannelFooter",
      "aria-label": ariaLabelMessageInput,
      tabIndex: "-1",
      className: "post-body__cell"
    }, react_default.a.createElement("span", {
      className: "post-icon"
    }), react_default.a.createElement(components_textbox, {
      onChange: this.handleChange,
      onKeyPress: this.postMsgKeyPress,
      onKeyDown: this.handleKeyDown,
      onComposition: this.emitTypingEvent,
      onHeightChange: this.handleHeightChange,
      handlePostError: this.handlePostError,
      value: readOnlyChannel ? '' : this.state.message,
      onBlur: this.handleBlur,
      emojiEnabled: this.props.enableEmojiPicker,
      createMessage: createMessage,
      channelId: currentChannel.id,
      id: "post_textbox",
      ref: "textbox",
      disabled: readOnlyChannel,
      characterLimit: this.props.maxPostSize,
      badConnection: this.props.badConnection,
      listenForMentionKeyClick: true
    }), react_default.a.createElement("span", {
      ref: "createPostControls",
      className: "post-body__actions"
    }, fileUpload, react_default.a.createElement("span", {
      onClick: this.getVideo,
      className: 'phone-icon'
    }), emojiPicker, react_default.a.createElement("a", {
      role: "button",
      tabIndex: "0",
      "aria-label": formatMessage({
        id: 'create_post.send_message',
        defaultMessage: 'Send a message'
      }),
      className: sendButtonClass,
      onClick: this.handleSubmit
    }, react_default.a.createElement("i", {
      className: "fa fa-paper-plane",
      title: formatMessage({
        id: 'create_post.icon',
        defaultMessage: 'Send Post Icon'
      })
    })))), tutorialTip)), react_default.a.createElement("div", {
      id: "postCreateFooter",
      className: postFooterClassName
    }, react_default.a.createElement(msg_typing, {
      channelId: currentChannel.id,
      postId: ""
    }), postError, preview, serverError)), react_default.a.createElement(post_deleted_modal_PostDeletedModal, {
      show: this.state.showPostDeletedModal,
      onHide: this.hidePostDeletedModal
    }), react_default.a.createElement(confirm_modal["a" /* default */], {
      title: notifyAllTitle,
      message: notifyAllMessage,
      confirmButtonText: notifyAllConfirm,
      show: this.state.showConfirmModal,
      onConfirm: this.handleNotifyAllConfirmation,
      onCancel: this.hideNotifyAllModal
    })), react_default.a.createElement(new_zoom_share_model, {
      show: this.state.showCreat,
      handleSubmit: this.shareHandleSubmit,
      handleClose: this.shareHandleClose,
      channel_id: this.props.currentChannel.id,
      type: 0
    }));
  }

}

create_post_defineProperty(create_post_CreatePost, "propTypes", {
  isMeeting: prop_types_default.a.bool,
  users: prop_types_default.a.array,
  currentUser: prop_types_default.a.object,

  /**
   *  ref passed from channelView for EmojiPickerOverlay
   */
  getChannelView: prop_types_default.a.func,

  /**
   *  Data used in notifying user for @all and @channel
   */
  currentChannelMembersCount: prop_types_default.a.number,

  /**
   *  Data used in multiple places of the component
   */
  currentChannel: prop_types_default.a.object,

  /**
   *  Data used in executing commands for channel actions passed down to client4 function
   */
  currentTeamId: prop_types_default.a.string,

  /**
   *  Data used for posting message
   */
  currentUserId: prop_types_default.a.string,

  /**
   * Force message submission on CTRL/CMD + ENTER
   */
  codeBlockOnCtrlEnter: prop_types_default.a.bool,

  /**
   *  Flag used for handling submit
   */
  ctrlSend: prop_types_default.a.bool,

  /**
   *  Flag used for adding a class center to Postbox based on user pref
   */
  fullWidthTextBox: prop_types_default.a.bool,

  /**
   *  Data used for deciding if tutorial tip is to be shown
   */
  showTutorialTip: prop_types_default.a.bool.isRequired,

  /**
   *  Data used populating message state when triggered by shortcuts
   */
  messageInHistoryItem: prop_types_default.a.string,

  /**
   *  Data used for populating message state from previous draft
   */
  draft: prop_types_default.a.shape({
    message: prop_types_default.a.string.isRequired,
    uploadsInProgress: prop_types_default.a.array.isRequired,
    fileInfos: prop_types_default.a.array.isRequired
  }).isRequired,

  /**
   *  Data used dispatching handleViewAction
   */
  commentCountForPost: prop_types_default.a.number,

  /**
   *  Data used dispatching handleViewAction ex: edit post
   */
  latestReplyablePostId: prop_types_default.a.string,
  locale: prop_types_default.a.string.isRequired,

  /**
   *  Data used for calling edit of post
   */
  currentUsersLatestPost: prop_types_default.a.object,

  /**
   *  Set if the channel is read only.
   */
  readOnlyChannel: prop_types_default.a.bool,

  /**
   * Whether or not file upload is allowed.
   */
  canUploadFiles: prop_types_default.a.bool.isRequired,

  /**
   * Whether to show the emoji picker.
   */
  enableEmojiPicker: prop_types_default.a.bool.isRequired,

  /**
   * Whether to show the gif picker.
   */
  enableGifPicker: prop_types_default.a.bool.isRequired,

  /**
   * Whether to check with the user before notifying the whole channel.
   */
  enableConfirmNotificationsToChannel: prop_types_default.a.bool.isRequired,

  /**
   * The maximum length of a post
   */
  maxPostSize: prop_types_default.a.number.isRequired,
  emojiMap: prop_types_default.a.object.isRequired,

  /**
   * If our connection is bad
   */
  badConnection: prop_types_default.a.bool.isRequired,

  /**
   * Whether to display a confirmation modal to reset status.
   */
  userIsOutOfOffice: prop_types_default.a.bool.isRequired,
  rhsExpanded: prop_types_default.a.bool.isRequired,

  /**
   * To check if the timezones are enable on the server.
   */
  isTimezoneEnabled: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    /**
     *  func called after message submit.
     */
    addMessageIntoHistory: prop_types_default.a.func.isRequired,

    /**
     *  func called for navigation through messages by Up arrow
     */
    moveHistoryIndexBack: prop_types_default.a.func.isRequired,

    /**
     *  func called for navigation through messages by Down arrow
     */
    moveHistoryIndexForward: prop_types_default.a.func.isRequired,

    /**
     *  func called for adding a reaction
     */
    addReaction: prop_types_default.a.func.isRequired,

    /**
     *  func called for posting message
     */
    onSubmitPost: prop_types_default.a.func.isRequired,

    /**
     *  func called for removing a reaction
     */
    removeReaction: prop_types_default.a.func.isRequired,

    /**
     *  func called on load of component to clear drafts
     */
    clearDraftUploads: prop_types_default.a.func.isRequired,

    /**
     * hooks called before a message is sent to the server
     */
    runMessageWillBePostedHooks: prop_types_default.a.func.isRequired,

    /**
     * hooks called before a slash command is sent to the server
     */
    runSlashCommandWillBePostedHooks: prop_types_default.a.func.isRequired,

    /**
     *  func called for setting drafts
     */
    setDraft: prop_types_default.a.func.isRequired,

    /**
     *  func called for editing posts
     */
    setEditingPost: prop_types_default.a.func.isRequired,

    /**
     *  func called for opening the last replayable post in the RHS
     */
    selectPostFromRightHandSideSearchByPostId: prop_types_default.a.func.isRequired,

    /**
     * Function to open a modal
     */
    openModal: prop_types_default.a.func.isRequired,
    executeCommand: prop_types_default.a.func.isRequired,

    /**
     * Function to get the users timezones in the channel
     */
    getChannelTimezones: prop_types_default.a.func.isRequired,
    scrollPostListToBottom: prop_types_default.a.func.isRequired
  }).isRequired
});

create_post_defineProperty(create_post_CreatePost, "contextTypes", {
  intl: index_es["i" /* intlShape */].isRequired
});

create_post_defineProperty(create_post_CreatePost, "defaultProps", {
  latestReplyablePostId: ''
});
// CONCATENATED MODULE: ./components/create_post/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






















 // import { submitPost as onSubmitReply } from "actions/views/create_comment";







function create_post_makeMapStateToProps() {
  const getCommentCountForPost = Object(entities_posts["makeGetCommentCountForPost"])();
  const getMessageInHistoryItem = Object(entities_posts["makeGetMessageInHistoryItem"])(mattermost_redux_constants["Posts"].MESSAGE_TYPES.POST);
  return (state, ownProps) => {
    const config = Object(general["getConfig"])(state);
    const currentChannel = Object(entities_channels["getCurrentChannel"])(state) || {};
    const draft = Object(selectors_rhs["k" /* getPostDraft */])(state, constants["F" /* StoragePrefixes */].DRAFT, currentChannel.id);
    const recentPostIdInChannel = Object(entities_posts["getMostRecentPostIdInChannel"])(state, currentChannel.id);
    const post = Object(entities_posts["getPost"])(state, recentPostIdInChannel);
    const latestReplyablePostId = Object(entities_posts["getLatestReplyablePostId"])(state);
    const currentChannelMembersCount = Object(entities_channels["getCurrentChannelStats"])(state) ? Object(entities_channels["getCurrentChannelStats"])(state).member_count : 1;
    const enableTutorial = config.EnableTutorial === "true";
    const tutorialStep = Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, Object(entities_users["getCurrentUserId"])(state), constants["H" /* TutorialSteps */].FINISHED);
    const enableEmojiPicker = config.EnableEmojiPicker === "true";
    const enableGifPicker = config.EnableGifPicker === "true";
    const enableConfirmNotificationsToChannel = config.EnableConfirmNotificationsToChannel === "true";
    const currentUserId = Object(entities_users["getCurrentUserId"])(state);
    const userIsOutOfOffice = Object(entities_users["getStatusForUserId"])(state, currentUserId) === constants["L" /* UserStatuses */].OUT_OF_OFFICE;
    const badConnection = connectionErrorCount(state) > 1;
    const isTimezoneEnabled = config.ExperimentalTimezone === "true";

    const users = (() => {
      const doGetProfilesInChannel = Object(entities_users["makeGetProfilesInChannel"])();
      const users = doGetProfilesInChannel(state, currentChannel.id, true);
      return users;
    })();

    const isMeeting = state.views.meeting.invitation.isMeeting || false; //是否正在会议中

    return {
      isMeeting,
      users,
      currentTeamId: Object(entities_teams["getCurrentTeamId"])(state),
      currentChannel,
      currentChannelMembersCount,
      currentUserId,
      currentUser: Object(entities_users["getCurrentUser"])(state),
      codeBlockOnCtrlEnter: Object(entities_preferences["getBool"])(state, mattermost_redux_constants["Preferences"].CATEGORY_ADVANCED_SETTINGS, "code_block_ctrl_enter", true),
      ctrlSend: Object(entities_preferences["getBool"])(state, constants["w" /* Preferences */].CATEGORY_ADVANCED_SETTINGS, "send_on_ctrl_enter"),
      fullWidthTextBox: Object(entities_preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_DISPLAY_SETTINGS, constants["w" /* Preferences */].CHANNEL_DISPLAY_MODE, constants["w" /* Preferences */].CHANNEL_DISPLAY_MODE_DEFAULT) === constants["w" /* Preferences */].CHANNEL_DISPLAY_MODE_FULL_SCREEN,
      showTutorialTip: enableTutorial && tutorialStep === constants["H" /* TutorialSteps */].POST_POPOVER,
      messageInHistoryItem: getMessageInHistoryItem(state),
      draft,
      commentCountForPost: getCommentCountForPost(state, {
        post
      }),
      latestReplyablePostId,
      locale: Object(selectors_i18n["a" /* getCurrentLocale */])(state),
      currentUsersLatestPost: Object(entities_posts["getCurrentUsersLatestPost"])(state),
      readOnlyChannel: ownProps.readOnlyChannel || !Object(entities_users["isCurrentUserSystemAdmin"])(state) && config.ExperimentalTownSquareIsReadOnly === "true" && currentChannel.name === constants["g" /* Constants */].DEFAULT_CHANNEL,
      canUploadFiles: Object(file_utils["d" /* canUploadFiles */])(config),
      enableEmojiPicker,
      enableGifPicker,
      enableConfirmNotificationsToChannel,
      maxPostSize: parseInt(config.MaxPostSize, 10) || constants["g" /* Constants */].DEFAULT_CHARACTER_LIMIT,
      userIsOutOfOffice,
      rhsExpanded: Object(selectors_rhs["a" /* getIsRhsExpanded */])(state),
      emojiMap: Object(selectors_emojis["a" /* getEmojiMap */])(state),
      badConnection,
      isTimezoneEnabled,
      channelMsgReply: state.views.channel.channelMsgReply
    };
  };
}

function onSubmitPost(post, fileInfos) {
  return dispatch => {
    dispatch(Object(post_actions["c" /* createPost */])(post, fileInfos));
  };
}

function create_post_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      addMessageIntoHistory: actions_posts["addMessageIntoHistory"],
      onSubmitPost,
      // onSubmitReply,
      moveHistoryIndexBack: actions_posts["moveHistoryIndexBack"],
      moveHistoryIndexForward: actions_posts["moveHistoryIndexForward"],
      addReaction: post_actions["b" /* addReaction */],
      removeReaction: actions_posts["removeReaction"],
      setDraft: storage["e" /* setGlobalItem */],
      clearDraftUploads: storage["a" /* actionOnGlobalItemsWithPrefix */],
      selectPostFromRightHandSideSearchByPostId: rhs["k" /* selectPostFromRightHandSideSearchByPostId */],
      setEditingPost: post_actions["n" /* setEditingPost */],
      openModal: modals["b" /* openModal */],
      executeCommand: executeCommand,
      getChannelTimezones: actions_channels["getChannelTimezones"],
      runMessageWillBePostedHooks: runMessageWillBePostedHooks,
      runSlashCommandWillBePostedHooks: runSlashCommandWillBePostedHooks,
      scrollPostListToBottom: views_channel["i" /* scrollPostListToBottom */],
      closeRightHandSide: rhs["b" /* closeRightHandSide */]
    }, dispatch),
    dispatch
  };
}

/* harmony default export */ var create_post = (Object(es["connect"])(create_post_makeMapStateToProps, create_post_mapDispatchToProps)(Object(react_router["f" /* withRouter */])(create_post_CreatePost)));
// EXTERNAL MODULE: ./images/appIcons.png
var appIcons = __webpack_require__(3196);
var appIcons_default = /*#__PURE__*/__webpack_require__.n(appIcons);

// CONCATENATED MODULE: ./components/tutorial/tutorial_intro_screens/tutorial_intro_screens.jsx
function tutorial_intro_screens_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const NUM_SCREENS = 3;
class tutorial_intro_screens_TutorialIntroScreens extends react_default.a.Component {
  constructor(props) {
    super(props);

    tutorial_intro_screens_defineProperty(this, "handleNext", () => {
      switch (this.state.currentScreen) {
        case 0:
          Object(diagnostics_actions["d" /* trackEvent */])('tutorial', 'tutorial_screen_1_welcome_to_mattermost_next');
          break;

        case 1:
          Object(diagnostics_actions["d" /* trackEvent */])('tutorial', 'tutorial_screen_2_how_mattermost_works_next');
          break;

        case 2:
          Object(diagnostics_actions["d" /* trackEvent */])('tutorial', 'tutorial_screen_3_youre_all_set_next');
          break;
      }

      if (this.state.currentScreen < 2) {
        this.setState({
          currentScreen: this.state.currentScreen + 1
        });
        return;
      }

      const {
        currentUserId
      } = this.props;
      const preferences = [{
        user_id: currentUserId,
        category: constants["w" /* Preferences */].TUTORIAL_STEP,
        name: currentUserId,
        value: (this.props.step + 1).toString()
      }];
      this.props.actions.savePreferences(currentUserId, preferences);
    });

    tutorial_intro_screens_defineProperty(this, "skipTutorial", e => {
      e.preventDefault();

      switch (this.state.currentScreen) {
        case 0:
          Object(diagnostics_actions["d" /* trackEvent */])('tutorial', 'tutorial_screen_1_welcome_to_mattermost_skip');
          break;

        case 1:
          Object(diagnostics_actions["d" /* trackEvent */])('tutorial', 'tutorial_screen_2_how_mattermost_works_skip');
          break;

        case 2:
          Object(diagnostics_actions["d" /* trackEvent */])('tutorial', 'tutorial_screen_3_youre_all_set_skip');
          break;
      }

      const {
        currentUserId
      } = this.props;
      const preferences = [{
        user_id: currentUserId,
        category: constants["w" /* Preferences */].TUTORIAL_STEP,
        name: currentUserId,
        value: constants["g" /* Constants */].TutorialSteps.FINISHED.toString()
      }];
      this.props.actions.savePreferences(currentUserId, preferences);
    });

    tutorial_intro_screens_defineProperty(this, "createScreen", () => {
      switch (this.state.currentScreen) {
        case 0:
          return this.createScreenOne();

        case 1:
          return this.createScreenTwo();

        case 2:
          return this.createScreenThree();
      }

      return null;
    });

    tutorial_intro_screens_defineProperty(this, "handleCircleClick", (e, screen) => {
      e.preventDefault();
      this.setState({
        currentScreen: screen
      });
    });

    tutorial_intro_screens_defineProperty(this, "createCircles", () => {
      const circles = [];

      for (let i = 0; i < NUM_SCREENS; i++) {
        let className = 'circle';

        if (i === this.state.currentScreen) {
          className += ' active';
        }

        circles.push(react_default.a.createElement("a", {
          id: 'tutorialIntroCircle' + i,
          href: "#",
          key: 'circle' + i,
          className: className,
          "data-screen": i,
          onClick: e => this.handleCircleClick(e, i)
        }));
      }

      return react_default.a.createElement("div", {
        className: "tutorial__circles"
      }, circles);
    });

    this.state = {
      currentScreen: 0
    };
  }

  createScreenOne() {
    const circles = this.createCircles();
    return react_default.a.createElement("div", {
      id: "tutorialIntroOne"
    }, react_default.a.createElement("h3", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.screenOne.title1",
      defaultMessage: "Welcome to:"
    })), react_default.a.createElement("h1", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.screenOne.title2",
      defaultMessage: "Aboutone"
    })), react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.screenOne.body1",
      defaultMessage: "Your team communication all in one place, instantly searchable and available anywhere."
    })), react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.screenOne.body2",
      defaultMessage: "Keep your team connected to help them achieve what matters most."
    })), circles);
  }

  createScreenTwo() {
    const circles = this.createCircles();
    let appDownloadLink = null;
    let appDownloadImage = null;

    if (this.props.appDownloadLink) {
      const link = Object(utils_url["g" /* useSafeUrl */])(this.props.appDownloadLink); // not using a FormattedHTMLMessage here since appDownloadLink is configurable and could be used
      // to inject HTML if we're not careful

      appDownloadLink = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "tutorial_intro.mobileApps",
        defaultMessage: "Install the apps for {link} for easy access and notifications on the go.",
        values: {
          link: react_default.a.createElement("a", {
            id: "appDownloadLink",
            href: link,
            target: "_blank",
            rel: "noopener noreferrer"
          }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
            id: "tutorial_intro.mobileAppsLinkText",
            defaultMessage: "PC, Mac, iOS and Android"
          }))
        }
      });
      appDownloadImage = react_default.a.createElement("a", {
        id: "appDownloadImage",
        href: link,
        target: "_blank",
        rel: "noopener noreferrer"
      }, react_default.a.createElement("img", {
        alt: 'tutorial icons',
        className: "tutorial__app-icons",
        src: appIcons_default.a
      }));
    }

    return react_default.a.createElement("div", {
      id: "tutorialIntroTwo"
    }, react_default.a.createElement("h3", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.screenTwo.title",
      defaultMessage: "How Mattermost works:"
    })), react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.screenTwo.body1",
      defaultMessage: "Communication happens in public discussion channels, private channels and direct messages."
    })), react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.screenTwo.body2",
      defaultMessage: "Everything is archived and searchable from any web-enabled desktop, laptop or phone."
    })), appDownloadLink, appDownloadImage, circles);
  }

  createScreenThree() {
    let inviteModalLink;
    let inviteText;
    const {
      teamType
    } = this.props;
    const {
      formatMessage
    } = this.context.intl;

    if (!this.props.isLicensed || !this.props.restrictTeamInvite) {
      if (teamType === constants["g" /* Constants */].INVITE_TEAM) {
        const inviteMessage = formatMessage({
          id: 'tutorial_intro.invite',
          defaultMessage: 'Invite teammates'
        });
        inviteModalLink = react_default.a.createElement(toggle_modal_button_redux["a" /* default */], {
          accessibilityLabel: inviteMessage,
          id: "tutorialIntroInvite",
          className: "intro-links color--link style--none",
          modalId: constants["p" /* ModalIdentifiers */].EMAIL_INVITE,
          dialogType: components_invite_member_modal,
          dialogProps: {}
        }, inviteMessage);
      } else {
        inviteModalLink = react_default.a.createElement("button", {
          id: "tutorialIntroInvite",
          className: "intro-links color--link style--none",
          onClick: global_actions["l" /* showGetTeamInviteLinkModal */]
        }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
          id: "tutorial_intro.teamInvite",
          defaultMessage: "Invite teammates"
        }));
      }

      inviteText = react_default.a.createElement("p", null, inviteModalLink, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "tutorial_intro.whenReady",
        defaultMessage: ' when you\'re ready.'
      }));
    }

    const circles = this.createCircles();
    let supportInfo = null;

    if (this.props.supportEmail) {
      supportInfo = react_default.a.createElement("p", {
        id: "supportInfo"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "tutorial_intro.support",
        defaultMessage: "Need anything, just email us at "
      }), react_default.a.createElement("a", {
        href: 'mailto:' + this.props.supportEmail,
        target: "_blank",
        rel: "noopener noreferrer"
      }, this.props.supportEmail), '.');
    }

    return react_default.a.createElement("div", {
      id: "tutorialIntroThree"
    }, react_default.a.createElement("h3", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.allSet",
      defaultMessage: 'You\'re all set'
    })), inviteText, supportInfo, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.end",
      defaultMessage: "Click \"Next\" to enter {channel}. This is the first channel teammates see when they sign up. Use it for posting updates everyone needs to know.",
      values: {
        channel: this.props.townSquareDisplayName
      }
    }), circles);
  }

  render() {
    const screen = this.createScreen();
    return react_default.a.createElement("div", {
      className: "tutorial-steps__container"
    }, react_default.a.createElement("div", {
      id: "tutorialIntroContent",
      className: "tutorial__content"
    }, react_default.a.createElement("div", {
      className: "tutorial__steps"
    }, screen, react_default.a.createElement("div", {
      className: "tutorial__footer"
    }, react_default.a.createElement("button", {
      id: "tutorialNextButton",
      className: "btn btn-primary",
      tabIndex: "1",
      onClick: this.handleNext
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.next",
      defaultMessage: "Next"
    })), react_default.a.createElement("a", {
      id: "tutorialSkipLink",
      className: "tutorial-skip",
      href: "#",
      onClick: this.skipTutorial
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "tutorial_intro.skip",
      defaultMessage: "Skip tutorial"
    }))))));
  }

}

tutorial_intro_screens_defineProperty(tutorial_intro_screens_TutorialIntroScreens, "propTypes", {
  currentUserId: prop_types_default.a.string.isRequired,
  teamType: prop_types_default.a.string,
  step: prop_types_default.a.number,
  townSquareDisplayName: prop_types_default.a.string.isRequired,
  appDownloadLink: prop_types_default.a.string,
  isLicensed: prop_types_default.a.bool.isRequired,
  restrictTeamInvite: prop_types_default.a.bool.isRequired,
  supportEmail: prop_types_default.a.string.isRequired,
  actions: prop_types_default.a.shape({
    savePreferences: prop_types_default.a.func.isRequired
  }).isRequired
});

tutorial_intro_screens_defineProperty(tutorial_intro_screens_TutorialIntroScreens, "contextTypes", {
  intl: index_es["i" /* intlShape */].isRequired
});
// CONCATENATED MODULE: ./components/tutorial/tutorial_intro_screens/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









function tutorial_intro_screens_mapStateToProps(state) {
  const currentUserId = Object(entities_users["getCurrentUserId"])(state);
  const team = Object(entities_teams["getCurrentTeam"])(state) || {};
  return {
    currentUserId,
    teamType: team.type,
    step: Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, currentUserId, 0)
  };
}

function tutorial_intro_screens_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      savePreferences: actions_preferences["savePreferences"]
    }, dispatch)
  };
}

/* harmony default export */ var tutorial_intro_screens = (Object(es["connect"])(tutorial_intro_screens_mapStateToProps, tutorial_intro_screens_mapDispatchToProps)(tutorial_intro_screens_TutorialIntroScreens));
// CONCATENATED MODULE: ./components/tutorial/tutorial_view.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class tutorial_view_TutorialView extends react_default.a.Component {
  componentDidMount() {
    if (this.props.isRoot) {
      jquery_default()('body').addClass('app__body');
    }
  }

  componentWillUnmount() {
    if (this.props.isRoot) {
      jquery_default()('body').removeClass('app__body');
    }
  }

  render() {
    return react_default.a.createElement("div", {
      id: "app-content",
      className: "app__content"
    }, react_default.a.createElement(tutorial_intro_screens, {
      townSquareDisplayName: this.props.townSquareDisplayName,
      appDownloadLink: this.props.appDownloadLink,
      isLicensed: this.props.isLicensed,
      restrictTeamInvite: this.props.restrictTeamInvite,
      supportEmail: this.props.supportEmail
    }));
  }

}
tutorial_view_TutorialView.propTypes = {
  isRoot: prop_types_default.a.bool,
  townSquareDisplayName: prop_types_default.a.string.isRequired,
  appDownloadLink: prop_types_default.a.string,
  isLicensed: prop_types_default.a.bool.isRequired,
  restrictTeamInvite: prop_types_default.a.bool.isRequired,
  supportEmail: prop_types_default.a.string.isRequired
};
tutorial_view_TutorialView.defaultProps = {
  isRoot: true
};
// CONCATENATED MODULE: ./components/tutorial/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









function tutorial_mapStateToProps(state) {
  const license = Object(general["getLicense"])(state);
  const config = Object(general["getConfig"])(state);
  const team = Object(entities_teams["getCurrentTeam"])(state);
  const teamChannels = Object(entities_channels["getChannelsNameMapInCurrentTeam"])(state);
  const townSquare = teamChannels[constants["N" /* default */].DEFAULT_CHANNEL];
  const townSquareDisplayName = townSquare ? townSquare.display_name : constants["N" /* default */].DEFAULT_CHANNEL_UI_NAME;
  const appDownloadLink = config.AppDownloadLink;
  const isLicensed = license.IsLicensed === 'true';
  const restrictTeamInvite = !Object(roles["haveITeamPermission"])(state, {
    team: team.id,
    permission: mattermost_redux_constants["Permissions"].INVITE_USER
  });
  const supportEmail = config.SupportEmail;
  return {
    townSquareDisplayName,
    appDownloadLink,
    isLicensed,
    restrictTeamInvite,
    supportEmail
  };
}

/* harmony default export */ var tutorial = (Object(es["connect"])(tutorial_mapStateToProps)(tutorial_view_TutorialView));
// EXTERNAL MODULE: ./images/share_png@2x.png
var share_png_2x = __webpack_require__(1869);
var share_png_2x_default = /*#__PURE__*/__webpack_require__.n(share_png_2x);

// EXTERNAL MODULE: ./components/select_member/index.js + 2 modules
var select_member = __webpack_require__(2260);

// CONCATENATED MODULE: ./components/icons/collect_btn.jsx
function collect_btn_extends() { collect_btn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return collect_btn_extends.apply(this, arguments); }

/* harmony default export */ var collect_btn = (({
  fill = '#343434',
  ...rest
}) => React.createElement("svg", collect_btn_extends({
  height: "46",
  viewBox: "0 0 46 46",
  width: "46",
  xmlns: "http://www.w3.org/2000/svg"
}, rest), React.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React.createElement("circle", {
  cx: "23",
  cy: "23",
  fill: "#f5f5f5",
  r: "23"
}), React.createElement("path", {
  className: "aoicon",
  d: "m5.75620821 15.6031827 3.26241021-1.3206474.73046535-.2952102.73046533.2952102 3.2625185 1.319521-.0971542-3.6080713-.0196474-.7145437.4476025-.5569525 2.0917724-2.60709044-3.3657814-1.01945851-.6505325-.19673456-.3861474-.55708246-2.01309583-2.90342702-2.01175284 2.90342702-.38616902.55708246-.65057579.19673456-3.36822922 1.02071491 2.0918157 2.60583404.44762421.5569525-.01966912.7145437zm10.01245079 2.92067-6.01957523-2.4348773-6.01944522 2.4348773.17578738-6.5828097-3.89697774-4.8537463 6.12775537-1.85572122 3.61288021-5.21275117 3.61417993 5.21275117 6.1241161 1.85572122-3.8957863 4.853768z",
  fill: fill,
  fillRule: "nonzero",
  transform: "translate(13.065217 13.47619)"
}))));
// CONCATENATED MODULE: ./components/icons/forward_btn.jsx
function forward_btn_extends() { forward_btn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return forward_btn_extends.apply(this, arguments); }

/* harmony default export */ var forward_btn = (({
  fill = '#343434',
  ...rest
}) => React.createElement("svg", forward_btn_extends({
  height: "46",
  viewBox: "0 0 46 46",
  width: "46",
  xmlns: "http://www.w3.org/2000/svg"
}, rest), React.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React.createElement("circle", {
  cx: "23",
  cy: "23",
  fill: "#f5f5f5",
  r: "23"
}), React.createElement("g", {
  transform: "translate(13 14)"
}, React.createElement("path", {
  className: "aoicon",
  d: "m0 0h20v20h-20z",
  fill: fill,
  fillRule: "nonzero",
  opacity: "0"
}), React.createElement("path", {
  className: "aoicon",
  d: "m2.5 16.25h15v1.875h-15z",
  fill: fill
}), React.createElement("g", {
  className: "aoicon_line",
  stroke: fill,
  strokeWidth: "2"
}, React.createElement("path", {
  d: "m5 2.5h10v10"
}), React.createElement("path", {
  d: "m14.375 3.45-8.381812 8.381812",
  strokeLinecap: "square"
}))))));
// CONCATENATED MODULE: ./components/icons/close_btn.jsx
function close_btn_extends() { close_btn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return close_btn_extends.apply(this, arguments); }

/* harmony default export */ var close_btn = (({
  fill = '#343434',
  ...rest
}) => React.createElement("svg", close_btn_extends({
  height: "16",
  viewBox: "0 0 16 16",
  width: "16",
  xmlns: "http://www.w3.org/2000/svg"
}, rest), React.createElement("path", {
  className: "aoicon",
  d: "m1398.14214 826.857864v9h9v2h-9v9h-2v-9h-9v-2h9v-9z",
  fill: fill,
  fillRule: "evenodd",
  transform: "matrix(.70710678 .70710678 -.70710678 .70710678 -388.038672 -1571.818685)"
})));
// EXTERNAL MODULE: ./api/collect.js
var collect = __webpack_require__(204);

// CONCATENATED MODULE: ./components/channel_view/operate_bar.jsx







/* harmony default export */ var operate_bar = (({
  setChannelPostSelect,
  setMessageMergeForward,
  postList,
  currentUser,
  addMergeCollect
}) => {
  const postIds = Object.keys(postList);

  const handleMergeForward = () => {
    if (postIds.length === 0) {
      return es_message["a" /* default */].warn('【合并转发】请至少选择一条消息');
    }

    setChannelPostSelect({
      type: constants["f" /* ChannelPostSelectType */].MERGE,
      visibleSelectMember: true,
      visibleCheckbox: true
    });
  };

  const handleClosed = () => {
    setChannelPostSelect({
      __TYPE__: 'RESET'
    });
    setMessageMergeForward({
      __TYPE__: 'RESET'
    });
  };

  const handleCollect = () => {
    if (postIds.length === 0) {
      return es_message["a" /* default */].warn('【合并收藏】请至少选择一条消息');
    }

    Object(collect["d" /* postMergeCollect */])(currentUser.id, postIds).then(res => {
      // console.log(res);
      if (res.data.status === 'OK') {
        addMergeCollect(postIds);
        handleClosed();
        es_message["a" /* default */].success('合并收藏成功');
      } else {
        es_message["a" /* default */].error('合并收藏失败，请重试');
      }
    });
  };

  const handleEsc = e => {
    if (e.keyCode === 27) {
      handleClosed();
    }
  };

  Object(react["useEffect"])(() => {
    document.addEventListener('keydown', handleEsc, false);
    return () => {
      document.removeEventListener('keydown', handleEsc, false);
    };
  });
  return react_default.a.createElement("div", {
    className: "post__operate__bar"
  }, react_default.a.createElement("div", {
    className: "operate__btns"
  }, react_default.a.createElement("div", null, react_default.a.createElement(forward_btn, {
    onClick: handleMergeForward
  }), react_default.a.createElement("span", null, "\u5408\u5E76\u8F6C\u53D1")), react_default.a.createElement("div", null, react_default.a.createElement(collect_btn, {
    onClick: handleCollect
  }), react_default.a.createElement("span", null, "\u5408\u5E76\u6536\u85CF"))), react_default.a.createElement("div", {
    className: "esc__btn"
  }, react_default.a.createElement("div", null, react_default.a.createElement(close_btn, {
    onClick: handleClosed
  }), react_default.a.createElement("span", null, "esc"))));
});
// EXTERNAL MODULE: ./components/channel_view/index.scss
var channel_view = __webpack_require__(3198);

// CONCATENATED MODULE: ./components/channel_view/channel_view.jsx
function channel_view_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





























const {
  confirm: channel_view_confirm
} = es_modal["a" /* default */];
class channel_view_ChannelView extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    channel_view_defineProperty(this, "isLeaving", false);

    channel_view_defineProperty(this, "showChannelInviteModal", () => {
      this.setState({
        showChannelInviteModal: true
      });
    });

    channel_view_defineProperty(this, "hideChannelInviteModal", () => {
      this.setState({
        showChannelInviteModal: false
      });
    });

    channel_view_defineProperty(this, "createDeferredPostView", () => {
      this.deferredPostView = deferComponentRender(post_view, react_default.a.createElement("div", {
        id: "post-list"
      }));
    });

    channel_view_defineProperty(this, "getChannelView", () => {
      return this.refs.channelView;
    });

    channel_view_defineProperty(this, "onClickCloseChannel", () => {
      this.props.actions.goToLastViewedChannel();
    });

    channel_view_defineProperty(this, "toggleFavorite", e => {
      if (e) e.stopPropagation();

      if (this.props.isFavorite) {
        this.props.actions.unfavoriteChannel(this.props.channel.id);
      } else {
        this.props.actions.favoriteChannel(this.props.channel.id);
      }
    });

    channel_view_defineProperty(this, "handleLeavePublicChannel", () => {
      this.props.actions.leaveChannel(this.props.channelId);
      Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_public_channel_x_button_clicked');
    });

    channel_view_defineProperty(this, "handleLeavePrivateChannel", () => {
      global_actions["m" /* showLeavePrivateChannelModal */]({
        id: this.props.channelId,
        display_name: this.props.channel.display_name
      });
      Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_private_channel_x_button_clicked');
    });

    channel_view_defineProperty(this, "handleExit", () => {
      const {
        channel,
        channelMembers,
        channelUsers,
        currentUser,
        memberCount,
        actions
      } = this.props;
      const myMember = channelMembers[currentUser.id];

      if (myMember && myMember.scheme_admin) {
        if (memberCount <= 1) {
          dissolveChannel({
            id: channel.id
          });
          return;
        } else {
          // 管理员顺位给第一位
          const userId = currentUser.id !== channelUsers[0].id ? channelUsers[0].id : channelUsers[1].id;
          actions.updateChannelMemberSchemeRoles(channel.id, userId, true, true);
        }
      }

      const _type = this.props.channel.type;
      const _id = this.props.currentUser.id;

      if (_type === constants["g" /* Constants */].PRIVATE_CHANNEL || _type === constants["g" /* Constants */].OPEN_CHANNEL) {
        this.handleLeavePublicChannel();
      } else if (_type === constants["g" /* Constants */].DM_CHANNEL || _type === constants["g" /* Constants */].GM_CHANNEL) {
        // closeHandler = this.handleLeaveDirectChannel;
        if (!this.isLeaving) {
          this.isLeaving = true;
          let id;
          let category;

          if (_type === constants["g" /* Constants */].DM_CHANNEL) {
            id = this.props.channel.teammate_id;
            category = constants["g" /* Constants */].Preferences.CATEGORY_DIRECT_CHANNEL_SHOW;
          } else {
            id = this.props.channelId;
            category = constants["g" /* Constants */].Preferences.CATEGORY_GROUP_CHANNEL_SHOW;
          } // console.log(11111, _id, [{user_id: _id, category, name: id, value: 'false'}]);


          this.props.actions.savePreferences(_id, [{
            user_id: _id,
            category,
            name: id,
            value: 'false'
          }]).then(() => {
            this.isLeaving = false;
          });
          Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_direct_channel_x_button_clicked');
        }

        browser_history["a" /* browserHistory */].push(`/${this.props.currentTeamName}/channels/${this.props.redirectChannel}`);
      } else if (this.props.config.EnableXToLeaveChannelsFromLHS === 'true') {
        if (_type === constants["g" /* Constants */].OPEN_CHANNEL && this.props.channel.name !== constants["g" /* Constants */].DEFAULT_CHANNEL) {
          // closeHandler = this.handleLeavePublicChannel;
          this.props.actions.leaveChannel(this.props.channelId);
          Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_public_channel_x_button_clicked'); // console.log(2222);
        } else if (_type === constants["g" /* Constants */].PRIVATE_CHANNEL) {
          // closeHandler = this.handleLeavePrivateChannel;
          // console.log(3333);
          global_actions["m" /* showLeavePrivateChannelModal */]({
            id: this.props.channelId,
            display_name: this.props.channel.display_name
          });
          Object(diagnostics_actions["d" /* trackEvent */])('ui', 'ui_private_channel_x_button_clicked');
        }
      }
    });

    channel_view_defineProperty(this, "handleChannelMenu", e => {
      let _this = this;

      if (e.key === "edit") {
        const modalData = {
          modalId: constants["p" /* ModalIdentifiers */].RENAME_CHANNEL,
          dialogProps: {
            channel: this.props.channel
          },
          dialogType: rename_channel_modal,
          text: Object(utils["gb" /* localizeMessage */])('channel_header.rename', 'Rename Channel')
        };
        this.props.actions.openModal(modalData);
      }

      if (e.key === 'notify') {
        console.log(666);
        this.props.actions.updateChannelNotifyProps(this.props.currentUser.id, this.props.channelId, {
          mark_unread: this.props.isMuted ? constants["q" /* NotificationLevels */].ALL : constants["q" /* NotificationLevels */].MENTION
        });
      }

      if (e.key === 'favorite') {
        // console.log('favorite')
        this.toggleFavorite();
      }

      if (e.key === 'exit') {
        channel_view_confirm({
          title: '退出后不会通知群聊中其他成员，且不会再接受此群聊消息',
          cancelText: '取消',
          okText: '确定',

          onOk() {
            // 由于搜索有缓存，所以当退出频道后，需将数据清空，重新搜索
            _this.props.actions.updateSearchKeyword('');

            _this.props.actions.search();

            _this.handleExit();
          }

        });
      } // 解散频道


      if (e.key === 'dissolve') {
        dissolveChannel({
          id: this.props.channelId
        });
      }
    });

    this.state = {
      //paoInfo:null, //泡泡内容,
      showChannelInviteModal: false
    };
    this.inTime = -1; //计时器

    this.createDeferredPostView(); //this.getMeetingPao();
  }

  componentDidMount() {
    const platform = window.navigator.platform;
    jquery_default()('body').addClass('app__body'); // IE Detection

    if (user_agent["f" /* isInternetExplorer */]() || user_agent["d" /* isEdge */]()) {
      jquery_default()('body').addClass('browser--ie');
    } // OS Detection


    if (platform === 'Win32' || platform === 'Win64') {
      jquery_default()('body').addClass('os--windows');
    } else if (platform === 'MacIntel' || platform === 'MacPPC') {
      jquery_default()('body').addClass('os--mac');
    }

    this.addInterval();
  }

  componentWillUnmount() {
    jquery_default()('body').removeClass('app__body');
    this.removeInterval();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.match.url !== nextProps.match.url) {
      this.createDeferredPostView();
    }

    if (this.props.channelId !== nextProps.channelId) {
      //console.log("---------",this.props.channelId,nextProps.channelId);
      this.getMeetingPao(nextProps.channelId);
    }
  }

  getMeetingPao(channelId) {
    const data = {
      channel_id: channelId,
      username: this.props.currentUser.username,
      phone: this.props.currentUser.username
    };
    this.props.actions.getMeetingPao(data);
  } //查询该频道的会议id


  addInterval() {
    this.inTime = setInterval(() => {
      if (this.props.channelId != "") {
        this.getMeetingPao(this.props.channelId);
        this.removeInterval();
      }
    }, 1000);
  }

  meetingStatus(state) {
    this.props.actions.updateMe({
      notify_props: { ...this.props.currentUser.notify_props,
        meeting_status: state
      }
    });
  }

  getMyInMeetState() {
    if (!this.props.channel) return; //不清楚为什么先容错吧

    const data = {
      channel_id: this.props.channelId,
      username: this.props.currentUser.username,
      phone: this.props.currentUser.username
    };
    Object(api_post["c" /* getMyInMeetState */])(data).then(res => {
      //console.log("this.props.channelId---",this.props.invitationChannleId,this.props.channelId);
      if (res && this.props.invitationChannleId != this.props.channelId) {
        let data1 = Object.assign({}, res);
        this.setState({
          paoInfo: data1
        });
      } else {
        this.setState({
          paoInfo: null
        });
      }
    });
  }

  removeInterval() {
    clearInterval(this.inTime);
    this.inTime = -1;
  } //加入会议


  joinMeeting(e) {
    this.props.actions.meetAddAction({
      channel_id: e.channel_id,
      meeting_id: e.meeting_id,
      meeting_no: e.meeting_no.toString(),
      user_name: this.props.currentUser.username,
      nick_name: this.props.currentUser.nickname,
      meetName: e.meeting_name
    });
  } //分享会议复制


  copyMeeting(e) {
    copy_to_clipboard_default()(`[@meeting:@${e.nick_name}:${e.meeting_no}:${e.meeting_id}:${e.meeting_name}:${Object(api_post["b" /* getFormatDate */])()}:${e.channel_id}]`);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.channelId !== this.props.channelId || prevProps.channelIsArchived !== this.props.channelIsArchived) {
      //this.setState({paoInfo:null});
      Object(diagnostics_actions["b" /* mark */])('ChannelView#componentDidUpdate');
      const [dur1] = Object(diagnostics_actions["c" /* measure */])('SidebarChannelLink#click', 'ChannelView#componentDidUpdate');
      const [dur2] = Object(diagnostics_actions["c" /* measure */])('TeamLink#click', 'ChannelView#componentDidUpdate');
      Object(diagnostics_actions["a" /* clearMarks */])(['SidebarChannelLink#click', 'ChannelView#componentDidUpdate', 'TeamLink#click']);

      if (dur1 !== -1) {
        Object(diagnostics_actions["d" /* trackEvent */])('performance', 'channel_switch', {
          duration: Math.round(dur1)
        });
      }

      if (dur2 !== -1) {
        Object(diagnostics_actions["d" /* trackEvent */])('performance', 'team_switch', {
          duration: Math.round(dur2)
        });
      }

      if (this.props.channelIsArchived && !this.props.viewArchivedChannels) {
        this.props.actions.goToLastViewedChannel();
      }
    }
  }

  render() {
    if (window.isNewChannel) {
      window.isNewChannel = false;
      this.showChannelInviteModal();
    }

    const hasExit = (this.props.channel ? this.props.channel.type === constants["g" /* Constants */].PRIVATE_CHANNEL || this.props.channel.type === constants["g" /* Constants */].OPEN_CHANNEL : false) || this.props.config.EnableXToLeaveChannelsFromLHS === 'true';
    const {
      channelIsArchived,
      channel,
      memberCount,
      channelMembers
    } = this.props;

    if (this.props.showTutorial) {
      return react_default.a.createElement(tutorial, {
        isRoot: false
      });
    }

    let createPost;

    if (this.props.deactivatedChannel) {
      createPost = react_default.a.createElement("div", {
        className: "post-create-message"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "create_post.deactivated",
        defaultMessage: "You are viewing an archived channel with a deactivated user."
      }));
    } else {
      createPost = react_default.a.createElement("div", {
        className: "post-create__container",
        id: "post-create"
      }, !channelIsArchived && react_default.a.createElement(create_post, {
        getChannelView: this.getChannelView,
        visible: this.props.hasCheckbox
      }), channelIsArchived && react_default.a.createElement("div", {
        className: "channel-archived__message"
      }, react_default.a.createElement(formatted_markdown_message["b" /* default */], {
        id: "archivedChannelMessage",
        defaultMessage: "You are viewing an **archived channel**. New messages cannot be posted."
      }), react_default.a.createElement("button", {
        className: "btn btn-primary channel-archived__close-btn",
        onClick: this.onClickCloseChannel
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: "center_panel.archived.closeChannel",
        defaultMessage: "Close Channel"
      }))));
    }

    const DeferredPostView = this.deferredPostView;
    let paoView = null;

    if (this.props.paoInfo.meetInfo && this.props.paoInfo.meetInfo.data.meeting_name && this.props.invitationChannleId != this.props.channelId) {
      const {
        meetInfo
      } = this.props.paoInfo;
      const {
        nick_name,
        meeting_name
      } = meetInfo.data;
      paoView = react_default.a.createElement("div", {
        className: "meeting-class-paoview"
      }, react_default.a.createElement("img", {
        src: share_png_2x_default.a,
        width: "20px",
        height: "20px"
      }), react_default.a.createElement("span", {
        className: "meeting-class-top-left"
      }, nick_name, "\u9080\u8BF7\u4F60\u52A0\u5165", meeting_name, "\u89C6\u9891\u4F1A\u8BAE"), meetInfo.is_join == "1" ? react_default.a.createElement(es_button["a" /* default */], {
        className: "meeting-class-button",
        ghost: true,
        value: "small",
        type: "primary",
        onClick: () => this.copyMeeting(meetInfo.data)
      }, "\u5206\u4EAB\u94FE\u63A5") : react_default.a.createElement(es_button["a" /* default */], {
        className: "meeting-class-button",
        ghost: true,
        value: "small",
        type: "primary",
        onClick: () => this.joinMeeting(meetInfo.data)
      }, "\u70B9\u51FB\u52A0\u5165"));
    }

    const isMyChannel = channel && channel.creator_id != "" && channel.creator_id === this.props.currentUser.id; //如果频道是我自己创建的

    const myMember = channel && channelMembers && channelMembers[this.props.currentUser.id]; // 默认频道不允许解散

    const isDefaultChannel = channel && (channel.name === constants["g" /* Constants */].DEFAULT_CHANNEL || channel.name === constants["g" /* Constants */].OFFTOPIC_CHANNEL);
    let channelInviteModal;

    if (this.state.showChannelInviteModal) {
      channelInviteModal = react_default.a.createElement(channel_new_invite_modal["a" /* default */], {
        onHide: this.hideChannelInviteModal,
        channel: this.props.channel
      });
    }

    return react_default.a.createElement("div", {
      ref: "channelView",
      id: "app-content",
      className: "app__content"
    }, react_default.a.createElement(FileUploadOverlay, {
      overlayType: "center"
    }), react_default.a.createElement(channel_header, {
      channelId: this.props.channelId
    }), react_default.a.createElement("div", {
      className: "channel-header-content"
    }, react_default.a.createElement("div", {
      style: {
        padding: '17px 0 11px 18px',
        float: "left"
      }
    }, react_default.a.createElement("div", {
      className: 'channel-cont-title'
    }, react_default.a.createElement(dropdown["a" /* default */], {
      overlay: react_default.a.createElement(es_menu["a" /* default */], {
        onClick: this.handleChannelMenu
      }, react_default.a.createElement(es_menu["a" /* default */].Item, {
        key: "favorite"
      }, this.props.isFavorite ? '已置顶' : '置顶'), react_default.a.createElement(es_menu["a" /* default */].Item, {
        key: "notify"
      }, this.props.isMuted ? '关闭免打扰' : '消息免打扰'), channel && channel.type != 'O' && channel.type != 'D' && isMyChannel && react_default.a.createElement(es_menu["a" /* default */].Item, {
        key: "edit"
      }, "\u4FEE\u6539\u540D\u79F0"), hasExit && react_default.a.createElement(es_menu["a" /* default */].Item, {
        key: "exit"
      }, "\u9000\u51FA\u9891\u9053"), !isDefaultChannel && myMember && myMember.scheme_admin && react_default.a.createElement(es_menu["a" /* default */].Item, {
        key: "dissolve"
      }, "\u89E3\u6563\u9891\u9053")),
      trigger: ['click', 'hover']
    }, react_default.a.createElement("span", {
      style: {
        color: '#343434',
        fontWeight: 600,
        fontSize: 16,
        marginBottom: 3,
        marginRight: 5,
        cursor: 'pointer'
      }
    }, channel && channel.display_name, " ", react_default.a.createElement(es_icon["a" /* default */], {
      type: "down"
    }))), channel && channel.type === 'O' && react_default.a.createElement("span", {
      className: 'channel-type-public'
    })), react_default.a.createElement("div", {
      style: {
        color: '#909090',
        fontSize: 14
      }
    }, react_default.a.createElement("span", {
      onClick: () => {
        if (this.props.isMember) {
          this.props.actions.closeRightHandSide();
        } else {
          this.props.actions.showMembers();
        }
      },
      style: {
        cursor: 'pointer'
      }
    }, react_default.a.createElement("i", {
      className: "members-icon"
    }), react_default.a.createElement("span", {
      style: {
        marginLeft: 3
      }
    }, memberCount || '-')), react_default.a.createElement("span", {
      style: {
        borderLeft: '1px solid #F0F0F0',
        height: '100%',
        margin: '0 10px'
      }
    }), react_default.a.createElement("span", {
      onClick: this.toggleFavorite,
      className: "top-icon"
    }, this.props.isFavorite ? '已置顶' : '置顶'))), paoView), this.props.channelId !== "" && react_default.a.createElement(DeferredPostView, {
      channelId: this.props.channelId
    }), this.props.hasCheckbox && react_default.a.createElement(operate_bar, {
      visible: this.props.hasCheckbox,
      setChannelPostSelect: this.props.actions.setChannelPostSelect,
      setMessageMergeForward: this.props.actions.setMessageMergeForward,
      postList: this.props.messageMergeForward,
      currentUser: this.props.currentUser,
      addMergeCollect: this.props.actions.addMergeCollect
    }), react_default.a.createElement(select_member["a" /* default */], null), createPost, channelInviteModal);
  }

}

channel_view_defineProperty(channel_view_ChannelView, "propTypes", {
  invitationChannleId: prop_types_default.a.string,
  currentUser: prop_types_default.a.object,
  channelId: prop_types_default.a.string.isRequired,
  deactivatedChannel: prop_types_default.a.bool.isRequired,
  match: prop_types_default.a.shape({
    url: prop_types_default.a.string.isRequired
  }).isRequired,
  showTutorial: prop_types_default.a.bool.isRequired,
  channelIsArchived: prop_types_default.a.bool.isRequired,
  viewArchivedChannels: prop_types_default.a.bool.isRequired,
  actions: prop_types_default.a.shape({
    goToLastViewedChannel: prop_types_default.a.func.isRequired,
    showMembers: prop_types_default.a.func.isRequired
  }),
  channel: prop_types_default.a.object,
  memberCount: prop_types_default.a.number,
  isFavorite: prop_types_default.a.bool,
  isMember: prop_types_default.a.bool,
  paoInfo: prop_types_default.a.object,
  actions: prop_types_default.a.shape({
    favoriteChannel: prop_types_default.a.func.isRequired,
    unfavoriteChannel: prop_types_default.a.func.isRequired,
    openModal: prop_types_default.a.func.isRequired,
    meetAddAction: prop_types_default.a.func.isRequired,
    getMeetingPao: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/channel_view/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

























 // Temporary selector until getDirectTeammate is converted to be redux-friendly

const getDeactivatedChannel = Object(reselect_es["a" /* createSelector */])(state => state.entities.users.profiles, (state, channelId) => channelId, (users, channelId) => {
  const teammate = Object(utils["v" /* getDirectTeammate */])(channelId);
  return Boolean(teammate && teammate.delete_at);
});

function channel_view_mapStateToProps(state) {
  const currentUserId = Object(entities_users["getCurrentUserId"])(state);
  const channel = Object(entities_channels["getCurrentChannel"])(state);
  const channelId = channel ? channel.id : '';
  const stats = Object(entities_channels["getAllChannelStats"])(state)[channelId] || {};
  const rhsState = Object(selectors_rhs["m" /* getRhsState */])(state);
  const config = Object(general["getConfig"])(state);
  const enableTutorial = config.EnableTutorial === 'true';
  const tutorialStep = Object(entities_preferences["getInt"])(state, constants["w" /* Preferences */].TUTORIAL_STEP, Object(entities_users["getCurrentUserId"])(state), constants["H" /* TutorialSteps */].FINISHED);
  const viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';
  const currentTeam = Object(entities_teams["getCurrentTeam"])(state);
  const channelMembers = Object(entities_channels["getChannelMembersInChannels"])(state) || {};
  let forwardList = {};

  if (state.views.posts) {
    forwardList = state.views.posts.messageMergeForward;
  }

  let hasCheckbox = false;

  if (state.views.posts) {
    let channelPostSelect = state.views.posts.channelPostSelect;

    if (channelPostSelect) {
      if (constants["f" /* ChannelPostSelectType */].MERGE === channelPostSelect.type) {
        hasCheckbox = channelPostSelect.visibleCheckbox;
      }
    }
  }

  const channelUsers = (() => {
    if (!channel) {
      return [];
    }

    const doGetProfilesInChannel = Object(entities_users["makeGetProfilesInChannel"])();
    const users = doGetProfilesInChannel(state, channelId, true);
    return users;
  })();

  let messageMergeForward;

  if (state.views.posts) {
    messageMergeForward = state.views.posts.messageMergeForward;
  }

  const invitationChannleId = state.views.meeting.invitation ? state.views.meeting.invitation.invitation ? state.views.meeting.invitation.invitation.channel_id : '' : ''; //当前全屏频道id

  const paoInfo = state.views.meeting.invitation.meetingPao || {};
  return {
    config,
    channelId,
    deactivatedChannel: channel ? getDeactivatedChannel(state, channelId) : false,
    showTutorial: enableTutorial && tutorialStep <= constants["H" /* TutorialSteps */].INTRO_SCREENS,
    channelIsArchived: channel ? channel.delete_at !== 0 : false,
    viewArchivedChannels,
    channel,
    redirectChannel: Object(entities_channels["getRedirectChannelNameForTeam"])(state, Object(entities_teams["getCurrentTeamId"])(state)),
    currentTeamName: currentTeam.name,
    memberCount: stats.member_count,
    isFavorite: Object(entities_channels["isCurrentChannelFavorite"])(state),
    isMuted: Object(entities_channels["isCurrentChannelMuted"])(state),
    isMember: rhsState === constants["x" /* RHSStates */].MEMBER,
    currentUser: Object(entities_users["getCurrentUser"])(state),
    channelMembers: channelMembers[channelId],
    forwardList,
    hasCheckbox,
    hasOperateBar: Object.keys(forwardList).length > 0,
    // hasOperateBar: Object.keys(forwardList).length > 0,
    channelUsers,
    messageMergeForward,
    invitationChannleId,
    paoInfo
  };
}

function channel_view_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      goToLastViewedChannel: views_channel["c" /* goToLastViewedChannel */],
      favoriteChannel: actions_channels["favoriteChannel"],
      unfavoriteChannel: actions_channels["unfavoriteChannel"],
      showMembers: rhs["o" /* showMembers */],
      closeRightHandSide: rhs["b" /* closeRightHandSide */],
      updateMe: actions_users["updateMe"],
      savePreferences: actions_preferences["savePreferences"],
      leaveChannel: views_channel["f" /* leaveChannel */],
      openModal: modals["b" /* openModal */],
      updateChannelNotifyProps: actions_channels["updateChannelNotifyProps"],
      setChannelPostSelect: views_posts["c" /* setChannelPostSelect */],
      setMessageMergeForward: views_posts["d" /* setMessageMergeForward */],
      meetAddAction: meeting["g" /* meetAddAction */],
      getMeetingPao: meeting["c" /* getMeetingPao */],
      search: search_chat_search,
      updateSearchKeyword: updateSearchKeyword,
      updateChannelMemberSchemeRoles: actions_channels["updateChannelMemberSchemeRoles"],
      addMergeCollect: post_actions["a" /* addMergeCollect */]
    }, dispatch)
  };
}

/* harmony default export */ var components_channel_view = (Object(react_router["f" /* withRouter */])(Object(es["connect"])(channel_view_mapStateToProps, channel_view_mapDispatchToProps, null, {
  withRef: true
})(channel_view_ChannelView)));
// CONCATENATED MODULE: ./components/channel_layout/channel_identifier_router/channel_identifier_router.jsx
function channel_identifier_router_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



class channel_identifier_router_ChannelIdentifierRouter extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.props.actions.onChannelByIdentifierEnter(props);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.match.params.team !== nextProps.match.params.team || this.props.match.params.identifier !== nextProps.match.params.identifier) {
      this.props.actions.onChannelByIdentifierEnter(nextProps);
    }
  }

  init(channel) {
    // console.log("init");
    // this.props.actions.showMembers();
    if (channel) this.props.actions.getProfilesInChannel(channel.id, 0, undefined, "status");
    if (channel) this.props.actions.getChannelMembers(channel.id, 0, 100);
  }

  componentDidMount() {
    if (this.props.channel) {
      this.init(this.props.channel);
    }
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    //console.log('prevProps:', prevProps, ', this.props:', this.props);
    if (!prevProps.channel || this.props.channel && this.props.channel.id !== prevProps.channel.id) {
      this.init(this.props.channel);
    }
  }

  render() {
    return react_default.a.createElement(components_channel_view, null);
  }

}

channel_identifier_router_defineProperty(channel_identifier_router_ChannelIdentifierRouter, "propTypes", {
  /*
   * Object from react-router
   */
  match: prop_types_default.a.shape({
    params: prop_types_default.a.shape({
      identifier: prop_types_default.a.string.isRequired,
      team: prop_types_default.a.string.isRequired
    }).isRequired
  }).isRequired,
  actions: prop_types_default.a.shape({
    onChannelByIdentifierEnter: prop_types_default.a.func.isRequired,
    getProfilesInChannel: prop_types_default.a.func.isRequired,
    showMembers: prop_types_default.a.func.isRequired
  }).isRequired,
  channel: prop_types_default.a.object
});
// CONCATENATED MODULE: ./components/channel_layout/channel_identifier_router/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.










const channel_identifier_router_mapStateToProps = state => {
  const channel = Object(entities_channels["getCurrentChannel"])(state) || null;
  return {
    channel
  };
};

function channel_identifier_router_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      onChannelByIdentifierEnter: onChannelByIdentifierEnter,
      showMembers: rhs["o" /* showMembers */],
      getProfilesInChannel: actions_users["getProfilesInChannel"],
      getChannelMembers: actions_channels["getChannelMembers"]
    }, dispatch)
  };
}

/* harmony default export */ var channel_identifier_router = (Object(react_router["f" /* withRouter */])(Object(es["connect"])(channel_identifier_router_mapStateToProps, channel_identifier_router_mapDispatchToProps)(channel_identifier_router_ChannelIdentifierRouter)));
// CONCATENATED MODULE: ./components/channel_layout/center_channel/center_channel.jsx
function center_channel_extends() { center_channel_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return center_channel_extends.apply(this, arguments); }

function center_channel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class center_channel_CenterChannel extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      returnTo: ''
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.location.pathname !== nextProps.location.pathname && nextProps.location.pathname.includes('/pl/')) {
      this.setState({
        returnTo: this.props.location.pathname
      });
    }
  }

  render() {
    const {
      lastChannelPath
    } = this.props;
    const url = this.props.match.url;
    return react_default.a.createElement("div", {
      key: "inner-wrap",
      className: classnames_default()('inner-wrap', 'channel__wrap', {
        'move--right': this.props.lhsOpen,
        'move--left': this.props.rhsOpen,
        'move--left-small': this.props.rhsMenuOpen
      })
    }, react_default.a.createElement("div", {
      className: "row header"
    }, react_default.a.createElement("div", {
      id: "navbar"
    }, react_default.a.createElement(channel_header_mobile, null))), react_default.a.createElement("div", {
      className: "row main"
    }, react_default.a.createElement(react_router["d" /* Switch */], null, react_default.a.createElement(react_router["b" /* Route */], {
      path: `${url}/pl/:postid`,
      render: props => react_default.a.createElement(permalink_view, center_channel_extends({}, props, {
        returnTo: this.state.returnTo
      }))
    }), react_default.a.createElement(react_router["b" /* Route */], {
      path: '/:team/:path(channels|messages)/:identifier',
      component: channel_identifier_router
    }), react_default.a.createElement(react_router["a" /* Redirect */], {
      to: lastChannelPath
    }))));
  }

}

center_channel_defineProperty(center_channel_CenterChannel, "propTypes", {
  match: prop_types_default.a.object.isRequired,
  location: prop_types_default.a.object.isRequired,
  lastChannelPath: prop_types_default.a.string.isRequired,
  lhsOpen: prop_types_default.a.bool.isRequired,
  rhsOpen: prop_types_default.a.bool.isRequired,
  rhsMenuOpen: prop_types_default.a.bool.isRequired
});
// CONCATENATED MODULE: ./components/channel_layout/center_channel/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.








const center_channel_mapStateToProps = (state, ownProps) => {
  let channelName = Object(selectors_local_storage["b" /* getLastViewedChannelNameByTeamName */])(state, ownProps.match.params.team);

  if (!channelName) {
    const team = Object(entities_teams["getTeamByName"])(state, ownProps.match.params.team);
    channelName = Object(entities_channels["getRedirectChannelNameForTeam"])(state, team.id);
  }

  const lastChannelPath = `${ownProps.match.url}/channels/${channelName}`;
  return {
    lastChannelPath,
    lhsOpen: getIsLhsOpen(state),
    rhsOpen: Object(selectors_rhs["c" /* getIsRhsOpen */])(state),
    rhsMenuOpen: Object(selectors_rhs["b" /* getIsRhsMenuOpen */])(state)
  };
};

/* harmony default export */ var center_channel = (Object(es["connect"])(center_channel_mapStateToProps)(center_channel_CenterChannel));
// EXTERNAL MODULE: ./node_modules/antd/es/carousel/index.js
var carousel = __webpack_require__(3480);

// EXTERNAL MODULE: ./components/system_guide/module_guide_modal/index.scss
var module_guide_modal = __webpack_require__(3199);

// CONCATENATED MODULE: ./components/system_guide/module_guide_modal/index.js
function module_guide_modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




const modules = [{
  title: '全新工作方式',
  desc: '数据汇聚，应用汇聚链接人的协作工具',
  imgUrl: __webpack_require__(3200)
}, {
  title: '交互式命令',
  desc: '通过输入命令可以快速唤起指定应用',
  imgUrl: __webpack_require__(3201)
}, {
  title: '我的工作台',
  desc: '支持全局自定义配置，模块化按需组合',
  imgUrl: __webpack_require__(3202)
}];
class module_guide_modal_SystemGuide extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.state = {};
    this.closeModal = this.closeModal.bind(this);
  }

  closeModal() {
    this.props.onCancel();
  }

  prev() {
    this.refs.slider.prev();
  }

  next() {
    this.refs.slider.next();
  }

  render() {
    return react_default.a.createElement(es_modal["a" /* default */], {
      className: "module-guide-modal",
      closeIcon: react_default.a.createElement(es_icon["a" /* default */], {
        type: "close-circle",
        theme: "filled"
      }),
      visible: this.props.visible,
      onCancel: this.closeModal,
      role: "dialog",
      title: '',
      footer: null,
      mask: false,
      maskClosable: false,
      centered: true,
      width: '720px'
    }, react_default.a.createElement(carousel["a" /* default */], {
      ref: 'slider',
      autoplay: true,
      autoplaySpeed: 4000
    }, modules.map((item, index) => {
      return react_default.a.createElement("div", {
        className: 'item',
        key: index
      }, react_default.a.createElement("p", null, item.title), react_default.a.createElement("p", null, item.desc), react_default.a.createElement("img", {
        src: item.imgUrl
      }));
    })), react_default.a.createElement("a", {
      className: 'prev-btn',
      onClick: () => {
        this.prev();
      }
    }), react_default.a.createElement("a", {
      className: 'next-btn',
      onClick: () => {
        this.next();
      }
    }));
  }

}

module_guide_modal_defineProperty(module_guide_modal_SystemGuide, "propTypes", {
  visible: PropTypes.bool.isRequired,
  onCancel: PropTypes.func.isRequired
});
// EXTERNAL MODULE: ./components/system_guide/index.scss
var system_guide = __webpack_require__(3203);

// CONCATENATED MODULE: ./components/system_guide/index.js



const guides = [{
  className: 'guide-search',
  imgUrl: __webpack_require__(3204)
}, {
  className: 'guide-create-channel',
  imgUrl: __webpack_require__(3205)
}, {
  className: 'guide-zoom',
  imgUrl: __webpack_require__(3206)
}, {
  className: 'guide-application',
  imgUrl: __webpack_require__(3207)
}];
class system_guide_SystemGuide extends react_default.a.Component {
  constructor(props) {
    super(props);
    this.state = {
      modalVisible: true,
      showGuide: false,
      step: 1
    };
  }

  componentDidMount() {
    window.localStorage.setItem('is_new', 'false');
  }

  handleCancel() {
    this.setState({
      modalVisible: false,
      showGuide: true
    });
  }

  next() {
    if (this.state.step === guides.length) {
      this.setState({
        showGuide: false
      });
      return;
    }

    this.setState({
      step: this.state.step + 1
    });
  }

  render() {
    return react_default.a.createElement("div", null, react_default.a.createElement(module_guide_modal_SystemGuide, {
      onCancel: () => {
        this.handleCancel();
      },
      visible: this.state.modalVisible
    }), this.state.showGuide ? react_default.a.createElement("div", {
      className: 'guide-content'
    }, react_default.a.createElement("div", {
      className: "ant-modal-mask"
    }), guides.map((item, index) => {
      return react_default.a.createElement("div", {
        className: 'guide-item ' + item.className + (index + 1 !== this.state.step ? ' hide' : ''),
        key: index
      }, react_default.a.createElement("img", {
        src: item.imgUrl
      }), react_default.a.createElement("a", {
        className: "next-btn",
        onClick: () => {
          this.next();
        }
      }, "\u6211\u77E5\u9053\u4E86"));
    })) : null);
  }

}
// CONCATENATED MODULE: ./components/channel_layout/channel_controller.jsx
function channel_controller_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






















class channel_controller_ChannelController extends react_default.a.Component {
  shouldComponentUpdate(nextProps) {
    return this.props.teamType !== nextProps.teamType || this.props.pathName !== nextProps.pathName;
  }

  render() {
    const is_new = window.localStorage.getItem('is_new');
    return react_default.a.createElement("div", {
      id: "channel_view",
      className: "channel-view"
    }, react_default.a.createElement(announcement_bar["a" /* default */], null), react_default.a.createElement(system_notice["a" /* default */], null), react_default.a.createElement("div", {
      className: "container-fluid"
    }, react_default.a.createElement(sidebar_right, null), react_default.a.createElement(sidebar_right_menu, {
      teamType: this.props.teamType
    }), react_default.a.createElement(react_router["b" /* Route */], {
      component: sidebar
    }), react_default.a.createElement(react_router["b" /* Route */], {
      component: center_channel
    }), react_default.a.createElement(pluggable["a" /* default */], {
      pluggableName: "Root"
    }), react_default.a.createElement(get_post_link_modal, null), react_default.a.createElement(get_public_link_modal, null), react_default.a.createElement(get_team_invite_link_modal, null), react_default.a.createElement(import_theme_modal_ImportThemeModal, null), react_default.a.createElement(edit_post_modal, null), react_default.a.createElement(components_leave_private_channel_modal, null), react_default.a.createElement(shortcuts_modal, {
      isMac: utils["W" /* isMac */]()
    }), react_default.a.createElement(modal_controller["a" /* default */], null)), is_new === 'true' ? react_default.a.createElement(system_guide_SystemGuide, null) : null);
  }

}

channel_controller_defineProperty(channel_controller_ChannelController, "propTypes", {
  pathName: prop_types_default.a.string.isRequired,
  teamType: prop_types_default.a.string.isRequired
});
// EXTERNAL MODULE: ./components/ao_field_info/index.js
var ao_field_info = __webpack_require__(1677);

// EXTERNAL MODULE: ./components/ao_user_profile/ao_user_profile.scss
var ao_user_profile = __webpack_require__(3208);

// CONCATENATED MODULE: ./components/ao_user_profile/ao_user_profile.jsx
function ao_user_profile_extends() { ao_user_profile_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ao_user_profile_extends.apply(this, arguments); }










const FieldInfo = props => react_default.a.createElement(ao_field_info["a" /* default */], ao_user_profile_extends({
  labelWidth: 30
}, props));

/* harmony default export */ var ao_user_profile_ao_user_profile = (({
  visible,
  userinfo,
  teamUrl,
  currentUserId,
  currentUser,
  actions
}) => {
  let avatarUrl = userinfo ? utils["K" /* imageURLForUser */]({
    id: userinfo.id
  }) : ''; // 当前用户更改头像后需要刷新

  if (currentUser && userinfo && userinfo.id === currentUser.id) {
    avatarUrl = client["Client4"].getProfilePictureUrl(currentUser.id, currentUser.last_picture_update);
  }

  const genderImg = {
    'M': __webpack_require__(3209),
    'F': __webpack_require__(3210)
  }[userinfo && userinfo.gender ? userinfo.gender : 'M']; //修改于191015

  return react_default.a.createElement(components_ao_modal, {
    visible: visible,
    maskStyle: {
      background: 'transparent'
    },
    closable: false,
    footer: null,
    maskClosable: true,
    width: 360,
    onCancel: () => actions.closeUserProfile()
  }, userinfo ? react_default.a.createElement("div", {
    className: "ao-userprofile"
  }, react_default.a.createElement("div", {
    className: "ao-userprofile-header"
  }, react_default.a.createElement("div", {
    className: "ao-userprofile-name"
  }, userinfo.nickname || 'bot', react_default.a.createElement("img", {
    className: "ao-userprofile-gender",
    src: genderImg
  })), react_default.a.createElement("div", {
    className: "ao-userprofile-org"
  }, userinfo.department_name || '部门暂无'), react_default.a.createElement("img", {
    className: "ao-userprofile-avatar",
    src: avatarUrl
  })), react_default.a.createElement(react["Fragment"], null, react_default.a.createElement(FieldInfo, {
    marginBottom: "10px",
    label: "\u624B\u673A",
    value: userinfo.phone || '无'
  }), react_default.a.createElement(FieldInfo, {
    marginBottom: "10px",
    label: "\u5EA7\u673A",
    value: "\u65E0"
  }), react_default.a.createElement(FieldInfo, {
    marginBottom: "10px",
    label: "\u90AE\u7BB1",
    value: userinfo.email || '无'
  }), react_default.a.createElement(FieldInfo, {
    marginBottom: "10px",
    label: "\u5C97\u4F4D",
    value: userinfo.position || '无'
  }), react_default.a.createElement(FieldInfo, {
    label: "\u804C\u7EA7",
    value: userinfo.job_grade || '无'
  })), currentUserId !== userinfo.id ? react_default.a.createElement("div", {
    className: "ao-userprofile-actions"
  }, react_default.a.createElement(es_button["a" /* default */], {
    type: "primary",
    onClick: () => {
      actions.closeUserProfile();
      const link = `${teamUrl}/messages/@${userinfo.username}`;
      browser_history["a" /* browserHistory */].push(link);
    }
  }, "\u53D1\u6D88\u606F")) : null) : null);
});
// EXTERNAL MODULE: ./actions/views/user_profile.js
var views_user_profile = __webpack_require__(2033);

// CONCATENATED MODULE: ./components/ao_user_profile/index.js







function ao_user_profile_mapStateToProps(state) {
  const userprofile = state.views.userprofile.userprofile;
  return {
    teamUrl: Object(entities_teams["getCurrentRelativeTeamUrl"])(state),
    visible: userprofile.opened,
    userinfo: userprofile.userinfo,
    currentUserId: Object(entities_users["getCurrentUserId"])(state),
    currentUser: Object(entities_users["getCurrentUser"])(state)
  };
}

function ao_user_profile_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      closeUserProfile: views_user_profile["a" /* closeUserProfile */]
    }, dispatch)
  };
}

/* harmony default export */ var components_ao_user_profile = (Object(es["connect"])(ao_user_profile_mapStateToProps, ao_user_profile_mapDispatchToProps)(ao_user_profile_ao_user_profile));
// CONCATENATED MODULE: ./components/needs_team/needs_team.jsx
function needs_team_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.














const BackstageController = Object(async_load["b" /* makeAsyncComponent */])(backstage_default.a);
let wakeUpInterval;
let lastTime = Date.now();
const WAKEUP_CHECK_INTERVAL = 30000; // 30 seconds

const WAKEUP_THRESHOLD = 60000; // 60 seconds

const UNREAD_CHECK_TIME_MILLISECONDS = 10000;
class needs_team_NeedsTeam extends react_default.a.Component {
  constructor(params) {
    super(params);

    needs_team_defineProperty(this, "handleBlur", () => {
      window.isActive = false;
      this.blurTime = new Date().getTime();

      if (this.props.currentUser) {
        this.props.actions.viewChannel('');
      }
    });

    needs_team_defineProperty(this, "handleFocus", () => {
      this.props.actions.markChannelAsRead(this.props.currentChannelId);
      window.isActive = true;

      if (Date.now() - this.blurTime > UNREAD_CHECK_TIME_MILLISECONDS) {
        this.props.actions.fetchMyChannelsAndMembers(this.props.currentTeamId);
        this.props.actions.loadProfilesForDirect();
      }
    });

    needs_team_defineProperty(this, "joinTeam", async props => {
      const {
        data: team
      } = await this.props.actions.getTeamByName(props.match.params.team);

      if (team) {
        const {
          error
        } = await props.actions.addUserToTeam(team.id, props.currentUser && props.currentUser.id);

        if (error) {
          props.history.push('/error?type=team_not_found');
        } else {
          this.setState({
            team
          });
          this.initTeam(team);
        }
      } else {
        props.history.push('/error?type=team_not_found');
      }
    });

    needs_team_defineProperty(this, "initTeam", team => {
      // If current team is set, then this is not first load
      // The first load action pulls team unreads
      this.props.actions.getMyTeamUnreads();
      this.props.actions.selectTeam(team);
      this.props.actions.setPreviousTeamId(team.id);
      global_actions["c" /* emitCloseRightHandSide */]();
      this.props.actions.fetchMyChannelsAndMembers(team.id).then(() => {
        this.setState({
          finishedFetchingChannels: true
        });
      });
      this.props.actions.loadStatusesForChannelAndSidebar();
      this.props.actions.loadProfilesForDirect();
      return team;
    });

    needs_team_defineProperty(this, "updateCurrentTeam", props => {
      // First check to make sure you're in the current team
      // for the current url.
      const team = props.teamsList ? props.teamsList.find(teamObj => teamObj.name === props.match.params.team) : null;

      if (team) {
        this.initTeam(team);
        return team;
      }

      return null;
    });

    needs_team_defineProperty(this, "onShortcutKeyDown", e => {
      if (e.shiftKey && utils["e" /* cmdOrCtrlPressed */](e) && utils["V" /* isKeyPressed */](e, constants["N" /* default */].KeyCodes.L)) {
        const sidebar = document.getElementById('sidebar-right');

        if (sidebar) {
          if (sidebar.className.match('sidebar--right sidebar--right--expanded move--left')) {
            const replyTextbox = document.getElementById('reply_textbox');

            if (replyTextbox) {
              replyTextbox.focus();
            }
          } else {
            const postTextbox = document.getElementById('post_textbox');

            if (postTextbox) {
              postTextbox.focus();
            }
          }
        }
      }
    });

    this.blurTime = new Date().getTime();

    if (this.props.mfaRequired) {
      this.props.history.push('/mfa/setup');
      return;
    }

    clearInterval(wakeUpInterval);
    wakeUpInterval = setInterval(() => {
      const currentTime = new Date().getTime();

      if (currentTime > lastTime + WAKEUP_THRESHOLD) {
        // ignore small delays
        console.log('computer woke up - fetching latest'); //eslint-disable-line no-console

        Object(websocket_actions["c" /* reconnect */])(false);
      }

      lastTime = currentTime;
    }, WAKEUP_CHECK_INTERVAL);

    const _team = this.updateCurrentTeam(this.props);

    this.state = {
      team: _team,
      finishedFetchingChannels: false
    };

    if (!_team) {
      this.joinTeam(this.props);
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // eslint-disable-line camelcase
    if (this.props.match.params.team !== nextProps.match.params.team) {
      const team = this.updateCurrentTeam(nextProps);
      this.setState({
        team
      });

      if (!team) {
        this.joinTeam(nextProps);
      }
    }
  }

  componentDidMount() {
    Object(status_actions["d" /* startPeriodicStatusUpdates */])();
    Object(websocket_actions["f" /* startPeriodicSync */])(); // Set up tracking for whether the window is active

    window.isActive = true;
    utils["b" /* applyTheme */](this.props.theme);

    if (user_agent["j" /* isIosSafari */]()) {
      // Use iNoBounce to prevent scrolling past the boundaries of the page
      inobounce_default.a.enable();
    }

    window.addEventListener('focus', this.handleFocus);
    window.addEventListener('blur', this.handleBlur);
    window.addEventListener('keydown', this.onShortcutKeyDown);
  }

  componentDidUpdate(prevProps) {
    const {
      theme
    } = this.props;

    if (!utils["c" /* areObjectsEqual */](prevProps.theme, theme)) {
      utils["b" /* applyTheme */](theme);
    }
  }

  componentWillUnmount() {
    window.isActive = false;
    Object(status_actions["e" /* stopPeriodicStatusUpdates */])();
    Object(websocket_actions["g" /* stopPeriodicSync */])();

    if (user_agent["j" /* isIosSafari */]()) {
      inobounce_default.a.disable();
    }

    clearInterval(wakeUpInterval);
    window.removeEventListener('focus', this.handleFocus);
    window.removeEventListener('blur', this.handleBlur);
    window.removeEventListener('keydown', this.onShortcutKeyDown);
  }

  render() {
    if (this.state.team === null || this.state.finishedFetchingChannels === false) {
      return react_default.a.createElement("div", null);
    }

    const teamType = this.state.team ? this.state.team.type : '';
    return react_default.a.createElement(react["Fragment"], null, react_default.a.createElement(components_ao_user_profile, null), react_default.a.createElement(react_router["d" /* Switch */], null, react_default.a.createElement(react_router["b" /* Route */], {
      path: '/:team/integrations',
      component: BackstageController
    }), react_default.a.createElement(react_router["b" /* Route */], {
      path: '/:team/emoji',
      component: BackstageController
    }), react_default.a.createElement(react_router["b" /* Route */], {
      render: renderProps => react_default.a.createElement(channel_controller_ChannelController, {
        pathName: renderProps.location.pathname,
        teamType: teamType
      })
    })));
  }

}

needs_team_defineProperty(needs_team_NeedsTeam, "propTypes", {
  params: prop_types_default.a.object,
  currentUser: prop_types_default.a.object,
  currentChannelId: prop_types_default.a.string,
  currentTeamId: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    fetchMyChannelsAndMembers: prop_types_default.a.func.isRequired,
    getMyTeamUnreads: prop_types_default.a.func.isRequired,
    viewChannel: prop_types_default.a.func.isRequired,
    markChannelAsRead: prop_types_default.a.func.isRequired,
    getTeamByName: prop_types_default.a.func.isRequired,
    addUserToTeam: prop_types_default.a.func.isRequired,
    selectTeam: prop_types_default.a.func.isRequired,
    setPreviousTeamId: prop_types_default.a.func.isRequired,
    loadStatusesForChannelAndSidebar: prop_types_default.a.func.isRequired,
    loadProfilesForDirect: prop_types_default.a.func.isRequired
  }).isRequired,
  theme: prop_types_default.a.object.isRequired,
  mfaRequired: prop_types_default.a.bool.isRequired,

  /*
   * Object from react-router
   */
  match: prop_types_default.a.shape({
    params: prop_types_default.a.shape({
      team: prop_types_default.a.string.isRequired
    }).isRequired
  }).isRequired,
  history: prop_types_default.a.object.isRequired
});
// CONCATENATED MODULE: ./components/needs_team/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


















function needs_team_mapStateToProps(state, ownProps) {
  const license = Object(general["getLicense"])(state);
  const config = Object(general["getConfig"])(state);
  const currentUser = Object(entities_users["getCurrentUser"])(state);
  return {
    theme: Object(entities_preferences["getTheme"])(state),
    mfaRequired: Object(route["a" /* checkIfMFARequired */])(currentUser, license, config, ownProps.match.url),
    currentUser,
    currentTeamId: Object(entities_teams["getCurrentTeamId"])(state),
    teamsList: Object(entities_teams["getMyTeams"])(state),
    currentChannelId: Object(entities_channels["getCurrentChannelId"])(state)
  };
}

function needs_team_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      fetchMyChannelsAndMembers: actions_channels["fetchMyChannelsAndMembers"],
      getMyTeamUnreads: actions_teams["getMyTeamUnreads"],
      viewChannel: actions_channels["viewChannel"],
      markChannelAsRead: actions_channels["markChannelAsRead"],
      getTeamByName: actions_teams["getTeamByName"],
      addUserToTeam: team_actions["a" /* addUserToTeam */],
      setPreviousTeamId: local_storage["a" /* setPreviousTeamId */],
      selectTeam: actions_teams["selectTeam"],
      loadStatusesForChannelAndSidebar: status_actions["a" /* loadStatusesForChannelAndSidebar */],
      loadProfilesForDirect: actions_users["loadProfilesForDirect"],
      setChannelsLastPost: views_channel["j" /* setChannelsLastPost */]
    }, dispatch)
  };
}

/* harmony default export */ var needs_team = __webpack_exports__["a"] = (Object(react_router["f" /* withRouter */])(Object(es["connect"])(needs_team_mapStateToProps, needs_team_mapDispatchToProps)(needs_team_NeedsTeam)));

/***/ }),

/***/ 3445:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./components/ao_cloud/ao_cloud_item/index.scss
var ao_cloud_item = __webpack_require__(2947);

// EXTERNAL MODULE: ./node_modules/moment/moment.js
var moment = __webpack_require__(2);
var moment_default = /*#__PURE__*/__webpack_require__.n(moment);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./actions/views/posts.js
var posts = __webpack_require__(1618);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/preferences.js
var preferences = __webpack_require__(41);

// EXTERNAL MODULE: ./components/ao_post_dropdown/index.scss
var ao_post_dropdown = __webpack_require__(2948);

// EXTERNAL MODULE: ./node_modules/antd/es/menu/index.js + 7 modules
var es_menu = __webpack_require__(3485);

// EXTERNAL MODULE: ./node_modules/antd/es/dropdown/index.js + 2 modules
var dropdown = __webpack_require__(3490);

// EXTERNAL MODULE: ./components/icons/forward_icon.jsx
var forward_icon = __webpack_require__(2181);

// EXTERNAL MODULE: ./components/icons/star_line_icon.jsx
var star_line_icon = __webpack_require__(2062);

// CONCATENATED MODULE: ./components/icons/download_icon.jsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/* harmony default export */ var download_icon = (({
  fill = "#909090",
  ...rest
}) => React.createElement("svg", _extends({
  width: "13px",
  height: "13px",
  viewBox: "0 0 13 13",
  xmlns: "http://www.w3.org/2000/svg"
}, rest), React.createElement("g", {
  stroke: "none",
  strokeWidth: "1",
  fill: "none",
  fillRule: "evenodd"
}, React.createElement("g", {
  transform: "translate(-3347.000000, -356.000000)"
}, React.createElement("g", {
  transform: "translate(3342.000000, 351.000000)"
}, React.createElement("rect", {
  fill: fill,
  x: "10.75",
  y: "5",
  width: "1.5",
  height: "9"
}), React.createElement("polyline", {
  stroke: fill,
  strokeWidth: "1.5",
  points: "7 10 11.5 14 16 10"
}), React.createElement("polyline", {
  stroke: fill,
  strokeWidth: "1.5",
  points: "6 14 6 17 17 17 17 14"
}))))));
// EXTERNAL MODULE: ./node_modules/antd/lib/index.js
var lib = __webpack_require__(2064);

// EXTERNAL MODULE: ./mattermost-redux/utils/file_utils.js
var file_utils = __webpack_require__(1611);

// CONCATENATED MODULE: ./components/ao_post_dropdown/ao_post_dropdown.jsx









class ao_post_dropdown_CollectItemMoreFunc extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
  }

  handleClick({
    key
  }) {
    const {
      postId,
      isFlagged,
      actions
    } = this.props;

    if (key === 'forward') {
      actions.setChannelPostSelect({
        type: constants["f" /* ChannelPostSelectType */].SINGLE,
        visibleSelectMember: true,
        postId
      });
    } else if (key === 'flag') {
      if (isFlagged) {
        lib["message"].warn('该消息已收藏');
      } else {
        actions.flagPost(postId).then(() => {
          lib["message"].success('收藏成功');
        });
      }
    }
  }

  render() {
    const {
      fileInfo,
      hasForward,
      hasFlag,
      hasDownload,
      iconElement,
      trigger,
      placement
    } = this.props;
    let fileUrl = '';

    if (fileInfo) {
      fileUrl = fileInfo.link || Object(file_utils["getFileUrl"])(fileInfo.id);
    }

    const menu = react_default.a.createElement(es_menu["a" /* default */], {
      onClick: val => {
        this.handleClick(val);
      }
    }, hasForward && react_default.a.createElement(es_menu["a" /* default */].Item, {
      key: "forward",
      className: "forward"
    }, react_default.a.createElement(forward_icon["a" /* default */], null), " \u8F6C\u53D1"), hasFlag && react_default.a.createElement(es_menu["a" /* default */].Item, {
      key: "flag",
      className: "flag"
    }, react_default.a.createElement(star_line_icon["a" /* default */], null), " \u6536\u85CF"), hasDownload && react_default.a.createElement(es_menu["a" /* default */].Item, {
      key: "download",
      className: "download"
    }, react_default.a.createElement("a", {
      href: fileUrl + '?download=1',
      target: "_blank",
      rel: "noopener noreferrer",
      download: fileInfo.name
    }, react_default.a.createElement(download_icon, null), " \u4E0B\u8F7D")));
    return react_default.a.createElement("div", {
      className: "post-dropdown"
    }, react_default.a.createElement(dropdown["a" /* default */], {
      overlayClassName: "post-dropdown-inner",
      overlay: menu,
      placement: placement ? placement : "bottomRight",
      trigger: trigger ? trigger : ['hover', 'click']
    }, iconElement ? iconElement : react_default.a.createElement("div", {
      className: "more-icon"
    })));
  }

}
// CONCATENATED MODULE: ./components/ao_post_dropdown/index.js








function mapStateToProps(state, ownProps) {
  return {
    isFlagged: Object(preferences["get"])(state, constants["w" /* Preferences */].CATEGORY_FLAGGED_POST, ownProps.postId, null) != null
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      setChannelPostSelect: posts["c" /* setChannelPostSelect */],
      flagPost: post_actions["f" /* flagPost */]
    }, dispatch)
  };
}

/* harmony default export */ var components_ao_post_dropdown = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(ao_post_dropdown_CollectItemMoreFunc));
// EXTERNAL MODULE: ./utils/file_utils.jsx
var utils_file_utils = __webpack_require__(1601);

// CONCATENATED MODULE: ./components/ao_cloud/ao_cloud_item/ao_cloud_item.jsx






class ao_cloud_item_CollectItem extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
  }

  render() {
    const {
      file,
      user
    } = this.props;
    return react_default.a.createElement("div", {
      className: "cloud-item"
    }, react_default.a.createElement("img", {
      src: Object(utils["y" /* getFileIconPath */])(file),
      className: "cover"
    }), react_default.a.createElement("div", {
      className: "intro"
    }, react_default.a.createElement("p", {
      className: "title"
    }, Object(utils_file_utils["h" /* trimFilename */])(file.name)), react_default.a.createElement("div", {
      className: "details"
    }, react_default.a.createElement("span", null, Object(utils["p" /* fileSizeToString */])(file.size)), react_default.a.createElement("span", null, user && user.nickname), react_default.a.createElement("span", null, moment_default()(file.create_at).format('YYYY/MM/DD')))), react_default.a.createElement(components_ao_post_dropdown, {
      fileInfo: file,
      hasForward: true,
      hasFlag: true,
      hasDownload: true,
      postId: file.post_id
    }));
  }

}
// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/channels.js
var channels = __webpack_require__(15);

// CONCATENATED MODULE: ./components/ao_cloud/ao_cloud_item/index.js






function ao_cloud_item_mapStateToProps(state, ownProps) {
  const {
    file
  } = ownProps;
  const user = Object(users["getUser"])(state, file.user_id);
  const currentChannel = Object(channels["getCurrentChannel"])(state) || {};
  return {
    user,
    currentChannel
  };
}

function ao_cloud_item_mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({}, dispatch)
  };
}

/* harmony default export */ var ao_cloud_ao_cloud_item = __webpack_exports__["a"] = (Object(es["connect"])(ao_cloud_item_mapStateToProps, ao_cloud_item_mapDispatchToProps)(ao_cloud_item_CollectItem));

/***/ }),

/***/ 3462:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./actions/views/channel.js + 2 modules
var channel = __webpack_require__(1589);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Modal.js
var Modal = __webpack_require__(1972);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// CONCATENATED MODULE: ./components/removed_from_channel_modal/removed_from_channel_modal.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class removed_from_channel_modal_RemovedFromChannelModal extends react_default.a.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "onHide", () => {
      this.setState({
        show: false
      });
    });

    this.state = {
      show: true
    };
  }

  componentDidMount() {
    this.props.actions.goToLastViewedChannel();
  }

  render() {
    let channelName = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "removed_channel.channelName",
      defaultMessage: "the channel"
    });

    if (this.props.channelName) {
      channelName = this.props.channelName;
    }

    let remover = react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "removed_channel.someone",
      defaultMessage: "Someone"
    });

    if (this.props.remover) {
      remover = this.props.remover;
    }

    if (this.props.currentUserId === '') {
      return null;
    }

    return react_default.a.createElement(Modal["a" /* default */], {
      show: this.state.show,
      onHide: this.onHide,
      onExited: this.props.onHide,
      role: "dialog",
      "aria-labelledby": "removeFromChannelModalLabel"
    }, react_default.a.createElement(Modal["a" /* default */].Header, {
      closeButton: true
    }, react_default.a.createElement(Modal["a" /* default */].Title, {
      componentClass: "h1",
      id: "removeFromChannelModalLabel"
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "removed_channel.from",
      defaultMessage: "Removed from "
    }), react_default.a.createElement("span", {
      className: "name"
    }, channelName))), react_default.a.createElement(Modal["a" /* default */].Body, {
      ref: "modalBody"
    }, react_default.a.createElement("p", null, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "removed_channel.remover",
      defaultMessage: "{remover} removed you from {channel}",
      values: {
        remover,
        channel: channelName
      }
    }))), react_default.a.createElement(Modal["a" /* default */].Footer, null, react_default.a.createElement("button", {
      type: "button",
      className: "btn btn-primary",
      onClick: this.onHide
    }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
      id: "removed_channel.okay",
      defaultMessage: "Okay"
    }))));
  }

}

_defineProperty(removed_from_channel_modal_RemovedFromChannelModal, "propTypes", {
  currentUserId: prop_types_default.a.string.isRequired,
  onHide: prop_types_default.a.func.isRequired,
  channelName: prop_types_default.a.string,
  remover: prop_types_default.a.string,
  actions: prop_types_default.a.shape({
    goToLastViewedChannel: prop_types_default.a.func.isRequired
  })
});
// CONCATENATED MODULE: ./components/removed_from_channel_modal/index.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function mapStateToProps(state) {
  return {
    currentUserId: Object(users["getCurrentUserId"])(state)
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      goToLastViewedChannel: channel["c" /* goToLastViewedChannel */]
    }, dispatch)
  };
}

/* harmony default export */ var removed_from_channel_modal = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(removed_from_channel_modal_RemovedFromChannelModal));

/***/ }),

/***/ 3471:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./actions/views/root.js
var root = __webpack_require__(421);

// EXTERNAL MODULE: ./selectors/i18n.js
var i18n = __webpack_require__(302);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(6);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// EXTERNAL MODULE: ./mattermost-redux/client/index.js
var client = __webpack_require__(27);

// EXTERNAL MODULE: ./mattermost-redux/utils/i18n_utils.js
var i18n_utils = __webpack_require__(986);

// EXTERNAL MODULE: ./i18n/i18n.jsx
var i18n_i18n = __webpack_require__(416);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// CONCATENATED MODULE: ./components/intl_provider/intl_provider.jsx
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







class intl_provider_IntlProvider extends react_default.a.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "handleLocaleChange", locale => {
      client["Client4"].setAcceptLanguage(locale);
      this.loadTranslationsIfNecessary(locale);
    });

    _defineProperty(this, "loadTranslationsIfNecessary", locale => {
      if (this.props.translations) {
        // Already loaded
        return;
      }

      const localeInfo = i18n_i18n["c" /* getLanguageInfo */](locale);

      if (!localeInfo) {
        return;
      }

      this.props.actions.loadTranslations(locale, localeInfo.url);
    });
  }

  componentDidMount() {
    // Initialize browser's i18n data
    i18n_i18n["a" /* doAddLocaleData */](); // Pass localization function back to mattermost-redux

    Object(i18n_utils["setLocalizeFunction"])(utils["gb" /* localizeMessage */]);
    this.handleLocaleChange(this.props.locale);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.locale !== this.props.locale) {
      this.handleLocaleChange(this.props.locale);
    }
  }

  render() {
    if (!this.props.translations) {
      return null;
    }

    return react_default.a.createElement(index_es["e" /* IntlProvider */], {
      key: this.props.locale,
      locale: this.props.locale,
      messages: this.props.translations
    }, this.props.children);
  }

}

_defineProperty(intl_provider_IntlProvider, "propTypes", {
  children: prop_types_default.a.element.isRequired,
  locale: prop_types_default.a.string.isRequired,
  translations: prop_types_default.a.object,
  actions: prop_types_default.a.shape({
    loadTranslations: prop_types_default.a.func.isRequired
  }).isRequired
});
// CONCATENATED MODULE: ./components/intl_provider/index.jsx
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






function mapStateToProps(state) {
  const locale = Object(i18n["a" /* getCurrentLocale */])(state);
  return {
    locale,
    translations: Object(i18n["b" /* getTranslations */])(state, locale)
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      loadTranslations: root["c" /* loadTranslations */]
    }, dispatch)
  };
}

/* harmony default export */ var intl_provider = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(intl_provider_IntlProvider));

/***/ }),

/***/ 3472:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./actions/views/meeting.js
var meeting = __webpack_require__(182);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./utils/utils.jsx + 1 modules
var utils = __webpack_require__(22);

// EXTERNAL MODULE: ./components/meeting_invitation/index.scss
var meeting_invitation = __webpack_require__(2389);

// CONCATENATED MODULE: ./components/meeting_invitation/meeting_invitation.jsx


 // 倒计时(秒)

const _countdown = 30;
/* harmony default export */ var meeting_invitation_meeting_invitation = (({
  invitation,
  actions
}) => {
  const [countdown, setCountdown] = Object(react["useState"])();

  const hangup = () => {
    actions.hangup(true);
    actions.openNextInvitation();
  };

  const join = () => {
    actions.join();
    actions.openNextInvitation();
  };

  Object(react["useEffect"])(() => {
    if (invitation) {
      setCountdown(_countdown);
    }
  }, [!!invitation]);
  Object(react["useEffect"])(() => {
    if (countdown === 0) {
      // 倒计时结束
      actions.hangup(false);
      actions.openNextInvitation();
    }
  }, [countdown]);
  Object(react["useEffect"])(() => {
    if (!invitation || countdown === 0) {
      return;
    }

    let timer = setTimeout(() => {
      setCountdown(countdown - 1);
      timer = null;
    }, 1000);
    return () => {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
  }, [!!invitation, countdown]);

  if (!invitation) {
    return null;
  }

  const {
    userId,
    userName,
    meetName
  } = invitation;
  const avatarUrl = utils["K" /* imageURLForUser */]({
    id: userId
  });
  return react_default.a.createElement("div", {
    className: "meeting-invitation"
  }, react_default.a.createElement("div", {
    className: "meeting-invitation-mask"
  }), react_default.a.createElement("div", {
    className: "meeting-invitation-main"
  }, react_default.a.createElement("div", {
    className: "meeting-invitation-content"
  }, react_default.a.createElement("img", {
    className: "meeting-invitation-avatar",
    src: avatarUrl
  }), react_default.a.createElement("div", {
    className: "meeting-invitation-title"
  }, userName, "\u9080\u8BF7\u4F60\u52A0\u5165", meetName), react_default.a.createElement("div", {
    className: "meeting-invitation-countdown"
  }, countdown, "s\u540E\u81EA\u52A8\u6302\u8D77")), react_default.a.createElement("div", {
    className: "meeting-invitation-actions"
  }, react_default.a.createElement("div", {
    onClick: hangup
  }, react_default.a.createElement("img", {
    src: __webpack_require__(2390)
  }), "\u6302\u8D77"), react_default.a.createElement("div", {
    onClick: join
  }, react_default.a.createElement("img", {
    src: __webpack_require__(2391)
  }), "\u52A0\u5165"))));
});
// CONCATENATED MODULE: ./components/meeting_invitation/index.js





function mapStateToProps(state) {
  // console.log('meeting_invitation:', state);
  const invitation = state.views.meeting.invitation.invitation;
  return {
    invitation
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      hangup: meeting["d" /* hangup */],
      join: meeting["e" /* join */],
      openNextInvitation: meeting["i" /* openNextInvitation */]
    }, dispatch)
  };
}

/* harmony default export */ var components_meeting_invitation = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(meeting_invitation_meeting_invitation));

/***/ }),

/***/ 3473:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./utils/message_html_to_component.jsx + 3 modules
var message_html_to_component = __webpack_require__(1684);

// EXTERNAL MODULE: ./utils/text_formatting.jsx
var text_formatting = __webpack_require__(81);

// EXTERNAL MODULE: ./mattermost-redux/action_types/index.js
var action_types = __webpack_require__(8);

// EXTERNAL MODULE: ./actions/views/modals.js
var modals = __webpack_require__(1578);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./components/interactive_dialog/index.js + 2 modules
var interactive_dialog = __webpack_require__(1964);

// EXTERNAL MODULE: ./stores/redux_store.jsx + 3 modules
var redux_store = __webpack_require__(14);

// CONCATENATED MODULE: ./plugins/interactive_dialog.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function openInteractiveDialog(dialog) {
  redux_store["a" /* default */].dispatch({
    type: action_types["IntegrationTypes"].RECEIVED_DIALOG,
    data: dialog
  });
  redux_store["a" /* default */].dispatch(Object(modals["b" /* openModal */])({
    modalId: constants["p" /* ModalIdentifiers */].INTERACTIVE_DIALOG,
    dialogType: interactive_dialog["a" /* default */]
  }));
}
// CONCATENATED MODULE: ./plugins/export.js
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


 // Common libraries exposed on window for plugins to use as Webpack externals.

window.React = __webpack_require__(1);
window.ReactDOM = __webpack_require__(33);
window.Redux = __webpack_require__(16);
window.ReactRedux = __webpack_require__(405);
window.ReactBootstrap = __webpack_require__(1558);
window.PostUtils = {
  formatText: text_formatting["e" /* formatText */],
  messageHtmlToComponent: message_html_to_component["a" /* default */]
};
window.PropTypes = __webpack_require__(6);
window.PDFJS = __webpack_require__(448);
window.openInteractiveDialog = openInteractiveDialog;

/***/ }),

/***/ 3475:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 15 modules
var es = __webpack_require__(405);

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(16);

// EXTERNAL MODULE: ./mattermost-redux/selectors/entities/users.js
var users = __webpack_require__(10);

// EXTERNAL MODULE: ./actions/post_actions.jsx + 2 modules
var post_actions = __webpack_require__(408);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./utils/i18n.jsx
var i18n = __webpack_require__(53);

// EXTERNAL MODULE: ./utils/constants.jsx
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./components/icons/star_icon_filled.jsx
var star_icon_filled = __webpack_require__(2063);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/OverlayTrigger.js
var OverlayTrigger = __webpack_require__(1995);

// EXTERNAL MODULE: ./node_modules/react-bootstrap/es/Tooltip.js
var Tooltip = __webpack_require__(1998);

// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules
var index_es = __webpack_require__(52);

// CONCATENATED MODULE: ./components/ao_collect_item/ao_merge_collect_icon/ao_merge_collect_icon.jsx






class ao_merge_collect_icon_CollectIcon extends react_default.a.PureComponent {
  constructor(props) {
    super(props);
  } // 取消收藏


  unflagPost() {
    this.props.actions.deleteMergeCollect(this.props.collectId);
  }

  render() {
    return react_default.a.createElement("div", {
      className: "merge-collect-icon",
      onClick: () => {
        this.unflagPost();
      }
    }, react_default.a.createElement(OverlayTrigger["a" /* default */], {
      trigger: ['hover', 'focus'],
      key: 'flagtooltipkey',
      delayShow: constants["N" /* default */].OVERLAY_TIME_DELAY,
      placement: "top",
      overlay: react_default.a.createElement(Tooltip["a" /* default */], {
        id: "flagTooltip"
      }, react_default.a.createElement(index_es["c" /* FormattedMessage */], {
        id: Object(i18n["b" /* t */])('flag_post.unflag'),
        defaultMessage: 'Unflag'
      }))
    }, react_default.a.createElement(star_icon_filled["a" /* default */], {
      className: "icon"
    })));
  }

}
// CONCATENATED MODULE: ./components/ao_collect_item/ao_merge_collect_icon/index.js






function mapStateToProps(state, ownProps) {
  return {
    currentUserId: Object(users["getCurrentUserId"])(state)
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: Object(redux["bindActionCreators"])({
      deleteMergeCollect: post_actions["e" /* deleteMergeCollect */]
    }, dispatch)
  };
}

/* harmony default export */ var ao_merge_collect_icon = __webpack_exports__["a"] = (Object(es["connect"])(mapStateToProps, mapDispatchToProps)(ao_merge_collect_icon_CollectIcon));

/***/ })

}]);
//# sourceMappingURL=5.94d6a58e9151a1139b4f.js.map